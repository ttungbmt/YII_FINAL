{"version":3,"sources":["../external \"_\"","@core/bootstrap.js","@core/serviceWorker.js","@core/components/Header.js","@core/containers/AppContainer.js","@core/utils/checkStore.js","@core/utils/history.js","@core/reducers/index.js","@core/utils/reducerInjectors.js","@core/utils/injectReducer.js","@core/utils/constants.js","@core/utils/sagaInjectors.js","@core/utils/injectSaga.js","app/containers/HomePage/reducer.js","app/containers/HomePage/saga.js","app/containers/HomePage/index.js","app/containers/ContactPage/index.js","app/containers/NotFoundPage/index.js","app/App.js","index.js","@core/configureStore.js"],"names":["module","exports","_","window","BASE_URL","Boolean","location","hostname","match","memo","AppWrapper","styled","div","AppContainer","children","Helmet","defaultTitle","rel","href","src","type","checkStore","store","shape","dispatch","isFunction","subscribe","getState","replaceReducer","runSaga","injectedReducers","isObject","injectedSagas","invariant","conformsTo","history","createBrowserHistory","createReducer","combineReducers","router","connectRouter","injectReducerFactory","isValid","key","reducer","isString","isEmpty","Reflect","has","getInjectors","injectReducer","useInjectReducer","context","React","useContext","ReactReduxContext","useEffect","DAEMON","ONCE_TILL_UNMOUNT","allowedModes","checkKey","checkDescriptor","descriptor","saga","mode","includes","injectSagaFactory","args","newDescriptor","hasSaga","task","ejectSagaFactory","cancel","injectSaga","ejectSaga","useInjectSaga","injectors","nextTodoId","todosSlice","createSlice","name","initialState","text","reducers","addTodo","state","action","payload","id","push","completed","prepare","toggleTodo","todo","find","actions","watchData","console","log","process","withConnect","connect","compose","hot","to","exact","path","component","HomePage","ContactPage","NotFoundPage","sagaMiddleware","createSagaMiddleware","baseConfigureStore","preloadedState","middleware","getDefaultMiddleware","routerMiddleware","run","configureStore","MOUNT_NODE","document","getElementById","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.chunk.js","sourcesContent":["module.exports = _;","// Needed for redux-saga es6 generator support\r\nimport 'react-app-polyfill/stable';\r\nimport 'sanitize.css/sanitize.css';\r\nimport './styles/index.scss'\r\n\r\nwindow.BASE_URL = window.BASE_URL ? window.BASE_URL : '/'","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React, { memo } from 'react'\r\n\r\nfunction Header() {\r\n    return (\r\n        <div>\r\n            Header\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default memo(Header)","import React from 'react'\r\nimport styled from 'styled-components';\r\nimport Header from '../components/Header'\r\nimport { Helmet } from 'react-helmet';\r\n\r\nconst AppWrapper = styled.div`\r\n\r\n`;\r\n\r\nfunction AppContainer({children}) {\r\n    return (\r\n        <AppWrapper>\r\n            <Helmet\r\n                defaultTitle=\"React App\"\r\n            >\r\n                <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/leaflet@1.3.4/dist/leaflet.min.css\"/>\r\n                <script src=\"https://cdn.jsdelivr.net/npm/leaflet@1.3.4/dist/leaflet-src.min.js\" type=\"text/javascript\" />\r\n                <script src=\"https://cdn.jsdelivr.net/npm/lodash\" type=\"text/javascript\" />\r\n\r\n            </Helmet>\r\n            <Header />\r\n            {children}\r\n        </AppWrapper>\r\n    )\r\n}\r\n\r\nexport default AppContainer","import { conformsTo, isFunction, isObject } from 'lodash-es'\r\nimport invariant from 'invariant'\r\n\r\n/**\r\n * Validate the shape of redux store\r\n */\r\nexport default function checkStore(store) {\r\n    const shape = {\r\n        dispatch: isFunction,\r\n        subscribe: isFunction,\r\n        getState: isFunction,\r\n        replaceReducer: isFunction,\r\n        runSaga: isFunction,\r\n        injectedReducers: isObject,\r\n        injectedSagas: isObject,\r\n    };\r\n    invariant(\r\n        conformsTo(store, shape),\r\n        '(app/utils...) injectors: Expected a valid redux store',\r\n    );\r\n}","import { createBrowserHistory } from 'history';\r\nconst history = createBrowserHistory();\r\nexport default history;","import { combineReducers } from 'redux'\r\nimport { connectRouter } from 'connected-react-router'\r\n\r\nimport history from '@core/utils/history'\r\n\r\nexport default function createReducer(injectedReducers = {}) {\r\n    const rootReducer = combineReducers({\r\n        // global: globalReducer,\r\n        router: connectRouter(history),\r\n        // language: languageProviderReducer,\r\n        // router: connectRouter(history),\r\n        ...injectedReducers,\r\n    });\r\n\r\n    return rootReducer;\r\n}","import invariant from 'invariant';\r\nimport { isEmpty, isFunction, isString } from 'lodash';\r\n\r\nimport checkStore from './checkStore';\r\nimport createReducer from '../reducers';\r\n\r\nexport function injectReducerFactory(store, isValid) {\r\n    return function injectReducer(key, reducer) {\r\n        if (!isValid) checkStore(store);\r\n\r\n        invariant(\r\n            isString(key) && !isEmpty(key) && isFunction(reducer),\r\n            '(app/utils...) injectReducer: Expected `reducer` to be a reducer function',\r\n        );\r\n\r\n        // Check `store.injectedReducers[key] === reducer` for hot reloading when a key is the same but a reducer is different\r\n        if (\r\n            Reflect.has(store.injectedReducers, key) &&\r\n            store.injectedReducers[key] === reducer\r\n        )\r\n            return;\r\n\r\n        store.injectedReducers[key] = reducer; // eslint-disable-line no-param-reassign\r\n        store.replaceReducer(createReducer(store.injectedReducers));\r\n    };\r\n}\r\n\r\nexport default function getInjectors(store) {\r\n    checkStore(store);\r\n\r\n    return {\r\n        injectReducer: injectReducerFactory(store, true),\r\n    };\r\n}","import React, { useEffect } from 'react';\r\nimport hoistNonReactStatics from 'hoist-non-react-statics';\r\nimport { ReactReduxContext } from 'react-redux';\r\n\r\nimport getInjectors from './reducerInjectors';\r\n\r\n/**\r\n * Dynamically injects a reducer\r\n *\r\n * @param {string} key A key of the reducer\r\n * @param {function} reducer A reducer that will be injected\r\n *\r\n */\r\nexport default ({key, reducer}) => WrappedComponent => {\r\n    class ReducerInjector extends React.Component {\r\n        static WrappedComponent = WrappedComponent;\r\n\r\n        static contextType = ReactReduxContext;\r\n\r\n        static displayName = `withReducer(${WrappedComponent.displayName ||\r\n        WrappedComponent.name ||\r\n        'Component'})`;\r\n\r\n        constructor(props, context) {\r\n            super(props, context);\r\n\r\n            getInjectors(context.store).injectReducer(key, reducer);\r\n        }\r\n\r\n        render() {\r\n            return <WrappedComponent {...this.props} />;\r\n        }\r\n    }\r\n\r\n    return hoistNonReactStatics(ReducerInjector, WrappedComponent);\r\n};\r\n\r\nconst useInjectReducer = ({key, reducer}) => {\r\n    const context = React.useContext(ReactReduxContext);\r\n\r\n    useEffect(() => {\r\n        getInjectors(context.store).injectReducer(key, reducer);\r\n        // eslint-disable-next-line\r\n    }, []);\r\n};\r\n\r\nexport { useInjectReducer };","export const RESTART_ON_REMOUNT = '@@saga-injector/restart-on-remount';\r\nexport const DAEMON = '@@saga-injector/daemon';\r\nexport const ONCE_TILL_UNMOUNT = '@@saga-injector/once-till-unmount';","import invariant from 'invariant'\r\nimport { isEmpty, isFunction, isString, conformsTo } from 'lodash-es'\r\n\r\nimport checkStore from './checkStore'\r\nimport { DAEMON, ONCE_TILL_UNMOUNT, RESTART_ON_REMOUNT } from './constants'\r\n\r\nconst allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT];\r\n\r\nconst checkKey = key =>\r\n    invariant(\r\n        isString(key) && !isEmpty(key),\r\n        '(app/utils...) injectSaga: Expected `key` to be a non empty string',\r\n    );\r\n\r\nconst checkDescriptor = descriptor => {\r\n    const shape = {\r\n        saga: isFunction,\r\n        mode: mode => isString(mode) && allowedModes.includes(mode),\r\n    };\r\n    invariant(\r\n        conformsTo(descriptor, shape),\r\n        '(app/utils...) injectSaga: Expected a valid saga descriptor',\r\n    );\r\n};\r\n\r\nexport function injectSagaFactory(store, isValid) {\r\n    return function injectSaga(key, descriptor = {}, args) {\r\n        if (!isValid) checkStore(store);\r\n\r\n        const newDescriptor = {\r\n            ...descriptor,\r\n            mode: descriptor.mode || DAEMON,\r\n        };\r\n        const { saga, mode } = newDescriptor;\r\n\r\n        checkKey(key);\r\n        checkDescriptor(newDescriptor);\r\n\r\n        let hasSaga = Reflect.has(store.injectedSagas, key);\r\n\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            const oldDescriptor = store.injectedSagas[key];\r\n            // enable hot reloading of daemon and once-till-unmount sagas\r\n            if (hasSaga && oldDescriptor.saga !== saga) {\r\n                oldDescriptor.task.cancel();\r\n                hasSaga = false;\r\n            }\r\n        }\r\n\r\n        if (\r\n            !hasSaga ||\r\n            (hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT)\r\n        ) {\r\n            /* eslint-disable no-param-reassign */\r\n            store.injectedSagas[key] = {\r\n                ...newDescriptor,\r\n                task: store.runSaga(saga, args),\r\n            };\r\n            /* eslint-enable no-param-reassign */\r\n        }\r\n    };\r\n}\r\n\r\nexport function ejectSagaFactory(store, isValid) {\r\n    return function ejectSaga(key) {\r\n        if (!isValid) checkStore(store);\r\n\r\n        checkKey(key);\r\n\r\n        if (Reflect.has(store.injectedSagas, key)) {\r\n            const descriptor = store.injectedSagas[key];\r\n            if (descriptor.mode && descriptor.mode !== DAEMON) {\r\n                descriptor.task.cancel();\r\n                // Clean up in production; in development we need `descriptor.saga` for hot reloading\r\n                if (process.env.NODE_ENV === 'production') {\r\n                    // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\r\n                    store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\r\n                }\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nexport default function getInjectors(store) {\r\n    checkStore(store);\r\n\r\n    return {\r\n        injectSaga: injectSagaFactory(store, true),\r\n        ejectSaga: ejectSagaFactory(store, true),\r\n    };\r\n}","import React, { useEffect } from 'react';\r\nimport hoistNonReactStatics from 'hoist-non-react-statics';\r\nimport { ReactReduxContext } from 'react-redux';\r\n\r\nimport getInjectors from './sagaInjectors';\r\n\r\n/**\r\n * Dynamically injects a saga, passes component's props as saga arguments\r\n *\r\n * @param {string} key A key of the saga\r\n * @param {function} saga A root saga that will be injected\r\n * @param {string} [mode] By default (constants.DAEMON) the saga will be started\r\n * on component mount and never canceled or started again. Another two options:\r\n *   - constants.RESTART_ON_REMOUNT — the saga will be started on component mount and\r\n *   cancelled with `task.cancel()` on component unmount for improved performance,\r\n *   - constants.ONCE_TILL_UNMOUNT — behaves like 'RESTART_ON_REMOUNT' but never runs it again.\r\n *\r\n */\r\nexport default ({key, saga, mode}) => WrappedComponent => {\r\n    class InjectSaga extends React.Component {\r\n        static WrappedComponent = WrappedComponent;\r\n\r\n        static contextType = ReactReduxContext;\r\n\r\n        static displayName = `withSaga(${WrappedComponent.displayName ||\r\n        WrappedComponent.name ||\r\n        'Component'})`;\r\n\r\n        constructor(props, context) {\r\n            super(props, context);\r\n\r\n            this.injectors = getInjectors(context.store);\r\n\r\n            this.injectors.injectSaga(key, {saga, mode}, this.props);\r\n        }\r\n\r\n        componentWillUnmount() {\r\n            this.injectors.ejectSaga(key);\r\n        }\r\n\r\n        render() {\r\n            return <WrappedComponent {...this.props} />;\r\n        }\r\n    }\r\n\r\n    return hoistNonReactStatics(InjectSaga, WrappedComponent);\r\n};\r\n\r\nconst useInjectSaga = ({key, saga, mode}) => {\r\n    const context = React.useContext(ReactReduxContext);\r\n    useEffect(() => {\r\n        const injectors = getInjectors(context.store);\r\n        injectors.injectSaga(key, {saga, mode});\r\n\r\n        return () => {\r\n            injectors.ejectSaga(key);\r\n        };\r\n        // eslint-disable-next-line\r\n    }, []);\r\n};\r\n\r\nexport { useInjectSaga };","import { createSlice } from '@reduxjs/toolkit'\r\n\r\nlet nextTodoId = 0\r\n\r\nconst todosSlice = createSlice({\r\n    name: 'todos',\r\n    initialState: [\r\n        {text: '11'}\r\n    ],\r\n    reducers: {\r\n        addTodo: {\r\n            reducer(state, action) {\r\n                const { id, text } = action.payload\r\n                state.push({ id, text, completed: false })\r\n            },\r\n            prepare(text) {\r\n                return { payload: { text, id: nextTodoId++ } }\r\n            }\r\n        },\r\n        toggleTodo(state, action) {\r\n            const todo = state.find(todo => todo.id === action.payload)\r\n            if (todo) {\r\n                todo.completed = !todo.completed\r\n            }\r\n        }\r\n    }\r\n})\r\n\r\nexport const { addTodo, toggleTodo } = todosSlice.actions\r\n\r\nexport default todosSlice.reducer\r\n","export default function* watchData() {\r\n\r\n}","import React, {memo} from 'react'\r\nimport { useInjectReducer } from '@core/utils/injectReducer'\r\nimport { useInjectSaga } from '@core/utils/injectSaga'\r\nimport reducer from './reducer'\r\nimport saga from './saga'\r\n\r\n\r\nimport {compose, connect} from '@ttungbmt/redux-toolkit'\r\n\r\nconst key = 'todos'\r\n\r\nconsole.log(process.env)\r\n\r\nfunction HomePage() {\r\n    useInjectReducer({ key, reducer })\r\n    useInjectSaga({ key, saga })\r\n\r\n    return (\r\n        <div>\r\n            HomePage\r\n        </div>\r\n    )\r\n}\r\n\r\nconst mapStateToProps = () => ({\r\n\r\n})\r\n\r\n\r\nconst mapDispatchToProps = (dispatch) => ({\r\n\r\n})\r\n\r\nconst withConnect = connect(\r\n    mapStateToProps,\r\n    mapDispatchToProps,\r\n);\r\n\r\nexport default compose(\r\n    withConnect,\r\n    memo,\r\n)(HomePage);\r\n\r\n","import React, {memo} from 'react'\r\n\r\nfunction ContactPage() {\r\n    return (\r\n        <div>\r\n            ContactPage\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default memo(ContactPage)","import React, {memo} from 'react'\r\n\r\nfunction NotFoundPage() {\r\n    return (\r\n        <div>\r\n            NotFoundPage\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default memo(NotFoundPage)","// // @flow\n//\n//\n// import './styles/index.scss'\n//\n// import Header from './components/Header'\nimport React, {memo} from 'react'\nimport { hot } from 'react-hot-loader/root';\nimport { AppContainer } from '@core/containers'\nimport { Switch, Route, Link } from 'react-router-dom';\n\nimport HomePage from './containers/HomePage'\nimport ContactPage from './containers/ContactPage'\nimport NotFoundPage from './containers/NotFoundPage'\n\nfunction App() {\n    return (\n        <AppContainer>\n            <div>\n                <Link to=\"/\">HomePage</Link> |\n                <Link to=\"/contact\">ContactPage</Link> |\n                <Link to=\"/123\">NotFoundPage</Link>\n\n                <Switch>\n                    <Route exact path=\"/\" component={HomePage} />\n                    <Route path=\"/contact\" component={ContactPage} />\n                    <Route path=\"\" component={NotFoundPage} />\n                </Switch>\n            </div>\n        </AppContainer>\n    )\n}\nexport default memo(hot(App))\n\n","import 'app/bootstrap'\nimport * as serviceWorker from '@core/serviceWorker'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Provider } from 'react-redux';\nimport { ConnectedRouter } from 'connected-react-router';\nimport App from './app/App'\nimport history from '@core/utils/history'\nimport configureStore from '@core/configureStore'\n\n// Create redux store with history\nconst initialState = {};\nconst store = configureStore(initialState, history);\n\nconst MOUNT_NODE = document.getElementById('root')\nconst render = () => ReactDOM.render((\n    <Provider store={store}>\n        <ConnectedRouter history={history}>\n            <App />\n        </ConnectedRouter>\n    </Provider>\n), MOUNT_NODE);\n\nrender()\n\n//\n// import store, {history} from \"./app/store\"\n//\n// render((\n//     <Provider store={store}>\n//         <ConnectedRouter history={history}>\n//             <>\n//                 <App />\n//             </>\n//         </ConnectedRouter>\n//     </Provider>\n// ), document.getElementById('root'));\n//\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { routerMiddleware } from 'connected-react-router'\r\nimport createSagaMiddleware from 'redux-saga'\r\nimport createReducer from './reducers'\r\nimport { configureStore as baseConfigureStore, getDefaultMiddleware  } from '@reduxjs/toolkit'\r\n\r\nexport default function configureStore(initialState = {}, history) {\r\n    const reduxSagaMonitorOptions = {};\r\n\r\n    const sagaMiddleware = createSagaMiddleware(reduxSagaMonitorOptions);\r\n\r\n    const store = baseConfigureStore({\r\n        reducer: createReducer(),\r\n        preloadedState: initialState,\r\n        middleware: [\r\n            ...getDefaultMiddleware(),\r\n            sagaMiddleware,\r\n            routerMiddleware(history),\r\n        ],\r\n    })\r\n\r\n\r\n\r\n    // Extensions\r\n    store.runSaga = sagaMiddleware.run;\r\n    store.injectedReducers = {}; // Reducer registry\r\n    store.injectedSagas = {}; // Saga registry\r\n\r\n    // Make reducers hot reloadable\r\n    if (process.env.NODE_ENV === 'development' && module.hot) {\r\n        module.hot.accept('./reducers', () => {\r\n            const newRootReducer = createReducer(store.injectedReducers)\r\n            store.replaceReducer(newRootReducer)\r\n        })\r\n    }\r\n\r\n    return store;\r\n}"],"sourceRoot":""}