(function (Vue, lodash, moment$1, $$1, Vuex, L$1) {
	'use strict';

	Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;
	var lodash__default = 'default' in lodash ? lodash['default'] : lodash;
	moment$1 = moment$1 && moment$1.hasOwnProperty('default') ? moment$1['default'] : moment$1;
	$$1 = $$1 && $$1.hasOwnProperty('default') ? $$1['default'] : $$1;
	var Vuex__default = 'default' in Vuex ? Vuex['default'] : Vuex;
	var L$1__default = 'default' in L$1 ? L$1['default'] : L$1;

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') { __g = global; } // eslint-disable-line no-undef
	});

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.11' };
	if (typeof __e == 'number') { __e = core; } // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) { throw TypeError(it + ' is not an object!'); }
	  return it;
	};

	var document$1 = _global.document;
	// typeof document.createElement is 'object' in old IE
	var is = _isObject(document$1) && _isObject(document$1.createElement);
	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) { return it; }
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;

	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) { try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ } }
	  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported!'); }
	  if ('value' in Attributes) { O[P] = Attributes.value; }
	  return O;
	};

	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _library = false;

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode:  'global',
	  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
	});
	});

	var _functionToString = _shared('native-function-to-string', Function.toString);

	var _redefine = createCommonjsModule(function (module) {
	var SRC = _uid('src');

	var TO_STRING = 'toString';
	var TPL = ('' + _functionToString).split(TO_STRING);

	_core.inspectSource = function (it) {
	  return _functionToString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) { _has(val, 'name') || _hide(val, 'name', key); }
	  if (O[key] === val) { return; }
	  if (isFunction) { _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); }
	  if (O === _global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    _hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    _hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || _functionToString.call(this);
	});
	});

	var _aFunction = function (it) {
	  if (typeof it != 'function') { throw TypeError(it + ' is not a function!'); }
	  return it;
	};

	// optional / simple context binding

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) { return fn; }
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) { source = name; }
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    // extend global
	    if (target) { _redefine(target, key, out, type & $export.U); }
	    // export
	    if (exports[key] != out) { _hide(exports, key, exp); }
	    if (IS_PROTO && expProto[key] != out) { expProto[key] = out; }
	  }
	};
	_global.core = _core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	var _meta = createCommonjsModule(function (module) {
	var META = _uid('meta');


	var setDesc = _objectDp.f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !_fails(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  } });
	};
	var fastKey = function (it, create) {
	  // return primitive with prefix
	  if (!_isObject(it)) { return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it; }
	  if (!_has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) { return 'F'; }
	    // not necessary to add metadata
	    if (!create) { return 'E'; }
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!_has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) { return true; }
	    // not necessary to add metadata
	    if (!create) { return false; }
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) { setMeta(it); }
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};
	});
	var _meta_1 = _meta.KEY;
	var _meta_2 = _meta.NEED;
	var _meta_3 = _meta.fastKey;
	var _meta_4 = _meta.getWeak;
	var _meta_5 = _meta.onFreeze;

	var _wks = createCommonjsModule(function (module) {
	var store = _shared('wks');

	var Symbol = _global.Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
	};

	$exports.store = store;
	});

	var def = _objectDp.f;

	var TAG = _wks('toStringTag');

	var _setToStringTag = function (it, tag, stat) {
	  if (it && !_has(it = stat ? it : it.prototype, TAG)) { def(it, TAG, { configurable: true, value: tag }); }
	};

	var f$1 = _wks;

	var _wksExt = {
		f: f$1
	};

	var defineProperty = _objectDp.f;
	var _wksDefine = function (name) {
	  var $Symbol = _core.Symbol || (_core.Symbol =  _global.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) { defineProperty($Symbol, name, { value: _wksExt.f(name) }); }
	};

	var toString = {}.toString;

	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	// fallback for non-array-like ES3 and non-enumerable old V8 strings

	// eslint-disable-next-line no-prototype-builtins
	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return _cof(it) == 'String' ? it.split('') : Object(it);
	};

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function (it) {
	  if (it == undefined) { throw TypeError("Can't call method on  " + it); }
	  return it;
	};

	// to indexed object, toObject with fallback for non-array-like ES3 strings


	var _toIobject = function (it) {
	  return _iobject(_defined(it));
	};

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	// 7.1.15 ToLength

	var min = Math.min;
	var _toLength = function (it) {
	  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	// false -> Array#indexOf
	// true  -> Array#includes



	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = _toIobject($this);
	    var length = _toLength(O.length);
	    var index = _toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) { while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) { return true; }
	    // Array#indexOf ignores holes, Array#includes - not
	    } } else { for (;length > index; index++) { if (IS_INCLUDES || index in O) {
	      if (O[index] === el) { return IS_INCLUDES || index || 0; }
	    } } } return !IS_INCLUDES && -1;
	  };
	};

	var shared = _shared('keys');

	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = _uid(key));
	};

	var arrayIndexOf = _arrayIncludes(false);
	var IE_PROTO = _sharedKey('IE_PROTO');

	var _objectKeysInternal = function (object, names) {
	  var O = _toIobject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) { if (key != IE_PROTO) { _has(O, key) && result.push(key); } }
	  // Don't enum bug & hidden keys
	  while (names.length > i) { if (_has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  } }
	  return result;
	};

	// IE 8- don't enum bug keys
	var _enumBugKeys = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)



	var _objectKeys = Object.keys || function keys(O) {
	  return _objectKeysInternal(O, _enumBugKeys);
	};

	var f$2 = Object.getOwnPropertySymbols;

	var _objectGops = {
		f: f$2
	};

	var f$3 = {}.propertyIsEnumerable;

	var _objectPie = {
		f: f$3
	};

	// all enumerable object keys, includes symbols



	var _enumKeys = function (it) {
	  var result = _objectKeys(it);
	  var getSymbols = _objectGops.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = _objectPie.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) { if (isEnum.call(it, key = symbols[i++])) { result.push(key); } }
	  } return result;
	};

	// 7.2.2 IsArray(argument)

	var _isArray = Array.isArray || function isArray(arg) {
	  return _cof(arg) == 'Array';
	};

	// 7.1.13 ToObject(argument)

	var _toObject = function (it) {
	  return Object(_defined(it));
	};

	var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  _anObject(O);
	  var keys = _objectKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) { _objectDp.f(O, P = keys[i++], Properties[P]); }
	  return O;
	};

	var document$2 = _global.document;
	var _html = document$2 && document$2.documentElement;

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



	var IE_PROTO$1 = _sharedKey('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE$1 = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = _domCreate('iframe');
	  var i = _enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  _html.appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) { delete createDict[PROTOTYPE$1][_enumBugKeys[i]]; }
	  return createDict();
	};

	var _objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE$1] = _anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE$1] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else { result = createDict(); }
	  return Properties === undefined ? result : _objectDps(result, Properties);
	};

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

	var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

	var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return _objectKeysInternal(O, hiddenKeys);
	};

	var _objectGopn = {
		f: f$4
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

	var gOPN = _objectGopn.f;
	var toString$1 = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};

	var f$5 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));
	};

	var _objectGopnExt = {
		f: f$5
	};

	var gOPD = Object.getOwnPropertyDescriptor;

	var f$6 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = _toIobject(O);
	  P = _toPrimitive(P, true);
	  if (_ie8DomDefine) { try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ } }
	  if (_has(O, P)) { return _propertyDesc(!_objectPie.f.call(O, P), O[P]); }
	};

	var _objectGopd = {
		f: f$6
	};

	// ECMAScript 6 symbols shim





	var META = _meta.KEY;





















	var gOPD$1 = _objectGopd.f;
	var dP$1 = _objectDp.f;
	var gOPN$1 = _objectGopnExt.f;
	var $Symbol = _global.Symbol;
	var $JSON = _global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE$2 = 'prototype';
	var HIDDEN = _wks('_hidden');
	var TO_PRIMITIVE = _wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = _shared('symbol-registry');
	var AllSymbols = _shared('symbols');
	var OPSymbols = _shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE$2];
	var USE_NATIVE = typeof $Symbol == 'function' && !!_objectGops.f;
	var QObject = _global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = _descriptors && _fails(function () {
	  return _objectCreate(dP$1({}, 'a', {
	    get: function () { return dP$1(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD$1(ObjectProto, key);
	  if (protoDesc) { delete ObjectProto[key]; }
	  dP$1(it, key, D);
	  if (protoDesc && it !== ObjectProto) { dP$1(ObjectProto, key, protoDesc); }
	} : dP$1;

	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) { $defineProperty(OPSymbols, key, D); }
	  _anObject(it);
	  key = _toPrimitive(key, true);
	  _anObject(D);
	  if (_has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!_has(it, HIDDEN)) { dP$1(it, HIDDEN, _propertyDesc(1, {})); }
	      it[HIDDEN][key] = true;
	    } else {
	      if (_has(it, HIDDEN) && it[HIDDEN][key]) { it[HIDDEN][key] = false; }
	      D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP$1(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  _anObject(it);
	  var keys = _enumKeys(P = _toIobject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) { $defineProperty(it, key = keys[i++], P[key]); }
	  return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = _toPrimitive(key, true));
	  if (this === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) { return false; }
	  return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = _toIobject(it);
	  key = _toPrimitive(key, true);
	  if (it === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) { return; }
	  var D = gOPD$1(it, key);
	  if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) { D.enumerable = true; }
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN$1(_toIobject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) { result.push(key); }
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto, key) : true)) { result.push(AllSymbols[key]); }
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) { throw TypeError('Symbol is not a constructor!'); }
	    var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto) { $set.call(OPSymbols, value); }
	      if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) { this[HIDDEN][tag] = false; }
	      setSymbolDesc(this, tag, _propertyDesc(1, value));
	    };
	    if (_descriptors && setter) { setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set }); }
	    return wrap(tag);
	  };
	  _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
	    return this._k;
	  });

	  _objectGopd.f = $getOwnPropertyDescriptor;
	  _objectDp.f = $defineProperty;
	  _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
	  _objectPie.f = $propertyIsEnumerable;
	  _objectGops.f = $getOwnPropertySymbols;

	  if (_descriptors && !_library) {
	    _redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  _wksExt.f = function (name) {
	    return wrap(_wks(name));
	  };
	}

	_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Symbol: $Symbol });

	for (var es6Symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;){ _wks(es6Symbols[j++]); }

	for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) { _wksDefine(wellKnownSymbols[k++]); }

	_export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function (key) {
	    return _has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) { throw TypeError(sym + ' is not a symbol!'); }
	    for (var key in SymbolRegistry) { if (SymbolRegistry[key] === sym) { return key; } }
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});

	_export(_export.S + _export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443
	var FAILS_ON_PRIMITIVES = _fails(function () { _objectGops.f(1); });

	_export(_export.S + _export.F * FAILS_ON_PRIMITIVES, 'Object', {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return _objectGops.f(_toObject(it));
	  }
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var arguments$1 = arguments;

	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) { args.push(arguments$1[i++]); }
	    $replacer = replacer = args[1];
	    if (!_isObject(replacer) && it === undefined || isSymbol(it)) { return; } // IE8 returns string on undefined
	    if (!_isArray(replacer)) { replacer = function (key, value) {
	      if (typeof $replacer == 'function') { value = $replacer.call(this, key, value); }
	      if (!isSymbol(value)) { return value; }
	    }; }
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	_setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	_setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	_setToStringTag(_global.JSON, 'JSON', true);

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	_export(_export.S, 'Object', { create: _objectCreate });

	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	_export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });

	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	_export(_export.S + _export.F * !_descriptors, 'Object', { defineProperties: _objectDps });

	// most Object methods by ES6 should accept primitives



	var _objectSap = function (KEY, exec) {
	  var fn = (_core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
	};

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)

	var $getOwnPropertyDescriptor$1 = _objectGopd.f;

	_objectSap('getOwnPropertyDescriptor', function () {
	  return function getOwnPropertyDescriptor(it, key) {
	    return $getOwnPropertyDescriptor$1(_toIobject(it), key);
	  };
	});

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


	var IE_PROTO$2 = _sharedKey('IE_PROTO');
	var ObjectProto$1 = Object.prototype;

	var _objectGpo = Object.getPrototypeOf || function (O) {
	  O = _toObject(O);
	  if (_has(O, IE_PROTO$2)) { return O[IE_PROTO$2]; }
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto$1 : null;
	};

	// 19.1.2.9 Object.getPrototypeOf(O)



	_objectSap('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return _objectGpo(_toObject(it));
	  };
	});

	// 19.1.2.14 Object.keys(O)



	_objectSap('keys', function () {
	  return function keys(it) {
	    return _objectKeys(_toObject(it));
	  };
	});

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	_objectSap('getOwnPropertyNames', function () {
	  return _objectGopnExt.f;
	});

	// 19.1.2.5 Object.freeze(O)

	var meta = _meta.onFreeze;

	_objectSap('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && _isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

	// 19.1.2.17 Object.seal(O)

	var meta$1 = _meta.onFreeze;

	_objectSap('seal', function ($seal) {
	  return function seal(it) {
	    return $seal && _isObject(it) ? $seal(meta$1(it)) : it;
	  };
	});

	// 19.1.2.15 Object.preventExtensions(O)

	var meta$2 = _meta.onFreeze;

	_objectSap('preventExtensions', function ($preventExtensions) {
	  return function preventExtensions(it) {
	    return $preventExtensions && _isObject(it) ? $preventExtensions(meta$2(it)) : it;
	  };
	});

	// 19.1.2.12 Object.isFrozen(O)


	_objectSap('isFrozen', function ($isFrozen) {
	  return function isFrozen(it) {
	    return _isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

	// 19.1.2.13 Object.isSealed(O)


	_objectSap('isSealed', function ($isSealed) {
	  return function isSealed(it) {
	    return _isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

	// 19.1.2.11 Object.isExtensible(O)


	_objectSap('isExtensible', function ($isExtensible) {
	  return function isExtensible(it) {
	    return _isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

	// 19.1.2.1 Object.assign(target, source, ...)






	var $assign = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	var _objectAssign = !$assign || _fails(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) {
	  var arguments$1 = arguments;
	 // eslint-disable-line no-unused-vars
	  var T = _toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = _objectGops.f;
	  var isEnum = _objectPie.f;
	  while (aLen > index) {
	    var S = _iobject(arguments$1[index++]);
	    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!_descriptors || isEnum.call(S, key)) { T[key] = S[key]; }
	    }
	  } return T;
	} : $assign;

	// 19.1.3.1 Object.assign(target, source)


	_export(_export.S + _export.F, 'Object', { assign: _objectAssign });

	// 7.2.9 SameValue(x, y)
	var _sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	// 19.1.3.10 Object.is(value1, value2)

	_export(_export.S, 'Object', { is: _sameValue });

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */


	var check = function (O, proto) {
	  _anObject(O);
	  if (!_isObject(proto) && proto !== null) { throw TypeError(proto + ": can't set as prototype!"); }
	};
	var _setProto = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function (test, buggy, set) {
	      try {
	        set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch (e) { buggy = true; }
	      return function setPrototypeOf(O, proto) {
	        check(O, proto);
	        if (buggy) { O.__proto__ = proto; }
	        else { set(O, proto); }
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

	// 19.1.3.19 Object.setPrototypeOf(O, proto)

	_export(_export.S, 'Object', { setPrototypeOf: _setProto.set });

	// getting tag from 19.1.3.6 Object.prototype.toString()

	var TAG$1 = _wks('toStringTag');
	// ES3 wrong here
	var ARG = _cof(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};

	var _classof = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
	    // builtinTag case
	    : ARG ? _cof(O)
	    // ES3 arguments fallback
	    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

	// 19.1.3.6 Object.prototype.toString()

	var test = {};
	test[_wks('toStringTag')] = 'z';
	if (test + '' != '[object z]') {
	  _redefine(Object.prototype, 'toString', function toString() {
	    return '[object ' + _classof(this) + ']';
	  }, true);
	}

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	var _invoke = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};

	var arraySlice = [].slice;
	var factories = {};

	var construct = function (F, len, args) {
	  if (!(len in factories)) {
	    for (var n = [], i = 0; i < len; i++) { n[i] = 'a[' + i + ']'; }
	    // eslint-disable-next-line no-new-func
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};

	var _bind = Function.bind || function bind(that /* , ...args */) {
	  var fn = _aFunction(this);
	  var partArgs = arraySlice.call(arguments, 1);
	  var bound = function (/* args... */) {
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : _invoke(fn, args, that);
	  };
	  if (_isObject(fn.prototype)) { bound.prototype = fn.prototype; }
	  return bound;
	};

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)


	_export(_export.P, 'Function', { bind: _bind });

	var dP$2 = _objectDp.f;
	var FProto = Function.prototype;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name';

	// 19.2.4.2 name
	NAME in FProto || _descriptors && dP$2(FProto, NAME, {
	  configurable: true,
	  get: function () {
	    try {
	      return ('' + this).match(nameRE)[1];
	    } catch (e) {
	      return '';
	    }
	  }
	});

	var HAS_INSTANCE = _wks('hasInstance');
	var FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if (!(HAS_INSTANCE in FunctionProto)) { _objectDp.f(FunctionProto, HAS_INSTANCE, { value: function (O) {
	  if (typeof this != 'function' || !_isObject(O)) { return false; }
	  if (!_isObject(this.prototype)) { return O instanceof this; }
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while (O = _objectGpo(O)) { if (this.prototype === O) { return true; } }
	  return false;
	} }); }

	var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var space = '[' + _stringWs + ']';
	var non = '\u200b\u0085';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');

	var exporter = function (KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = _fails(function () {
	    return !!_stringWs[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
	  if (ALIAS) { exp[ALIAS] = fn; }
	  _export(_export.P + _export.F * FORCE, 'String', exp);
	};

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(_defined(string));
	  if (TYPE & 1) { string = string.replace(ltrim, ''); }
	  if (TYPE & 2) { string = string.replace(rtrim, ''); }
	  return string;
	};

	var _stringTrim = exporter;

	var $parseInt = _global.parseInt;
	var $trim = _stringTrim.trim;

	var hex = /^[-+]?0[xX]/;

	var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

	// 18.2.5 parseInt(string, radix)
	_export(_export.G + _export.F * (parseInt != _parseInt), { parseInt: _parseInt });

	var $parseFloat = _global.parseFloat;
	var $trim$1 = _stringTrim.trim;

	var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim$1(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	// 18.2.4 parseFloat(string)
	_export(_export.G + _export.F * (parseFloat != _parseFloat), { parseFloat: _parseFloat });

	var setPrototypeOf = _setProto.set;
	var _inheritIfRequired = function (that, target, C) {
	  var S = target.constructor;
	  var P;
	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf) {
	    setPrototypeOf(that, P);
	  } return that;
	};

	var gOPN$2 = _objectGopn.f;
	var gOPD$2 = _objectGopd.f;
	var dP$3 = _objectDp.f;
	var $trim$2 = _stringTrim.trim;
	var NUMBER = 'Number';
	var $Number = _global[NUMBER];
	var Base = $Number;
	var proto = $Number.prototype;
	// Opera ~12 has broken Object#toString
	var BROKEN_COF = _cof(_objectCreate(proto)) == NUMBER;
	var TRIM = 'trim' in String.prototype;

	// 7.1.3 ToNumber(argument)
	var toNumber = function (argument) {
	  var it = _toPrimitive(argument, false);
	  if (typeof it == 'string' && it.length > 2) {
	    it = TRIM ? it.trim() : $trim$2(it, 3);
	    var first = it.charCodeAt(0);
	    var third, radix, maxCode;
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) { return NaN; } // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default: return +it;
	      }
	      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) { return NaN; }
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
	  $Number = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? _fails(function () { proto.valueOf.call(that); }) : _cof(that) != NUMBER)
	        ? _inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for (var keys = _descriptors ? gOPN$2(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j$1 = 0, key; keys.length > j$1; j$1++) {
	    if (_has(Base, key = keys[j$1]) && !_has($Number, key)) {
	      dP$3($Number, key, gOPD$2(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  _redefine(_global, NUMBER, $Number);
	}

	var _aNumberValue = function (it, msg) {
	  if (typeof it != 'number' && _cof(it) != 'Number') { throw TypeError(msg); }
	  return +it;
	};

	var _stringRepeat = function repeat(count) {
	  var str = String(_defined(this));
	  var res = '';
	  var n = _toInteger(count);
	  if (n < 0 || n == Infinity) { throw RangeError("Count can't be negative"); }
	  for (;n > 0; (n >>>= 1) && (str += str)) { if (n & 1) { res += str; } }
	  return res;
	};

	var $toFixed = 1.0.toFixed;
	var floor$1 = Math.floor;
	var data = [0, 0, 0, 0, 0, 0];
	var ERROR = 'Number.toFixed: incorrect invocation!';
	var ZERO = '0';

	var multiply = function (n, c) {
	  var i = -1;
	  var c2 = c;
	  while (++i < 6) {
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor$1(c2 / 1e7);
	  }
	};
	var divide = function (n) {
	  var i = 6;
	  var c = 0;
	  while (--i >= 0) {
	    c += data[i];
	    data[i] = floor$1(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function () {
	  var i = 6;
	  var s = '';
	  while (--i >= 0) {
	    if (s !== '' || i === 0 || data[i] !== 0) {
	      var t = String(data[i]);
	      s = s === '' ? t : s + _stringRepeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function (x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function (x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  } return n;
	};

	_export(_export.P + _export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
	) || !_fails(function () {
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits) {
	    var x = _aNumberValue(this, ERROR);
	    var f = _toInteger(fractionDigits);
	    var s = '';
	    var m = ZERO;
	    var e, z, j, k;
	    if (f < 0 || f > 20) { throw RangeError(ERROR); }
	    // eslint-disable-next-line no-self-compare
	    if (x != x) { return 'NaN'; }
	    if (x <= -1e21 || x >= 1e21) { return String(x); }
	    if (x < 0) {
	      s = '-';
	      x = -x;
	    }
	    if (x > 1e-21) {
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = f;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + _stringRepeat.call(ZERO, f);
	      }
	    }
	    if (f > 0) {
	      k = m.length;
	      m = s + (k <= f ? '0.' + _stringRepeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

	var $toPrecision = 1.0.toPrecision;

	_export(_export.P + _export.F * (_fails(function () {
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !_fails(function () {
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision) {
	    var that = _aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
	  }
	});

	// 20.1.2.1 Number.EPSILON


	_export(_export.S, 'Number', { EPSILON: Math.pow(2, -52) });

	// 20.1.2.2 Number.isFinite(number)

	var _isFinite = _global.isFinite;

	_export(_export.S, 'Number', {
	  isFinite: function isFinite(it) {
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

	// 20.1.2.3 Number.isInteger(number)

	var floor$2 = Math.floor;
	var _isInteger = function isInteger(it) {
	  return !_isObject(it) && isFinite(it) && floor$2(it) === it;
	};

	// 20.1.2.3 Number.isInteger(number)


	_export(_export.S, 'Number', { isInteger: _isInteger });

	// 20.1.2.4 Number.isNaN(number)


	_export(_export.S, 'Number', {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});

	// 20.1.2.5 Number.isSafeInteger(number)


	var abs = Math.abs;

	_export(_export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number) {
	    return _isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

	// 20.1.2.6 Number.MAX_SAFE_INTEGER


	_export(_export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

	// 20.1.2.10 Number.MIN_SAFE_INTEGER


	_export(_export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

	// 20.1.2.12 Number.parseFloat(string)
	_export(_export.S + _export.F * (Number.parseFloat != _parseFloat), 'Number', { parseFloat: _parseFloat });

	// 20.1.2.13 Number.parseInt(string, radix)
	_export(_export.S + _export.F * (Number.parseInt != _parseInt), 'Number', { parseInt: _parseInt });

	// 20.2.2.20 Math.log1p(x)
	var _mathLog1p = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

	// 20.2.2.3 Math.acosh(x)


	var sqrt = Math.sqrt;
	var $acosh = Math.acosh;

	_export(_export.S + _export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : _mathLog1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

	// 20.2.2.5 Math.asinh(x)

	var $asinh = Math.asinh;

	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}

	// Tor Browser bug: Math.asinh(0) -> -0
	_export(_export.S + _export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

	// 20.2.2.7 Math.atanh(x)

	var $atanh = Math.atanh;

	// Tor Browser bug: Math.atanh(-0) -> 0
	_export(_export.S + _export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

	// 20.2.2.28 Math.sign(x)
	var _mathSign = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

	// 20.2.2.9 Math.cbrt(x)



	_export(_export.S, 'Math', {
	  cbrt: function cbrt(x) {
	    return _mathSign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

	// 20.2.2.11 Math.clz32(x)


	_export(_export.S, 'Math', {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

	// 20.2.2.12 Math.cosh(x)

	var exp = Math.exp;

	_export(_export.S, 'Math', {
	  cosh: function cosh(x) {
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	var _mathExpm1 = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

	// 20.2.2.14 Math.expm1(x)



	_export(_export.S + _export.F * (_mathExpm1 != Math.expm1), 'Math', { expm1: _mathExpm1 });

	// 20.2.2.16 Math.fround(x)

	var pow$1 = Math.pow;
	var EPSILON = pow$1(2, -52);
	var EPSILON32 = pow$1(2, -23);
	var MAX32 = pow$1(2, 127) * (2 - EPSILON32);
	var MIN32 = pow$1(2, -126);

	var roundTiesToEven = function (n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};

	var _mathFround = Math.fround || function fround(x) {
	  var $abs = Math.abs(x);
	  var $sign = _mathSign(x);
	  var a, result;
	  if ($abs < MIN32) { return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32; }
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare
	  if (result > MAX32 || result != result) { return $sign * Infinity; }
	  return $sign * result;
	};

	// 20.2.2.16 Math.fround(x)


	_export(_export.S, 'Math', { fround: _mathFround });

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])

	var abs$1 = Math.abs;

	_export(_export.S, 'Math', {
	  hypot: function hypot(value1, value2) {
	    var arguments$1 = arguments;
	 // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs$1(arguments$1[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else { sum += arg; }
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

	// 20.2.2.18 Math.imul(x, y)

	var $imul = Math.imul;

	// some WebKit versions fails with big numbers, some has wrong arity
	_export(_export.S + _export.F * _fails(function () {
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y) {
	    var UINT16 = 0xffff;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

	// 20.2.2.21 Math.log10(x)


	_export(_export.S, 'Math', {
	  log10: function log10(x) {
	    return Math.log(x) * Math.LOG10E;
	  }
	});

	// 20.2.2.20 Math.log1p(x)


	_export(_export.S, 'Math', { log1p: _mathLog1p });

	// 20.2.2.22 Math.log2(x)


	_export(_export.S, 'Math', {
	  log2: function log2(x) {
	    return Math.log(x) / Math.LN2;
	  }
	});

	// 20.2.2.28 Math.sign(x)


	_export(_export.S, 'Math', { sign: _mathSign });

	// 20.2.2.30 Math.sinh(x)


	var exp$1 = Math.exp;

	// V8 near Chromium 38 has a problem with very small numbers
	_export(_export.S + _export.F * _fails(function () {
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x) {
	    return Math.abs(x = +x) < 1
	      ? (_mathExpm1(x) - _mathExpm1(-x)) / 2
	      : (exp$1(x - 1) - exp$1(-x - 1)) * (Math.E / 2);
	  }
	});

	// 20.2.2.33 Math.tanh(x)


	var exp$2 = Math.exp;

	_export(_export.S, 'Math', {
	  tanh: function tanh(x) {
	    var a = _mathExpm1(x = +x);
	    var b = _mathExpm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));
	  }
	});

	// 20.2.2.34 Math.trunc(x)


	_export(_export.S, 'Math', {
	  trunc: function trunc(it) {
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	_export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) {
	    var arguments$1 = arguments;
	 // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments$1[i++];
	      if (_toAbsoluteIndex(code, 0x10ffff) !== code) { throw RangeError(code + ' is not a valid code point'); }
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

	_export(_export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite) {
	    var arguments$1 = arguments;

	    var tpl = _toIobject(callSite.raw);
	    var len = _toLength(tpl.length);
	    var aLen = arguments.length;
	    var res = [];
	    var i = 0;
	    while (len > i) {
	      res.push(String(tpl[i++]));
	      if (i < aLen) { res.push(String(arguments$1[i])); }
	    } return res.join('');
	  }
	});

	// 21.1.3.25 String.prototype.trim()
	_stringTrim('trim', function ($trim) {
	  return function trim() {
	    return $trim(this, 3);
	  };
	});

	// true  -> String#at
	// false -> String#codePointAt
	var _stringAt = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(_defined(that));
	    var i = _toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) { return TO_STRING ? '' : undefined; }
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var _iterators = {};

	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	_hide(IteratorPrototype, _wks('iterator'), function () { return this; });

	var _iterCreate = function (Constructor, NAME, next) {
	  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
	  _setToStringTag(Constructor, NAME + ' Iterator');
	};

	var ITERATOR = _wks('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function () { return this; };

	var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  _iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) { return proto[kind]; }
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      _setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if ( typeof IteratorPrototype[ITERATOR] != 'function') { _hide(IteratorPrototype, ITERATOR, returnThis); }
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if ( (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    _hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  _iterators[NAME] = $default;
	  _iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) { for (key in methods) {
	      if (!(key in proto)) { _redefine(proto, key, methods[key]); }
	    } } else { _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods); }
	  }
	  return methods;
	};

	var $at = _stringAt(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	_iterDefine(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) { return { value: undefined, done: true }; }
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});

	var $at$1 = _stringAt(false);
	_export(_export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at$1(this, pos);
	  }
	});

	// 7.2.8 IsRegExp(argument)


	var MATCH = _wks('match');
	var _isRegexp = function (it) {
	  var isRegExp;
	  return _isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
	};

	// helper for String#{startsWith, endsWith, includes}



	var _stringContext = function (that, searchString, NAME) {
	  if (_isRegexp(searchString)) { throw TypeError('String#' + NAME + " doesn't accept regex!"); }
	  return String(_defined(that));
	};

	var MATCH$1 = _wks('match');
	var _failsIsRegexp = function (KEY) {
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch (e) {
	    try {
	      re[MATCH$1] = false;
	      return !'/./'[KEY](re);
	    } catch (f) { /* empty */ }
	  } return true;
	};

	var ENDS_WITH = 'endsWith';
	var $endsWith = ''[ENDS_WITH];

	_export(_export.P + _export.F * _failsIsRegexp(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = _stringContext(this, searchString, ENDS_WITH);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = _toLength(that.length);
	    var end = endPosition === undefined ? len : Math.min(_toLength(endPosition), len);
	    var search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

	var INCLUDES = 'includes';

	_export(_export.P + _export.F * _failsIsRegexp(INCLUDES), 'String', {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~_stringContext(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	_export(_export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: _stringRepeat
	});

	var STARTS_WITH = 'startsWith';
	var $startsWith = ''[STARTS_WITH];

	_export(_export.P + _export.F * _failsIsRegexp(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = _stringContext(this, searchString, STARTS_WITH);
	    var index = _toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

	var quot = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function (string, tag, attribute, value) {
	  var S = String(_defined(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') { p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"'; }
	  return p1 + '>' + S + '</' + tag + '>';
	};
	var _stringHtml = function (NAME, exec) {
	  var O = {};
	  O[NAME] = exec(createHTML);
	  _export(_export.P + _export.F * _fails(function () {
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

	// B.2.3.2 String.prototype.anchor(name)
	_stringHtml('anchor', function (createHTML) {
	  return function anchor(name) {
	    return createHTML(this, 'a', 'name', name);
	  };
	});

	// B.2.3.3 String.prototype.big()
	_stringHtml('big', function (createHTML) {
	  return function big() {
	    return createHTML(this, 'big', '', '');
	  };
	});

	// B.2.3.4 String.prototype.blink()
	_stringHtml('blink', function (createHTML) {
	  return function blink() {
	    return createHTML(this, 'blink', '', '');
	  };
	});

	// B.2.3.5 String.prototype.bold()
	_stringHtml('bold', function (createHTML) {
	  return function bold() {
	    return createHTML(this, 'b', '', '');
	  };
	});

	// B.2.3.6 String.prototype.fixed()
	_stringHtml('fixed', function (createHTML) {
	  return function fixed() {
	    return createHTML(this, 'tt', '', '');
	  };
	});

	// B.2.3.7 String.prototype.fontcolor(color)
	_stringHtml('fontcolor', function (createHTML) {
	  return function fontcolor(color) {
	    return createHTML(this, 'font', 'color', color);
	  };
	});

	// B.2.3.8 String.prototype.fontsize(size)
	_stringHtml('fontsize', function (createHTML) {
	  return function fontsize(size) {
	    return createHTML(this, 'font', 'size', size);
	  };
	});

	// B.2.3.9 String.prototype.italics()
	_stringHtml('italics', function (createHTML) {
	  return function italics() {
	    return createHTML(this, 'i', '', '');
	  };
	});

	// B.2.3.10 String.prototype.link(url)
	_stringHtml('link', function (createHTML) {
	  return function link(url) {
	    return createHTML(this, 'a', 'href', url);
	  };
	});

	// B.2.3.11 String.prototype.small()
	_stringHtml('small', function (createHTML) {
	  return function small() {
	    return createHTML(this, 'small', '', '');
	  };
	});

	// B.2.3.12 String.prototype.strike()
	_stringHtml('strike', function (createHTML) {
	  return function strike() {
	    return createHTML(this, 'strike', '', '');
	  };
	});

	// B.2.3.13 String.prototype.sub()
	_stringHtml('sub', function (createHTML) {
	  return function sub() {
	    return createHTML(this, 'sub', '', '');
	  };
	});

	// B.2.3.14 String.prototype.sup()
	_stringHtml('sup', function (createHTML) {
	  return function sup() {
	    return createHTML(this, 'sup', '', '');
	  };
	});

	// 20.3.3.1 / 15.9.4.4 Date.now()


	_export(_export.S, 'Date', { now: function () { return new Date().getTime(); } });

	_export(_export.P + _export.F * _fails(function () {
	  return new Date(NaN).toJSON() !== null
	    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
	}), 'Date', {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = _toObject(this);
	    var pv = _toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

	var getTime = Date.prototype.getTime;
	var $toISOString = Date.prototype.toISOString;

	var lz = function (num) {
	  return num > 9 ? num : '0' + num;
	};

	// PhantomJS / old WebKit has a broken implementations
	var _dateToIsoString = (_fails(function () {
	  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !_fails(function () {
	  $toISOString.call(new Date(NaN));
	})) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) { throw RangeError('Invalid time value'); }
	  var d = this;
	  var y = d.getUTCFullYear();
	  var m = d.getUTCMilliseconds();
	  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
	  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	} : $toISOString;

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()



	// PhantomJS / old WebKit has a broken implementations
	_export(_export.P + _export.F * (Date.prototype.toISOString !== _dateToIsoString), 'Date', {
	  toISOString: _dateToIsoString
	});

	var DateProto = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var $toString = DateProto[TO_STRING];
	var getTime$1 = DateProto.getTime;
	if (new Date(NaN) + '' != INVALID_DATE) {
	  _redefine(DateProto, TO_STRING, function toString() {
	    var value = getTime$1.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

	var NUMBER$1 = 'number';

	var _dateToPrimitive = function (hint) {
	  if (hint !== 'string' && hint !== NUMBER$1 && hint !== 'default') { throw TypeError('Incorrect hint'); }
	  return _toPrimitive(_anObject(this), hint != NUMBER$1);
	};

	var TO_PRIMITIVE$1 = _wks('toPrimitive');
	var proto$1 = Date.prototype;

	if (!(TO_PRIMITIVE$1 in proto$1)) { _hide(proto$1, TO_PRIMITIVE$1, _dateToPrimitive); }

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)


	_export(_export.S, 'Array', { isArray: _isArray });

	// call something on iterator step with safe closing on error

	var _iterCall = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) { _anObject(ret.call(iterator)); }
	    throw e;
	  }
	};

	// check on default Array iterator

	var ITERATOR$1 = _wks('iterator');
	var ArrayProto = Array.prototype;

	var _isArrayIter = function (it) {
	  return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
	};

	var _createProperty = function (object, index, value) {
	  if (index in object) { _objectDp.f(object, index, _propertyDesc(0, value)); }
	  else { object[index] = value; }
	};

	var ITERATOR$2 = _wks('iterator');

	var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
	  if (it != undefined) { return it[ITERATOR$2]
	    || it['@@iterator']
	    || _iterators[_classof(it)]; }
	};

	var ITERATOR$3 = _wks('iterator');
	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR$3]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(riter, function () { throw 2; });
	} catch (e) { /* empty */ }

	var _iterDetect = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) { return false; }
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR$3]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR$3] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};

	_export(_export.S + _export.F * !_iterDetect(function (iter) { Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	    var O = _toObject(arrayLike);
	    var C = typeof this == 'function' ? this : Array;
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var index = 0;
	    var iterFn = core_getIteratorMethod(O);
	    var length, result, step, iterator;
	    if (mapping) { mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); }
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = _toLength(O.length);
	      for (result = new C(length); length > index; index++) {
	        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});

	// WebKit Array.of isn't generic
	_export(_export.S + _export.F * _fails(function () {
	  function F() { /* empty */ }
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */) {
	    var arguments$1 = arguments;

	    var index = 0;
	    var aLen = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(aLen);
	    while (aLen > index) { _createProperty(result, index, arguments$1[index++]); }
	    result.length = aLen;
	    return result;
	  }
	});

	var _strictMethod = function (method, arg) {
	  return !!method && _fails(function () {
	    // eslint-disable-next-line no-useless-call
	    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
	  });
	};

	// 22.1.3.13 Array.prototype.join(separator)


	var arrayJoin = [].join;

	// fallback for not array-like strings
	_export(_export.P + _export.F * (_iobject != Object || !_strictMethod(arrayJoin)), 'Array', {
	  join: function join(separator) {
	    return arrayJoin.call(_toIobject(this), separator === undefined ? ',' : separator);
	  }
	});

	var arraySlice$1 = [].slice;

	// fallback for not array-like ES3 strings and DOM objects
	_export(_export.P + _export.F * _fails(function () {
	  if (_html) { arraySlice$1.call(_html); }
	}), 'Array', {
	  slice: function slice(begin, end) {
	    var len = _toLength(this.length);
	    var klass = _cof(this);
	    end = end === undefined ? len : end;
	    if (klass == 'Array') { return arraySlice$1.call(this, begin, end); }
	    var start = _toAbsoluteIndex(begin, len);
	    var upTo = _toAbsoluteIndex(end, len);
	    var size = _toLength(upTo - start);
	    var cloned = new Array(size);
	    var i = 0;
	    for (; i < size; i++) { cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i]; }
	    return cloned;
	  }
	});

	var $sort = [].sort;
	var test$1 = [1, 2, 3];

	_export(_export.P + _export.F * (_fails(function () {
	  // IE8-
	  test$1.sort(undefined);
	}) || !_fails(function () {
	  // V8 bug
	  test$1.sort(null);
	  // Old WebKit
	}) || !_strictMethod($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? $sort.call(_toObject(this))
	      : $sort.call(_toObject(this), _aFunction(comparefn));
	  }
	});

	var SPECIES = _wks('species');

	var _arraySpeciesConstructor = function (original) {
	  var C;
	  if (_isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) { C = undefined; }
	    if (_isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) { C = undefined; }
	    }
	  } return C === undefined ? Array : C;
	};

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


	var _arraySpeciesCreate = function (original, length) {
	  return new (_arraySpeciesConstructor(original))(length);
	};

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex





	var _arrayMethods = function (TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || _arraySpeciesCreate;
	  return function ($this, callbackfn, that) {
	    var O = _toObject($this);
	    var self = _iobject(O);
	    var f = _ctx(callbackfn, that, 3);
	    var length = _toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;
	    for (;length > index; index++) { if (NO_HOLES || index in self) {
	      val = self[index];
	      res = f(val, index, O);
	      if (TYPE) {
	        if (IS_MAP) { result[index] = res; }   // map
	        else if (res) { switch (TYPE) {
	          case 3: return true;             // some
	          case 5: return val;              // find
	          case 6: return index;            // findIndex
	          case 2: result.push(val);        // filter
	        } } else if (IS_EVERY) { return false; } // every
	      }
	    } }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

	var $forEach = _arrayMethods(0);
	var STRICT = _strictMethod([].forEach, true);

	_export(_export.P + _export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */) {
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

	var $map = _arrayMethods(1);

	_export(_export.P + _export.F * !_strictMethod([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

	var $filter = _arrayMethods(2);

	_export(_export.P + _export.F * !_strictMethod([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

	var $some = _arrayMethods(3);

	_export(_export.P + _export.F * !_strictMethod([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

	var $every = _arrayMethods(4);

	_export(_export.P + _export.F * !_strictMethod([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

	var _arrayReduce = function (that, callbackfn, aLen, memo, isRight) {
	  _aFunction(callbackfn);
	  var O = _toObject(that);
	  var self = _iobject(O);
	  var length = _toLength(O.length);
	  var index = isRight ? length - 1 : 0;
	  var i = isRight ? -1 : 1;
	  if (aLen < 2) { for (;;) {
	    if (index in self) {
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if (isRight ? index < 0 : length <= index) {
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  } }
	  for (;isRight ? index >= 0 : length > index; index += i) { if (index in self) {
	    memo = callbackfn(memo, self[index], index, O);
	  } }
	  return memo;
	};

	_export(_export.P + _export.F * !_strictMethod([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return _arrayReduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

	_export(_export.P + _export.F * !_strictMethod([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return _arrayReduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

	var $indexOf = _arrayIncludes(false);
	var $native = [].indexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

	_export(_export.P + _export.F * (NEGATIVE_ZERO || !_strictMethod($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

	var $native$1 = [].lastIndexOf;
	var NEGATIVE_ZERO$1 = !!$native$1 && 1 / [1].lastIndexOf(1, -0) < 0;

	_export(_export.P + _export.F * (NEGATIVE_ZERO$1 || !_strictMethod($native$1)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	    // convert -0 to +0
	    if (NEGATIVE_ZERO$1) { return $native$1.apply(this, arguments) || 0; }
	    var O = _toIobject(this);
	    var length = _toLength(O.length);
	    var index = length - 1;
	    if (arguments.length > 1) { index = Math.min(index, _toInteger(arguments[1])); }
	    if (index < 0) { index = length + index; }
	    for (;index >= 0; index--) { if (index in O) { if (O[index] === searchElement) { return index || 0; } } }
	    return -1;
	  }
	});

	var _arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = _toObject(this);
	  var len = _toLength(O.length);
	  var to = _toAbsoluteIndex(target, len);
	  var from = _toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = Math.min((end === undefined ? len : _toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) { O[to] = O[from]; }
	    else { delete O[to]; }
	    to += inc;
	    from += inc;
	  } return O;
	};

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = _wks('unscopables');
	var ArrayProto$1 = Array.prototype;
	if (ArrayProto$1[UNSCOPABLES] == undefined) { _hide(ArrayProto$1, UNSCOPABLES, {}); }
	var _addToUnscopables = function (key) {
	  ArrayProto$1[UNSCOPABLES][key] = true;
	};

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


	_export(_export.P, 'Array', { copyWithin: _arrayCopyWithin });

	_addToUnscopables('copyWithin');

	var _arrayFill = function fill(value /* , start = 0, end = @length */) {
	  var O = _toObject(this);
	  var length = _toLength(O.length);
	  var aLen = arguments.length;
	  var index = _toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
	  var end = aLen > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : _toAbsoluteIndex(end, length);
	  while (endPos > index) { O[index++] = value; }
	  return O;
	};

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


	_export(_export.P, 'Array', { fill: _arrayFill });

	_addToUnscopables('fill');

	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

	var $find = _arrayMethods(5);
	var KEY = 'find';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) { Array(1)[KEY](function () { forced = false; }); }
	_export(_export.P + _export.F * forced, 'Array', {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	_addToUnscopables(KEY);

	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

	var $find$1 = _arrayMethods(6);
	var KEY$1 = 'findIndex';
	var forced$1 = true;
	// Shouldn't skip holes
	if (KEY$1 in []) { Array(1)[KEY$1](function () { forced$1 = false; }); }
	_export(_export.P + _export.F * forced$1, 'Array', {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	_addToUnscopables(KEY$1);

	var SPECIES$1 = _wks('species');

	var _setSpecies = function (KEY) {
	  var C = _global[KEY];
	  if (_descriptors && C && !C[SPECIES$1]) { _objectDp.f(C, SPECIES$1, {
	    configurable: true,
	    get: function () { return this; }
	  }); }
	};

	_setSpecies('Array');

	var _iterStep = function (done, value) {
	  return { value: value, done: !!done };
	};

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
	  this._t = _toIobject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return _iterStep(1);
	  }
	  if (kind == 'keys') { return _iterStep(0, index); }
	  if (kind == 'values') { return _iterStep(0, O[index]); }
	  return _iterStep(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	_iterators.Arguments = _iterators.Array;

	_addToUnscopables('keys');
	_addToUnscopables('values');
	_addToUnscopables('entries');

	// 21.2.5.3 get RegExp.prototype.flags

	var _flags = function () {
	  var that = _anObject(this);
	  var result = '';
	  if (that.global) { result += 'g'; }
	  if (that.ignoreCase) { result += 'i'; }
	  if (that.multiline) { result += 'm'; }
	  if (that.unicode) { result += 'u'; }
	  if (that.sticky) { result += 'y'; }
	  return result;
	};

	var dP$4 = _objectDp.f;
	var gOPN$3 = _objectGopn.f;


	var $RegExp = _global.RegExp;
	var Base$1 = $RegExp;
	var proto$2 = $RegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;
	// "new" creates a new object, old webkit buggy here
	var CORRECT_NEW = new $RegExp(re1) !== re1;

	if (_descriptors && (!CORRECT_NEW || _fails(function () {
	  re2[_wks('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp;
	    var piRE = _isRegexp(p);
	    var fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : _inheritIfRequired(CORRECT_NEW
	        ? new Base$1(piRE && !fiU ? p.source : p, f)
	        : Base$1((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? _flags.call(p) : f)
	      , tiRE ? this : proto$2, $RegExp);
	  };
	  var proxy = function (key) {
	    key in $RegExp || dP$4($RegExp, key, {
	      configurable: true,
	      get: function () { return Base$1[key]; },
	      set: function (it) { Base$1[key] = it; }
	    });
	  };
	  for (var keys$1 = gOPN$3(Base$1), i = 0; keys$1.length > i;) { proxy(keys$1[i++]); }
	  proto$2.constructor = $RegExp;
	  $RegExp.prototype = proto$2;
	  _redefine(_global, 'RegExp', $RegExp);
	}

	_setSpecies('RegExp');

	var nativeExec = RegExp.prototype.exec;
	// This always refers to the native implementation, because the
	// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
	// which loads this file before patching the method.
	var nativeReplace = String.prototype.replace;

	var patchedExec = nativeExec;

	var LAST_INDEX = 'lastIndex';

	var UPDATES_LAST_INDEX_WRONG = (function () {
	  var re1 = /a/,
	      re2 = /b*/g;
	  nativeExec.call(re1, 'a');
	  nativeExec.call(re2, 'a');
	  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
	})();

	// nonparticipating capturing group, copied from es5-shim's String#split patch.
	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

	if (PATCH) {
	  patchedExec = function exec(str) {
	    var re = this;
	    var lastIndex, reCopy, match, i;

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + re.source + '$(?!\\s)', _flags.call(re));
	    }
	    if (UPDATES_LAST_INDEX_WRONG) { lastIndex = re[LAST_INDEX]; }

	    match = nativeExec.call(re, str);

	    if (UPDATES_LAST_INDEX_WRONG && match) {
	      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
	    }
	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      // eslint-disable-next-line no-loop-func
	      nativeReplace.call(match[0], reCopy, function () {
	        var arguments$1 = arguments;

	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments$1[i] === undefined) { match[i] = undefined; }
	        }
	      });
	    }

	    return match;
	  };
	}

	var _regexpExec = patchedExec;

	_export({
	  target: 'RegExp',
	  proto: true,
	  forced: _regexpExec !== /./.exec
	}, {
	  exec: _regexpExec
	});

	// 21.2.5.3 get RegExp.prototype.flags()
	if (_descriptors && /./g.flags != 'g') { _objectDp.f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: _flags
	}); }

	var TO_STRING$1 = 'toString';
	var $toString$1 = /./[TO_STRING$1];

	var define = function (fn) {
	  _redefine(RegExp.prototype, TO_STRING$1, fn, true);
	};

	// 21.2.5.14 RegExp.prototype.toString()
	if (_fails(function () { return $toString$1.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
	  define(function toString() {
	    var R = _anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if ($toString$1.name != TO_STRING$1) {
	  define(function toString() {
	    return $toString$1.call(this);
	  });
	}

	var at = _stringAt(true);

	 // `AdvanceStringIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-advancestringindex
	var _advanceStringIndex = function (S, index, unicode) {
	  return index + (unicode ? at(S, index).length : 1);
	};

	var builtinExec = RegExp.prototype.exec;

	 // `RegExpExec` abstract operation
	// https://tc39.github.io/ecma262/#sec-regexpexec
	var _regexpExecAbstract = function (R, S) {
	  var exec = R.exec;
	  if (typeof exec === 'function') {
	    var result = exec.call(R, S);
	    if (typeof result !== 'object') {
	      throw new TypeError('RegExp exec method returned something other than an Object or null');
	    }
	    return result;
	  }
	  if (_classof(R) !== 'RegExp') {
	    throw new TypeError('RegExp#exec called on incompatible receiver');
	  }
	  return builtinExec.call(R, S);
	};

	var SPECIES$2 = _wks('species');

	var REPLACE_SUPPORTS_NAMED_GROUPS = !_fails(function () {
	  // #replace needs built-in support for named groups.
	  // #match works fine because it just return the exec results, even if it has
	  // a "grops" property.
	  var re = /./;
	  re.exec = function () {
	    var result = [];
	    result.groups = { a: '7' };
	    return result;
	  };
	  return ''.replace(re, '$<a>') !== '7';
	});

	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
	  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	  var re = /(?:)/;
	  var originalExec = re.exec;
	  re.exec = function () { return originalExec.apply(this, arguments); };
	  var result = 'ab'.split(re);
	  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
	})();

	var _fixReWks = function (KEY, length, exec) {
	  var SYMBOL = _wks(KEY);

	  var DELEGATES_TO_SYMBOL = !_fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  });

	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !_fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;
	    re.exec = function () { execCalled = true; return null; };
	    if (KEY === 'split') {
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};
	      re.constructor[SPECIES$2] = function () { return re; };
	    }
	    re[SYMBOL]('');
	    return !execCalled;
	  }) : undefined;

	  if (
	    !DELEGATES_TO_SYMBOL ||
	    !DELEGATES_TO_EXEC ||
	    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
	    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
	  ) {
	    var nativeRegExpMethod = /./[SYMBOL];
	    var fns = exec(
	      _defined,
	      SYMBOL,
	      ''[KEY],
	      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
	        if (regexp.exec === _regexpExec) {
	          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	            // The native String method already delegates to @@method (this
	            // polyfilled function), leasing to infinite recursion.
	            // We avoid it by directly calling the native @@method method.
	            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
	          }
	          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
	        }
	        return { done: false };
	      }
	    );
	    var strfn = fns[0];
	    var rxfn = fns[1];

	    _redefine(String.prototype, KEY, strfn);
	    _hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return rxfn.call(string, this); }
	    );
	  }
	};

	// @@match logic
	_fixReWks('match', 1, function (defined, MATCH, $match, maybeCallNative) {
	  return [
	    // `String.prototype.match` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.match
	    function match(regexp) {
	      var O = defined(this);
	      var fn = regexp == undefined ? undefined : regexp[MATCH];
	      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	    },
	    // `RegExp.prototype[@@match]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
	    function (regexp) {
	      var res = maybeCallNative($match, regexp, this);
	      if (res.done) { return res.value; }
	      var rx = _anObject(regexp);
	      var S = String(this);
	      if (!rx.global) { return _regexpExecAbstract(rx, S); }
	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	      var A = [];
	      var n = 0;
	      var result;
	      while ((result = _regexpExecAbstract(rx, S)) !== null) {
	        var matchStr = String(result[0]);
	        A[n] = matchStr;
	        if (matchStr === '') { rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode); }
	        n++;
	      }
	      return n === 0 ? null : A;
	    }
	  ];
	});

	var max$1 = Math.max;
	var min$2 = Math.min;
	var floor$3 = Math.floor;
	var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

	var maybeToString = function (it) {
	  return it === undefined ? it : String(it);
	};

	// @@replace logic
	_fixReWks('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
	  return [
	    // `String.prototype.replace` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
	    function replace(searchValue, replaceValue) {
	      var O = defined(this);
	      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	      return fn !== undefined
	        ? fn.call(searchValue, O, replaceValue)
	        : $replace.call(String(O), searchValue, replaceValue);
	    },
	    // `RegExp.prototype[@@replace]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
	    function (regexp, replaceValue) {
	      var res = maybeCallNative($replace, regexp, this, replaceValue);
	      if (res.done) { return res.value; }

	      var rx = _anObject(regexp);
	      var S = String(this);
	      var functionalReplace = typeof replaceValue === 'function';
	      if (!functionalReplace) { replaceValue = String(replaceValue); }
	      var global = rx.global;
	      if (global) {
	        var fullUnicode = rx.unicode;
	        rx.lastIndex = 0;
	      }
	      var results = [];
	      while (true) {
	        var result = _regexpExecAbstract(rx, S);
	        if (result === null) { break; }
	        results.push(result);
	        if (!global) { break; }
	        var matchStr = String(result[0]);
	        if (matchStr === '') { rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode); }
	      }
	      var accumulatedResult = '';
	      var nextSourcePosition = 0;
	      for (var i = 0; i < results.length; i++) {
	        result = results[i];
	        var matched = String(result[0]);
	        var position = max$1(min$2(_toInteger(result.index), S.length), 0);
	        var captures = [];
	        // NOTE: This is equivalent to
	        //   captures = result.slice(1).map(maybeToString)
	        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
	        for (var j = 1; j < result.length; j++) { captures.push(maybeToString(result[j])); }
	        var namedCaptures = result.groups;
	        if (functionalReplace) {
	          var replacerArgs = [matched].concat(captures, position, S);
	          if (namedCaptures !== undefined) { replacerArgs.push(namedCaptures); }
	          var replacement = String(replaceValue.apply(undefined, replacerArgs));
	        } else {
	          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	        }
	        if (position >= nextSourcePosition) {
	          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
	          nextSourcePosition = position + matched.length;
	        }
	      }
	      return accumulatedResult + S.slice(nextSourcePosition);
	    }
	  ];

	    // https://tc39.github.io/ecma262/#sec-getsubstitution
	  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	    var tailPos = position + matched.length;
	    var m = captures.length;
	    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
	    if (namedCaptures !== undefined) {
	      namedCaptures = _toObject(namedCaptures);
	      symbols = SUBSTITUTION_SYMBOLS;
	    }
	    return $replace.call(replacement, symbols, function (match, ch) {
	      var capture;
	      switch (ch.charAt(0)) {
	        case '$': return '$';
	        case '&': return matched;
	        case '`': return str.slice(0, position);
	        case "'": return str.slice(tailPos);
	        case '<':
	          capture = namedCaptures[ch.slice(1, -1)];
	          break;
	        default: // \d\d?
	          var n = +ch;
	          if (n === 0) { return match; }
	          if (n > m) {
	            var f = floor$3(n / 10);
	            if (f === 0) { return match; }
	            if (f <= m) { return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1); }
	            return match;
	          }
	          capture = captures[n - 1];
	      }
	      return capture === undefined ? '' : capture;
	    });
	  }
	});

	// @@search logic
	_fixReWks('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
	  return [
	    // `String.prototype.search` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.search
	    function search(regexp) {
	      var O = defined(this);
	      var fn = regexp == undefined ? undefined : regexp[SEARCH];
	      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	    },
	    // `RegExp.prototype[@@search]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
	    function (regexp) {
	      var res = maybeCallNative($search, regexp, this);
	      if (res.done) { return res.value; }
	      var rx = _anObject(regexp);
	      var S = String(this);
	      var previousLastIndex = rx.lastIndex;
	      if (!_sameValue(previousLastIndex, 0)) { rx.lastIndex = 0; }
	      var result = _regexpExecAbstract(rx, S);
	      if (!_sameValue(rx.lastIndex, previousLastIndex)) { rx.lastIndex = previousLastIndex; }
	      return result === null ? -1 : result.index;
	    }
	  ];
	});

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)


	var SPECIES$3 = _wks('species');
	var _speciesConstructor = function (O, D) {
	  var C = _anObject(O).constructor;
	  var S;
	  return C === undefined || (S = _anObject(C)[SPECIES$3]) == undefined ? D : _aFunction(S);
	};

	var $min = Math.min;
	var $push = [].push;
	var $SPLIT = 'split';
	var LENGTH = 'length';
	var LAST_INDEX$1 = 'lastIndex';
	var MAX_UINT32 = 0xffffffff;

	// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
	var SUPPORTS_Y = !_fails(function () { RegExp(MAX_UINT32, 'y'); });

	// @@split logic
	_fixReWks('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
	  var internalSplit;
	  if (
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function (separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) { return []; }
	      // If `separator` is not a regex, use native split
	      if (!_isRegexp(separator)) { return $split.call(string, separator, limit); }
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;
	      while (match = _regexpExec.call(separatorCopy, string)) {
	        lastIndex = separatorCopy[LAST_INDEX$1];
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) { $push.apply(output, match.slice(1)); }
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) { break; }
	        }
	        if (separatorCopy[LAST_INDEX$1] === match.index) { separatorCopy[LAST_INDEX$1]++; } // Avoid an infinite loop
	      }
	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) { output.push(''); }
	      } else { output.push(string.slice(lastLastIndex)); }
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    internalSplit = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
	    };
	  } else {
	    internalSplit = $split;
	  }

	  return [
	    // `String.prototype.split` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.split
	    function split(separator, limit) {
	      var O = defined(this);
	      var splitter = separator == undefined ? undefined : separator[SPLIT];
	      return splitter !== undefined
	        ? splitter.call(separator, O, limit)
	        : internalSplit.call(String(O), separator, limit);
	    },
	    // `RegExp.prototype[@@split]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
	    //
	    // NOTE: This cannot be properly polyfilled in engines that don't support
	    // the 'y' flag.
	    function (regexp, limit) {
	      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
	      if (res.done) { return res.value; }

	      var rx = _anObject(regexp);
	      var S = String(this);
	      var C = _speciesConstructor(rx, RegExp);

	      var unicodeMatching = rx.unicode;
	      var flags = (rx.ignoreCase ? 'i' : '') +
	                  (rx.multiline ? 'm' : '') +
	                  (rx.unicode ? 'u' : '') +
	                  (SUPPORTS_Y ? 'y' : 'g');

	      // ^(? + rx + ) is needed, in combination with some S slicing, to
	      // simulate the 'y' flag.
	      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) { return []; }
	      if (S.length === 0) { return _regexpExecAbstract(splitter, S) === null ? [S] : []; }
	      var p = 0;
	      var q = 0;
	      var A = [];
	      while (q < S.length) {
	        splitter.lastIndex = SUPPORTS_Y ? q : 0;
	        var z = _regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
	        var e;
	        if (
	          z === null ||
	          (e = $min(_toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
	        ) {
	          q = _advanceStringIndex(S, q, unicodeMatching);
	        } else {
	          A.push(S.slice(p, q));
	          if (A.length === lim) { return A; }
	          for (var i = 1; i <= z.length - 1; i++) {
	            A.push(z[i]);
	            if (A.length === lim) { return A; }
	          }
	          q = p = e;
	        }
	      }
	      A.push(S.slice(p));
	      return A;
	    }
	  ];
	});

	var _anInstance = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

	var _forOf = createCommonjsModule(function (module) {
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
	  var f = _ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') { throw TypeError(iterable + ' is not iterable!'); }
	  // fast case for arrays with default iterator
	  if (_isArrayIter(iterFn)) { for (length = _toLength(iterable.length); length > index; index++) {
	    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) { return result; }
	  } } else { for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = _iterCall(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) { return result; }
	  } }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;
	});

	var process$1 = _global.process;
	var setTask = _global.setImmediate;
	var clearTask = _global.clearImmediate;
	var MessageChannel$1 = _global.MessageChannel;
	var Dispatch = _global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var arguments$1 = arguments;

	    var args = [];
	    var i = 1;
	    while (arguments.length > i) { args.push(arguments$1[i++]); }
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (_cof(process$1) == 'process') {
	    defer = function (id) {
	      process$1.nextTick(_ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(_ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel$1) {
	    channel = new MessageChannel$1();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = _ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
	    defer = function (id) {
	      _global.postMessage(id + '', '*');
	    };
	    _global.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
	    defer = function (id) {
	      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
	        _html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(_ctx(run, id, 1), 0);
	    };
	  }
	}
	var _task = {
	  set: setTask,
	  clear: clearTask
	};

	var macrotask = _task.set;
	var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
	var process$2 = _global.process;
	var Promise$1 = _global.Promise;
	var isNode = _cof(process$2) == 'process';

	var _microtask = function () {
	  var head, last, notify;

	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process$2.domain)) { parent.exit(); }
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) { notify(); }
	        else { last = undefined; }
	        throw e;
	      }
	    } last = undefined;
	    if (parent) { parent.enter(); }
	  };

	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process$2.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    var promise = Promise$1.resolve(undefined);
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(_global, flush);
	    };
	  }

	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) { last.next = task; }
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};

	// 25.4.1.5 NewPromiseCapability(C)


	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) { throw TypeError('Bad Promise constructor'); }
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = _aFunction(resolve);
	  this.reject = _aFunction(reject);
	}

	var f$7 = function (C) {
	  return new PromiseCapability(C);
	};

	var _newPromiseCapability = {
		f: f$7
	};

	var _perform = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};

	var navigator$1 = _global.navigator;

	var _userAgent = navigator$1 && navigator$1.userAgent || '';

	var _promiseResolve = function (C, x) {
	  _anObject(C);
	  if (_isObject(x) && x.constructor === C) { return x; }
	  var promiseCapability = _newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var _redefineAll = function (target, src, safe) {
	  for (var key in src) { _redefine(target, key, src[key], safe); }
	  return target;
	};

	var task = _task.set;
	var microtask = _microtask();




	var PROMISE = 'Promise';
	var TypeError$1 = _global.TypeError;
	var process$3 = _global.process;
	var versions = process$3 && process$3.versions;
	var v8 = versions && versions.v8 || '';
	var $Promise = _global[PROMISE];
	var isNode$1 = _classof(process$3) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;

	var USE_NATIVE$1 = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode$1 || typeof PromiseRejectionEvent == 'function')
	      && promise.then(empty) instanceof FakePromise
	      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	      // we can't detect it synchronously, so just check versions
	      && v8.indexOf('6.6') !== 0
	      && _userAgent.indexOf('Chrome/66') === -1;
	  } catch (e) { /* empty */ }
	}();

	// helpers
	var isThenable = function (it) {
	  var then;
	  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) { return; }
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) { onHandleUnhandled(promise); }
	            promise._h = 1;
	          }
	          if (handler === true) { result = value; }
	          else {
	            if (domain) { domain.enter(); }
	            result = handler(value); // may throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else { resolve(result); }
	        } else { reject(value); }
	      } catch (e) {
	        if (domain && !exited) { domain.exit(); }
	        reject(e);
	      }
	    };
	    while (chain.length > i) { run(chain[i++]); } // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) { onUnhandled(promise); }
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(_global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = _perform(function () {
	        if (isNode$1) {
	          process$3.emit('unhandledRejection', value, promise);
	        } else if (handler = _global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = _global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) { throw result.v; }
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(_global, function () {
	    var handler;
	    if (isNode$1) {
	      process$3.emit('rejectionHandled', promise);
	    } else if (handler = _global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) { return; }
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) { promise._a = promise._c.slice(); }
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) { return; }
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) { throw TypeError$1("Promise can't be resolved itself"); }
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};

	// constructor polyfill
	if (!USE_NATIVE$1) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    _anInstance(this, $Promise, PROMISE, '_h');
	    _aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = _redefineAll($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode$1 ? process$3.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) { this._a.push(reaction); }
	      if (this._s) { notify(this, false); }
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = _ctx($resolve, promise, 1);
	    this.reject = _ctx($reject, promise, 1);
	  };
	  _newPromiseCapability.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	_export(_export.G + _export.W + _export.F * !USE_NATIVE$1, { Promise: $Promise });
	_setToStringTag($Promise, PROMISE);
	_setSpecies(PROMISE);
	Wrapper = _core[PROMISE];

	// statics
	_export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	_export(_export.S + _export.F * ( !USE_NATIVE$1), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return _promiseResolve( this, x);
	  }
	});
	_export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = _perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      _forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) { return; }
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) { reject(result.v); }
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = _perform(function () {
	      _forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) { reject(result.v); }
	    return capability.promise;
	  }
	});

	var _validateCollection = function (it, TYPE) {
	  if (!_isObject(it) || it._t !== TYPE) { throw TypeError('Incompatible receiver, ' + TYPE + ' required!'); }
	  return it;
	};

	var dP$5 = _objectDp.f;









	var fastKey = _meta.fastKey;

	var SIZE = _descriptors ? '_s' : 'size';

	var getEntry = function (that, key) {
	  // fast case
	  var index = fastKey(key);
	  var entry;
	  if (index !== 'F') { return that._i[index]; }
	  // frozen object case
	  for (entry = that._f; entry; entry = entry.n) {
	    if (entry.k == key) { return entry; }
	  }
	};

	var _collectionStrong = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      _anInstance(that, C, NAME, '_i');
	      that._t = NAME;         // collection type
	      that._i = _objectCreate(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if (iterable != undefined) { _forOf(iterable, IS_MAP, that[ADDER], that); }
	    });
	    _redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
	          entry.r = true;
	          if (entry.p) { entry.p = entry.p.n = undefined; }
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = _validateCollection(this, NAME);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.n;
	          var prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if (prev) { prev.n = next; }
	          if (next) { next.p = prev; }
	          if (that._f == entry) { that._f = next; }
	          if (that._l == entry) { that._l = prev; }
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        _validateCollection(this, NAME);
	        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.n : this._f) {
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while (entry && entry.r) { entry = entry.p; }
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(_validateCollection(this, NAME), key);
	      }
	    });
	    if (_descriptors) { dP$5(C.prototype, 'size', {
	      get: function () {
	        return _validateCollection(this, NAME)[SIZE];
	      }
	    }); }
	    return C;
	  },
	  def: function (that, key, value) {
	    var entry = getEntry(that, key);
	    var prev, index;
	    // change existing entry
	    if (entry) {
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if (!that._f) { that._f = entry; }
	      if (prev) { prev.n = entry; }
	      that[SIZE]++;
	      // add to index
	      if (index !== 'F') { that._i[index] = entry; }
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function (C, NAME, IS_MAP) {
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    _iterDefine(C, NAME, function (iterated, kind) {
	      this._t = _validateCollection(iterated, NAME); // target
	      this._k = kind;                     // kind
	      this._l = undefined;                // previous
	    }, function () {
	      var that = this;
	      var kind = that._k;
	      var entry = that._l;
	      // revert to the last existing entry
	      while (entry && entry.r) { entry = entry.p; }
	      // get next entry
	      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
	        // or finish the iteration
	        that._t = undefined;
	        return _iterStep(1);
	      }
	      // return step by kind
	      if (kind == 'keys') { return _iterStep(0, entry.k); }
	      if (kind == 'values') { return _iterStep(0, entry.v); }
	      return _iterStep(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    _setSpecies(NAME);
	  }
	};

	var _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
	  var Base = _global[NAME];
	  var C = Base;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var proto = C && C.prototype;
	  var O = {};
	  var fixMethod = function (KEY) {
	    var fn = proto[KEY];
	    _redefine(proto, KEY,
	      KEY == 'delete' ? function (a) {
	        return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a) {
	        return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a) {
	        return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
	    new C().entries().next();
	  }))) {
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    _redefineAll(C.prototype, methods);
	    _meta.NEED = true;
	  } else {
	    var instance = new C();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = _fails(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    var ACCEPT_ITERABLES = _iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && _fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new C();
	      var index = 5;
	      while (index--) { $instance[ADDER](index, index); }
	      return !$instance.has(-0);
	    });
	    if (!ACCEPT_ITERABLES) {
	      C = wrapper(function (target, iterable) {
	        _anInstance(target, C, NAME);
	        var that = _inheritIfRequired(new Base(), target, C);
	        if (iterable != undefined) { _forOf(iterable, IS_MAP, that[ADDER], that); }
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if (BUGGY_ZERO || HASNT_CHAINING) { fixMethod(ADDER); }
	    // weak collections should not contains .clear method
	    if (IS_WEAK && proto.clear) { delete proto.clear; }
	  }

	  _setToStringTag(C, NAME);

	  O[NAME] = C;
	  _export(_export.G + _export.W + _export.F * (C != Base), O);

	  if (!IS_WEAK) { common.setStrong(C, NAME, IS_MAP); }

	  return C;
	};

	var MAP = 'Map';

	// 23.1 Map Objects
	var es6_map = _collection(MAP, function (get) {
	  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key) {
	    var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value) {
	    return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
	  }
	}, _collectionStrong, true);

	var SET = 'Set';

	// 23.2 Set Objects
	var es6_set = _collection(SET, function (get) {
	  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value) {
	    return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
	  }
	}, _collectionStrong);

	var getWeak = _meta.getWeak;







	var arrayFind = _arrayMethods(5);
	var arrayFindIndex = _arrayMethods(6);
	var id$1 = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function (that) {
	  return that._l || (that._l = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function () {
	  this.a = [];
	};
	var findUncaughtFrozen = function (store, key) {
	  return arrayFind(store.a, function (it) {
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function (key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) { return entry[1]; }
	  },
	  has: function (key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function (key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) { entry[1] = value; }
	    else { this.a.push([key, value]); }
	  },
	  'delete': function (key) {
	    var index = arrayFindIndex(this.a, function (it) {
	      return it[0] === key;
	    });
	    if (~index) { this.a.splice(index, 1); }
	    return !!~index;
	  }
	};

	var _collectionWeak = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      _anInstance(that, C, NAME, '_i');
	      that._t = NAME;      // collection type
	      that._i = id$1++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if (iterable != undefined) { _forOf(iterable, IS_MAP, that[ADDER], that); }
	    });
	    _redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function (key) {
	        if (!_isObject(key)) { return false; }
	        var data = getWeak(key);
	        if (data === true) { return uncaughtFrozenStore(_validateCollection(this, NAME))['delete'](key); }
	        return data && _has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key) {
	        if (!_isObject(key)) { return false; }
	        var data = getWeak(key);
	        if (data === true) { return uncaughtFrozenStore(_validateCollection(this, NAME)).has(key); }
	        return data && _has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var data = getWeak(_anObject(key), true);
	    if (data === true) { uncaughtFrozenStore(that).set(key, value); }
	    else { data[that._i] = value; }
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

	var es6_weakMap = createCommonjsModule(function (module) {

	var each = _arrayMethods(0);






	var NATIVE_WEAK_MAP = _validateCollection;
	var IS_IE11 = !_global.ActiveXObject && 'ActiveXObject' in _global;
	var WEAK_MAP = 'WeakMap';
	var getWeak = _meta.getWeak;
	var isExtensible = Object.isExtensible;
	var uncaughtFrozenStore = _collectionWeak.ufstore;
	var InternalMap;

	var wrapper = function (get) {
	  return function WeakMap() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};

	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key) {
	    if (_isObject(key)) {
	      var data = getWeak(key);
	      if (data === true) { return uncaughtFrozenStore(_validateCollection(this, WEAK_MAP)).get(key); }
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value) {
	    return _collectionWeak.def(_validateCollection(this, WEAK_MAP), key, value);
	  }
	};

	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = _collection(WEAK_MAP, wrapper, methods, _collectionWeak, true, true);

	// IE11 WeakMap frozen keys fix
	if (NATIVE_WEAK_MAP && IS_IE11) {
	  InternalMap = _collectionWeak.getConstructor(wrapper, WEAK_MAP);
	  _objectAssign(InternalMap.prototype, methods);
	  _meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function (key) {
	    var proto = $WeakMap.prototype;
	    var method = proto[key];
	    _redefine(proto, key, function (a, b) {
	      // store frozen objects on internal weakmap shim
	      if (_isObject(a) && !isExtensible(a)) {
	        if (!this._f) { this._f = new InternalMap(); }
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}
	});

	var WEAK_SET = 'WeakSet';

	// 23.4 WeakSet Objects
	_collection(WEAK_SET, function (get) {
	  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value) {
	    return _collectionWeak.def(_validateCollection(this, WEAK_SET), value, true);
	  }
	}, _collectionWeak, false, true);

	var TYPED = _uid('typed_array');
	var VIEW = _uid('view');
	var ABV = !!(_global.ArrayBuffer && _global.DataView);
	var CONSTR = ABV;
	var i$1 = 0;
	var l = 9;
	var Typed;

	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');

	while (i$1 < l) {
	  if (Typed = _global[TypedArrayConstructors[i$1++]]) {
	    _hide(Typed.prototype, TYPED, true);
	    _hide(Typed.prototype, VIEW, true);
	  } else { CONSTR = false; }
	}

	var _typed = {
	  ABV: ABV,
	  CONSTR: CONSTR,
	  TYPED: TYPED,
	  VIEW: VIEW
	};

	// https://tc39.github.io/ecma262/#sec-toindex


	var _toIndex = function (it) {
	  if (it === undefined) { return 0; }
	  var number = _toInteger(it);
	  var length = _toLength(number);
	  if (number !== length) { throw RangeError('Wrong length!'); }
	  return length;
	};

	var _typedBuffer = createCommonjsModule(function (module, exports) {











	var gOPN = _objectGopn.f;
	var dP = _objectDp.f;


	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE = 'prototype';
	var WRONG_LENGTH = 'Wrong length!';
	var WRONG_INDEX = 'Wrong index!';
	var $ArrayBuffer = _global[ARRAY_BUFFER];
	var $DataView = _global[DATA_VIEW];
	var Math = _global.Math;
	var RangeError = _global.RangeError;
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity = _global.Infinity;
	var BaseBuffer = $ArrayBuffer;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;
	var BUFFER = 'buffer';
	var BYTE_LENGTH = 'byteLength';
	var BYTE_OFFSET = 'byteOffset';
	var $BUFFER = _descriptors ? '_b' : BUFFER;
	var $LENGTH = _descriptors ? '_l' : BYTE_LENGTH;
	var $OFFSET = _descriptors ? '_o' : BYTE_OFFSET;

	// IEEE754 conversions based on https://github.com/feross/ieee754
	function packIEEE754(value, mLen, nBytes) {
	  var buffer = new Array(nBytes);
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var i = 0;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	  var e, m, c;
	  value = abs(value);
	  // eslint-disable-next-line no-self-compare
	  if (value != value || value === Infinity) {
	    // eslint-disable-next-line no-self-compare
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if (value * (c = pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8){ }
	  e = e << mLen | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8){ }
	  buffer[--i] |= s * 128;
	  return buffer;
	}
	function unpackIEEE754(buffer, mLen, nBytes) {
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = eLen - 7;
	  var i = nBytes - 1;
	  var s = buffer[i--];
	  var e = s & 127;
	  var m;
	  s >>= 7;
	  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8){ }
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8){ }
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	}

	function unpackI32(bytes) {
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	}
	function packI8(it) {
	  return [it & 0xff];
	}
	function packI16(it) {
	  return [it & 0xff, it >> 8 & 0xff];
	}
	function packI32(it) {
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	}
	function packF64(it) {
	  return packIEEE754(it, 52, 8);
	}
	function packF32(it) {
	  return packIEEE754(it, 23, 4);
	}

	function addGetter(C, key, internal) {
	  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
	}

	function get(view, bytes, index, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = _toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) { throw RangeError(WRONG_INDEX); }
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	}
	function set(view, bytes, index, conversion, value, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = _toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) { throw RangeError(WRONG_INDEX); }
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = conversion(+value);
	  for (var i = 0; i < bytes; i++) { store[start + i] = pack[isLittleEndian ? i : bytes - i - 1]; }
	}

	if (!_typed.ABV) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    _anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = _toIndex(length);
	    this._b = _arrayFill.call(new Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    _anInstance(this, $DataView, DATA_VIEW);
	    _anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH];
	    var offset = _toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) { throw RangeError('Wrong offset!'); }
	    byteLength = byteLength === undefined ? bufferLength - offset : _toLength(byteLength);
	    if (offset + byteLength > bufferLength) { throw RangeError(WRONG_LENGTH); }
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };

	  if (_descriptors) {
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }

	  _redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset) {
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if (!_fails(function () {
	    $ArrayBuffer(1);
	  }) || !_fails(function () {
	    new $ArrayBuffer(-1); // eslint-disable-line no-new
	  }) || _fails(function () {
	    new $ArrayBuffer(); // eslint-disable-line no-new
	    new $ArrayBuffer(1.5); // eslint-disable-line no-new
	    new $ArrayBuffer(NaN); // eslint-disable-line no-new
	    return $ArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      _anInstance(this, $ArrayBuffer);
	      return new BaseBuffer(_toIndex(length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
	      if (!((key = keys[j++]) in $ArrayBuffer)) { _hide($ArrayBuffer, key, BaseBuffer[key]); }
	    }
	    { ArrayBufferProto.constructor = $ArrayBuffer; }
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if (view.getInt8(0) || !view.getInt8(1)) { _redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true); }
	}
	_setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	_setToStringTag($DataView, DATA_VIEW);
	_hide($DataView[PROTOTYPE], _typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;
	});

	var ArrayBuffer = _global.ArrayBuffer;

	var $ArrayBuffer = _typedBuffer.ArrayBuffer;
	var $DataView = _typedBuffer.DataView;
	var $isView = _typed.ABV && ArrayBuffer.isView;
	var $slice = $ArrayBuffer.prototype.slice;
	var VIEW$1 = _typed.VIEW;
	var ARRAY_BUFFER = 'ArrayBuffer';

	_export(_export.G + _export.W + _export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

	_export(_export.S + _export.F * !_typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it) {
	    return $isView && $isView(it) || _isObject(it) && VIEW$1 in it;
	  }
	});

	_export(_export.P + _export.U + _export.F * _fails(function () {
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end) {
	    if ($slice !== undefined && end === undefined) { return $slice.call(_anObject(this), start); } // FF fix
	    var len = _anObject(this).byteLength;
	    var first = _toAbsoluteIndex(start, len);
	    var fin = _toAbsoluteIndex(end === undefined ? len : end, len);
	    var result = new (_speciesConstructor(this, $ArrayBuffer))(_toLength(fin - first));
	    var viewS = new $DataView(this);
	    var viewT = new $DataView(result);
	    var index = 0;
	    while (first < fin) {
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});

	_setSpecies(ARRAY_BUFFER);

	_export(_export.G + _export.W + _export.F * !_typed.ABV, {
	  DataView: _typedBuffer.DataView
	});

	var _typedArray = createCommonjsModule(function (module) {
	if (_descriptors) {
	  var LIBRARY = _library;
	  var global = _global;
	  var fails = _fails;
	  var $export = _export;
	  var $typed = _typed;
	  var $buffer = _typedBuffer;
	  var ctx = _ctx;
	  var anInstance = _anInstance;
	  var propertyDesc = _propertyDesc;
	  var hide = _hide;
	  var redefineAll = _redefineAll;
	  var toInteger = _toInteger;
	  var toLength = _toLength;
	  var toIndex = _toIndex;
	  var toAbsoluteIndex = _toAbsoluteIndex;
	  var toPrimitive = _toPrimitive;
	  var has = _has;
	  var classof = _classof;
	  var isObject = _isObject;
	  var toObject = _toObject;
	  var isArrayIter = _isArrayIter;
	  var create = _objectCreate;
	  var getPrototypeOf = _objectGpo;
	  var gOPN = _objectGopn.f;
	  var getIterFn = core_getIteratorMethod;
	  var uid = _uid;
	  var wks = _wks;
	  var createArrayMethod = _arrayMethods;
	  var createArrayIncludes = _arrayIncludes;
	  var speciesConstructor = _speciesConstructor;
	  var ArrayIterators = es6_array_iterator;
	  var Iterators = _iterators;
	  var $iterDetect = _iterDetect;
	  var setSpecies = _setSpecies;
	  var arrayFill = _arrayFill;
	  var arrayCopyWithin = _arrayCopyWithin;
	  var $DP = _objectDp;
	  var $GOPD = _objectGopd;
	  var dP = $DP.f;
	  var gOPD = $GOPD.f;
	  var RangeError = global.RangeError;
	  var TypeError = global.TypeError;
	  var Uint8Array = global.Uint8Array;
	  var ARRAY_BUFFER = 'ArrayBuffer';
	  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
	  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	  var PROTOTYPE = 'prototype';
	  var ArrayProto = Array[PROTOTYPE];
	  var $ArrayBuffer = $buffer.ArrayBuffer;
	  var $DataView = $buffer.DataView;
	  var arrayForEach = createArrayMethod(0);
	  var arrayFilter = createArrayMethod(2);
	  var arraySome = createArrayMethod(3);
	  var arrayEvery = createArrayMethod(4);
	  var arrayFind = createArrayMethod(5);
	  var arrayFindIndex = createArrayMethod(6);
	  var arrayIncludes = createArrayIncludes(true);
	  var arrayIndexOf = createArrayIncludes(false);
	  var arrayValues = ArrayIterators.values;
	  var arrayKeys = ArrayIterators.keys;
	  var arrayEntries = ArrayIterators.entries;
	  var arrayLastIndexOf = ArrayProto.lastIndexOf;
	  var arrayReduce = ArrayProto.reduce;
	  var arrayReduceRight = ArrayProto.reduceRight;
	  var arrayJoin = ArrayProto.join;
	  var arraySort = ArrayProto.sort;
	  var arraySlice = ArrayProto.slice;
	  var arrayToString = ArrayProto.toString;
	  var arrayToLocaleString = ArrayProto.toLocaleString;
	  var ITERATOR = wks('iterator');
	  var TAG = wks('toStringTag');
	  var TYPED_CONSTRUCTOR = uid('typed_constructor');
	  var DEF_CONSTRUCTOR = uid('def_constructor');
	  var ALL_CONSTRUCTORS = $typed.CONSTR;
	  var TYPED_ARRAY = $typed.TYPED;
	  var VIEW = $typed.VIEW;
	  var WRONG_LENGTH = 'Wrong length!';

	  var $map = createArrayMethod(1, function (O, length) {
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });

	  var LITTLE_ENDIAN = fails(function () {
	    // eslint-disable-next-line no-undef
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });

	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	    new Uint8Array(1).set({});
	  });

	  var toOffset = function (it, BYTES) {
	    var offset = toInteger(it);
	    if (offset < 0 || offset % BYTES) { throw RangeError('Wrong offset!'); }
	    return offset;
	  };

	  var validate = function (it) {
	    if (isObject(it) && TYPED_ARRAY in it) { return it; }
	    throw TypeError(it + ' is not a typed array!');
	  };

	  var allocate = function (C, length) {
	    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };

	  var speciesFromList = function (O, list) {
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };

	  var fromList = function (C, list) {
	    var index = 0;
	    var length = list.length;
	    var result = allocate(C, length);
	    while (length > index) { result[index] = list[index++]; }
	    return result;
	  };

	  var addGetter = function (it, key, internal) {
	    dP(it, key, { get: function () { return this._d[internal]; } });
	  };

	  var $from = function from(source /* , mapfn, thisArg */) {
	    var O = toObject(source);
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var iterFn = getIterFn(O);
	    var i, length, values, result, step, iterator;
	    if (iterFn != undefined && !isArrayIter(iterFn)) {
	      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
	        values.push(step.value);
	      } O = values;
	    }
	    if (mapping && aLen > 2) { mapfn = ctx(mapfn, arguments[2], 2); }
	    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };

	  var $of = function of(/* ...items */) {
	    var arguments$1 = arguments;

	    var index = 0;
	    var length = arguments.length;
	    var result = allocate(this, length);
	    while (length > index) { result[index] = arguments$1[index++]; }
	    return result;
	  };

	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

	  var $toLocaleString = function toLocaleString() {
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };

	  var proto = {
	    copyWithin: function copyWithin(target, start /* , end */) {
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /* , thisArg */) {
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /* , thisArg */) {
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /* , thisArg */) {
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /* , thisArg */) {
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /* , thisArg */) {
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /* , fromIndex */) {
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /* , fromIndex */) {
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator) { // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /* , thisArg */) {
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse() {
	      var that = this;
	      var length = validate(that).length;
	      var middle = Math.floor(length / 2);
	      var index = 0;
	      var value;
	      while (index < middle) {
	        value = that[index];
	        that[index++] = that[--length];
	        that[length] = value;
	      } return that;
	    },
	    some: function some(callbackfn /* , thisArg */) {
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn) {
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end) {
	      var O = validate(this);
	      var length = O.length;
	      var $begin = toAbsoluteIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
	      );
	    }
	  };

	  var $slice = function slice(start, end) {
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };

	  var $set = function set(arrayLike /* , offset */) {
	    validate(this);
	    var offset = toOffset(arguments[1], 1);
	    var length = this.length;
	    var src = toObject(arrayLike);
	    var len = toLength(src.length);
	    var index = 0;
	    if (len + offset > length) { throw RangeError(WRONG_LENGTH); }
	    while (index < len) { this[offset + index] = src[index++]; }
	  };

	  var $iterators = {
	    entries: function entries() {
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys() {
	      return arrayKeys.call(validate(this));
	    },
	    values: function values() {
	      return arrayValues.call(validate(this));
	    }
	  };

	  var isTAIndex = function (target, key) {
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key) {
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc) {
	    if (isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ) {
	      target[key] = desc.value;
	      return target;
	    } return dP(target, key, desc);
	  };

	  if (!ALL_CONSTRUCTORS) {
	    $GOPD.f = $getDesc;
	    $DP.f = $setDesc;
	  }

	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty: $setDesc
	  });

	  if (fails(function () { arrayToString.call({}); })) {
	    arrayToString = arrayToLocaleString = function toString() {
	      return arrayJoin.call(this);
	    };
	  }

	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice: $slice,
	    set: $set,
	    constructor: function () { /* noop */ },
	    toString: arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function () { return this[TYPED_ARRAY]; }
	  });

	  // eslint-disable-next-line max-statements
	  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	    CLAMPED = !!CLAMPED;
	    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + KEY;
	    var SETTER = 'set' + KEY;
	    var TypedArray = global[NAME];
	    var Base = TypedArray || {};
	    var TAC = TypedArray && getPrototypeOf(TypedArray);
	    var FORCED = !TypedArray || !$typed.ABV;
	    var O = {};
	    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function (that, index) {
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function (that, index, value) {
	      var data = that._d;
	      if (CLAMPED) { value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff; }
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function (that, index) {
	      dP(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if (FORCED) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME, '_d');
	        var index = 0;
	        var offset = 0;
	        var buffer, byteLength, length, klass;
	        if (!isObject(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new $ArrayBuffer(byteLength);
	        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) { throw RangeError(WRONG_LENGTH); }
	            byteLength = $len - offset;
	            if (byteLength < 0) { throw RangeError(WRONG_LENGTH); }
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + offset > $len) { throw RangeError(WRONG_LENGTH); }
	          }
	          length = byteLength / BYTES;
	        } else if (TYPED_ARRAY in data) {
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while (index < length) { addElement(that, index++); }
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if (!fails(function () {
	      TypedArray(1);
	    }) || !fails(function () {
	      new TypedArray(-1); // eslint-disable-line no-new
	    }) || !$iterDetect(function (iter) {
	      new TypedArray(); // eslint-disable-line no-new
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(1.5); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if (!isObject(data)) { return new Base(toIndex(data)); }
	        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if (TYPED_ARRAY in data) { return fromList(TypedArray, data); }
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
	        if (!(key in TypedArray)) { hide(TypedArray, key, Base[key]); }
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if (!LIBRARY) { TypedArrayPrototype.constructor = TypedArray; }
	    }
	    var $nativeIterator = TypedArrayPrototype[ITERATOR];
	    var CORRECT_ITER_NAME = !!$nativeIterator
	      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	    var $iterator = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
	      dP(TypedArrayPrototype, TAG, {
	        get: function () { return NAME; }
	      });
	    }

	    O[NAME] = TypedArray;

	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES
	    });

	    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
	      from: $from,
	      of: $of
	    });

	    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) { hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES); }

	    $export($export.P, NAME, proto);

	    setSpecies(NAME);

	    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

	    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) { TypedArrayPrototype.toString = arrayToString; }

	    $export($export.P + $export.F * fails(function () {
	      new TypedArray(1).slice();
	    }), NAME, { slice: $slice });

	    $export($export.P + $export.F * (fails(function () {
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	    }) || !fails(function () {
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, { toLocaleString: $toLocaleString });

	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if (!LIBRARY && !CORRECT_ITER_NAME) { hide(TypedArrayPrototype, ITERATOR, $iterator); }
	  };
	} else { module.exports = function () { /* empty */ }; }
	});

	_typedArray('Int8', 1, function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Uint8', 1, function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Uint8', 1, function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

	_typedArray('Int16', 2, function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Uint16', 2, function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Int32', 4, function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Uint32', 4, function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Float32', 4, function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	_typedArray('Float64', 8, function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)



	var rApply = (_global.Reflect || {}).apply;
	var fApply = Function.apply;
	// MS Edge argumentsList argument is optional
	_export(_export.S + _export.F * !_fails(function () {
	  rApply(function () { /* empty */ });
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList) {
	    var T = _aFunction(target);
	    var L = _anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])







	var rConstruct = (_global.Reflect || {}).construct;

	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = _fails(function () {
	  function F() { /* empty */ }
	  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
	});
	var ARGS_BUG = !_fails(function () {
	  rConstruct(function () { /* empty */ });
	});

	_export(_export.S + _export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /* , newTarget */) {
	    _aFunction(Target);
	    _anObject(args);
	    var newTarget = arguments.length < 3 ? Target : _aFunction(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) { return rConstruct(Target, args, newTarget); }
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0: return new Target();
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (_bind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = _objectCreate(_isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return _isObject(result) ? result : instance;
	  }
	});

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)





	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	_export(_export.S + _export.F * _fails(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(_objectDp.f({}, 1, { value: 1 }), 1, { value: 2 });
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    _anObject(target);
	    propertyKey = _toPrimitive(propertyKey, true);
	    _anObject(attributes);
	    try {
	      _objectDp.f(target, propertyKey, attributes);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)

	var gOPD$3 = _objectGopd.f;


	_export(_export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var desc = gOPD$3(_anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

	// 26.1.5 Reflect.enumerate(target)


	var Enumerate = function (iterated) {
	  this._t = _anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = [];      // keys
	  var key;
	  for (key in iterated) { keys.push(key); }
	};
	_iterCreate(Enumerate, 'Object', function () {
	  var that = this;
	  var keys = that._k;
	  var key;
	  do {
	    if (that._i >= keys.length) { return { value: undefined, done: true }; }
	  } while (!((key = keys[that._i++]) in that._t));
	  return { value: key, done: false };
	});

	_export(_export.S, 'Reflect', {
	  enumerate: function enumerate(target) {
	    return new Enumerate(target);
	  }
	});

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])







	function get(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var desc, proto;
	  if (_anObject(target) === receiver) { return target[propertyKey]; }
	  if (desc = _objectGopd.f(target, propertyKey)) { return _has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined; }
	  if (_isObject(proto = _objectGpo(target))) { return get(proto, propertyKey, receiver); }
	}

	_export(_export.S, 'Reflect', { get: get });

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)




	_export(_export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return _objectGopd.f(_anObject(target), propertyKey);
	  }
	});

	// 26.1.8 Reflect.getPrototypeOf(target)




	_export(_export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return _objectGpo(_anObject(target));
	  }
	});

	// 26.1.9 Reflect.has(target, propertyKey)


	_export(_export.S, 'Reflect', {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});

	// 26.1.10 Reflect.isExtensible(target)


	var $isExtensible = Object.isExtensible;

	_export(_export.S, 'Reflect', {
	  isExtensible: function isExtensible(target) {
	    _anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

	// all object keys, includes non-enumerable and symbols



	var Reflect$1 = _global.Reflect;
	var _ownKeys = Reflect$1 && Reflect$1.ownKeys || function ownKeys(it) {
	  var keys = _objectGopn.f(_anObject(it));
	  var getSymbols = _objectGops.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

	// 26.1.11 Reflect.ownKeys(target)


	_export(_export.S, 'Reflect', { ownKeys: _ownKeys });

	// 26.1.12 Reflect.preventExtensions(target)


	var $preventExtensions = Object.preventExtensions;

	_export(_export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target) {
	    _anObject(target);
	    try {
	      if ($preventExtensions) { $preventExtensions(target); }
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])









	function set(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDesc = _objectGopd.f(_anObject(target), propertyKey);
	  var existingDescriptor, proto;
	  if (!ownDesc) {
	    if (_isObject(proto = _objectGpo(target))) {
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = _propertyDesc(0);
	  }
	  if (_has(ownDesc, 'value')) {
	    if (ownDesc.writable === false || !_isObject(receiver)) { return false; }
	    if (existingDescriptor = _objectGopd.f(receiver, propertyKey)) {
	      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) { return false; }
	      existingDescriptor.value = V;
	      _objectDp.f(receiver, propertyKey, existingDescriptor);
	    } else { _objectDp.f(receiver, propertyKey, _propertyDesc(0, V)); }
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}

	_export(_export.S, 'Reflect', { set: set });

	// 26.1.14 Reflect.setPrototypeOf(target, proto)



	if (_setProto) { _export(_export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    _setProto.check(target, proto);
	    try {
	      _setProto.set(target, proto);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	}); }

	// https://github.com/tc39/Array.prototype.includes

	var $includes = _arrayIncludes(true);

	_export(_export.P, 'Array', {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	_addToUnscopables('includes');

	var includes = _core.Array.includes;

	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray




	var IS_CONCAT_SPREADABLE = _wks('isConcatSpreadable');

	function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? _ctx(mapper, thisArg, 3) : false;
	  var element, spreadable;

	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

	      spreadable = false;
	      if (_isObject(element)) {
	        spreadable = element[IS_CONCAT_SPREADABLE];
	        spreadable = spreadable !== undefined ? !!spreadable : _isArray(element);
	      }

	      if (spreadable && depth > 0) {
	        targetIndex = flattenIntoArray(target, original, element, _toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1fffffffffffff) { throw TypeError(); }
	        target[targetIndex] = element;
	      }

	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	}

	var _flattenIntoArray = flattenIntoArray;

	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap







	_export(_export.P, 'Array', {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = _toObject(this);
	    var sourceLen, A;
	    _aFunction(callbackfn);
	    sourceLen = _toLength(O.length);
	    A = _arraySpeciesCreate(O, 0);
	    _flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
	    return A;
	  }
	});

	_addToUnscopables('flatMap');

	var flatMap = _core.Array.flatMap;

	// https://github.com/tc39/proposal-string-pad-start-end




	var _stringPad = function (that, maxLength, fillString, left) {
	  var S = String(_defined(that));
	  var stringLength = S.length;
	  var fillStr = fillString === undefined ? ' ' : String(fillString);
	  var intMaxLength = _toLength(maxLength);
	  if (intMaxLength <= stringLength || fillStr == '') { return S; }
	  var fillLen = intMaxLength - stringLength;
	  var stringFiller = _stringRepeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if (stringFiller.length > fillLen) { stringFiller = stringFiller.slice(0, fillLen); }
	  return left ? stringFiller + S : S + stringFiller;
	};

	// https://github.com/tc39/proposal-string-pad-start-end




	// https://github.com/zloirock/core-js/issues/280
	var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(_userAgent);

	_export(_export.P + _export.F * WEBKIT_BUG, 'String', {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

	var padStart = _core.String.padStart;

	// https://github.com/tc39/proposal-string-pad-start-end




	// https://github.com/zloirock/core-js/issues/280
	var WEBKIT_BUG$1 = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(_userAgent);

	_export(_export.P + _export.F * WEBKIT_BUG$1, 'String', {
	  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
	    return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

	var padEnd = _core.String.padEnd;

	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	_stringTrim('trimLeft', function ($trim) {
	  return function trimLeft() {
	    return $trim(this, 1);
	  };
	}, 'trimStart');

	var trimStart = _core.String.trimLeft;

	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	_stringTrim('trimRight', function ($trim) {
	  return function trimRight() {
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

	var trimEnd = _core.String.trimRight;

	_wksDefine('asyncIterator');

	var asyncIterator = _wksExt.f('asyncIterator');

	// https://github.com/tc39/proposal-object-getownpropertydescriptors






	_export(_export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = _toIobject(object);
	    var getDesc = _objectGopd.f;
	    var keys = _ownKeys(O);
	    var result = {};
	    var i = 0;
	    var key, desc;
	    while (keys.length > i) {
	      desc = getDesc(O, key = keys[i++]);
	      if (desc !== undefined) { _createProperty(result, key, desc); }
	    }
	    return result;
	  }
	});

	var getOwnPropertyDescriptors = _core.Object.getOwnPropertyDescriptors;

	var isEnum$1 = _objectPie.f;
	var _objectToArray = function (isEntries) {
	  return function (it) {
	    var O = _toIobject(it);
	    var keys = _objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!_descriptors || isEnum$1.call(O, key)) {
	        result.push(isEntries ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};

	// https://github.com/tc39/proposal-object-values-entries

	var $values = _objectToArray(false);

	_export(_export.S, 'Object', {
	  values: function values(it) {
	    return $values(it);
	  }
	});

	var values = _core.Object.values;

	// https://github.com/tc39/proposal-object-values-entries

	var $entries = _objectToArray(true);

	_export(_export.S, 'Object', {
	  entries: function entries(it) {
	    return $entries(it);
	  }
	});

	var entries = _core.Object.entries;

	_export(_export.P + _export.R, 'Promise', { 'finally': function (onFinally) {
	  var C = _speciesConstructor(this, _core.Promise || _global.Promise);
	  var isFunction = typeof onFinally == 'function';
	  return this.then(
	    isFunction ? function (x) {
	      return _promiseResolve(C, onFinally()).then(function () { return x; });
	    } : onFinally,
	    isFunction ? function (e) {
	      return _promiseResolve(C, onFinally()).then(function () { throw e; });
	    } : onFinally
	  );
	} });

	var _finally = _core.Promise['finally'];

	// ie9- setTimeout & setInterval additional parameters fix



	var slice = [].slice;
	var MSIE = /MSIE .\./.test(_userAgent); // <- dirty ie9- check
	var wrap$1 = function (set) {
	  return function (fn, time /* , ...args */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice.call(arguments, 2) : false;
	    return set(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
	    } : fn, time);
	  };
	};
	_export(_export.G + _export.B + _export.F * MSIE, {
	  setTimeout: wrap$1(_global.setTimeout),
	  setInterval: wrap$1(_global.setInterval)
	});

	_export(_export.G + _export.B, {
	  setImmediate: _task.set,
	  clearImmediate: _task.clear
	});

	var ITERATOR$4 = _wks('iterator');
	var TO_STRING_TAG = _wks('toStringTag');
	var ArrayValues = _iterators.Array;

	var DOMIterables = {
	  CSSRuleList: true, // TODO: Not spec compliant, should be false.
	  CSSStyleDeclaration: false,
	  CSSValueList: false,
	  ClientRectList: false,
	  DOMRectList: false,
	  DOMStringList: false,
	  DOMTokenList: true,
	  DataTransferItemList: false,
	  FileList: false,
	  HTMLAllCollection: false,
	  HTMLCollection: false,
	  HTMLFormElement: false,
	  HTMLSelectElement: false,
	  MediaList: true, // TODO: Not spec compliant, should be false.
	  MimeTypeArray: false,
	  NamedNodeMap: false,
	  NodeList: true,
	  PaintRequestList: false,
	  Plugin: false,
	  PluginArray: false,
	  SVGLengthList: false,
	  SVGNumberList: false,
	  SVGPathSegList: false,
	  SVGPointList: false,
	  SVGStringList: false,
	  SVGTransformList: false,
	  SourceBufferList: false,
	  StyleSheetList: true, // TODO: Not spec compliant, should be false.
	  TextTrackCueList: false,
	  TextTrackList: false,
	  TouchList: false
	};

	for (var collections = _objectKeys(DOMIterables), i$2 = 0; i$2 < collections.length; i$2++) {
	  var NAME$1 = collections[i$2];
	  var explicit = DOMIterables[NAME$1];
	  var Collection = _global[NAME$1];
	  var proto$3 = Collection && Collection.prototype;
	  var key$1;
	  if (proto$3) {
	    if (!proto$3[ITERATOR$4]) { _hide(proto$3, ITERATOR$4, ArrayValues); }
	    if (!proto$3[TO_STRING_TAG]) { _hide(proto$3, TO_STRING_TAG, NAME$1); }
	    _iterators[NAME$1] = ArrayValues;
	    if (explicit) { for (key$1 in es6_array_iterator) { if (!proto$3[key$1]) { _redefine(proto$3, key$1, es6_array_iterator[key$1], true); } } }
	  }
	}

	var runtime_1 = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var runtime = (function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  exports.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  exports.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  exports.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  exports.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  exports.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  exports.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return exports.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) { continue; }
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined$1) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        // Note: ["return"] must be used for ES3 parsing compatibility.
	        if (delegate.iterator["return"]) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  exports.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined$1;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  exports.values = values;

	  function doneResult() {
	    return { value: undefined$1, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined$1;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined$1;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined$1;
	      }

	      return ContinueSentinel;
	    }
	  };

	  // Regardless of whether this script is executing as a CommonJS module
	  // or not, return the runtime object so that we can declare the variable
	  // regeneratorRuntime in the outer scope, which allows this module to be
	  // injected easily by `bin/regenerator --include-runtime script.js`.
	  return exports;

	}(
	  // If this script is executing as a CommonJS module, use module.exports
	  // as the regeneratorRuntime namespace. Otherwise create a new empty
	  // object. Either way, the resulting object will be used to initialize
	  // the regeneratorRuntime variable at the top of this file.
	   module.exports 
	));

	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  // This module should not be running in strict mode, so the above
	  // assignment should always work unless something is misconfigured. Just
	  // in case runtime.js accidentally runs in strict mode, we can escape
	  // strict mode using a global Function call. This could conceivably fail
	  // if a Content Security Policy forbids using Function, but in that case
	  // the proper solution is to fix the accidental strict mode problem. If
	  // you've misconfigured your bundler to force strict mode and applied a
	  // CSP to forbid Function, and you're not willing to fix either of those
	  // problems, please detail your unique predicament in a GitHub issue.
	  Function("r", "regeneratorRuntime = r")(runtime);
	}
	});

	var _global$1 = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') { __g = global; } // eslint-disable-line no-undef
	});

	var _core$1 = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.11' };
	if (typeof __e == 'number') { __e = core; } // eslint-disable-line no-undef
	});
	var _core_1$1 = _core$1.version;

	var _aFunction$1 = function (it) {
	  if (typeof it != 'function') { throw TypeError(it + ' is not a function!'); }
	  return it;
	};

	// optional / simple context binding

	var _ctx$1 = function (fn, that, length) {
	  _aFunction$1(fn);
	  if (that === undefined) { return fn; }
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var _isObject$1 = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject$1 = function (it) {
	  if (!_isObject$1(it)) { throw TypeError(it + ' is not an object!'); }
	  return it;
	};

	var _fails$1 = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var _descriptors$1 = !_fails$1(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document$3 = _global$1.document;
	// typeof document.createElement is 'object' in old IE
	var is$1 = _isObject$1(document$3) && _isObject$1(document$3.createElement);
	var _domCreate$1 = function (it) {
	  return is$1 ? document$3.createElement(it) : {};
	};

	var _ie8DomDefine$1 = !_descriptors$1 && !_fails$1(function () {
	  return Object.defineProperty(_domCreate$1('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive$1 = function (it, S) {
	  if (!_isObject$1(it)) { return it; }
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject$1(val = fn.call(it))) { return val; }
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject$1(val = fn.call(it))) { return val; }
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject$1(val = fn.call(it))) { return val; }
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP$6 = Object.defineProperty;

	var f$8 = _descriptors$1 ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject$1(O);
	  P = _toPrimitive$1(P, true);
	  _anObject$1(Attributes);
	  if (_ie8DomDefine$1) { try {
	    return dP$6(O, P, Attributes);
	  } catch (e) { /* empty */ } }
	  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported!'); }
	  if ('value' in Attributes) { O[P] = Attributes.value; }
	  return O;
	};

	var _objectDp$1 = {
		f: f$8
	};

	var _propertyDesc$1 = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide$1 = _descriptors$1 ? function (object, key, value) {
	  return _objectDp$1.f(object, key, _propertyDesc$1(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty$1 = {}.hasOwnProperty;
	var _has$1 = function (it, key) {
	  return hasOwnProperty$1.call(it, key);
	};

	var PROTOTYPE$3 = 'prototype';

	var $export$1 = function (type, name, source) {
	  var IS_FORCED = type & $export$1.F;
	  var IS_GLOBAL = type & $export$1.G;
	  var IS_STATIC = type & $export$1.S;
	  var IS_PROTO = type & $export$1.P;
	  var IS_BIND = type & $export$1.B;
	  var IS_WRAP = type & $export$1.W;
	  var exports = IS_GLOBAL ? _core$1 : _core$1[name] || (_core$1[name] = {});
	  var expProto = exports[PROTOTYPE$3];
	  var target = IS_GLOBAL ? _global$1 : IS_STATIC ? _global$1[name] : (_global$1[name] || {})[PROTOTYPE$3];
	  var key, own, out;
	  if (IS_GLOBAL) { source = name; }
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if (own && _has$1(exports, key)) { continue; }
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? _ctx$1(out, _global$1)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function (C) {
	      var F = function (a, b, c) {
	        if (this instanceof C) {
	          switch (arguments.length) {
	            case 0: return new C();
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE$3] = C[PROTOTYPE$3];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? _ctx$1(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if (IS_PROTO) {
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if (type & $export$1.R && expProto && !expProto[key]) { _hide$1(expProto, key, out); }
	    }
	  }
	};
	// type bitmap
	$export$1.F = 1;   // forced
	$export$1.G = 2;   // global
	$export$1.S = 4;   // static
	$export$1.P = 8;   // proto
	$export$1.B = 16;  // bind
	$export$1.W = 32;  // wrap
	$export$1.U = 64;  // safe
	$export$1.R = 128; // real proto method for `library`
	var _export$1 = $export$1;

	// https://github.com/tc39/proposal-global


	_export$1(_export$1.G, { global: _global$1 });

	var global$1 = _core$1.global;

	var lib = createCommonjsModule(function (module) {



	var _global = _interopRequireDefault(global$1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	if (_global["default"]._babelPolyfill && typeof console !== "undefined" && console.warn) {
	  console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended " + "and may have consequences if different versions of the polyfills are applied sequentially. " + "If you do need to load the polyfill more than once, use @babel/polyfill/noConflict " + "instead to bypass the warning.");
	}

	_global["default"]._babelPolyfill = true;
	});

	unwrapExports(lib);

	//

	/**
	 * Utilities to get information about the current environment
	 */
	// --- Constants ---
	var hasWindowSupport = typeof window !== 'undefined';
	var hasDocumentSupport = typeof document !== 'undefined';
	var hasNavigatorSupport = typeof navigator !== 'undefined';
	var hasPromiseSupport = typeof Promise !== 'undefined';
	var hasMutationObserverSupport = typeof MutationObserver !== 'undefined' || typeof WebKitMutationObserver !== 'undefined' || typeof MozMutationObserver !== 'undefined';
	var isBrowser = hasWindowSupport && hasDocumentSupport && hasNavigatorSupport; // Browser type sniffing

	var userAgent = isBrowser ? window.navigator.userAgent.toLowerCase() : '';
	var isJSDOM = userAgent.indexOf('jsdom') > 0;
	var isIE = /msie|trident/.test(userAgent); // Determine if the browser supports the option passive for events

	var hasPassiveEventSupport = function () {
	  var passiveEventSupported = false;

	  if (isBrowser) {
	    try {
	      var options = {
	        get passive() {
	          // This function will be called when the browser
	          // attempts to access the passive property.

	          /* istanbul ignore next: will never be called in JSDOM */
	          passiveEventSupported = true;
	        }

	      };
	      window.addEventListener('test', options, options);
	      window.removeEventListener('test', options, options);
	    } catch (err) {
	      /* istanbul ignore next: will never be called in JSDOM */
	      passiveEventSupported = false;
	    }
	  }

	  return passiveEventSupported;
	}();
	var hasTouchSupport = isBrowser && ('ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0);
	var hasPointerEventSupport = isBrowser && Boolean(window.PointerEvent || window.MSPointerEvent);
	var hasIntersectionObserverSupport = isBrowser && 'IntersectionObserver' in window && 'IntersectionObserverEntry' in window && // Edge 15 and UC Browser lack support for `isIntersecting`
	// but we an use intersectionRatio > 0 instead
	// 'isIntersecting' in window.IntersectionObserverEntry.prototype &&
	'intersectionRatio' in window.IntersectionObserverEntry.prototype; // --- Getters ---

	var getEnv = function getEnv(key) {
	  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	  var env = typeof process !== 'undefined' && process ? process.env || {} : {};

	  if (!key) {
	    /* istanbul ignore next */
	    return env;
	  }

	  return env[key] || fallback;
	};
	var getNoWarn = function getNoWarn() {
	  return getEnv('BOOTSTRAP_VUE_NO_WARN');
	};

	/**
	 * Log a warning message to the console with BootstrapVue formatting
	 * @param {string} message
	 */

	var warn = function warn(message)
	/* istanbul ignore next */
	{
	  if (!getNoWarn()) {
	    console.warn("[BootstrapVue warn]: ".concat(message));
	  }
	};
	/**
	 * Warn when no Promise support is given
	 * @param {string} source
	 * @returns {boolean} warned
	 */

	var warnNotClient = function warnNotClient(source) {
	  /* istanbul ignore else */
	  if (isBrowser) {
	    return false;
	  } else {
	    warn("".concat(source, ": Can not be called during SSR."));
	    return true;
	  }
	};
	/**
	 * Warn when no Promise support is given
	 * @param {string} source
	 * @returns {boolean} warned
	 */

	var warnNoPromiseSupport = function warnNoPromiseSupport(source) {
	  /* istanbul ignore else */
	  if (hasPromiseSupport) {
	    return false;
	  } else {
	    warn("".concat(source, ": Requires Promise support."));
	    return true;
	  }
	};
	/**
	 * Warn when no MutationObserver support is given
	 * @param {string} source
	 * @returns {boolean} warned
	 */

	var warnNoMutationObserverSupport = function warnNoMutationObserverSupport(source) {
	  /* istanbul ignore else */
	  if (hasMutationObserverSupport) {
	    return false;
	  } else {
	    warn("".concat(source, ": Requires MutationObserver support."));
	    return true;
	  }
	}; // Default export

	// --- Static ---
	var from = Array.from;
	var isArray = Array.isArray; // --- Instance ---

	var arrayIncludes = function arrayIncludes(array, value) {
	  return array.indexOf(value) !== -1;
	};
	var concat = function concat() {
	  var arguments$1 = arguments;

	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments$1[_key];
	  }

	  return Array.prototype.concat.apply([], args);
	};

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	var assign = Object.assign;
	var getOwnPropertyNames = Object.getOwnPropertyNames;
	var keys$2 = Object.keys;
	var defineProperties = Object.defineProperties;
	var defineProperty$1 = Object.defineProperty;
	var freeze = Object.freeze;
	var create = Object.create;

	var hasOwnProperty$2 = function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	};
	var toString$2 = function toString(obj) {
	  return Object.prototype.toString.call(obj);
	}; // --- Utilities ---

	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 * Note object could be a complex type like array, date, etc.
	 */

	var isObject = function isObject(obj) {
	  return obj !== null && _typeof(obj) === 'object';
	};
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 */

	var isPlainObject = function isPlainObject(obj) {
	  return Object.prototype.toString.call(obj) === '[object Object]';
	};
	/**
	 * Shallow copy an object. If the passed in object
	 * is null or undefined, returns an empty object
	 */

	var clone = function clone(obj) {
	  return _objectSpread({}, obj);
	};
	/**
	 * Return a shallow copy of object with
	 * the specified properties omitted
	 * @link https://gist.github.com/bisubus/2da8af7e801ffd813fab7ac221aa7afc
	 */

	var omit = function omit(obj, props) {
	  return keys$2(obj).filter(function (key) {
	    return props.indexOf(key) === -1;
	  }).reduce(function (result, key) {
	    return _objectSpread({}, result, _defineProperty({}, key, obj[key]));
	  }, {});
	};
	/**
	 * Convenience method to create a read-only descriptor
	 */

	var readonlyDescriptor = function readonlyDescriptor() {
	  return {
	    enumerable: true,
	    configurable: false,
	    writable: false
	  };
	};
	/**
	 * Deep-freezes and object, making it immutable / read-only.
	 * Returns the same object passed-in, but frozen.
	 * Freezes inner object/array/values first.
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
	 * Note: this method will not work for property values using Symbol() as a key
	 */

	var deepFreeze = function deepFreeze(obj) {
	  // Retrieve the property names defined on object/array
	  // Note: `keys` will ignore properties that are keyed by a `Symbol()`
	  var props = keys$2(obj); // Iterate over each prop and recursively freeze it

	  props.forEach(function (prop) {
	    var value = obj[prop]; // If value is a plain object or array, we deepFreeze it

	    obj[prop] = value && (isPlainObject(value) || isArray(value)) ? deepFreeze(value) : value;
	  });
	  return freeze(obj);
	};

	function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof$1(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) { _setPrototypeOf(subClass, superClass); } }

	function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) { return Class; } if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) { return _cache.get(Class); } _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

	function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) { return false; } if (Reflect.construct.sham) { return false; } if (typeof Proxy === "function") { return true; } try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) { _setPrototypeOf(instance, Class.prototype); } return instance; }; } return _construct.apply(null, arguments); }

	function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
	var w = hasWindowSupport ? window : {};
	var Element$1 = hasWindowSupport ? w.Element :
	/*#__PURE__*/
	function (_Object) {
	  _inherits(Element, _Object);

	  function Element() {
	    _classCallCheck(this, Element);

	    return _possibleConstructorReturn(this, _getPrototypeOf(Element).apply(this, arguments));
	  }

	  return Element;
	}(_wrapNativeSuper(Object));
	var HTMLElement$1 = hasWindowSupport ? w.HTMLElement :
	/*#__PURE__*/
	function (_Element) {
	  _inherits(HTMLElement, _Element);

	  function HTMLElement() {
	    _classCallCheck(this, HTMLElement);

	    return _possibleConstructorReturn(this, _getPrototypeOf(HTMLElement).apply(this, arguments));
	  }

	  return HTMLElement;
	}(Element$1);
	var SVGElement = hasWindowSupport ? w.SVGElement :
	/*#__PURE__*/
	function (_Element2) {
	  _inherits(SVGElement, _Element2);

	  function SVGElement() {
	    _classCallCheck(this, SVGElement);

	    return _possibleConstructorReturn(this, _getPrototypeOf(SVGElement).apply(this, arguments));
	  }

	  return SVGElement;
	}(Element$1);
	var File = hasWindowSupport ? w.File :
	/*#__PURE__*/
	function (_Object2) {
	  _inherits(File, _Object2);

	  function File() {
	    _classCallCheck(this, File);

	    return _possibleConstructorReturn(this, _getPrototypeOf(File).apply(this, arguments));
	  }

	  return File;
	}(_wrapNativeSuper(Object));

	function _typeof$2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }

	var toType = function toType(val) {
	  return _typeof$2(val);
	};
	var toRawType = function toRawType(val) {
	  return Object.prototype.toString.call(val).slice(8, -1);
	};
	var isUndefined = function isUndefined(val) {
	  return val === undefined;
	};
	var isNull = function isNull(val) {
	  return val === null;
	};
	var isUndefinedOrNull = function isUndefinedOrNull(val) {
	  return isUndefined(val) || isNull(val);
	};
	var isFunction = function isFunction(val) {
	  return toType(val) === 'function';
	};
	var isBoolean = function isBoolean(val) {
	  return toType(val) === 'boolean';
	};
	var isString = function isString(val) {
	  return toType(val) === 'string';
	};
	var isNumber = function isNumber(val) {
	  return toType(val) === 'number';
	};
	var isDate = function isDate(val) {
	  return val instanceof Date;
	};
	var isEvent = function isEvent(val) {
	  return val instanceof Event;
	};
	var isFile = function isFile(val) {
	  return val instanceof File;
	};
	var isRegExp = function isRegExp(val) {
	  return toRawType(val) === 'RegExp';
	};
	var isPromise = function isPromise(val) {
	  return !isUndefinedOrNull(val) && isFunction(val.then) && isFunction(val.catch);
	}; // Extra convenience named re-exports

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$1(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") { return Array.from(iter); } }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }
	var cloneDeep = function cloneDeep(obj) {
	  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : obj;

	  if (isArray(obj)) {
	    return obj.reduce(function (result, val) {
	      return [].concat(_toConsumableArray(result), [cloneDeep(val, val)]);
	    }, []);
	  }

	  if (isPlainObject(obj)) {
	    return keys$2(obj).reduce(function (result, key) {
	      return _objectSpread$1({}, result, _defineProperty$1({}, key, cloneDeep(obj[key], obj[key])));
	    }, {});
	  }

	  return defaultValue;
	};

	/**
	 * Get property defined by dot/array notation in string.
	 *
	 * @link https://gist.github.com/jeneg/9767afdcca45601ea44930ea03e0febf#gistcomment-1935901
	 *
	 * @param {Object} obj
	 * @param {string|Array} path
	 * @param {*} defaultValue (optional)
	 * @return {*}
	 */

	var get$1 = function get(obj, path) {
	  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	  // Handle array of path values
	  path = isArray(path) ? path.join('.') : path; // If no path or no object passed

	  if (!path || !isObject(obj)) {
	    return defaultValue;
	  } // Handle edge case where user has dot(s) in top-level item field key
	  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2762
	  // Switched to `in` operator vs `hasOwnProperty` to handle obj.prototype getters
	  // https://github.com/bootstrap-vue/bootstrap-vue/issues/3463


	  if (path in obj) {
	    return obj[path];
	  } // Handle string array notation (numeric indices only)


	  path = String(path).replace(/\[(\d+)]/g, '.$1');
	  var steps = path.split('.').filter(Boolean); // Handle case where someone passes a string of only dots

	  if (steps.length === 0) {
	    return defaultValue;
	  } // Traverse path in object to find result
	  // We use `!=` vs `!==` to test for both `null` and `undefined`
	  // Switched to `in` operator vs `hasOwnProperty` to handle obj.prototype getters
	  // https://github.com/bootstrap-vue/bootstrap-vue/issues/3463


	  return steps.every(function (step) {
	    return isObject(obj) && step in obj && (obj = obj[step]) != null;
	  }) ? obj : defaultValue;
	};

	// NOTES
	//
	// The global config SHALL NOT be used to set defaults for Boolean props, as the props
	// would loose their semantic meaning, and force people writing 3rd party components to
	// explicity set a true or false value using the v-bind syntax on boolean props
	//
	// Supported config values (depending on the prop's supported type(s)):
	// `String`, `Array`, `Object`, `null` or `undefined`
	// BREAKPOINT DEFINITIONS
	//
	// Some components (`<b-col>` and `<b-form-group>`) generate props based on breakpoints,
	// and this occurs when the component is first loaded (evaluated), which may happen
	// before the config is created/modified
	//
	// To get around this we make these components' props async (lazy evaluation)
	// The component definition is only called/executed when the first access to the
	// component is used (and cached on subsequent uses)
	// PROP DEFAULTS
	//
	// For default values on props, we use the default value factory function approach so
	// that the default values are pulled in at each component instantiation
	//
	//  props: {
	//    variant: {
	//      type: String,
	//      default: () => getConfigComponent('BAlert', 'variant')
	//    }
	//  }
	//
	// We also provide a cached getter for breakpoints, which are "frozen" on first access
	// prettier-ignore

	var DEFAULTS = deepFreeze({
	  // Breakpoints
	  breakpoints: ['xs', 'sm', 'md', 'lg', 'xl'],
	  // Form controls
	  formControls: {
	    size: null
	  },
	  // Component specific defaults are keyed by the component
	  // name (PascalCase) and prop name (camelCase)
	  BAlert: {
	    dismissLabel: 'Close',
	    variant: 'info'
	  },
	  BBadge: {
	    variant: 'secondary'
	  },
	  BButton: {
	    size: null,
	    variant: 'secondary'
	  },
	  BButtonClose: {
	    // `textVariant` is `null` to inherit the current text color
	    textVariant: null,
	    ariaLabel: 'Close'
	  },
	  BCardSubTitle: {
	    // `<b-card>` and `<b-card-body>` also inherit this prop
	    subTitleTextVariant: 'muted'
	  },
	  BCarousel: {
	    labelPrev: 'Previous Slide',
	    labelNext: 'Next Slide',
	    labelGotoSlide: 'Goto Slide',
	    labelIndicators: 'Select a slide to display'
	  },
	  BDropdown: {
	    toggleText: 'Toggle Dropdown',
	    size: null,
	    variant: 'secondary',
	    splitVariant: null
	  },
	  BFormFile: {
	    browseText: 'Browse',
	    // Chrome default file prompt
	    placeholder: 'No file chosen',
	    dropPlaceholder: 'Drop files here'
	  },
	  BFormText: {
	    textVariant: 'muted'
	  },
	  BImg: {
	    blankColor: 'transparent'
	  },
	  BImgLazy: {
	    blankColor: 'transparent'
	  },
	  BInputGroup: {
	    size: null
	  },
	  BJumbotron: {
	    bgVariant: null,
	    borderVariant: null,
	    textVariant: null
	  },
	  BListGroupItem: {
	    variant: null
	  },
	  BModal: {
	    titleTag: 'h5',
	    size: 'md',
	    headerBgVariant: null,
	    headerBorderVariant: null,
	    headerTextVariant: null,
	    headerCloseVariant: null,
	    bodyBgVariant: null,
	    bodyTextVariant: null,
	    footerBgVariant: null,
	    footerBorderVariant: null,
	    footerTextVariant: null,
	    cancelTitle: 'Cancel',
	    cancelVariant: 'secondary',
	    okTitle: 'OK',
	    okVariant: 'primary',
	    headerCloseLabel: 'Close'
	  },
	  BNavbar: {
	    variant: null
	  },
	  BNavbarToggle: {
	    label: 'Toggle navigation'
	  },
	  BPagination: {
	    size: null
	  },
	  BPaginationNav: {
	    size: null
	  },
	  BPopover: {
	    boundary: 'scrollParent',
	    boundaryPadding: 5,
	    customClass: null,
	    delay: 50,
	    variant: null
	  },
	  BProgress: {
	    variant: null
	  },
	  BProgressBar: {
	    variant: null
	  },
	  BSpinner: {
	    variant: null
	  },
	  BTable: {
	    selectedVariant: 'active',
	    headVariant: null,
	    footVariant: null
	  },
	  BToast: {
	    toaster: 'b-toaster-top-right',
	    autoHideDelay: 5000,
	    variant: null,
	    toastClass: null,
	    headerClass: null,
	    bodyClass: null
	  },
	  BToaster: {
	    ariaLive: null,
	    ariaAtomic: null,
	    role: null
	  },
	  BTooltip: {
	    boundary: 'scrollParent',
	    boundaryPadding: 5,
	    customClass: null,
	    delay: 50,
	    variant: null
	  }
	});

	function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) { _defineProperties(Constructor.prototype, protoProps); } if (staticProps) { _defineProperties(Constructor, staticProps); } return Constructor; }

	var PROP_NAME = '$bvConfig'; // Config manager class

	var BvConfig =
	/*#__PURE__*/
	function () {
	  function BvConfig() {
	    _classCallCheck$1(this, BvConfig);

	    // TODO: pre-populate with default config values (needs updated tests)
	    // this.$_config = cloneDeep(DEFAULTS)
	    this.$_config = {};
	    this.$_cachedBreakpoints = null;
	  }

	  _createClass(BvConfig, [{
	    key: "getDefaults",
	    // Returns the defaults
	    value: function getDefaults()
	    /* istanbul ignore next */
	    {
	      return this.defaults;
	    } // Method to merge in user config parameters

	  }, {
	    key: "setConfig",
	    value: function setConfig() {
	      var _this = this;

	      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (!isPlainObject(config)) {
	        /* istanbul ignore next */
	        return;
	      }

	      var configKeys = getOwnPropertyNames(config);
	      configKeys.forEach(function (cmpName) {
	        /* istanbul ignore next */
	        if (!hasOwnProperty$2(DEFAULTS, cmpName)) {
	          warn("config: unknown config property \"".concat(cmpName, "\""));
	          return;
	        }

	        var cmpConfig = config[cmpName];

	        if (cmpName === 'breakpoints') {
	          // Special case for breakpoints
	          var breakpoints = config.breakpoints;
	          /* istanbul ignore if */

	          if (!isArray(breakpoints) || breakpoints.length < 2 || breakpoints.some(function (b) {
	            return !isString(b) || b.length === 0;
	          })) {
	            warn('config: "breakpoints" must be an array of at least 2 breakpoint names');
	          } else {
	            _this.$_config.breakpoints = cloneDeep(breakpoints);
	          }
	        } else if (isPlainObject(cmpConfig)) {
	          // Component prop defaults
	          var props = getOwnPropertyNames(cmpConfig);
	          props.forEach(function (prop) {
	            /* istanbul ignore if */
	            if (!hasOwnProperty$2(DEFAULTS[cmpName], prop)) {
	              warn("config: unknown config property \"".concat(cmpName, ".").concat(prop, "\""));
	            } else {
	              // TODO: If we pre-populate the config with defaults, we can skip this line
	              _this.$_config[cmpName] = _this.$_config[cmpName] || {};

	              if (!isUndefined(cmpConfig[prop])) {
	                _this.$_config[cmpName][prop] = cloneDeep(cmpConfig[prop]);
	              }
	            }
	          });
	        }
	      });
	    } // Clear the config. For testing purposes only

	  }, {
	    key: "resetConfig",
	    value: function resetConfig() {
	      this.$_config = {};
	    } // Returns a deep copy of the user config

	  }, {
	    key: "getConfig",
	    value: function getConfig() {
	      return cloneDeep(this.$_config);
	    }
	  }, {
	    key: "getConfigValue",
	    value: function getConfigValue(key) {
	      // First we try the user config, and if key not found we fall back to default value
	      // NOTE: If we deep clone DEFAULTS into config, then we can skip the fallback for get
	      return cloneDeep(get$1(this.$_config, key, get$1(DEFAULTS, key)));
	    }
	  }, {
	    key: "defaults",
	    get: function get()
	    /* istanbul ignore next */
	    {
	      return DEFAULTS;
	    }
	  }], [{
	    key: "Defaults",
	    get: function get()
	    /* istanbul ignore next */
	    {
	      return DEFAULTS;
	    }
	  }]);

	  return BvConfig;
	}(); // Method for applying a global config


	var setConfig = function setConfig() {
	  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var Vue$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Vue;
	  // Ensure we have a $bvConfig Object on the Vue prototype.
	  // We set on Vue and OurVue just in case consumer has not set an alias of `vue`.
	  Vue$1.prototype[PROP_NAME] = Vue.prototype[PROP_NAME] = Vue$1.prototype[PROP_NAME] || Vue.prototype[PROP_NAME] || new BvConfig(); // Apply the config values

	  Vue$1.prototype[PROP_NAME].setConfig(config);
	}; // Method for resetting the user config. Exported for testing purposes only.

	function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$2(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$2(source, true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	/**
	 * Checks if there are multiple instances of Vue, and warns (once) about possible issues.
	 * @param {object} Vue
	 */

	var checkMultipleVue = function () {
	  var checkMultipleVueWarned = false;
	  var MULTIPLE_VUE_WARNING = ['Multiple instances of Vue detected!', 'You may need to set up an alias for Vue in your bundler config.', 'See: https://bootstrap-vue.js.org/docs#using-module-bundlers'].join('\n');
	  return function (Vue$1) {
	    /* istanbul ignore next */
	    if (!checkMultipleVueWarned && Vue !== Vue$1 && !isJSDOM) {
	      warn(MULTIPLE_VUE_WARNING);
	    }

	    checkMultipleVueWarned = true;
	  };
	}();
	/**
	 * Plugin install factory function.
	 * @param {object} { components, directives }
	 * @returns {function} plugin install function
	 */

	var installFactory = function installFactory() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      components = _ref.components,
	      directives = _ref.directives,
	      plugins = _ref.plugins;

	  var install = function install(Vue) {
	    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    if (install.installed) {
	      /* istanbul ignore next */
	      return;
	    }

	    install.installed = true;
	    checkMultipleVue(Vue);
	    setConfig(config, Vue);
	    registerComponents(Vue, components);
	    registerDirectives(Vue, directives);
	    registerPlugins(Vue, plugins);
	  };

	  install.installed = false;
	  return install;
	};
	/**
	 * Plugin object factory function.
	 * @param {object} { components, directives, plugins }
	 * @returns {object} plugin install object
	 */

	var pluginFactory = function pluginFactory() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var extend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  return _objectSpread$2({}, extend, {
	    install: installFactory(opts)
	  });
	};
	/**
	 * Load a group of plugins.
	 * @param {object} Vue
	 * @param {object} Plugin definitions
	 */

	var registerPlugins = function registerPlugins(Vue) {
	  var plugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  for (var plugin in plugins) {
	    if (plugin && plugins[plugin]) {
	      Vue.use(plugins[plugin]);
	    }
	  }
	};
	/**
	 * Load a component.
	 * @param {object} Vue
	 * @param {string} Component name
	 * @param {object} Component definition
	 */

	var registerComponent = function registerComponent(Vue, name, def) {
	  if (Vue && name && def) {
	    Vue.component(name, def);
	  }
	};
	/**
	 * Load a group of components.
	 * @param {object} Vue
	 * @param {object} Object of component definitions
	 */

	var registerComponents = function registerComponents(Vue) {
	  var components = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  for (var component in components) {
	    registerComponent(Vue, component, components[component]);
	  }
	};
	/**
	 * Load a directive.
	 * @param {object} Vue
	 * @param {string} Directive name
	 * @param {object} Directive definition
	 */

	var registerDirective = function registerDirective(Vue, name, def) {
	  if (Vue && name && def) {
	    // Ensure that any leading V is removed from the
	    // name, as Vue adds it automatically
	    Vue.directive(name.replace(/^VB/, 'B'), def);
	  }
	};
	/**
	 * Load a group of directives.
	 * @param {object} Vue
	 * @param {object} Object of directive definitions
	 */

	var registerDirectives = function registerDirectives(Vue) {
	  var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  for (var directive in directives) {
	    registerDirective(Vue, directive, directives[directive]);
	  }
	};

	var memoize = function memoize(fn) {
	  var cache = create(null);
	  return function () {
	    var arguments$1 = arguments;

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments$1[_key];
	    }

	    var argsKey = JSON.stringify(args);
	    return cache[argsKey] = cache[argsKey] || fn.apply(null, args);
	  };
	};

	var PROP_NAME$1 = '$bvConfig';
	var VueProto = Vue.prototype; // --- Getter methods ---

	var getConfigValue = function getConfigValue(key) {
	  return VueProto[PROP_NAME$1] ? VueProto[PROP_NAME$1].getConfigValue(key) : cloneDeep(get$1(DEFAULTS, key));
	}; // Method to grab a config value for a particular component

	var getComponentConfig = function getComponentConfig(cmpName) {
	  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	  // Return the particular config value for key for if specified,
	  // otherwise we return the full config (or an empty object if not found)
	  return key ? getConfigValue("".concat(cmpName, ".").concat(key)) : getConfigValue(cmpName) || {};
	}; // Convenience method for getting all breakpoint names

	var getBreakpoints = function getBreakpoints() {
	  return getConfigValue('breakpoints');
	}; // Private function for caching / locking-in breakpoint names

	var _getBreakpointsCached = memoize(function () {
	  return getBreakpoints();
	}); // Convenience method for getting all breakpoint names.
	// Caches the results after first access.


	var getBreakpointsCached = function getBreakpointsCached() {
	  return cloneDeep(_getBreakpointsCached());
	}; // Convenience method for getting breakpoints with
	// the smallest breakpoint set as ''.
	// Useful for components that create breakpoint specific props.
	// Caches the results after first access.

	var getBreakpointsUpCached = memoize(function () {
	  var breakpoints = getBreakpointsCached();
	  breakpoints[0] = '';
	  return breakpoints;
	}); // Convenience method for getting breakpoints with

	var w$1 = hasWindowSupport ? window : {};
	var d = hasDocumentSupport ? document : {};
	var elProto = typeof Element !== 'undefined' ? Element.prototype : {}; // --- Normalization utils ---
	// See: https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill

	/* istanbul ignore next */

	var matchesEl = elProto.matches || elProto.msMatchesSelector || elProto.webkitMatchesSelector; // See: https://developer.mozilla.org/en-US/docs/Web/API/Element/closest

	/* istanbul ignore next */

	var closestEl = elProto.closest || function (sel)
	/* istanbul ignore next */
	{
	  var el = this;

	  do {
	    // Use our "patched" matches function
	    if (matches(el, sel)) {
	      return el;
	    }

	    el = el.parentElement || el.parentNode;
	  } while (!isNull(el) && el.nodeType === Node.ELEMENT_NODE);

	  return null;
	}; // `requestAnimationFrame()` convenience method

	var requestAF = w$1.requestAnimationFrame || w$1.webkitRequestAnimationFrame || w$1.mozRequestAnimationFrame || w$1.msRequestAnimationFrame || w$1.oRequestAnimationFrame || // Fallback, but not a true polyfill
	// Only needed for Opera Mini

	/* istanbul ignore next */
	function (cb) {
	  return setTimeout(cb, 16);
	};
	var MutationObs = w$1.MutationObserver || w$1.WebKitMutationObserver || w$1.MozMutationObserver || null; // --- Utils ---
	// Normalize event options based on support of passive option
	// Exported only for testing purposes

	var parseEventOptions = function parseEventOptions(options) {
	  /* istanbul ignore else: can't test in JSDOM, as it supports passive */
	  if (hasPassiveEventSupport) {
	    return isObject(options) ? options : {
	      useCapture: Boolean(options || false)
	    };
	  } else {
	    // Need to translate to actual Boolean value
	    return Boolean(isObject(options) ? options.useCapture : options);
	  }
	}; // Attach an event listener to an element

	var eventOn = function eventOn(el, evtName, handler, options) {
	  if (el && el.addEventListener) {
	    el.addEventListener(evtName, handler, parseEventOptions(options));
	  }
	}; // Remove an event listener from an element

	var eventOff = function eventOff(el, evtName, handler, options) {
	  if (el && el.removeEventListener) {
	    el.removeEventListener(evtName, handler, parseEventOptions(options));
	  }
	}; // Determine if an element is an HTML Element

	var isElement = function isElement(el) {
	  return Boolean(el && el.nodeType === Node.ELEMENT_NODE);
	}; // Determine if an HTML element is visible - Faster than CSS check

	var isVisible = function isVisible(el) {
	  if (!isElement(el) || !contains(d.body, el)) {
	    return false;
	  }

	  if (el.style.display === 'none') {
	    // We do this check to help with vue-test-utils when using v-show

	    /* istanbul ignore next */
	    return false;
	  } // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(
	  // So any tests that need isVisible will fail in JSDOM
	  // Except when we override the getBCR prototype in some tests


	  var bcr = getBCR(el);
	  return Boolean(bcr && bcr.height > 0 && bcr.width > 0);
	}; // Determine if an element is disabled

	var isDisabled = function isDisabled(el) {
	  return !isElement(el) || el.disabled || Boolean(getAttr(el, 'disabled')) || hasClass(el, 'disabled');
	}; // Cause/wait-for an element to reflow it's content (adjusting it's height/width)

	var reflow = function reflow(el) {
	  // Requesting an elements offsetHight will trigger a reflow of the element content

	  /* istanbul ignore next: reflow doesn't happen in JSDOM */
	  return isElement(el) && el.offsetHeight;
	}; // Select all elements matching selector. Returns `[]` if none found

	var selectAll = function selectAll(selector, root) {
	  return from((isElement(root) ? root : d).querySelectorAll(selector));
	}; // Select a single element, returns `null` if not found

	var select = function select(selector, root) {
	  return (isElement(root) ? root : d).querySelector(selector) || null;
	}; // Determine if an element matches a selector

	var matches = function matches(el, selector) {
	  if (!isElement(el)) {
	    return false;
	  }

	  return matchesEl.call(el, selector);
	}; // Finds closest element matching selector. Returns `null` if not found

	var closest = function closest(selector, root) {
	  var includeRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  if (!isElement(root)) {
	    return null;
	  }

	  var el = closestEl.call(root, selector); // Native closest behaviour when `includeRoot` is truthy,
	  // else emulate jQuery closest and return `null` if match is
	  // the passed in root element when `includeRoot` is falsey

	  return includeRoot ? el : el === root ? null : el;
	}; // Returns true if the parent element contains the child element

	var contains = function contains(parent, child) {
	  if (!parent || !isFunction(parent.contains)) {
	    return false;
	  }

	  return parent.contains(child);
	}; // Get an element given an ID

	var getById = function getById(id) {
	  return d.getElementById(/^#/.test(id) ? id.slice(1) : id) || null;
	}; // Add a class to an element

	var addClass = function addClass(el, className) {
	  // We are checking for `el.classList` existence here since IE 11
	  // returns `undefined` for some elements (e.g. SVG elements)
	  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713
	  if (className && isElement(el) && el.classList) {
	    el.classList.add(className);
	  }
	}; // Remove a class from an element

	var removeClass = function removeClass(el, className) {
	  // We are checking for `el.classList` existence here since IE 11
	  // returns `undefined` for some elements (e.g. SVG elements)
	  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713
	  if (className && isElement(el) && el.classList) {
	    el.classList.remove(className);
	  }
	}; // Test if an element has a class

	var hasClass = function hasClass(el, className) {
	  // We are checking for `el.classList` existence here since IE 11
	  // returns `undefined` for some elements (e.g. SVG elements)
	  // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713
	  if (className && isElement(el) && el.classList) {
	    return el.classList.contains(className);
	  }

	  return false;
	}; // Set an attribute on an element

	var setAttr = function setAttr(el, attr, val) {
	  if (attr && isElement(el)) {
	    el.setAttribute(attr, val);
	  }
	}; // Remove an attribute from an element

	var removeAttr = function removeAttr(el, attr) {
	  if (attr && isElement(el)) {
	    el.removeAttribute(attr);
	  }
	}; // Get an attribute value from an element
	// Returns `null` if not found

	var getAttr = function getAttr(el, attr) {
	  return attr && isElement(el) ? el.getAttribute(attr) : null;
	}; // Determine if an attribute exists on an element
	// Returns `true` or `false`, or `null` if element not found

	var hasAttr = function hasAttr(el, attr) {
	  return attr && isElement(el) ? el.hasAttribute(attr) : null;
	}; // Return the Bounding Client Rect of an element
	// Returns `null` if not an element

	/* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */

	var getBCR = function getBCR(el) {
	  return isElement(el) ? el.getBoundingClientRect() : null;
	}; // Get computed style object for an element

	/* istanbul ignore next: getComputedStyle() doesn't work in JSDOM */

	var getCS = function getCS(el) {
	  return hasWindowSupport && isElement(el) ? w$1.getComputedStyle(el) : {};
	}; // Returns a `Selection` object representing the range of text selected
	// Returns `null` if no window support is given

	/* istanbul ignore next: getSelection() doesn't work in JSDOM */

	var getSel = function getSel() {
	  return hasWindowSupport && w$1.getSelection ? w$1.getSelection() : null;
	}; // Return an element's offset with respect to document element
	// https://j11y.io/jquery/#v=git&fn=jQuery.fn.offset

	var offset = function offset(el)
	/* istanbul ignore next: getBoundingClientRect(), getClientRects() doesn't work in JSDOM */
	{
	  var _offset = {
	    top: 0,
	    left: 0
	  };

	  if (!isElement(el) || el.getClientRects().length === 0) {
	    return _offset;
	  }

	  var bcr = getBCR(el);

	  if (bcr) {
	    var win = el.ownerDocument.defaultView;
	    _offset.top = bcr.top + win.pageYOffset;
	    _offset.left = bcr.left + win.pageXOffset;
	  }

	  return _offset;
	}; // Return an element's offset with respect to to it's offsetParent
	// https://j11y.io/jquery/#v=git&fn=jQuery.fn.position

	var position = function position(el)
	/* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */
	{
	  var _offset = {
	    top: 0,
	    left: 0
	  };

	  if (!isElement(el)) {
	    return _offset;
	  }

	  var parentOffset = {
	    top: 0,
	    left: 0
	  };
	  var elStyles = getCS(el);

	  if (elStyles.position === 'fixed') {
	    _offset = getBCR(el) || _offset;
	  } else {
	    _offset = offset(el);
	    var doc = el.ownerDocument;
	    var offsetParent = el.offsetParent || doc.documentElement;

	    while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && getCS(offsetParent).position === 'static') {
	      offsetParent = offsetParent.parentNode;
	    }

	    if (offsetParent && offsetParent !== el && offsetParent.nodeType === Node.ELEMENT_NODE) {
	      parentOffset = offset(offsetParent);
	      var offsetParentStyles = getCS(offsetParent);
	      parentOffset.top += parseFloat(offsetParentStyles.borderTopWidth);
	      parentOffset.left += parseFloat(offsetParentStyles.borderLeftWidth);
	    }
	  }

	  return {
	    top: _offset.top - parentOffset.top - parseFloat(elStyles.marginTop),
	    left: _offset.left - parentOffset.left - parseFloat(elStyles.marginLeft)
	  };
	};

	var e=function(){return (e=Object.assign||function(e){for(var t,r=1,s=arguments.length;r<s;r++){ for(var a in t=arguments[r]){ Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]); } }return e}).apply(this,arguments)},t={kebab:/-(\w)/g,styleProp:/:(.*)/,styleList:/;(?![^(]*\))/g};function r(e,t){return t?t.toUpperCase():""}function s(e){for(var s,a={},c=0,o=e.split(t.styleList);c<o.length;c++){var n=o[c].split(t.styleProp),i=n[0],l=n[1];(i=i.trim())&&("string"==typeof l&&(l=l.trim()),a[(s=i,s.replace(t.kebab,r))]=l);}return a}function a(){
	var arguments$1 = arguments;
	for(var t,r,a={},c=arguments.length;c--;){ for(var o=0,n=Object.keys(arguments[c]);o<n.length;o++){ switch(t=n[o]){case"class":case"style":case"directives":if(Array.isArray(a[t])||(a[t]=[]),"style"===t){var i=void 0;i=Array.isArray(arguments$1[c].style)?arguments$1[c].style:[arguments$1[c].style];for(var l=0;l<i.length;l++){var y=i[l];"string"==typeof y&&(i[l]=s(y));}arguments$1[c].style=i;}a[t]=a[t].concat(arguments$1[c][t]);break;case"staticClass":if(!arguments$1[c][t]){ break; }void 0===a[t]&&(a[t]=""),a[t]&&(a[t]+=" "),a[t]+=arguments$1[c][t].trim();break;case"on":case"nativeOn":a[t]||(a[t]={});for(var p=0,f=Object.keys(arguments[c][t]||{});p<f.length;p++){ r=f[p],a[t][r]?a[t][r]=[].concat(a[t][r],arguments$1[c][t][r]):a[t][r]=arguments$1[c][t][r]; }break;case"attrs":case"props":case"domProps":case"scopedSlots":case"staticStyle":case"hook":case"transition":a[t]||(a[t]={}),a[t]=e({},arguments$1[c][t],a[t]);break;case"slot":case"key":case"ref":case"tag":case"show":case"keepAlive":default:a[t]||(a[t]=arguments$1[c][t]);} } }return a}

	function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$3(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$3(source, true).forEach(function (key) { _defineProperty$3(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NO_FADE_PROPS = {
	  name: '',
	  enterClass: '',
	  enterActiveClass: '',
	  enterToClass: 'show',
	  leaveClass: 'show',
	  leaveActiveClass: '',
	  leaveToClass: ''
	};

	var FADE_PROPS = _objectSpread$3({}, NO_FADE_PROPS, {
	  enterActiveClass: 'fade',
	  leaveActiveClass: 'fade'
	});

	var BVTransition =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BVTransition',
	  functional: true,
	  props: {
	    noFade: {
	      // Only applicable to the built in transition
	      // Has no effect if `trans-props` provided
	      type: Boolean,
	      default: false
	    },
	    appear: {
	      // Has no effect if `trans-props` provided
	      type: Boolean,
	      default: false
	    },
	    mode: {
	      // Can be overridden by user supplied trans-props
	      type: String // default: undefined

	    },
	    // For user supplied transitions (if needed)
	    transProps: {
	      type: Object,
	      default: null
	    }
	  },
	  render: function render(h, _ref) {
	    var children = _ref.children,
	        data = _ref.data,
	        listeners = _ref.listeners,
	        props = _ref.props;
	    var transProps = props.transProps;

	    if (!isPlainObject(transProps)) {
	      transProps = props.noFade ? NO_FADE_PROPS : FADE_PROPS;

	      if (props.appear) {
	        // Default the appear classes to equal the enter classes
	        transProps = _objectSpread$3({}, transProps, {
	          appear: true,
	          appearClass: transProps.enterClass,
	          appearActiveClass: transProps.enterActiveClass,
	          appearToClass: transProps.enterToClass
	        });
	      }
	    }

	    transProps = _objectSpread$3({
	      mode: props.mode
	    }, transProps, {
	      // We always need `css` true
	      css: true
	    });
	    return h('transition', // Any transition event listeners will get merged here
	    a(data, {
	      props: transProps
	    }), children);
	  }
	});

	// In functional components, `slots` is a function so it must be called
	// first before passing to the below methods. `scopedSlots` is always an
	// object and may be undefined (for Vue < 2.6.x)

	/**
	 * Returns true if either scoped or unscoped named slot exists
	 *
	 * @param {String, Array} name or name[]
	 * @param {Object} scopedSlots
	 * @param {Object} slots
	 * @returns {Array|undefined} VNodes
	 */

	var hasNormalizedSlot = function hasNormalizedSlot(names) {
	  var $scopedSlots = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var $slots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  // Ensure names is an array
	  names = concat(names).filter(Boolean); // Returns true if the either a $scopedSlot or $slot exists with the specified name

	  return names.some(function (name) {
	    return $scopedSlots[name] || $slots[name];
	  });
	};
	/**
	 * Returns VNodes for named slot either scoped or unscoped
	 *
	 * @param {String, Array} name or name[]
	 * @param {String} scope
	 * @param {Object} scopedSlots
	 * @param {Object} slots
	 * @returns {Array|undefined} VNodes
	 */


	var normalizeSlot = function normalizeSlot(names) {
	  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var $scopedSlots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var $slots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	  // Ensure names is an array
	  names = concat(names).filter(Boolean);
	  var slot;

	  for (var i = 0; i < names.length && !slot; i++) {
	    var name = names[i];
	    slot = $scopedSlots[name] || $slots[name];
	  } // Note: in Vue 2.6.x, all named slots are also scoped slots


	  return isFunction(slot) ? slot(scope) : slot;
	}; // Named exports

	var normalizeSlotMixin = {
	  methods: {
	    hasNormalizedSlot: function hasNormalizedSlot$1(names) {
	      // Returns true if the either a $scopedSlot or $slot exists with the specified name
	      // `names` can be a string name or an array of names
	      return hasNormalizedSlot(names, this.$scopedSlots, this.$slots);
	    },
	    normalizeSlot: function normalizeSlot$1(names) {
	      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      // Returns an array of rendered VNodes if slot found.
	      // Returns undefined if not found.
	      // `names` can be a string name or an array of names
	      var vNodes = normalizeSlot(names, scope, this.$scopedSlots, this.$slots);

	      return vNodes ? concat(vNodes) : vNodes;
	    }
	  }
	};

	function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$2 = 'BButtonClose';
	var props = {
	  disabled: {
	    type: Boolean,
	    default: false
	  },
	  ariaLabel: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$2, 'ariaLabel');
	    }
	  },
	  textVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$2, 'textVariant');
	    }
	  }
	}; // @vue/component

	var BButtonClose =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$2,
	  functional: true,
	  props: props,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        listeners = _ref.listeners,
	        slots = _ref.slots,
	        scopedSlots = _ref.scopedSlots;
	    var $slots = slots();
	    var $scopedSlots = scopedSlots || {};
	    var componentData = {
	      staticClass: 'close',
	      class: _defineProperty$4({}, "text-".concat(props.textVariant), props.textVariant),
	      attrs: {
	        type: 'button',
	        disabled: props.disabled,
	        'aria-label': props.ariaLabel ? String(props.ariaLabel) : null
	      },
	      on: {
	        click: function click(evt) {
	          // Ensure click on button HTML content is also disabled

	          /* istanbul ignore if: bug in JSDOM still emits click on inner element */
	          if (props.disabled && isEvent(evt)) {
	            evt.stopPropagation();
	            evt.preventDefault();
	          }
	        }
	      }
	    }; // Careful not to override the default slot with innerHTML

	    if (!hasNormalizedSlot('default', $scopedSlots, $slots)) {
	      componentData.domProps = {
	        innerHTML: '&times;'
	      };
	    }

	    return h('button', a(data, componentData), normalizeSlot('default', {}, $scopedSlots, $slots));
	  }
	});

	function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$3 = 'BAlert'; // Convert `show` value to a number

	var parseCountDown = function parseCountDown(show) {
	  if (show === '' || isBoolean(show)) {
	    return 0;
	  }

	  show = parseInt(show, 10);
	  return show > 0 ? show : 0;
	}; // Convert `show` value to a boolean


	var parseShow = function parseShow(show) {
	  if (show === '' || show === true) {
	    return true;
	  }

	  if (parseInt(show, 10) < 1) {
	    // Boolean will always return false for the above comparison
	    return false;
	  }

	  return Boolean(show);
	}; // Is a value number like (i.e. a number or a number as string)


	var isNumericLike = function isNumericLike(value) {
	  return !isNaN(parseInt(value, 10));
	}; // @vue/component


	var BAlert =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$3,
	  mixins: [normalizeSlotMixin],
	  model: {
	    prop: 'show',
	    event: 'input'
	  },
	  props: {
	    variant: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$3, 'variant');
	      }
	    },
	    dismissible: {
	      type: Boolean,
	      default: false
	    },
	    dismissLabel: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$3, 'dismissLabel');
	      }
	    },
	    show: {
	      type: [Boolean, Number, String],
	      default: false
	    },
	    fade: {
	      type: Boolean,
	      default: false
	    }
	  },
	  data: function data() {
	    return {
	      countDownTimerId: null,
	      countDown: 0,
	      // If initially shown, we need to set these for SSR
	      localShow: parseShow(this.show)
	    };
	  },
	  watch: {
	    show: function show(newVal) {
	      this.countDown = parseCountDown(newVal);
	      this.localShow = parseShow(newVal);
	    },
	    countDown: function countDown(newVal) {
	      var _this = this;

	      this.clearTimer();

	      if (isNumericLike(this.show)) {
	        // Ignore if this.show transitions to a boolean value.
	        this.$emit('dismiss-count-down', newVal);

	        if (this.show !== newVal) {
	          // Update the v-model if needed
	          this.$emit('input', newVal);
	        }

	        if (newVal > 0) {
	          this.localShow = true;
	          this.countDownTimerId = setTimeout(function () {
	            _this.countDown--;
	          }, 1000);
	        } else {
	          // Slightly delay the hide to allow any UI updates
	          this.$nextTick(function () {
	            requestAF(function () {
	              _this.localShow = false;
	            });
	          });
	        }
	      }
	    },
	    localShow: function localShow(newVal) {
	      if (!newVal && (this.dismissible || isNumericLike(this.show))) {
	        // Only emit dismissed events for dismissible or auto dismissing alerts
	        this.$emit('dismissed');
	      }

	      if (!isNumericLike(this.show) && this.show !== newVal) {
	        // Only emit booleans if we weren't passed a number via `this.show`
	        this.$emit('input', newVal);
	      }
	    }
	  },
	  created: function created() {
	    this.countDown = parseCountDown(this.show);
	    this.localShow = parseShow(this.show);
	  },
	  mounted: function mounted() {
	    this.countDown = parseCountDown(this.show);
	    this.localShow = parseShow(this.show);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.clearTimer();
	  },
	  methods: {
	    dismiss: function dismiss() {
	      this.clearTimer();
	      this.countDown = 0;
	      this.localShow = false;
	    },
	    clearTimer: function clearTimer() {
	      if (this.countDownTimerId) {
	        clearInterval(this.countDownTimerId);
	        this.countDownTimerId = null;
	      }
	    }
	  },
	  render: function render(h) {
	    var $alert; // undefined

	    if (this.localShow) {
	      var $dismissBtn = h();

	      if (this.dismissible) {
	        // Add dismiss button
	        $dismissBtn = h(BButtonClose, {
	          attrs: {
	            'aria-label': this.dismissLabel
	          },
	          on: {
	            click: this.dismiss
	          }
	        }, [this.normalizeSlot('dismiss')]);
	      }

	      $alert = h('div', {
	        key: this._uid,
	        staticClass: 'alert',
	        class: _defineProperty$5({
	          'alert-dismissible': this.dismissible
	        }, "alert-".concat(this.variant), this.variant),
	        attrs: {
	          role: 'alert',
	          'aria-live': 'polite',
	          'aria-atomic': true
	        }
	      }, [$dismissBtn, this.normalizeSlot('default')]);
	      $alert = [$alert];
	    }

	    return h(BVTransition, {
	      props: {
	        noFade: !this.fade
	      }
	    }, $alert);
	  }
	});

	var AlertPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BAlert: BAlert
	  }
	});

	var identity = function identity(x) {
	  return x;
	};

	/**
	 * Given an array of properties or an object of property keys,
	 * plucks all the values off the target object, returning a new object
	 * that has props that reference the original prop values
	 *
	 * @param {{}|string[]} keysToPluck
	 * @param {{}} objToPluck
	 * @param {Function} transformFn
	 * @return {{}}
	 */

	var pluckProps = function pluckProps(keysToPluck, objToPluck) {
	  var transformFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;
	  return (isArray(keysToPluck) ? keysToPluck.slice() : keys$2(keysToPluck)).reduce(function (memo, prop) {
	    memo[transformFn(prop)] = objToPluck[prop];
	    return memo;
	  }, {});
	};

	/**
	 * Convert a value to a string that can be rendered.
	 */

	var toString$3 = function toString(val) {
	  var spaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
	  return isUndefinedOrNull(val) ? '' : isArray(val) || isPlainObject(val) && val.toString === Object.prototype.toString ? JSON.stringify(val, null, spaces) : String(val);
	};

	var ANCHOR_TAG = 'a'; // Precompile RegExp

	var commaRE = /%2C/g;
	var encodeReserveRE = /[!'()*]/g; // Method to replace reserved chars

	var encodeReserveReplacer = function encodeReserveReplacer(c) {
	  return '%' + c.charCodeAt(0).toString(16);
	}; // Fixed encodeURIComponent which is more conformant to RFC3986:
	// - escapes [!'()*]
	// - preserve commas


	var encode = function encode(str) {
	  return encodeURIComponent(toString$3(str)).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
	};

	var decode = decodeURIComponent; // Stringifies an object of query parameters
	// See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js

	var stringifyQueryObj = function stringifyQueryObj(obj) {
	  if (!isPlainObject(obj)) {
	    return '';
	  }

	  var query = keys$2(obj).map(function (key) {
	    var val = obj[key];

	    if (isUndefined(val)) {
	      return '';
	    } else if (isNull(val)) {
	      return encode(key);
	    } else if (isArray(val)) {
	      return val.reduce(function (results, val2) {
	        if (isNull(val2)) {
	          results.push(encode(key));
	        } else if (!isUndefined(val2)) {
	          // Faster than string interpolation
	          results.push(encode(key) + '=' + encode(val2));
	        }

	        return results;
	      }, []).join('&');
	    } // Faster than string interpolation


	    return encode(key) + '=' + encode(val);
	  })
	  /* must check for length, as we only want to filter empty strings, not things that look falsey! */
	  .filter(function (x) {
	    return x.length > 0;
	  }).join('&');
	  return query ? "?".concat(query) : '';
	};
	var parseQuery = function parseQuery(query) {
	  var parsed = {};
	  query = toString$3(query).trim().replace(/^(\?|#|&)/, '');

	  if (!query) {
	    return parsed;
	  }

	  query.split('&').forEach(function (param) {
	    var parts = param.replace(/\+/g, ' ').split('=');
	    var key = decode(parts.shift());
	    var val = parts.length > 0 ? decode(parts.join('=')) : null;

	    if (isUndefined(parsed[key])) {
	      parsed[key] = val;
	    } else if (isArray(parsed[key])) {
	      parsed[key].push(val);
	    } else {
	      parsed[key] = [parsed[key], val];
	    }
	  });
	  return parsed;
	};
	var isRouterLink = function isRouterLink(tag) {
	  return toString$3(tag).toLowerCase() !== ANCHOR_TAG;
	};
	var computeTag = function computeTag() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      to = _ref.to,
	      disabled = _ref.disabled;

	  var thisOrParent = arguments.length > 1 ? arguments[1] : undefined;
	  return thisOrParent.$router && to && !disabled ? thisOrParent.$nuxt ? 'nuxt-link' : 'router-link' : ANCHOR_TAG;
	};
	var computeRel = function computeRel() {
	  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      target = _ref2.target,
	      rel = _ref2.rel;

	  if (target === '_blank' && isNull(rel)) {
	    return 'noopener';
	  }

	  return rel || null;
	};
	var computeHref = function computeHref() {
	  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      href = _ref3.href,
	      to = _ref3.to;

	  var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ANCHOR_TAG;
	  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#';
	  var toFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';

	  // We've already checked the $router in computeTag(), so isRouterLink() indicates a live router.
	  // When deferring to Vue Router's router-link, don't use the href attribute at all.
	  // We return null, and then remove href from the attributes passed to router-link
	  if (isRouterLink(tag)) {
	    return null;
	  } // Return `href` when explicitly provided


	  if (href) {
	    return href;
	  } // Reconstruct `href` when `to` used, but no router


	  if (to) {
	    // Fallback to `to` prop (if `to` is a string)
	    if (isString(to)) {
	      return to || toFallback;
	    } // Fallback to `to.path + to.query + to.hash` prop (if `to` is an object)


	    if (isPlainObject(to) && (to.path || to.query || to.hash)) {
	      var path = toString$3(to.path);
	      var query = stringifyQueryObj(to.query);
	      var hash = toString$3(to.hash);
	      hash = !hash || hash.charAt(0) === '#' ? hash : "#".concat(hash);
	      return "".concat(path).concat(query).concat(hash) || toFallback;
	    }
	  } // If nothing is provided return the fallback


	  return fallback;
	};

	function _toConsumableArray$1(arr) { return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1(); }

	function _nonIterableSpread$1() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray$1(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") { return Array.from(iter); } }

	function _arrayWithoutHoles$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$4(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$4(source, true).forEach(function (key) { _defineProperty$6(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$6(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	/**
	 * The Link component is used in many other BV components.
	 * As such, sharing its props makes supporting all its features easier.
	 * However, some components need to modify the defaults for their own purpose.
	 * Prefer sharing a fresh copy of the props to ensure mutations
	 * do not affect other component references to the props.
	 *
	 * https://github.com/vuejs/vue-router/blob/dev/src/components/link.js
	 * @return {{}}
	 */

	var propsFactory = function propsFactory() {
	  return {
	    href: {
	      type: String,
	      default: null
	    },
	    rel: {
	      type: String,
	      default: null
	    },
	    target: {
	      type: String,
	      default: '_self'
	    },
	    active: {
	      type: Boolean,
	      default: false
	    },
	    disabled: {
	      type: Boolean,
	      default: false
	    },
	    // router-link specific props
	    to: {
	      type: [String, Object],
	      default: null
	    },
	    append: {
	      type: Boolean,
	      default: false
	    },
	    replace: {
	      type: Boolean,
	      default: false
	    },
	    event: {
	      type: [String, Array],
	      default: 'click'
	    },
	    activeClass: {
	      type: String // default: undefined

	    },
	    exact: {
	      type: Boolean,
	      default: false
	    },
	    exactActiveClass: {
	      type: String // default: undefined

	    },
	    routerTag: {
	      type: String,
	      default: 'a'
	    },
	    // nuxt-link specific prop(s)
	    noPrefetch: {
	      type: Boolean,
	      default: false
	    }
	  };
	};

	var BLink =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BLink',
	  mixins: [normalizeSlotMixin],
	  inheritAttrs: false,
	  props: propsFactory(),
	  computed: {
	    computedTag: function computedTag() {
	      // We don't pass `this` as the first arg as we need reactivity of the props
	      return computeTag({
	        to: this.to,
	        disabled: this.disabled
	      }, this);
	    },
	    isRouterLink: function isRouterLink$1() {
	      return isRouterLink(this.computedTag);
	    },
	    computedRel: function computedRel() {
	      // We don't pass `this` as the first arg as we need reactivity of the props
	      return computeRel({
	        target: this.target,
	        rel: this.rel
	      });
	    },
	    computedHref: function computedHref() {
	      // We don't pass `this` as the first arg as we need reactivity of the props
	      return computeHref({
	        to: this.to,
	        href: this.href
	      }, this.computedTag);
	    },
	    computedProps: function computedProps() {
	      return this.isRouterLink ? _objectSpread$4({}, this.$props, {
	        tag: this.routerTag
	      }) : {};
	    }
	  },
	  methods: {
	    onClick: function onClick(evt) {
	      var _arguments = arguments;
	      var evtIsEvent = isEvent(evt);
	      var isRouterLink = this.isRouterLink;
	      var suppliedHandler = this.$listeners.click;

	      if (evtIsEvent && this.disabled) {
	        // Stop event from bubbling up
	        evt.stopPropagation(); // Kill the event loop attached to this specific `EventTarget`
	        // Needed to prevent `vue-router` for doing it's thing

	        evt.stopImmediatePropagation();
	      } else {
	        /* istanbul ignore next: difficult to test, but we know it works */
	        if (isRouterLink && evt.currentTarget.__vue__) {
	          // Router links do not emit instance `click` events, so we
	          // add in an $emit('click', evt) on it's vue instance
	          evt.currentTarget.__vue__.$emit('click', evt);
	        } // Call the suppliedHandler(s), if any provided


	        concat(suppliedHandler).filter(function (h) {
	          return isFunction(h);
	        }).forEach(function (handler) {
	          handler.apply(void 0, _toConsumableArray$1(_arguments));
	        }); // Emit the global $root click event

	        this.$root.$emit('clicked::link', evt);
	      } // Stop scroll-to-top behavior or navigation on
	      // regular links when href is just '#'


	      if (evtIsEvent && (this.disabled || !isRouterLink && this.computedHref === '#')) {
	        evt.preventDefault();
	      }
	    },
	    focus: function focus() {
	      if (this.$el && this.$el.focus) {
	        this.$el.focus();
	      }
	    },
	    blur: function blur() {
	      if (this.$el && this.$el.blur) {
	        this.$el.blur();
	      }
	    }
	  },
	  render: function render(h) {
	    var tag = this.computedTag;
	    var rel = this.computedRel;
	    var href = this.computedHref;
	    var isRouterLink = this.isRouterLink;
	    var componentData = {
	      class: {
	        active: this.active,
	        disabled: this.disabled
	      },
	      attrs: _objectSpread$4({}, this.$attrs, {
	        rel: rel,
	        target: this.target,
	        tabindex: this.disabled ? '-1' : isUndefined(this.$attrs.tabindex) ? null : this.$attrs.tabindex,
	        'aria-disabled': this.disabled ? 'true' : null
	      }),
	      props: this.computedProps
	    }; // Add the event handlers. We must use `navtiveOn` for
	    // `<router-link>`/`<nuxt-link>` instead of `on`

	    componentData[isRouterLink ? 'nativeOn' : 'on'] = _objectSpread$4({}, this.$listeners, {
	      // We want to overwrite any click handler since our callback
	      // will invoke the user supplied handler(s) if `!this.disabled`
	      click: this.onClick
	    }); // If href attribute exists on <router-link> (even undefined or null) it fails working on
	    // SSR, so we explicitly add it here if needed (i.e. if computedHref() is truthy)

	    if (href) {
	      componentData.attrs.href = href;
	    } else {
	      // Ensure the prop HREF does not exist for router links
	      delete componentData.props.href;
	    }

	    return h(tag, componentData, this.normalizeSlot('default'));
	  }
	});

	function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$5(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$5(source, true).forEach(function (key) { _defineProperty$7(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$7(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$4 = 'BBadge';
	var linkProps = propsFactory();
	delete linkProps.href.default;
	delete linkProps.to.default;
	var props$1 = _objectSpread$5({}, linkProps, {
	  tag: {
	    type: String,
	    default: 'span'
	  },
	  variant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$4, 'variant');
	    }
	  },
	  pill: {
	    type: Boolean,
	    default: false
	  }
	}); // @vue/component

	var BBadge =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$4,
	  functional: true,
	  props: props$1,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var tag = !props.href && !props.to ? props.tag : BLink;
	    var componentData = {
	      staticClass: 'badge',
	      class: [props.variant ? "badge-".concat(props.variant) : 'badge-secondary', {
	        'badge-pill': Boolean(props.pill),
	        active: props.active,
	        disabled: props.disabled
	      }],
	      props: pluckProps(linkProps, props)
	    };
	    return h(tag, a(data, componentData), children);
	  }
	});

	var BadgePlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BBadge: BBadge
	  }
	});

	var stripTagsRegex = /(<([^>]+)>)/gi; // Removes any thing that looks like an HTML tag from the supplied string

	var stripTags = function stripTags() {
	  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	  return String(text).replace(stripTagsRegex, '');
	}; // Generate a domProps object for either innerHTML, textContent or nothing

	var htmlOrText = function htmlOrText(innerHTML, textContent) {
	  return innerHTML ? {
	    innerHTML: innerHTML
	  } : textContent ? {
	    textContent: textContent
	  } : {};
	};

	function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$6(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$6(source, true).forEach(function (key) { _defineProperty$8(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$8(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$2 = _objectSpread$6({}, propsFactory(), {
	  text: {
	    type: String,
	    default: null
	  },
	  html: {
	    type: String,
	    default: null
	  },
	  ariaCurrent: {
	    type: String,
	    default: 'location'
	  }
	}); // @vue/component

	var BBreadcrumbLink =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BBreadcrumbLink',
	  functional: true,
	  props: props$2,
	  render: function render(h, _ref) {
	    var suppliedProps = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var tag = suppliedProps.active ? 'span' : BLink;
	    var componentData = {
	      props: pluckProps(props$2, suppliedProps)
	    };

	    if (suppliedProps.active) {
	      componentData.attrs = {
	        'aria-current': suppliedProps.ariaCurrent
	      };
	    }

	    if (!children) {
	      componentData.domProps = htmlOrText(suppliedProps.html, suppliedProps.text);
	    }

	    return h(tag, a(data, componentData), children);
	  }
	});

	var BBreadcrumbItem =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BBreadcrumbItem',
	  functional: true,
	  props: props$2,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h('li', a(data, {
	      staticClass: 'breadcrumb-item',
	      class: {
	        active: props.active
	      }
	    }), [h(BBreadcrumbLink, {
	      props: props
	    }, children)]);
	  }
	});

	function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$7(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$7(source, true).forEach(function (key) { _defineProperty$9(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$9(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$3 = {
	  items: {
	    type: Array,
	    default: null
	  }
	}; // @vue/component

	var BBreadcrumb =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BBreadcrumb',
	  functional: true,
	  props: props$3,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var childNodes = children; // Build child nodes from items if given.

	    if (isArray(props.items)) {
	      var activeDefined = false;
	      childNodes = props.items.map(function (item, idx) {
	        if (!isObject(item)) {
	          item = {
	            text: toString$3(item)
	          };
	        } // Copy the value here so we can normalize it.


	        var active = item.active;

	        if (active) {
	          activeDefined = true;
	        }

	        if (!active && !activeDefined) {
	          // Auto-detect active by position in list.
	          active = idx + 1 === props.items.length;
	        }

	        return h(BBreadcrumbItem, {
	          props: _objectSpread$7({}, item, {
	            active: active
	          })
	        });
	      });
	    }

	    return h('ol', a(data, {
	      staticClass: 'breadcrumb'
	    }), childNodes);
	  }
	});

	var BreadcrumbPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BBreadcrumb: BBreadcrumb,
	    BBreadcrumbItem: BBreadcrumbItem,
	    BBreadcrumbLink: BBreadcrumbLink
	  }
	});

	function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$8(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$8(source, true).forEach(function (key) { _defineProperty$a(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$a(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var NAME$5 = 'BButton';
	var btnProps = {
	  block: {
	    type: Boolean,
	    default: false
	  },
	  disabled: {
	    type: Boolean,
	    default: false
	  },
	  size: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$5, 'size');
	    }
	  },
	  variant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$5, 'variant');
	    }
	  },
	  type: {
	    type: String,
	    default: 'button'
	  },
	  tag: {
	    type: String,
	    default: 'button'
	  },
	  pill: {
	    type: Boolean,
	    default: false
	  },
	  squared: {
	    type: Boolean,
	    default: false
	  },
	  pressed: {
	    // tri-state prop: true, false or null
	    // => on, off, not a toggle
	    type: Boolean,
	    default: null
	  }
	};
	var linkProps$1 = propsFactory();
	delete linkProps$1.href.default;
	delete linkProps$1.to.default;
	var linkPropKeys = keys$2(linkProps$1);
	var props$4 = _objectSpread$8({}, linkProps$1, {}, btnProps); // --- Helper methods ---
	// Focus handler for toggle buttons.  Needs class of 'focus' when focused.

	var handleFocus = function handleFocus(evt) {
	  if (evt.type === 'focusin') {
	    addClass(evt.target, 'focus');
	  } else if (evt.type === 'focusout') {
	    removeClass(evt.target, 'focus');
	  }
	}; // Is the requested button a link?


	var isLink = function isLink(props) {
	  // If tag prop is set to `a`, we use a b-link to get proper disabled handling
	  return Boolean(props.href || props.to || props.tag && String(props.tag).toLowerCase() === 'a');
	}; // Is the button to be a toggle button?


	var isToggle = function isToggle(props) {
	  return isBoolean(props.pressed);
	}; // Is the button "really" a button?


	var isButton = function isButton(props) {
	  if (isLink(props)) {
	    return false;
	  } else if (props.tag && String(props.tag).toLowerCase() !== 'button') {
	    return false;
	  }

	  return true;
	}; // Is the requested tag not a button or link?


	var isNonStandardTag = function isNonStandardTag(props) {
	  return !isLink(props) && !isButton(props);
	}; // Compute required classes (non static classes)


	var computeClass = function computeClass(props) {
	  var _ref;

	  return ["btn-".concat(props.variant || getComponentConfig(NAME$5, 'variant')), (_ref = {}, _defineProperty$a(_ref, "btn-".concat(props.size), Boolean(props.size)), _defineProperty$a(_ref, 'btn-block', props.block), _defineProperty$a(_ref, 'rounded-pill', props.pill), _defineProperty$a(_ref, 'rounded-0', props.squared && !props.pill), _defineProperty$a(_ref, "disabled", props.disabled), _defineProperty$a(_ref, "active", props.pressed), _ref)];
	}; // Compute the link props to pass to b-link (if required)


	var computeLinkProps = function computeLinkProps(props) {
	  return isLink(props) ? pluckProps(linkPropKeys, props) : null;
	}; // Compute the attributes for a button


	var computeAttrs = function computeAttrs(props, data) {
	  var button = isButton(props);
	  var link = isLink(props);
	  var toggle = isToggle(props);
	  var nonStdTag = isNonStandardTag(props);
	  var role = data.attrs && data.attrs.role ? data.attrs.role : null;
	  var tabindex = data.attrs ? data.attrs.tabindex : null;

	  if (nonStdTag) {
	    tabindex = '0';
	  }

	  return {
	    // Type only used for "real" buttons
	    type: button && !link ? props.type : null,
	    // Disabled only set on "real" buttons
	    disabled: button ? props.disabled : null,
	    // We add a role of button when the tag is not a link or button for ARIA.
	    // Don't bork any role provided in data.attrs when isLink or isButton
	    role: nonStdTag ? 'button' : role,
	    // We set the aria-disabled state for non-standard tags
	    'aria-disabled': nonStdTag ? String(props.disabled) : null,
	    // For toggles, we need to set the pressed state for ARIA
	    'aria-pressed': toggle ? String(props.pressed) : null,
	    // autocomplete off is needed in toggle mode to prevent some browsers from
	    // remembering the previous setting when using the back button.
	    autocomplete: toggle ? 'off' : null,
	    // Tab index is used when the component is not a button.
	    // Links are tabbable, but don't allow disabled, while non buttons or links
	    // are not tabbable, so we mimic that functionality by disabling tabbing
	    // when disabled, and adding a tabindex of '0' to non buttons or non links.
	    tabindex: props.disabled && !button ? '-1' : tabindex
	  };
	}; // @vue/component


	var BButton =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$5,
	  functional: true,
	  props: props$4,
	  render: function render(h, _ref2) {
	    var props = _ref2.props,
	        data = _ref2.data,
	        listeners = _ref2.listeners,
	        children = _ref2.children;
	    var toggle = isToggle(props);
	    var link = isLink(props);
	    var on = {
	      click: function click(evt) {
	        /* istanbul ignore if: blink/button disabled should handle this */
	        if (props.disabled && isEvent(evt)) {
	          evt.stopPropagation();
	          evt.preventDefault();
	        } else if (toggle && listeners && listeners['update:pressed']) {
	          // Send .sync updates to any "pressed" prop (if .sync listeners)
	          // Concat will normalize the value to an array
	          // without double wrapping an array value in an array.
	          concat(listeners['update:pressed']).forEach(function (fn) {
	            if (isFunction(fn)) {
	              fn(!props.pressed);
	            }
	          });
	        }
	      }
	    };

	    if (toggle) {
	      on.focusin = handleFocus;
	      on.focusout = handleFocus;
	    }

	    var componentData = {
	      staticClass: 'btn',
	      class: computeClass(props),
	      props: computeLinkProps(props),
	      attrs: computeAttrs(props, data),
	      on: on
	    };
	    return h(link ? BLink : props.tag, a(data, componentData), children);
	  }
	});

	var ButtonPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BButton: BButton,
	    BBtn: BButton,
	    BButtonClose: BButtonClose,
	    BBtnClose: BButtonClose
	  }
	});

	function _defineProperty$b(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$6 = 'BButtonGroup';
	var props$5 = {
	  vertical: {
	    type: Boolean,
	    default: false
	  },
	  size: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig('BButton', 'size');
	    }
	  },
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  ariaRole: {
	    type: String,
	    default: 'group'
	  }
	}; // @vue/component

	var BButtonGroup =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$6,
	  functional: true,
	  props: props$5,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.tag, a(data, {
	      class: _defineProperty$b({
	        'btn-group': !props.vertical,
	        'btn-group-vertical': props.vertical
	      }, "btn-group-".concat(props.size), Boolean(props.size)),
	      attrs: {
	        role: props.ariaRole
	      }
	    }), children);
	  }
	});

	var ButtonGroupPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BButtonGroup: BButtonGroup,
	    BBtnGroup: BButtonGroup
	  }
	});

	/*
	 * Key Codes (events)
	 */
	var KEY_CODES = {
	  SPACE: 32,
	  ENTER: 13,
	  ESC: 27,
	  LEFT: 37,
	  UP: 38,
	  RIGHT: 39,
	  DOWN: 40,
	  PAGEUP: 33,
	  PAGEDOWN: 34,
	  HOME: 36,
	  END: 35,
	  TAB: 9,
	  SHIFT: 16,
	  CTRL: 17,
	  BACKSPACE: 8,
	  ALT: 18,
	  PAUSE: 19,
	  BREAK: 19,
	  INSERT: 45,
	  INS: 45,
	  DELETE: 46
	};

	var ITEM_SELECTOR = ['.btn:not(.disabled):not([disabled]):not(.dropdown-item)', '.form-control:not(.disabled):not([disabled])', 'select:not(.disabled):not([disabled])', 'input[type="checkbox"]:not(.disabled)', 'input[type="radio"]:not(.disabled)'].join(','); // @vue/component

	var BButtonToolbar =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BButtonToolbar',
	  mixins: [normalizeSlotMixin],
	  props: {
	    justify: {
	      type: Boolean,
	      default: false
	    },
	    keyNav: {
	      type: Boolean,
	      default: false
	    }
	  },
	  mounted: function mounted() {
	    if (this.keyNav) {
	      // Pre-set the tabindexes if the markup does not include tabindex="-1" on the toolbar items
	      this.getItems();
	    }
	  },
	  methods: {
	    onFocusin: function onFocusin(evt) {
	      if (evt.target === this.$el) {
	        evt.preventDefault();
	        evt.stopPropagation();
	        this.focusFirst(evt);
	      }
	    },
	    stop: function stop(evt) {
	      evt.preventDefault();
	      evt.stopPropagation();
	    },
	    onKeydown: function onKeydown(evt) {
	      if (!this.keyNav) {
	        /* istanbul ignore next: should never happen */
	        return;
	      }

	      var key = evt.keyCode;
	      var shift = evt.shiftKey;

	      if (key === KEY_CODES.UP || key === KEY_CODES.LEFT) {
	        this.stop(evt);
	        shift ? this.focusFirst(evt) : this.focusPrev(evt);
	      } else if (key === KEY_CODES.DOWN || key === KEY_CODES.RIGHT) {
	        this.stop(evt);
	        shift ? this.focusLast(evt) : this.focusNext(evt);
	      }
	    },
	    setItemFocus: function setItemFocus(item) {
	      item && item.focus && item.focus();
	    },
	    focusFirst: function focusFirst(evt) {
	      var items = this.getItems();
	      this.setItemFocus(items[0]);
	    },
	    focusPrev: function focusPrev(evt) {
	      var items = this.getItems();
	      var index = items.indexOf(evt.target);

	      if (index > -1) {
	        items = items.slice(0, index).reverse();
	        this.setItemFocus(items[0]);
	      }
	    },
	    focusNext: function focusNext(evt) {
	      var items = this.getItems();
	      var index = items.indexOf(evt.target);

	      if (index > -1) {
	        items = items.slice(index + 1);
	        this.setItemFocus(items[0]);
	      }
	    },
	    focusLast: function focusLast(evt) {
	      var items = this.getItems().reverse();
	      this.setItemFocus(items[0]);
	    },
	    getItems: function getItems() {
	      var items = selectAll(ITEM_SELECTOR, this.$el);
	      items.forEach(function (item) {
	        // Ensure tabfocus is -1 on any new elements
	        item.tabIndex = -1;
	      });
	      return items.filter(function (el) {
	        return isVisible(el);
	      });
	    }
	  },
	  render: function render(h) {
	    return h('div', {
	      staticClass: 'btn-toolbar',
	      class: {
	        'justify-content-between': this.justify
	      },
	      attrs: {
	        role: 'toolbar',
	        tabindex: this.keyNav ? '0' : null
	      },
	      on: this.keyNav ? {
	        focusin: this.onFocusin,
	        keydown: this.onKeydown
	      } : {}
	    }, [this.normalizeSlot('default')]);
	  }
	});

	var ButtonToolbarPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BButtonToolbar: BButtonToolbar,
	    BBtnToolbar: BButtonToolbar
	  }
	});

	/**
	 * Transform the first character to uppercase
	 * @param {string} str
	 */

	var upperFirst = function upperFirst(str) {
	  if (!isString(str)) {
	    str = String(str);
	  }

	  str = str.trim();
	  return str.charAt(0).toUpperCase() + str.slice(1);
	};

	/**
	 * @param {string} prefix
	 * @param {string} value
	 */

	var prefixPropName = function prefixPropName(prefix, value) {
	  return prefix + upperFirst(value);
	};

	/**
	 * @param {string} str
	 */
	var lowerFirst = function lowerFirst(str) {
	  str = String(str);
	  return str.charAt(0).toLowerCase() + str.slice(1);
	};

	/**
	 * @param {string} prefix
	 * @param {string} value
	 */

	var unprefixPropName = function unprefixPropName(prefix, value) {
	  return lowerFirst(value.replace(prefix, ''));
	};

	/**
	 * Copies props from one array/object to a new array/object. Prop values
	 * are also cloned as new references to prevent possible mutation of original
	 * prop object values. Optionally accepts a function to transform the prop name.
	 *
	 * @param {[]|{}} props
	 * @param {Function} transformFn
	 */

	var copyProps = function copyProps(props) {
	  var transformFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;

	  if (isArray(props)) {
	    return props.map(transformFn);
	  } // Props as an object.


	  var copied = {};

	  for (var prop in props) {
	    /* istanbul ignore else */
	    // eslint-disable-next-line no-prototype-builtins
	    if (props.hasOwnProperty(prop)) {
	      // If the prop value is an object, do a shallow clone to prevent
	      // potential mutations to the original object.
	      copied[transformFn(prop)] = isObject(props[prop]) ? clone(props[prop]) : props[prop];
	    }
	  }

	  return copied;
	};

	// @vue/component
	var cardMixin = {
	  props: {
	    tag: {
	      type: String,
	      default: 'div'
	    },
	    bgVariant: {
	      type: String,
	      default: null
	    },
	    borderVariant: {
	      type: String,
	      default: null
	    },
	    textVariant: {
	      type: String,
	      default: null
	    }
	  }
	};

	var props$6 = {
	  title: {
	    type: String,
	    default: ''
	  },
	  titleTag: {
	    type: String,
	    default: 'h4'
	  }
	}; // @vue/component

	var BCardTitle =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BCardTitle',
	  functional: true,
	  props: props$6,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.titleTag, a(data, {
	      staticClass: 'card-title'
	    }), children || props.title);
	  }
	});

	var NAME$7 = 'BCardSubTitle';
	var props$7 = {
	  subTitle: {
	    type: String,
	    default: ''
	  },
	  subTitleTag: {
	    type: String,
	    default: 'h6'
	  },
	  subTitleTextVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$7, 'subTitleTextVariant');
	    }
	  }
	}; // @vue/component

	var BCardSubTitle =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$7,
	  functional: true,
	  props: props$7,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.subTitleTag, a(data, {
	      staticClass: 'card-subtitle',
	      class: [props.subTitleTextVariant ? "text-".concat(props.subTitleTextVariant) : null]
	    }), children || props.subTitle);
	  }
	});

	function _toConsumableArray$2(arr) { return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _nonIterableSpread$2(); }

	function _nonIterableSpread$2() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray$2(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") { return Array.from(iter); } }

	function _arrayWithoutHoles$2(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$9(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$9(source, true).forEach(function (key) { _defineProperty$c(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$c(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$8 = _objectSpread$9({}, copyProps(cardMixin.props, prefixPropName.bind(null, 'body')), {
	  bodyClass: {
	    type: [String, Object, Array],
	    default: null
	  }
	}, props$6, {}, props$7, {
	  overlay: {
	    type: Boolean,
	    default: false
	  }
	}); // @vue/component

	var BCardBody =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BCardBody',
	  functional: true,
	  props: props$8,
	  render: function render(h, _ref) {
	    var _ref2;

	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var cardTitle = h();
	    var cardSubTitle = h();
	    var cardContent = children || [h()];

	    if (props.title) {
	      cardTitle = h(BCardTitle, {
	        props: pluckProps(props$6, props)
	      });
	    }

	    if (props.subTitle) {
	      cardSubTitle = h(BCardSubTitle, {
	        props: pluckProps(props$7, props),
	        class: ['mb-2']
	      });
	    }

	    return h(props.bodyTag, a(data, {
	      staticClass: 'card-body',
	      class: [(_ref2 = {
	        'card-img-overlay': props.overlay
	      }, _defineProperty$c(_ref2, "bg-".concat(props.bodyBgVariant), Boolean(props.bodyBgVariant)), _defineProperty$c(_ref2, "border-".concat(props.bodyBorderVariant), Boolean(props.bodyBorderVariant)), _defineProperty$c(_ref2, "text-".concat(props.bodyTextVariant), Boolean(props.bodyTextVariant)), _ref2), props.bodyClass || {}]
	    }), [cardTitle, cardSubTitle].concat(_toConsumableArray$2(cardContent)));
	  }
	});

	function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$a(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$a(source, true).forEach(function (key) { _defineProperty$d(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$d(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$9 = _objectSpread$a({}, copyProps(cardMixin.props, prefixPropName.bind(null, 'header')), {
	  header: {
	    type: String,
	    default: null
	  },
	  headerHtml: {
	    type: String,
	    default: null
	  },
	  headerClass: {
	    type: [String, Object, Array],
	    default: null
	  }
	}); // @vue/component

	var BCardHeader =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BCardHeader',
	  functional: true,
	  props: props$9,
	  render: function render(h, _ref) {
	    var _ref2;

	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.headerTag, a(data, {
	      staticClass: 'card-header',
	      class: [props.headerClass, (_ref2 = {}, _defineProperty$d(_ref2, "bg-".concat(props.headerBgVariant), Boolean(props.headerBgVariant)), _defineProperty$d(_ref2, "border-".concat(props.headerBorderVariant), Boolean(props.headerBorderVariant)), _defineProperty$d(_ref2, "text-".concat(props.headerTextVariant), Boolean(props.headerTextVariant)), _ref2)]
	    }), children || [h('div', {
	      domProps: htmlOrText(props.headerHtml, props.header)
	    })]);
	  }
	});

	function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$b(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$b(source, true).forEach(function (key) { _defineProperty$e(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$e(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$a = _objectSpread$b({}, copyProps(cardMixin.props, prefixPropName.bind(null, 'footer')), {
	  footer: {
	    type: String,
	    default: null
	  },
	  footerHtml: {
	    type: String,
	    default: null
	  },
	  footerClass: {
	    type: [String, Object, Array],
	    default: null
	  }
	}); // @vue/component

	var BCardFooter =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BCardFooter',
	  functional: true,
	  props: props$a,
	  render: function render(h, _ref) {
	    var _ref2;

	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.footerTag, a(data, {
	      staticClass: 'card-footer',
	      class: [props.footerClass, (_ref2 = {}, _defineProperty$e(_ref2, "bg-".concat(props.footerBgVariant), Boolean(props.footerBgVariant)), _defineProperty$e(_ref2, "border-".concat(props.footerBorderVariant), Boolean(props.footerBorderVariant)), _defineProperty$e(_ref2, "text-".concat(props.footerTextVariant), Boolean(props.footerTextVariant)), _ref2)]
	    }), children || [h('div', {
	      domProps: htmlOrText(props.footerHtml, props.footer)
	    })]);
	  }
	});

	var props$b = {
	  src: {
	    type: String,
	    default: null,
	    required: true
	  },
	  alt: {
	    type: String,
	    default: null
	  },
	  top: {
	    type: Boolean,
	    default: false
	  },
	  bottom: {
	    type: Boolean,
	    default: false
	  },
	  start: {
	    type: Boolean,
	    default: false
	  },
	  left: {
	    // alias of 'start'
	    type: Boolean,
	    default: false
	  },
	  end: {
	    type: Boolean,
	    default: false
	  },
	  right: {
	    // alias of 'end'
	    type: Boolean,
	    default: false
	  },
	  height: {
	    type: [Number, String],
	    default: null
	  },
	  width: {
	    type: [Number, String],
	    default: null
	  }
	}; // @vue/component

	var BCardImg =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BCardImg',
	  functional: true,
	  props: props$b,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data;
	    var baseClass = 'card-img';

	    if (props.top) {
	      baseClass += '-top';
	    } else if (props.right || props.end) {
	      baseClass += '-right';
	    } else if (props.bottom) {
	      baseClass += '-bottom';
	    } else if (props.left || props.start) {
	      baseClass += '-left';
	    }

	    return h('img', a(data, {
	      class: [baseClass],
	      attrs: {
	        src: props.src,
	        alt: props.alt,
	        height: props.height,
	        width: props.width
	      }
	    }));
	  }
	});

	function _toConsumableArray$3(arr) { return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _nonIterableSpread$3(); }

	function _nonIterableSpread$3() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray$3(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") { return Array.from(iter); } }

	function _arrayWithoutHoles$3(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$c(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$c(source, true).forEach(function (key) { _defineProperty$f(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$f(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var cardImgProps = copyProps(props$b, prefixPropName.bind(null, 'img'));
	cardImgProps.imgSrc.required = false;
	var props$c = _objectSpread$c({}, props$8, {}, props$9, {}, props$a, {}, cardImgProps, {}, copyProps(cardMixin.props), {
	  align: {
	    type: String,
	    default: null
	  },
	  noBody: {
	    type: Boolean,
	    default: false
	  }
	}); // @vue/component

	var BCard =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BCard',
	  functional: true,
	  props: props$c,
	  render: function render(h, _ref) {
	    var _class;

	    var props = _ref.props,
	        data = _ref.data,
	        slots = _ref.slots,
	        scopedSlots = _ref.scopedSlots;
	    var $slots = slots(); // Vue < 2.6.x may return undefined for scopedSlots

	    var $scopedSlots = scopedSlots || {}; // Create placeholder elements for each section

	    var imgFirst = h();
	    var header = h();
	    var content = h();
	    var footer = h();
	    var imgLast = h();

	    if (props.imgSrc) {
	      var img = h(BCardImg, {
	        props: pluckProps(cardImgProps, props, unprefixPropName.bind(null, 'img'))
	      });

	      if (props.imgBottom) {
	        imgLast = img;
	      } else {
	        imgFirst = img;
	      }
	    }

	    if (props.header || hasNormalizedSlot('header', $scopedSlots, $slots)) {
	      header = h(BCardHeader, {
	        props: pluckProps(props$9, props)
	      }, normalizeSlot('header', {}, $scopedSlots, $slots));
	    }

	    content = normalizeSlot('default', {}, $scopedSlots, $slots) || [];

	    if (!props.noBody) {
	      // Wrap content in card-body
	      content = [h(BCardBody, {
	        props: pluckProps(props$8, props)
	      }, _toConsumableArray$3(content))];
	    }

	    if (props.footer || hasNormalizedSlot('footer', $scopedSlots, $slots)) {
	      footer = h(BCardFooter, {
	        props: pluckProps(props$a, props)
	      }, normalizeSlot('footer', {}, $scopedSlots, $slots));
	    }

	    return h(props.tag, a(data, {
	      staticClass: 'card',
	      class: (_class = {
	        'flex-row': props.imgLeft || props.imgStart,
	        'flex-row-reverse': (props.imgRight || props.imgEnd) && !(props.imgLeft || props.imgStart)
	      }, _defineProperty$f(_class, "text-".concat(props.align), Boolean(props.align)), _defineProperty$f(_class, "bg-".concat(props.bgVariant), Boolean(props.bgVariant)), _defineProperty$f(_class, "border-".concat(props.borderVariant), Boolean(props.borderVariant)), _defineProperty$f(_class, "text-".concat(props.textVariant), Boolean(props.textVariant)), _class)
	    }), [imgFirst, header].concat(_toConsumableArray$3(content), [footer, imgLast]));
	  }
	});

	// Handles when arrays are "sparse" (array.every(...) doesn't handle sparse)

	var compareArrays = function compareArrays(a, b) {
	  if (a.length !== b.length) {
	    return false;
	  }

	  var equal = true;

	  for (var i = 0; equal && i < a.length; i++) {
	    equal = looseEqual(a[i], b[i]);
	  }

	  return equal;
	};
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 * Returns boolean true or false
	 */


	var looseEqual = function looseEqual(a, b) {
	  if (a === b) {
	    return true;
	  }

	  var aValidType = isDate(a);
	  var bValidType = isDate(b);

	  if (aValidType || bValidType) {
	    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
	  }

	  aValidType = isArray(a);
	  bValidType = isArray(b);

	  if (aValidType || bValidType) {
	    return aValidType && bValidType ? compareArrays(a, b) : false;
	  }

	  aValidType = isObject(a);
	  bValidType = isObject(b);

	  if (aValidType || bValidType) {
	    /* istanbul ignore if: this if will probably never be called */
	    if (!aValidType || !bValidType) {
	      return false;
	    }

	    var aKeysCount = keys$2(a).length;
	    var bKeysCount = keys$2(b).length;

	    if (aKeysCount !== bKeysCount) {
	      return false;
	    }

	    for (var key in a) {
	      // eslint-disable-next-line no-prototype-builtins
	      var aHasKey = a.hasOwnProperty(key); // eslint-disable-next-line no-prototype-builtins

	      var bHasKey = b.hasOwnProperty(key);

	      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
	        return false;
	      }
	    }
	  }

	  return String(a) === String(b);
	};

	function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) { _defineProperties$1(Constructor.prototype, protoProps); } if (staticProps) { _defineProperties$1(Constructor, staticProps); } return Constructor; }
	var OBSERVER_PROP_NAME = '__bv__visibility_observer';

	var VisibilityObserver =
	/*#__PURE__*/
	function () {
	  function VisibilityObserver(el, options, vnode) {
	    _classCallCheck$2(this, VisibilityObserver);

	    this.el = el;
	    this.callback = options.callback;
	    this.margin = options.margin || 0;
	    this.once = options.once || false;
	    this.observer = null;
	    this.visible = undefined;
	    this.doneOnce = false; // Create the observer instance (if possible)

	    this.createObserver(vnode);
	  }

	  _createClass$1(VisibilityObserver, [{
	    key: "createObserver",
	    value: function createObserver(vnode) {
	      var _this = this;

	      // Remove any previous observer
	      if (this.observer) {
	        /* istanbul ignore next */
	        this.stop();
	      } // Should only be called once and `callback` prop should be a function


	      if (this.doneOnce || !isFunction(this.callback)) {
	        /* istanbul ignore next */
	        return;
	      } // Create the observer instance


	      try {
	        // Future: Possibly add in other modifiers for left/right/top/bottom
	        // offsets, root element reference, and thresholds
	        this.observer = new IntersectionObserver(this.handler.bind(this), {
	          // `null` = 'viewport'
	          root: null,
	          // Pixels away from view port to consider "visible"
	          rootMargin: this.margin,
	          // Intersection ratio of el and root (as a value from 0 to 1)
	          threshold: 0
	        });
	      } catch (_unused) {
	        // No IntersectionObserver support, so just stop trying to observe
	        this.doneOnce = true;
	        this.observer = undefined;
	        this.callback(null);
	        return;
	      } // Start observing in a `$nextTick()` (to allow DOM to complete rendering)

	      /* istanbul ignore next: IntersectionObserver not supported in JSDOM */


	      vnode.context.$nextTick(function () {
	        requestAF(function () {
	          // Placed in an `if` just in case we were destroyed before
	          // this `requestAnimationFrame` runs
	          if (_this.observer) {
	            _this.observer.observe(_this.el);
	          }
	        });
	      });
	    }
	  }, {
	    key: "handler",
	    value: function handler(entries)
	    /* istanbul ignore next: IntersectionObserver not supported in JSDOM */
	    {
	      var entry = entries ? entries[0] : {};
	      var isIntersecting = Boolean(entry.isIntersecting || entry.intersectionRatio > 0.0);

	      if (isIntersecting !== this.visible) {
	        this.visible = isIntersecting;
	        this.callback(isIntersecting);

	        if (this.once && this.visible) {
	          this.doneOnce = true;
	          this.stop();
	        }
	      }
	    }
	  }, {
	    key: "stop",
	    value: function stop() {
	      var observer = this.observer;
	      /* istanbul ignore next */

	      if (observer && observer.disconnect) {
	        observer.disconnect();
	      }

	      this.observer = null;
	    }
	  }]);

	  return VisibilityObserver;
	}();

	var destroy = function destroy(el) {
	  var observer = el[OBSERVER_PROP_NAME];

	  if (observer && observer.stop) {
	    observer.stop();
	  }

	  delete el[OBSERVER_PROP_NAME];
	};

	var bind = function bind(el, _ref, vnode) {
	  var value = _ref.value,
	      modifiers = _ref.modifiers;
	  // `value` is the callback function
	  var options = {
	    margin: '0px',
	    once: false,
	    callback: value
	  }; // Parse modifiers

	  keys$2(modifiers).forEach(function (mod) {
	    /* istanbul ignore else: Until <b-img-lazy> is switched to use this directive */
	    if (/^\d+$/.test(mod)) {
	      options.margin = "".concat(mod, "px");
	    } else if (mod.toLowerCase() === 'once') {
	      options.once = true;
	    }
	  }); // Destroy any previous observer

	  destroy(el); // Create new observer

	  el[OBSERVER_PROP_NAME] = new VisibilityObserver(el, options, vnode); // Store the current modifiers on the object (cloned)

	  el[OBSERVER_PROP_NAME]._prevModifiers = clone(modifiers);
	}; // When the directive options may have been updated (or element)


	var componentUpdated = function componentUpdated(el, _ref2, vnode) {
	  var value = _ref2.value,
	      oldValue = _ref2.oldValue,
	      modifiers = _ref2.modifiers;
	  // Compare value/oldValue and modifiers to see if anything has changed
	  // and if so, destroy old observer and create new observer

	  /* istanbul ignore next */
	  modifiers = clone(modifiers);
	  /* istanbul ignore next */

	  if (el && (value !== oldValue || !el[OBSERVER_PROP_NAME] || !looseEqual(modifiers, el[OBSERVER_PROP_NAME]._prevModifiers))) {
	    // Re-bind on element
	    bind(el, {
	      value: value,
	      modifiers: modifiers
	    }, vnode);
	  }
	}; // When directive un-binds from element


	var unbind = function unbind(el) {
	  // Remove the observer
	  destroy(el);
	}; // Export the directive


	var VBVisible = {
	  bind: bind,
	  componentUpdated: componentUpdated,
	  unbind: unbind
	};

	function _defineProperty$g(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var NAME$8 = 'BImg'; // Blank image with fill template

	var BLANK_TEMPLATE = '<svg width="%{w}" height="%{h}" ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'viewBox="0 0 %{w} %{h}" preserveAspectRatio="none">' + '<rect width="100%" height="100%" style="fill:%{f};"></rect>' + '</svg>';
	var props$d = {
	  src: {
	    type: String,
	    default: null
	  },
	  srcset: {
	    type: [String, Array],
	    default: null
	  },
	  sizes: {
	    type: [String, Array],
	    default: null
	  },
	  alt: {
	    type: String,
	    default: null
	  },
	  width: {
	    type: [Number, String],
	    default: null
	  },
	  height: {
	    type: [Number, String],
	    default: null
	  },
	  block: {
	    type: Boolean,
	    default: false
	  },
	  fluid: {
	    type: Boolean,
	    default: false
	  },
	  fluidGrow: {
	    // Gives fluid images class `w-100` to make them grow to fit container
	    type: Boolean,
	    default: false
	  },
	  rounded: {
	    // rounded can be:
	    //   false: no rounding of corners
	    //   true: slightly rounded corners
	    //   'top': top corners rounded
	    //   'right': right corners rounded
	    //   'bottom': bottom corners rounded
	    //   'left': left corners rounded
	    //   'circle': circle/oval
	    //   '0': force rounding off
	    type: [Boolean, String],
	    default: false
	  },
	  thumbnail: {
	    type: Boolean,
	    default: false
	  },
	  left: {
	    type: Boolean,
	    default: false
	  },
	  right: {
	    type: Boolean,
	    default: false
	  },
	  center: {
	    type: Boolean,
	    default: false
	  },
	  blank: {
	    type: Boolean,
	    default: false
	  },
	  blankColor: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$8, 'blankColor');
	    }
	  }
	}; // --- Helper methods ---

	var makeBlankImgSrc = function makeBlankImgSrc(width, height, color) {
	  var src = encodeURIComponent(BLANK_TEMPLATE.replace('%{w}', String(width)).replace('%{h}', String(height)).replace('%{f}', color));
	  return "data:image/svg+xml;charset=UTF-8,".concat(src);
	}; // @vue/component


	var BImg =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$8,
	  functional: true,
	  props: props$d,
	  render: function render(h, _ref) {
	    var _class;

	    var props = _ref.props,
	        data = _ref.data;
	    var src = props.src;
	    var width = parseInt(props.width, 10) ? parseInt(props.width, 10) : null;
	    var height = parseInt(props.height, 10) ? parseInt(props.height, 10) : null;
	    var align = null;
	    var block = props.block;
	    var srcset = concat(props.srcset).filter(Boolean).join(',');
	    var sizes = concat(props.sizes).filter(Boolean).join(',');

	    if (props.blank) {
	      if (!height && Boolean(width)) {
	        height = width;
	      } else if (!width && Boolean(height)) {
	        width = height;
	      }

	      if (!width && !height) {
	        width = 1;
	        height = 1;
	      } // Make a blank SVG image


	      src = makeBlankImgSrc(width, height, props.blankColor || 'transparent'); // Disable srcset and sizes

	      srcset = null;
	      sizes = null;
	    }

	    if (props.left) {
	      align = 'float-left';
	    } else if (props.right) {
	      align = 'float-right';
	    } else if (props.center) {
	      align = 'mx-auto';
	      block = true;
	    }

	    return h('img', a(data, {
	      attrs: {
	        src: src,
	        alt: props.alt,
	        width: width ? String(width) : null,
	        height: height ? String(height) : null,
	        srcset: srcset || null,
	        sizes: sizes || null
	      },
	      class: (_class = {
	        'img-thumbnail': props.thumbnail,
	        'img-fluid': props.fluid || props.fluidGrow,
	        'w-100': props.fluidGrow,
	        rounded: props.rounded === '' || props.rounded === true
	      }, _defineProperty$g(_class, "rounded-".concat(props.rounded), isString(props.rounded) && props.rounded !== ''), _defineProperty$g(_class, align, Boolean(align)), _defineProperty$g(_class, 'd-block', block), _class)
	    }));
	  }
	});

	function _defineProperty$h(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$9 = 'BImgLazy';
	var props$e = {
	  src: {
	    type: String,
	    default: null,
	    required: true
	  },
	  srcset: {
	    type: [String, Array],
	    default: null
	  },
	  sizes: {
	    type: [String, Array],
	    default: null
	  },
	  alt: {
	    type: String,
	    default: null
	  },
	  width: {
	    type: [Number, String],
	    default: null
	  },
	  height: {
	    type: [Number, String],
	    default: null
	  },
	  blankSrc: {
	    // If null, a blank image is generated
	    type: String,
	    default: null
	  },
	  blankColor: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$9, 'blankColor');
	    }
	  },
	  blankWidth: {
	    type: [Number, String],
	    default: null
	  },
	  blankHeight: {
	    type: [Number, String],
	    default: null
	  },
	  show: {
	    type: Boolean,
	    default: false
	  },
	  fluid: {
	    type: Boolean,
	    default: false
	  },
	  fluidGrow: {
	    type: Boolean,
	    default: false
	  },
	  block: {
	    type: Boolean,
	    default: false
	  },
	  thumbnail: {
	    type: Boolean,
	    default: false
	  },
	  rounded: {
	    type: [Boolean, String],
	    default: false
	  },
	  left: {
	    type: Boolean,
	    default: false
	  },
	  right: {
	    type: Boolean,
	    default: false
	  },
	  center: {
	    type: Boolean,
	    default: false
	  },
	  offset: {
	    // Distance away from viewport (in pixels) before being
	    // considered "visible"
	    type: [Number, String],
	    default: 360
	  }
	}; // @vue/component

	var BImgLazy =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$9,
	  directives: {
	    bVisible: VBVisible
	  },
	  props: props$e,
	  data: function data() {
	    return {
	      isShown: this.show
	    };
	  },
	  computed: {
	    computedSrc: function computedSrc() {
	      return !this.blankSrc || this.isShown ? this.src : this.blankSrc;
	    },
	    computedBlank: function computedBlank() {
	      return !(this.isShown || this.blankSrc);
	    },
	    computedWidth: function computedWidth() {
	      return this.isShown ? this.width : this.blankWidth || this.width;
	    },
	    computedHeight: function computedHeight() {
	      return this.isShown ? this.height : this.blankHeight || this.height;
	    },
	    computedSrcset: function computedSrcset() {
	      var srcset = concat(this.srcset).filter(Boolean).join(',');
	      return !this.blankSrc || this.isShown ? srcset : null;
	    },
	    computedSizes: function computedSizes() {
	      var sizes = concat(this.sizes).filter(Boolean).join(',');
	      return !this.blankSrc || this.isShown ? sizes : null;
	    }
	  },
	  watch: {
	    show: function show(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        // If IntersectionObserver support is not available, image is always shown
	        var visible = hasIntersectionObserverSupport ? newVal : true;
	        this.isShown = visible;

	        if (visible !== newVal) {
	          // Ensure the show prop is synced (when no IntersectionObserver)
	          this.$nextTick(this.updateShowProp);
	        }
	      }
	    },
	    isShown: function isShown(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        // Update synched show prop
	        this.updateShowProp();
	      }
	    }
	  },
	  mounted: function mounted() {
	    // If IntersectionObserver is not available, image is always shown
	    this.isShown = hasIntersectionObserverSupport ? this.show : true;
	  },
	  methods: {
	    updateShowProp: function updateShowProp() {
	      this.$emit('update:show', this.isShown);
	    },
	    doShow: function doShow(visible) {
	      // If IntersectionObserver is not supported, the callback
	      // will be called with `null` rather than `true` or `false`
	      if ((visible || visible === null) && !this.isShown) {
	        this.isShown = true;
	      }
	    }
	  },
	  render: function render(h) {
	    var directives = [];

	    if (!this.isShown) {
	      var _modifiers;

	      // We only add the visible directive if we are not shown
	      directives.push({
	        // Visible directive will silently do nothing if
	        // IntersectionObserver is not supported
	        name: 'b-visible',
	        // Value expects a callback (passed one arg of `visible` = `true` or `false`)
	        value: this.doShow,
	        modifiers: (_modifiers = {}, _defineProperty$h(_modifiers, "".concat(parseInt(this.offset, 10) || 0), true), _defineProperty$h(_modifiers, "once", true), _modifiers)
	      });
	    }

	    return h(BImg, {
	      directives: directives,
	      props: {
	        // Computed value props
	        src: this.computedSrc,
	        blank: this.computedBlank,
	        width: this.computedWidth,
	        height: this.computedHeight,
	        srcset: this.computedSrcset || null,
	        sizes: this.computedSizes || null,
	        // Passthrough props
	        alt: this.alt,
	        blankColor: this.blankColor,
	        fluid: this.fluid,
	        fluidGrow: this.fluidGrow,
	        block: this.block,
	        thumbnail: this.thumbnail,
	        rounded: this.rounded,
	        left: this.left,
	        right: this.right,
	        center: this.center
	      }
	    });
	  }
	});

	function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$d(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$d(source, true).forEach(function (key) { _defineProperty$i(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$d(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$i(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	// The `omit()` util creates a new object, so we can just pass the original props

	var lazyProps = omit(props$e, ['left', 'right', 'center', 'block', 'rounded', 'thumbnail', 'fluid', 'fluidGrow']);
	var props$f = _objectSpread$d({}, lazyProps, {
	  top: {
	    type: Boolean,
	    default: false
	  },
	  bottom: {
	    type: Boolean,
	    default: false
	  },
	  start: {
	    type: Boolean,
	    default: false
	  },
	  left: {
	    // alias of 'start'
	    type: Boolean,
	    default: false
	  },
	  end: {
	    type: Boolean,
	    default: false
	  },
	  right: {
	    // alias of 'end'
	    type: Boolean,
	    default: false
	  }
	}); // @vue/component

	var BCardImgLazy =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BCardImgLazy',
	  functional: true,
	  props: props$f,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data;
	    var baseClass = 'card-img';

	    if (props.top) {
	      baseClass += '-top';
	    } else if (props.right || props.end) {
	      baseClass += '-right';
	    } else if (props.bottom) {
	      baseClass += '-bottom';
	    } else if (props.left || props.start) {
	      baseClass += '-left';
	    } // False out the left/center/right props before passing to b-img-lazy


	    var lazyProps = _objectSpread$d({}, props, {
	      left: false,
	      right: false,
	      center: false
	    });

	    return h(BImgLazy, a(data, {
	      class: [baseClass],
	      props: lazyProps
	    }));
	  }
	});

	var props$g = {
	  textTag: {
	    type: String,
	    default: 'p'
	  }
	}; // @vue/component

	var BCardText =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BCardText',
	  functional: true,
	  props: props$g,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.textTag, a(data, {
	      staticClass: 'card-text'
	    }), children);
	  }
	});

	var props$h = {
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  deck: {
	    type: Boolean,
	    default: false
	  },
	  columns: {
	    type: Boolean,
	    default: false
	  }
	}; // @vue/component

	var BCardGroup =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BCardGroup',
	  functional: true,
	  props: props$h,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var baseClass = 'card-group';

	    if (props.deck) {
	      baseClass = 'card-deck';
	    } else if (props.columns) {
	      baseClass = 'card-columns';
	    }

	    return h(props.tag, a(data, {
	      class: baseClass
	    }), children);
	  }
	});

	var CardPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BCard: BCard,
	    BCardHeader: BCardHeader,
	    BCardBody: BCardBody,
	    BCardTitle: BCardTitle,
	    BCardSubTitle: BCardSubTitle,
	    BCardFooter: BCardFooter,
	    BCardImg: BCardImg,
	    BCardImgLazy: BCardImgLazy,
	    BCardText: BCardText,
	    BCardGroup: BCardGroup
	  }
	});

	var noop = function noop() {};

	function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$e(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$e(source, true).forEach(function (key) { _defineProperty$j(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$e(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$j(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	/**
	 * Observe a DOM element changes, falls back to eventListener mode
	 * @param {Element} el The DOM element to observe
	 * @param {Function} callback callback to be called on change
	 * @param {object} [opts={childList: true, subtree: true}] observe options
	 * @see http://stackoverflow.com/questions/3219758
	 */

	var observeDom = function observeDom(el, callback, opts)
	/* istanbul ignore next: difficult to test in JSDOM */
	{
	  // Handle cases where we might be passed a Vue instance
	  el = el ? el.$el || el : null; // Early exit when we have no element

	  /* istanbul ignore next: difficult to test in JSDOM */

	  if (!isElement(el)) {
	    return null;
	  } // Exit and throw a warning when `MutationObserver` isn't available


	  if (warnNoMutationObserverSupport('observeDom')) {
	    return null;
	  } // Define a new observer


	  var obs = new MutationObs(function (mutations) {
	    var changed = false; // A mutation can contain several change records, so we loop
	    // through them to see what has changed
	    // We break out of the loop early if any "significant" change
	    // has been detected

	    for (var i = 0; i < mutations.length && !changed; i++) {
	      // The mutation record
	      var mutation = mutations[i]; // Mutation type

	      var type = mutation.type; // DOM node (could be any DOM node type - HTMLElement, Text, comment, etc.)

	      var target = mutation.target; // Detect whether a change happened based on type and target

	      if (type === 'characterData' && target.nodeType === Node.TEXT_NODE) {
	        // We ignore nodes that are not TEXT (i.e. comments, etc)
	        // as they don't change layout
	        changed = true;
	      } else if (type === 'attributes') {
	        changed = true;
	      } else if (type === 'childList' && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
	        // This includes HTMLElement and text nodes being
	        // added/removed/re-arranged
	        changed = true;
	      }
	    } // We only call the callback if a change that could affect
	    // layout/size truely happened


	    if (changed) {
	      callback();
	    }
	  }); // Have the observer observe foo for changes in children, etc

	  obs.observe(el, _objectSpread$e({
	    childList: true,
	    subtree: true
	  }, opts)); // We return a reference to the observer so that `obs.disconnect()`
	  // can be called if necessary
	  // To reduce overhead when the root element is hidden

	  return obs;
	};

	/*
	 * SSR Safe Client Side ID attribute generation
	 * id's can only be generated client side, after mount.
	 * this._uid is not synched between server and client.
	 */
	// @vue/component
	var idMixin = {
	  props: {
	    id: {
	      type: String,
	      default: null
	    }
	  },
	  data: function data() {
	    return {
	      localId_: null
	    };
	  },
	  computed: {
	    safeId: function safeId() {
	      // Computed property that returns a dynamic function for creating the ID.
	      // Reacts to changes in both .id and .localId_ And regens a new function
	      var id = this.id || this.localId_; // We return a function that accepts an optional suffix string
	      // So this computed prop looks and works like a method!!!
	      // But benefits from Vue's Computed prop caching

	      var fn = function fn(suffix) {
	        if (!id) {
	          return null;
	        }

	        suffix = String(suffix || '').replace(/\s+/g, '_');
	        return suffix ? id + '_' + suffix : id;
	      };

	      return fn;
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    // mounted only occurs client side
	    this.$nextTick(function () {
	      // Update dom with auto ID after dom loaded to prevent
	      // SSR hydration errors.
	      _this.localId_ = "__BVID__".concat(_this._uid);
	    });
	  }
	};

	var NAME$a = 'BCarousel'; // Slide directional classes

	var DIRECTION = {
	  next: {
	    dirClass: 'carousel-item-left',
	    overlayClass: 'carousel-item-next'
	  },
	  prev: {
	    dirClass: 'carousel-item-right',
	    overlayClass: 'carousel-item-prev'
	  }
	}; // Fallback Transition duration (with a little buffer) in ms

	var TRANS_DURATION = 600 + 50; // Time for mouse compat events to fire after touch

	var TOUCH_EVENT_COMPAT_WAIT = 500; // Number of pixels to consider touch move a swipe

	var SWIPE_THRESHOLD = 40; // PointerEvent pointer types

	var PointerType = {
	  TOUCH: 'touch',
	  PEN: 'pen'
	}; // Transition Event names

	var TransitionEndEvents = {
	  WebkitTransition: 'webkitTransitionEnd',
	  MozTransition: 'transitionend',
	  OTransition: 'otransitionend oTransitionEnd',
	  transition: 'transitionend'
	};
	var EventOptions = {
	  passive: true,
	  capture: false
	}; // Return the browser specific transitionEnd event name

	var getTransitionEndEvent = function getTransitionEndEvent(el) {
	  for (var name in TransitionEndEvents) {
	    if (!isUndefined(el.style[name])) {
	      return TransitionEndEvents[name];
	    }
	  } // Fallback

	  /* istanbul ignore next */


	  return null;
	}; // @vue/component


	var BCarousel =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$a,
	  mixins: [idMixin, normalizeSlotMixin],
	  provide: function provide() {
	    return {
	      bvCarousel: this
	    };
	  },
	  model: {
	    prop: 'value',
	    event: 'input'
	  },
	  props: {
	    labelPrev: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$a, 'labelPrev');
	      }
	    },
	    labelNext: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$a, 'labelNext');
	      }
	    },
	    labelGotoSlide: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$a, 'labelGotoSlide');
	      }
	    },
	    labelIndicators: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$a, 'labelIndicators');
	      }
	    },
	    interval: {
	      type: Number,
	      default: 5000
	    },
	    indicators: {
	      type: Boolean,
	      default: false
	    },
	    controls: {
	      type: Boolean,
	      default: false
	    },
	    noAnimation: {
	      // Disable slide/fade animation
	      type: Boolean,
	      default: false
	    },
	    fade: {
	      // Enable cross-fade animation instead of slide animation
	      type: Boolean,
	      default: false
	    },
	    noWrap: {
	      // Disable wrapping/looping when start/end is reached
	      type: Boolean,
	      default: false
	    },
	    noTouch: {
	      // Sniffed by carousel-slide
	      type: Boolean,
	      default: false
	    },
	    noHoverPause: {
	      // Disable pause on hover
	      type: Boolean,
	      default: false
	    },
	    imgWidth: {
	      // Sniffed by carousel-slide
	      type: [Number, String] // default: undefined

	    },
	    imgHeight: {
	      // Sniffed by carousel-slide
	      type: [Number, String] // default: undefined

	    },
	    background: {
	      type: String // default: undefined

	    },
	    value: {
	      type: Number,
	      default: 0
	    }
	  },
	  data: function data() {
	    return {
	      index: this.value || 0,
	      isSliding: false,
	      transitionEndEvent: null,
	      slides: [],
	      direction: null,
	      isPaused: !(parseInt(this.interval, 10) > 0),
	      // Touch event handling values
	      touchStartX: 0,
	      touchDeltaX: 0
	    };
	  },
	  computed: {
	    numSlides: function numSlides() {
	      return this.slides.length;
	    }
	  },
	  watch: {
	    value: function value(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        this.setSlide(parseInt(newVal, 10) || 0);
	      }
	    },
	    interval: function interval(newVal, oldVal) {
	      if (newVal === oldVal) {
	        /* istanbul ignore next */
	        return;
	      }

	      if (!newVal) {
	        // Pausing slide show
	        this.pause(false);
	      } else {
	        // Restarting or Changing interval
	        this.pause(true);
	        this.start(false);
	      }
	    },
	    isPaused: function isPaused(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        this.$emit(newVal ? 'paused' : 'unpaused');
	      }
	    },
	    index: function index(to, from) {
	      if (to === from || this.isSliding) {
	        /* istanbul ignore next */
	        return;
	      }

	      this.doSlide(to, from);
	    }
	  },
	  created: function created() {
	    // Create private non-reactive props
	    this._intervalId = null;
	    this._animationTimeout = null;
	    this._touchTimeout = null; // Set initial paused state

	    this.isPaused = !(parseInt(this.interval, 10) > 0);
	  },
	  mounted: function mounted() {
	    // Cache current browser transitionend event name
	    this.transitionEndEvent = getTransitionEndEvent(this.$el) || null; // Get all slides

	    this.updateSlides(); // Observe child changes so we can update slide list

	    observeDom(this.$refs.inner, this.updateSlides.bind(this), {
	      subtree: false,
	      childList: true,
	      attributes: true,
	      attributeFilter: ['id']
	    });
	  },
	  beforeDestroy: function beforeDestroy() {
	    clearTimeout(this._animationTimeout);
	    clearTimeout(this._touchTimeout);
	    clearInterval(this._intervalId);
	    this._intervalId = null;
	    this._animationTimeout = null;
	    this._touchTimeout = null;
	  },
	  methods: {
	    // Set slide
	    setSlide: function setSlide(slide) {
	      var _this = this;

	      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      // Don't animate when page is not visible

	      /* istanbul ignore if: difficult to test */
	      if (isBrowser && document.visibilityState && document.hidden) {
	        return;
	      }

	      var noWrap = this.noWrap;
	      var numSlides = this.numSlides; // Make sure we have an integer (you never know!)

	      slide = Math.floor(slide); // Don't do anything if nothing to slide to

	      if (numSlides === 0) {
	        return;
	      } // Don't change slide while transitioning, wait until transition is done


	      if (this.isSliding) {
	        // Schedule slide after sliding complete
	        this.$once('sliding-end', function () {
	          return _this.setSlide(slide, direction);
	        });
	        return;
	      }

	      this.direction = direction; // Set new slide index
	      // Wrap around if necessary (if no-wrap not enabled)

	      this.index = slide >= numSlides ? noWrap ? numSlides - 1 : 0 : slide < 0 ? noWrap ? 0 : numSlides - 1 : slide; // Ensure the v-model is synched up if no-wrap is enabled
	      // and user tried to slide pass either ends

	      if (noWrap && this.index !== slide && this.index !== this.value) {
	        this.$emit('input', this.index);
	      }
	    },
	    // Previous slide
	    prev: function prev() {
	      this.setSlide(this.index - 1, 'prev');
	    },
	    // Next slide
	    next: function next() {
	      this.setSlide(this.index + 1, 'next');
	    },
	    // Pause auto rotation
	    pause: function pause(evt) {
	      if (!evt) {
	        this.isPaused = true;
	      }

	      if (this._intervalId) {
	        clearInterval(this._intervalId);
	        this._intervalId = null;
	      }
	    },
	    // Start auto rotate slides
	    start: function start(evt) {
	      if (!evt) {
	        this.isPaused = false;
	      }
	      /* istanbul ignore next: most likely will never happen, but just in case */


	      if (this._intervalId) {
	        clearInterval(this._intervalId);
	        this._intervalId = null;
	      } // Don't start if no interval, or less than 2 slides


	      if (this.interval && this.numSlides > 1) {
	        this._intervalId = setInterval(this.next, Math.max(1000, this.interval));
	      }
	    },
	    // Restart auto rotate slides when focus/hover leaves the carousel
	    restart: function restart(evt)
	    /* istanbul ignore next: difficult to test */
	    {
	      if (!this.$el.contains(document.activeElement)) {
	        this.start();
	      }
	    },
	    doSlide: function doSlide(to, from) {
	      var _this2 = this;

	      var isCycling = Boolean(this.interval); // Determine sliding direction

	      var direction = this.calcDirection(this.direction, from, to);
	      var overlayClass = direction.overlayClass;
	      var dirClass = direction.dirClass; // Determine current and next slides

	      var currentSlide = this.slides[from];
	      var nextSlide = this.slides[to]; // Don't do anything if there aren't any slides to slide to

	      if (!currentSlide || !nextSlide) {
	        /* istanbul ignore next */
	        return;
	      } // Start animating


	      this.isSliding = true;

	      if (isCycling) {
	        this.pause(false);
	      }

	      this.$emit('sliding-start', to); // Update v-model

	      this.$emit('input', this.index);

	      if (this.noAnimation) {
	        addClass(nextSlide, 'active');
	        removeClass(currentSlide, 'active');
	        this.isSliding = false; // Notify ourselves that we're done sliding (slid)

	        this.$nextTick(function () {
	          return _this2.$emit('sliding-end', to);
	        });
	      } else {
	        addClass(nextSlide, overlayClass); // Trigger a reflow of next slide

	        reflow(nextSlide);
	        addClass(currentSlide, dirClass);
	        addClass(nextSlide, dirClass); // Transition End handler

	        var called = false;
	        /* istanbul ignore next: difficult to test */

	        var onceTransEnd = function onceTransEnd(evt) {
	          if (called) {
	            return;
	          }

	          called = true;
	          /* istanbul ignore if: transition events cant be tested in JSDOM */

	          if (_this2.transitionEndEvent) {
	            var events = _this2.transitionEndEvent.split(/\s+/);

	            events.forEach(function (evt) {
	              return eventOff(currentSlide, evt, onceTransEnd, EventOptions);
	            });
	          }

	          _this2._animationTimeout = null;
	          removeClass(nextSlide, dirClass);
	          removeClass(nextSlide, overlayClass);
	          addClass(nextSlide, 'active');
	          removeClass(currentSlide, 'active');
	          removeClass(currentSlide, dirClass);
	          removeClass(currentSlide, overlayClass);
	          setAttr(currentSlide, 'aria-current', 'false');
	          setAttr(nextSlide, 'aria-current', 'true');
	          setAttr(currentSlide, 'aria-hidden', 'true');
	          setAttr(nextSlide, 'aria-hidden', 'false');
	          _this2.isSliding = false;
	          _this2.direction = null; // Notify ourselves that we're done sliding (slid)

	          _this2.$nextTick(function () {
	            return _this2.$emit('sliding-end', to);
	          });
	        }; // Set up transitionend handler

	        /* istanbul ignore if: transition events cant be tested in JSDOM */


	        if (this.transitionEndEvent) {
	          var events = this.transitionEndEvent.split(/\s+/);
	          events.forEach(function (event) {
	            return eventOn(currentSlide, event, onceTransEnd, EventOptions);
	          });
	        } // Fallback to setTimeout()


	        this._animationTimeout = setTimeout(onceTransEnd, TRANS_DURATION);
	      }

	      if (isCycling) {
	        this.start(false);
	      }
	    },
	    // Update slide list
	    updateSlides: function updateSlides() {
	      this.pause(true); // Get all slides as DOM elements

	      this.slides = selectAll('.carousel-item', this.$refs.inner);
	      var numSlides = this.slides.length; // Keep slide number in range

	      var index = Math.max(0, Math.min(Math.floor(this.index), numSlides - 1));
	      this.slides.forEach(function (slide, idx) {
	        var n = idx + 1;

	        if (idx === index) {
	          addClass(slide, 'active');
	          setAttr(slide, 'aria-current', 'true');
	        } else {
	          removeClass(slide, 'active');
	          setAttr(slide, 'aria-current', 'false');
	        }

	        setAttr(slide, 'aria-posinset', String(n));
	        setAttr(slide, 'aria-setsize', String(numSlides));
	      }); // Set slide as active

	      this.setSlide(index);
	      this.start(this.isPaused);
	    },
	    calcDirection: function calcDirection() {
	      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var curIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var nextIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	      if (!direction) {
	        return nextIndex > curIndex ? DIRECTION.next : DIRECTION.prev;
	      }

	      return DIRECTION[direction];
	    },
	    handleClick: function handleClick(evt, fn) {
	      var keyCode = evt.keyCode;

	      if (evt.type === 'click' || keyCode === KEY_CODES.SPACE || keyCode === KEY_CODES.ENTER) {
	        evt.preventDefault();
	        evt.stopPropagation();
	        fn();
	      }
	    },
	    handleSwipe: function handleSwipe()
	    /* istanbul ignore next: JSDOM doesn't support touch events */
	    {
	      var absDeltaX = Math.abs(this.touchDeltaX);

	      if (absDeltaX <= SWIPE_THRESHOLD) {
	        return;
	      }

	      var direction = absDeltaX / this.touchDeltaX; // Reset touch delta X
	      // https://github.com/twbs/bootstrap/pull/28558

	      this.touchDeltaX = 0;

	      if (direction > 0) {
	        // Swipe left
	        this.prev();
	      } else if (direction < 0) {
	        // Swipe right
	        this.next();
	      }
	    },
	    touchStart: function touchStart(evt)
	    /* istanbul ignore next: JSDOM doesn't support touch events */
	    {
	      if (hasPointerEventSupport && PointerType[evt.pointerType.toUpperCase()]) {
	        this.touchStartX = evt.clientX;
	      } else if (!hasPointerEventSupport) {
	        this.touchStartX = evt.touches[0].clientX;
	      }
	    },
	    touchMove: function touchMove(evt)
	    /* istanbul ignore next: JSDOM doesn't support touch events */
	    {
	      // Ensure swiping with one touch and not pinching
	      if (evt.touches && evt.touches.length > 1) {
	        this.touchDeltaX = 0;
	      } else {
	        this.touchDeltaX = evt.touches[0].clientX - this.touchStartX;
	      }
	    },
	    touchEnd: function touchEnd(evt)
	    /* istanbul ignore next: JSDOM doesn't support touch events */
	    {
	      if (hasPointerEventSupport && PointerType[evt.pointerType.toUpperCase()]) {
	        this.touchDeltaX = evt.clientX - this.touchStartX;
	      }

	      this.handleSwipe(); // If it's a touch-enabled device, mouseenter/leave are fired as
	      // part of the mouse compatibility events on first tap - the carousel
	      // would stop cycling until user tapped out of it;
	      // here, we listen for touchend, explicitly pause the carousel
	      // (as if it's the second time we tap on it, mouseenter compat event
	      // is NOT fired) and after a timeout (to allow for mouse compatibility
	      // events to fire) we explicitly restart cycling

	      this.pause(false);

	      if (this._touchTimeout) {
	        clearTimeout(this._touchTimeout);
	      }

	      this._touchTimeout = setTimeout(this.start, TOUCH_EVENT_COMPAT_WAIT + Math.max(1000, this.interval));
	    }
	  },
	  render: function render(h) {
	    var _this3 = this;

	    // Wrapper for slides
	    var inner = h('div', {
	      ref: 'inner',
	      class: ['carousel-inner'],
	      attrs: {
	        id: this.safeId('__BV_inner_'),
	        role: 'list'
	      }
	    }, [this.normalizeSlot('default')]); // Prev and next controls

	    var controls = h();

	    if (this.controls) {
	      var prevHandler = function prevHandler(evt) {
	        /* istanbul ignore next */
	        if (!_this3.isSliding) {
	          _this3.handleClick(evt, _this3.prev);
	        } else {
	          evt.preventDefault();
	        }
	      };

	      var nextHandler = function nextHandler(evt) {
	        /* istanbul ignore next */
	        if (!_this3.isSliding) {
	          _this3.handleClick(evt, _this3.next);
	        } else {
	          evt.preventDefault();
	        }
	      };

	      controls = [h('a', {
	        class: ['carousel-control-prev'],
	        attrs: {
	          href: '#',
	          role: 'button',
	          'aria-controls': this.safeId('__BV_inner_'),
	          'aria-disabled': this.isSliding ? 'true' : null
	        },
	        on: {
	          click: prevHandler,
	          keydown: prevHandler
	        }
	      }, [h('span', {
	        class: ['carousel-control-prev-icon'],
	        attrs: {
	          'aria-hidden': 'true'
	        }
	      }), h('span', {
	        class: ['sr-only']
	      }, [this.labelPrev])]), h('a', {
	        class: ['carousel-control-next'],
	        attrs: {
	          href: '#',
	          role: 'button',
	          'aria-controls': this.safeId('__BV_inner_'),
	          'aria-disabled': this.isSliding ? 'true' : null
	        },
	        on: {
	          click: nextHandler,
	          keydown: nextHandler
	        }
	      }, [h('span', {
	        class: ['carousel-control-next-icon'],
	        attrs: {
	          'aria-hidden': 'true'
	        }
	      }), h('span', {
	        class: ['sr-only']
	      }, [this.labelNext])])];
	    } // Indicators


	    var indicators = h('ol', {
	      class: ['carousel-indicators'],
	      directives: [{
	        name: 'show',
	        rawName: 'v-show',
	        value: this.indicators,
	        expression: 'indicators'
	      }],
	      attrs: {
	        id: this.safeId('__BV_indicators_'),
	        'aria-hidden': this.indicators ? 'false' : 'true',
	        'aria-label': this.labelIndicators,
	        'aria-owns': this.safeId('__BV_inner_')
	      }
	    }, this.slides.map(function (slide, n) {
	      return h('li', {
	        key: "slide_".concat(n),
	        class: {
	          active: n === _this3.index
	        },
	        attrs: {
	          role: 'button',
	          id: _this3.safeId("__BV_indicator_".concat(n + 1, "_")),
	          tabindex: _this3.indicators ? '0' : '-1',
	          'aria-current': n === _this3.index ? 'true' : 'false',
	          'aria-label': "".concat(_this3.labelGotoSlide, " ").concat(n + 1),
	          'aria-describedby': _this3.slides[n].id || null,
	          'aria-controls': _this3.safeId('__BV_inner_')
	        },
	        on: {
	          click: function click(evt) {
	            _this3.handleClick(evt, function () {
	              _this3.setSlide(n);
	            });
	          },
	          keydown: function keydown(evt) {
	            _this3.handleClick(evt, function () {
	              _this3.setSlide(n);
	            });
	          }
	        }
	      });
	    }));
	    var on = {
	      mouseenter: this.noHoverPause ? noop : this.pause,
	      mouseleave: this.noHoverPause ? noop : this.restart,
	      focusin: this.pause,
	      focusout: this.restart,
	      keydown: function keydown(evt) {
	        if (/input|textarea/i.test(evt.target.tagName)) {
	          /* istanbul ignore next */
	          return;
	        }

	        var keyCode = evt.keyCode;

	        if (keyCode === KEY_CODES.LEFT || keyCode === KEY_CODES.RIGHT) {
	          evt.preventDefault();
	          evt.stopPropagation();

	          _this3[keyCode === KEY_CODES.LEFT ? 'prev' : 'next']();
	        }
	      }
	    }; // Touch support event handlers for environment

	    if (!this.noTouch && hasTouchSupport) {
	      // Attach appropriate listeners (prepend event name with '&' for passive mode)

	      /* istanbul ignore next: JSDOM doesn't support touch events */
	      if (hasPointerEventSupport) {
	        on['&pointerdown'] = this.touchStart;
	        on['&pointerup'] = this.touchEnd;
	      } else {
	        on['&touchstart'] = this.touchStart;
	        on['&touchmove'] = this.touchMove;
	        on['&touchend'] = this.touchEnd;
	      }
	    } // Return the carousel


	    return h('div', {
	      staticClass: 'carousel',
	      class: {
	        slide: !this.noAnimation,
	        'carousel-fade': !this.noAnimation && this.fade,
	        'pointer-event': !this.noTouch && hasTouchSupport && hasPointerEventSupport
	      },
	      style: {
	        background: this.background
	      },
	      attrs: {
	        role: 'region',
	        id: this.safeId(),
	        'aria-busy': this.isSliding ? 'true' : 'false'
	      },
	      on: on
	    }, [inner, controls, indicators]);
	  }
	});

	var props$i = {
	  imgSrc: {
	    type: String // default: undefined

	  },
	  imgAlt: {
	    type: String // default: undefined

	  },
	  imgWidth: {
	    type: [Number, String] // default: undefined

	  },
	  imgHeight: {
	    type: [Number, String] // default: undefined

	  },
	  imgBlank: {
	    type: Boolean,
	    default: false
	  },
	  imgBlankColor: {
	    type: String,
	    default: 'transparent'
	  },
	  contentVisibleUp: {
	    type: String
	  },
	  contentTag: {
	    type: String,
	    default: 'div'
	  },
	  caption: {
	    type: String
	  },
	  captionHtml: {
	    type: String
	  },
	  captionTag: {
	    type: String,
	    default: 'h3'
	  },
	  text: {
	    type: String
	  },
	  textHtml: {
	    type: String
	  },
	  textTag: {
	    type: String,
	    default: 'p'
	  },
	  background: {
	    type: String
	  }
	}; // @vue/component

	var BCarouselSlide =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BCarouselSlide',
	  mixins: [idMixin, normalizeSlotMixin],
	  inject: {
	    bvCarousel: {
	      default: function _default() {
	        return {
	          // Explicitly disable touch if not a child of carousel
	          noTouch: true
	        };
	      }
	    }
	  },
	  props: props$i,
	  computed: {
	    contentClasses: function contentClasses() {
	      return [this.contentVisibleUp ? 'd-none' : '', this.contentVisibleUp ? "d-".concat(this.contentVisibleUp, "-block") : ''];
	    },
	    computedWidth: function computedWidth() {
	      // Use local width, or try parent width
	      return this.imgWidth || this.bvCarousel.imgWidth || null;
	    },
	    computedHeight: function computedHeight() {
	      // Use local height, or try parent height
	      return this.imgHeight || this.bvCarousel.imgHeight || null;
	    }
	  },
	  render: function render(h) {
	    var noDrag = !this.bvCarousel.noTouch && hasTouchSupport;
	    var img = this.normalizeSlot('img');

	    if (!img && (this.imgSrc || this.imgBlank)) {
	      img = h(BImg, {
	        props: {
	          fluidGrow: true,
	          block: true,
	          src: this.imgSrc,
	          blank: this.imgBlank,
	          blankColor: this.imgBlankColor,
	          width: this.computedWidth,
	          height: this.computedHeight,
	          alt: this.imgAlt
	        },
	        // Touch support event handler
	        on: noDrag ? {
	          dragstart: function dragstart(e) {
	            /* istanbul ignore next: difficult to test in JSDOM */
	            e.preventDefault();
	          }
	        } : {}
	      });
	    }

	    if (!img) {
	      img = h();
	    }

	    var content = h();
	    var contentChildren = [this.caption || this.captionHtml ? h(this.captionTag, {
	      domProps: htmlOrText(this.captionHtml, this.caption)
	    }) : false, this.text || this.textHtml ? h(this.textTag, {
	      domProps: htmlOrText(this.textHtml, this.text)
	    }) : false, this.normalizeSlot('default') || false];

	    if (contentChildren.some(Boolean)) {
	      content = h(this.contentTag, {
	        staticClass: 'carousel-caption',
	        class: this.contentClasses
	      }, contentChildren.map(function (i) {
	        return i || h();
	      }));
	    }

	    return h('div', {
	      staticClass: 'carousel-item',
	      style: {
	        background: this.background || this.bvCarousel.background || null
	      },
	      attrs: {
	        id: this.safeId(),
	        role: 'listitem'
	      }
	    }, [img, content]);
	  }
	});

	var CarouselPlugin =
	/*#__PURE*/
	pluginFactory({
	  components: {
	    BCarousel: BCarousel,
	    BCarouselSlide: BCarouselSlide
	  }
	});

	/**
	 * Issue #569: collapse::toggle::state triggered too many times
	 * @link https://github.com/bootstrap-vue/bootstrap-vue/issues/569
	 */
	// @vue/component
	var listenOnRootMixin = {
	  methods: {
	    /**
	     * Safely register event listeners on the root Vue node.
	     * While Vue automatically removes listeners for individual components,
	     * when a component registers a listener on root and is destroyed,
	     * this orphans a callback because the node is gone,
	     * but the root does not clear the callback.
	     *
	     * When registering a $root listener, it also registers a listener on
	     * the component's `beforeDestroy` hook to automatically remove the
	     * event listener from the $root instance.
	     *
	     * @param {string} event
	     * @param {function} callback
	     * @chainable
	     */
	    listenOnRoot: function listenOnRoot(event, callback) {
	      var _this = this;

	      this.$root.$on(event, callback);
	      this.$on('hook:beforeDestroy', function () {
	        _this.$root.$off(event, callback);
	      }); // Return this for easy chaining

	      return this;
	    },

	    /**
	     * Safely register a $once event listener on the root Vue node.
	     * While Vue automatically removes listeners for individual components,
	     * when a component registers a listener on root and is destroyed,
	     * this orphans a callback because the node is gone,
	     * but the root does not clear the callback.
	     *
	     * When registering a $root listener, it also registers a listener on
	     * the component's `beforeDestroy` hook to automatically remove the
	     * event listener from the $root instance.
	     *
	     * @param {string} event
	     * @param {function} callback
	     * @chainable
	     */
	    listenOnRootOnce: function listenOnRootOnce(event, callback) {
	      var _this2 = this;

	      this.$root.$once(event, callback);
	      this.$on('hook:beforeDestroy', function () {
	        _this2.$root.$off(event, callback);
	      }); // Return this for easy chaining

	      return this;
	    },

	    /**
	     * Convenience method for calling vm.$emit on vm.$root.
	     * @param {string} event
	     * @param {*} args
	     * @chainable
	     */
	    emitOnRoot: function emitOnRoot(event) {
	      var arguments$1 = arguments;

	      var _this$$root;

	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments$1[_key];
	      }

	      (_this$$root = this.$root).$emit.apply(_this$$root, [event].concat(args)); // Return this for easy chaining


	      return this;
	    }
	  }
	};

	var EVENT_STATE = 'bv::collapse::state';
	var EVENT_ACCORDION = 'bv::collapse::accordion'; // Private event we emit on `$root` to ensure the toggle state is
	// always synced. It gets emitted even if the state has not changed!
	// This event is NOT to be documented as people should not be using it

	var EVENT_STATE_SYNC = 'bv::collapse::sync::state'; // Events we listen to on `$root`

	var EVENT_TOGGLE = 'bv::toggle::collapse';
	var EVENT_STATE_REQUEST = 'bv::request::collapse::state'; // Event listener options

	var EventOptions$1 = {
	  passive: true,
	  capture: false
	}; // @vue/component

	var BCollapse =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BCollapse',
	  mixins: [idMixin, listenOnRootMixin, normalizeSlotMixin],
	  model: {
	    prop: 'visible',
	    event: 'input'
	  },
	  props: {
	    isNav: {
	      type: Boolean,
	      default: false
	    },
	    accordion: {
	      type: String,
	      default: null
	    },
	    visible: {
	      type: Boolean,
	      default: false
	    },
	    tag: {
	      type: String,
	      default: 'div'
	    }
	  },
	  data: function data() {
	    return {
	      show: this.visible,
	      transitioning: false
	    };
	  },
	  computed: {
	    classObject: function classObject() {
	      return {
	        'navbar-collapse': this.isNav,
	        collapse: !this.transitioning,
	        show: this.show && !this.transitioning
	      };
	    }
	  },
	  watch: {
	    visible: function visible(newVal) {
	      if (newVal !== this.show) {
	        this.show = newVal;
	      }
	    },
	    show: function show(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        this.emitState();
	      }
	    }
	  },
	  created: function created() {
	    this.show = this.visible;
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.show = this.visible; // Listen for toggle events to open/close us

	    this.listenOnRoot(EVENT_TOGGLE, this.handleToggleEvt); // Listen to other collapses for accordion events

	    this.listenOnRoot(EVENT_ACCORDION, this.handleAccordionEvt);

	    if (this.isNav) {
	      // Set up handlers
	      this.setWindowEvents(true);
	      this.handleResize();
	    }

	    this.$nextTick(function () {
	      _this.emitState();
	    }); // Listen for "Sync state" requests from `v-b-toggle`

	    this.listenOnRoot(EVENT_STATE_REQUEST, function (id) {
	      if (id === _this.safeId()) {
	        _this.$nextTick(_this.emitSync);
	      }
	    });
	  },
	  updated: function updated() {
	    // Emit a private event every time this component updates to ensure
	    // the toggle button is in sync with the collapse's state
	    // It is emitted regardless if the visible state changes
	    this.emitSync();
	  },
	  deactivated: function deactivated()
	  /* istanbul ignore next */
	  {
	    if (this.isNav) {
	      this.setWindowEvents(false);
	    }
	  },
	  activated: function activated()
	  /* istanbul ignore next */
	  {
	    if (this.isNav) {
	      this.setWindowEvents(true);
	    }

	    this.emitSync();
	  },
	  beforeDestroy: function beforeDestroy() {
	    // Trigger state emit if needed
	    this.show = false;

	    if (this.isNav && isBrowser) {
	      this.setWindowEvents(false);
	    }
	  },
	  methods: {
	    setWindowEvents: function setWindowEvents(on) {
	      var method = on ? eventOn : eventOff;
	      method(window, 'resize', this.handleResize, EventOptions$1);
	      method(window, 'orientationchange', this.handleResize, EventOptions$1);
	    },
	    toggle: function toggle() {
	      this.show = !this.show;
	    },
	    onEnter: function onEnter(el) {
	      el.style.height = 0;
	      reflow(el);
	      el.style.height = el.scrollHeight + 'px';
	      this.transitioning = true; // This should be moved out so we can add cancellable events

	      this.$emit('show');
	    },
	    onAfterEnter: function onAfterEnter(el) {
	      el.style.height = null;
	      this.transitioning = false;
	      this.$emit('shown');
	    },
	    onLeave: function onLeave(el) {
	      el.style.height = 'auto';
	      el.style.display = 'block';
	      el.style.height = getBCR(el).height + 'px';
	      reflow(el);
	      this.transitioning = true;
	      el.style.height = 0; // This should be moved out so we can add cancellable events

	      this.$emit('hide');
	    },
	    onAfterLeave: function onAfterLeave(el) {
	      el.style.height = null;
	      this.transitioning = false;
	      this.$emit('hidden');
	    },
	    emitState: function emitState() {
	      this.$emit('input', this.show); // Let v-b-toggle know the state of this collapse

	      this.$root.$emit(EVENT_STATE, this.safeId(), this.show);

	      if (this.accordion && this.show) {
	        // Tell the other collapses in this accordion to close
	        this.$root.$emit(EVENT_ACCORDION, this.safeId(), this.accordion);
	      }
	    },
	    emitSync: function emitSync() {
	      // Emit a private event every time this component updates to ensure
	      // the toggle button is in sync with the collapse's state
	      // It is emitted regardless if the visible state changes
	      this.$root.$emit(EVENT_STATE_SYNC, this.safeId(), this.show);
	    },
	    checkDisplayBlock: function checkDisplayBlock() {
	      // Check to see if the collapse has `display: block !important;` set.
	      // We can't set `display: none;` directly on this.$el, as it would
	      // trigger a new transition to start (or cancel a current one).
	      var restore = hasClass(this.$el, 'show');
	      removeClass(this.$el, 'show');
	      var isBlock = getCS(this.$el).display === 'block';
	      restore && addClass(this.$el, 'show');
	      return isBlock;
	    },
	    clickHandler: function clickHandler(evt) {
	      // If we are in a nav/navbar, close the collapse when non-disabled link clicked
	      var el = evt.target;

	      if (!this.isNav || !el || getCS(this.$el).display !== 'block') {
	        /* istanbul ignore next: can't test getComputedStyle in JSDOM */
	        return;
	      }

	      if (matches(el, '.nav-link,.dropdown-item') || closest('.nav-link,.dropdown-item', el)) {
	        if (!this.checkDisplayBlock()) {
	          // Only close the collapse if it is not forced to be 'display: block !important;'
	          this.show = false;
	        }
	      }
	    },
	    handleToggleEvt: function handleToggleEvt(target) {
	      if (target !== this.safeId()) {
	        return;
	      }

	      this.toggle();
	    },
	    handleAccordionEvt: function handleAccordionEvt(openedId, accordion) {
	      if (!this.accordion || accordion !== this.accordion) {
	        return;
	      }

	      if (openedId === this.safeId()) {
	        // Open this collapse if not shown
	        if (!this.show) {
	          this.toggle();
	        }
	      } else {
	        // Close this collapse if shown
	        if (this.show) {
	          this.toggle();
	        }
	      }
	    },
	    handleResize: function handleResize() {
	      // Handler for orientation/resize to set collapsed state in nav/navbar
	      this.show = getCS(this.$el).display === 'block';
	    }
	  },
	  render: function render(h) {
	    var content = h(this.tag, {
	      class: this.classObject,
	      directives: [{
	        name: 'show',
	        value: this.show
	      }],
	      attrs: {
	        id: this.safeId()
	      },
	      on: {
	        click: this.clickHandler
	      }
	    }, [this.normalizeSlot('default')]);
	    return h('transition', {
	      props: {
	        enterClass: '',
	        enterActiveClass: 'collapsing',
	        enterToClass: '',
	        leaveClass: '',
	        leaveActiveClass: 'collapsing',
	        leaveToClass: ''
	      },
	      on: {
	        enter: this.onEnter,
	        afterEnter: this.onAfterEnter,
	        leave: this.onLeave,
	        afterLeave: this.onAfterLeave
	      }
	    }, [content]);
	  }
	});

	var allListenTypes = {
	  hover: true,
	  click: true,
	  focus: true
	};
	var BVBoundListeners = '__BV_boundEventListeners__';

	var getTargets = function getTargets(binding) {
	  var targets = keys$2(binding.modifiers || {}).filter(function (t) {
	    return !allListenTypes[t];
	  });

	  if (binding.value) {
	    targets.push(binding.value);
	  }

	  return targets;
	};

	var bindTargets = function bindTargets(vnode, binding, listenTypes, fn) {
	  var targets = getTargets(binding);

	  var listener = function listener() {
	    fn({
	      targets: targets,
	      vnode: vnode
	    });
	  };

	  keys$2(allListenTypes).forEach(function (type) {
	    if (listenTypes[type] || binding.modifiers[type]) {
	      eventOn(vnode.elm, type, listener);
	      var boundListeners = vnode.elm[BVBoundListeners] || {};
	      boundListeners[type] = boundListeners[type] || [];
	      boundListeners[type].push(listener);
	      vnode.elm[BVBoundListeners] = boundListeners;
	    }
	  }); // Return the list of targets

	  return targets;
	};

	var unbindTargets = function unbindTargets(vnode, binding, listenTypes) {
	  keys$2(allListenTypes).forEach(function (type) {
	    if (listenTypes[type] || binding.modifiers[type]) {
	      var boundListeners = vnode.elm[BVBoundListeners] && vnode.elm[BVBoundListeners][type];

	      if (boundListeners) {
	        boundListeners.forEach(function (listener) {
	          return eventOff(vnode.elm, type, listener);
	        });
	        delete vnode.elm[BVBoundListeners][type];
	      }
	    }
	  });
	};

	var listenTypes = {
	  click: true
	}; // Property key for handler storage

	var BV_TOGGLE = '__BV_toggle__';
	var BV_TOGGLE_STATE = '__BV_toggle_STATE__';
	var BV_TOGGLE_CONTROLS = '__BV_toggle_CONTROLS__';
	var BV_TOGGLE_TARGETS = '__BV_toggle_TARGETS__'; // Emitted control event for collapse (emitted to collapse)

	var EVENT_TOGGLE$1 = 'bv::toggle::collapse'; // Listen to event for toggle state update (emitted by collapse)

	var EVENT_STATE$1 = 'bv::collapse::state'; // Private event emitted on $root to ensure the toggle state is always synced.
	// Gets emitted even if the state of b-collapse has not changed.
	// This event is NOT to be documented as people should not be using it.

	var EVENT_STATE_SYNC$1 = 'bv::collapse::sync::state'; // Private event we send to collapse to request state update sync event

	var EVENT_STATE_REQUEST$1 = 'bv::request::collapse::state'; // Reset and remove a property from the provided element

	var resetProp = function resetProp(el, prop) {
	  el[prop] = null;
	  delete el[prop];
	}; // Handle targets update


	var handleTargets = function handleTargets(_ref) {
	  var targets = _ref.targets,
	      vnode = _ref.vnode;
	  targets.forEach(function (target) {
	    vnode.context.$root.$emit(EVENT_TOGGLE$1, target);
	  });
	}; // Handle directive updates

	/* istanbul ignore next: not easy to test */


	var handleUpdate = function handleUpdate(el, binding, vnode) {
	  if (!isBrowser) {
	    return;
	  }

	  if (!looseEqual(getTargets(binding), el[BV_TOGGLE_TARGETS])) {
	    // Targets have changed, so update accordingly
	    unbindTargets(vnode, binding, listenTypes);
	    var targets = bindTargets(vnode, binding, listenTypes, handleTargets); // Update targets array to element

	    el[BV_TOGGLE_TARGETS] = targets; // Add aria attributes to element

	    el[BV_TOGGLE_CONTROLS] = targets.join(' '); // ensure aria-controls is up to date

	    setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS]); // Request a state update from targets so that we can ensure
	    // expanded state is correct

	    targets.forEach(function (target) {
	      vnode.context.$root.$emit(EVENT_STATE_REQUEST$1, target);
	    });
	  } // Ensure the collapse class and aria-* attributes persist
	  // after element is updated (either by parent re-rendering
	  // or changes to this element or it's contents


	  if (el[BV_TOGGLE_STATE] === true) {
	    addClass(el, 'collapsed');
	    setAttr(el, 'aria-expanded', 'true');
	  } else if (el[BV_TOGGLE_STATE] === false) {
	    removeClass(el, 'collapsed');
	    setAttr(el, 'aria-expanded', 'false');
	  }

	  setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS]);
	};
	/*
	 * Export our directive
	 */


	var VBToggle = {
	  bind: function bind(el, binding, vnode) {
	    var targets = bindTargets(vnode, binding, listenTypes, handleTargets);

	    if (isBrowser && vnode.context && targets.length > 0) {
	      // Add targets array to element
	      el[BV_TOGGLE_TARGETS] = targets; // Add aria attributes to element

	      el[BV_TOGGLE_CONTROLS] = targets.join(' '); // State is initially collapsed until we receive a state event

	      el[BV_TOGGLE_STATE] = false;
	      setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS]);
	      setAttr(el, 'aria-expanded', 'false'); // If element is not a button, we add `role="button"` for accessibility

	      if (el.tagName !== 'BUTTON' && !hasAttr(el, 'role')) {
	        setAttr(el, 'role', 'button');
	      } // Toggle state handler


	      var toggleDirectiveHandler = function toggleDirectiveHandler(id, state) {
	        var targets = el[BV_TOGGLE_TARGETS] || [];

	        if (targets.indexOf(id) !== -1) {
	          // Set aria-expanded state
	          setAttr(el, 'aria-expanded', state ? 'true' : 'false'); // Set/Clear 'collapsed' class state

	          el[BV_TOGGLE_STATE] = state;

	          if (state) {
	            removeClass(el, 'collapsed');
	          } else {
	            addClass(el, 'collapsed');
	          }
	        }
	      }; // Store the toggle handler on the element


	      el[BV_TOGGLE] = toggleDirectiveHandler; // Listen for toggle state changes (public)

	      vnode.context.$root.$on(EVENT_STATE$1, el[BV_TOGGLE]); // Listen for toggle state sync (private)

	      vnode.context.$root.$on(EVENT_STATE_SYNC$1, el[BV_TOGGLE]);
	    }
	  },
	  componentUpdated: handleUpdate,
	  updated: handleUpdate,
	  unbind: function unbind(el, binding, vnode)
	  /* istanbul ignore next */
	  {
	    unbindTargets(vnode, binding, listenTypes); // Remove our $root listener

	    if (el[BV_TOGGLE]) {
	      vnode.context.$root.$off(EVENT_STATE$1, el[BV_TOGGLE]);
	      vnode.context.$root.$off(EVENT_STATE_SYNC$1, el[BV_TOGGLE]);
	    } // Reset custom  props


	    resetProp(el, BV_TOGGLE);
	    resetProp(el, BV_TOGGLE_STATE);
	    resetProp(el, BV_TOGGLE_CONTROLS);
	    resetProp(el, BV_TOGGLE_TARGETS); // Reset classes/attrs

	    removeClass(el, 'collapsed');
	    removeAttr(el, 'aria-expanded');
	    removeAttr(el, 'aria-controls');
	    removeAttr(el, 'role');
	  }
	};

	var CollapsePlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BCollapse: BCollapse
	  },
	  directives: {
	    VBToggle: VBToggle
	  }
	});

	/**!
	 * @fileOverview Kickass library to create and place poppers near their reference elements.
	 * @version 1.16.0
	 * @license
	 * Copyright (c) 2016 Federico Zivolo and contributors
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */
	var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

	var timeoutDuration = function () {
	  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
	  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
	    if (isBrowser$1 && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
	      return 1;
	    }
	  }
	  return 0;
	}();

	function microtaskDebounce(fn) {
	  var called = false;
	  return function () {
	    if (called) {
	      return;
	    }
	    called = true;
	    window.Promise.resolve().then(function () {
	      called = false;
	      fn();
	    });
	  };
	}

	function taskDebounce(fn) {
	  var scheduled = false;
	  return function () {
	    if (!scheduled) {
	      scheduled = true;
	      setTimeout(function () {
	        scheduled = false;
	        fn();
	      }, timeoutDuration);
	    }
	  };
	}

	var supportsMicroTasks = isBrowser$1 && window.Promise;

	/**
	* Create a debounced version of a method, that's asynchronously deferred
	* but called in the minimum time possible.
	*
	* @method
	* @memberof Popper.Utils
	* @argument {Function} fn
	* @returns {Function}
	*/
	var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

	/**
	 * Check if the given variable is a function
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Any} functionToCheck - variable to check
	 * @returns {Boolean} answer to: is a function?
	 */
	function isFunction$1(functionToCheck) {
	  var getType = {};
	  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
	}

	/**
	 * Get CSS computed property of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Eement} element
	 * @argument {String} property
	 */
	function getStyleComputedProperty(element, property) {
	  if (element.nodeType !== 1) {
	    return [];
	  }
	  // NOTE: 1 DOM access here
	  var window = element.ownerDocument.defaultView;
	  var css = window.getComputedStyle(element, null);
	  return property ? css[property] : css;
	}

	/**
	 * Returns the parentNode or the host of the element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} parent
	 */
	function getParentNode(element) {
	  if (element.nodeName === 'HTML') {
	    return element;
	  }
	  return element.parentNode || element.host;
	}

	/**
	 * Returns the scrolling parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} scroll parent
	 */
	function getScrollParent(element) {
	  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
	  if (!element) {
	    return document.body;
	  }

	  switch (element.nodeName) {
	    case 'HTML':
	    case 'BODY':
	      return element.ownerDocument.body;
	    case '#document':
	      return element.body;
	  }

	  // Firefox want us to check `-x` and `-y` variations as well

	  var _getStyleComputedProp = getStyleComputedProperty(element),
	      overflow = _getStyleComputedProp.overflow,
	      overflowX = _getStyleComputedProp.overflowX,
	      overflowY = _getStyleComputedProp.overflowY;

	  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
	    return element;
	  }

	  return getScrollParent(getParentNode(element));
	}

	/**
	 * Returns the reference node of the reference object, or the reference object itself.
	 * @method
	 * @memberof Popper.Utils
	 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
	 * @returns {Element} parent
	 */
	function getReferenceNode(reference) {
	  return reference && reference.referenceNode ? reference.referenceNode : reference;
	}

	var isIE11 = isBrowser$1 && !!(window.MSInputMethodContext && document.documentMode);
	var isIE10 = isBrowser$1 && /MSIE 10/.test(navigator.userAgent);

	/**
	 * Determines if the browser is Internet Explorer
	 * @method
	 * @memberof Popper.Utils
	 * @param {Number} version to check
	 * @returns {Boolean} isIE
	 */
	function isIE$1(version) {
	  if (version === 11) {
	    return isIE11;
	  }
	  if (version === 10) {
	    return isIE10;
	  }
	  return isIE11 || isIE10;
	}

	/**
	 * Returns the offset parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} offset parent
	 */
	function getOffsetParent(element) {
	  if (!element) {
	    return document.documentElement;
	  }

	  var noOffsetParent = isIE$1(10) ? document.body : null;

	  // NOTE: 1 DOM access here
	  var offsetParent = element.offsetParent || null;
	  // Skip hidden elements which don't have an offsetParent
	  while (offsetParent === noOffsetParent && element.nextElementSibling) {
	    offsetParent = (element = element.nextElementSibling).offsetParent;
	  }

	  var nodeName = offsetParent && offsetParent.nodeName;

	  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
	    return element ? element.ownerDocument.documentElement : document.documentElement;
	  }

	  // .offsetParent will return the closest TH, TD or TABLE in case
	  // no offsetParent is present, I hate this job...
	  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
	    return getOffsetParent(offsetParent);
	  }

	  return offsetParent;
	}

	function isOffsetContainer(element) {
	  var nodeName = element.nodeName;

	  if (nodeName === 'BODY') {
	    return false;
	  }
	  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
	}

	/**
	 * Finds the root node (document, shadowDOM root) of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} node
	 * @returns {Element} root node
	 */
	function getRoot(node) {
	  if (node.parentNode !== null) {
	    return getRoot(node.parentNode);
	  }

	  return node;
	}

	/**
	 * Finds the offset parent common to the two provided nodes
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element1
	 * @argument {Element} element2
	 * @returns {Element} common offset parent
	 */
	function findCommonOffsetParent(element1, element2) {
	  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
	  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
	    return document.documentElement;
	  }

	  // Here we make sure to give as "start" the element that comes first in the DOM
	  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
	  var start = order ? element1 : element2;
	  var end = order ? element2 : element1;

	  // Get common ancestor container
	  var range = document.createRange();
	  range.setStart(start, 0);
	  range.setEnd(end, 0);
	  var commonAncestorContainer = range.commonAncestorContainer;

	  // Both nodes are inside #document

	  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
	    if (isOffsetContainer(commonAncestorContainer)) {
	      return commonAncestorContainer;
	    }

	    return getOffsetParent(commonAncestorContainer);
	  }

	  // one of the nodes is inside shadowDOM, find which one
	  var element1root = getRoot(element1);
	  if (element1root.host) {
	    return findCommonOffsetParent(element1root.host, element2);
	  } else {
	    return findCommonOffsetParent(element1, getRoot(element2).host);
	  }
	}

	/**
	 * Gets the scroll value of the given element in the given side (top and left)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {String} side `top` or `left`
	 * @returns {number} amount of scrolled pixels
	 */
	function getScroll(element) {
	  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

	  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
	  var nodeName = element.nodeName;

	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    var html = element.ownerDocument.documentElement;
	    var scrollingElement = element.ownerDocument.scrollingElement || html;
	    return scrollingElement[upperSide];
	  }

	  return element[upperSide];
	}

	/*
	 * Sum or subtract the element scroll values (left and top) from a given rect object
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} rect - Rect object you want to change
	 * @param {HTMLElement} element - The element from the function reads the scroll values
	 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
	 * @return {Object} rect - The modifier rect object
	 */
	function includeScroll(rect, element) {
	  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  var scrollTop = getScroll(element, 'top');
	  var scrollLeft = getScroll(element, 'left');
	  var modifier = subtract ? -1 : 1;
	  rect.top += scrollTop * modifier;
	  rect.bottom += scrollTop * modifier;
	  rect.left += scrollLeft * modifier;
	  rect.right += scrollLeft * modifier;
	  return rect;
	}

	/*
	 * Helper to detect borders of a given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {CSSStyleDeclaration} styles
	 * Result of `getStyleComputedProperty` on the given element
	 * @param {String} axis - `x` or `y`
	 * @return {number} borders - The borders size of the given axis
	 */

	function getBordersSize(styles, axis) {
	  var sideA = axis === 'x' ? 'Left' : 'Top';
	  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

	  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
	}

	function getSize(axis, body, html, computedStyle) {
	  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE$1(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
	}

	function getWindowSizes(document) {
	  var body = document.body;
	  var html = document.documentElement;
	  var computedStyle = isIE$1(10) && getComputedStyle(html);

	  return {
	    height: getSize('Height', body, html, computedStyle),
	    width: getSize('Width', body, html, computedStyle)
	  };
	}

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) { descriptor.writable = true; }
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) { defineProperties(Constructor.prototype, protoProps); }
	    if (staticProps) { defineProperties(Constructor, staticProps); }
	    return Constructor;
	  };
	}();





	var defineProperty$2 = function (obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

	var _extends = Object.assign || function (target) {
	  var arguments$1 = arguments;

	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments$1[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

	/**
	 * Given element offsets, generate an output similar to getBoundingClientRect
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} offsets
	 * @returns {Object} ClientRect like output
	 */
	function getClientRect(offsets) {
	  return _extends({}, offsets, {
	    right: offsets.left + offsets.width,
	    bottom: offsets.top + offsets.height
	  });
	}

	/**
	 * Get bounding client rect of given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} element
	 * @return {Object} client rect
	 */
	function getBoundingClientRect(element) {
	  var rect = {};

	  // IE10 10 FIX: Please, don't ask, the element isn't
	  // considered in DOM in some circumstances...
	  // This isn't reproducible in IE10 compatibility mode of IE11
	  try {
	    if (isIE$1(10)) {
	      rect = element.getBoundingClientRect();
	      var scrollTop = getScroll(element, 'top');
	      var scrollLeft = getScroll(element, 'left');
	      rect.top += scrollTop;
	      rect.left += scrollLeft;
	      rect.bottom += scrollTop;
	      rect.right += scrollLeft;
	    } else {
	      rect = element.getBoundingClientRect();
	    }
	  } catch (e) {}

	  var result = {
	    left: rect.left,
	    top: rect.top,
	    width: rect.right - rect.left,
	    height: rect.bottom - rect.top
	  };

	  // subtract scrollbar size from sizes
	  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
	  var width = sizes.width || element.clientWidth || result.width;
	  var height = sizes.height || element.clientHeight || result.height;

	  var horizScrollbar = element.offsetWidth - width;
	  var vertScrollbar = element.offsetHeight - height;

	  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
	  // we make this check conditional for performance reasons
	  if (horizScrollbar || vertScrollbar) {
	    var styles = getStyleComputedProperty(element);
	    horizScrollbar -= getBordersSize(styles, 'x');
	    vertScrollbar -= getBordersSize(styles, 'y');

	    result.width -= horizScrollbar;
	    result.height -= vertScrollbar;
	  }

	  return getClientRect(result);
	}

	function getOffsetRectRelativeToArbitraryNode(children, parent) {
	  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  var isIE10 = isIE$1(10);
	  var isHTML = parent.nodeName === 'HTML';
	  var childrenRect = getBoundingClientRect(children);
	  var parentRect = getBoundingClientRect(parent);
	  var scrollParent = getScrollParent(children);

	  var styles = getStyleComputedProperty(parent);
	  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
	  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

	  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
	  if (fixedPosition && isHTML) {
	    parentRect.top = Math.max(parentRect.top, 0);
	    parentRect.left = Math.max(parentRect.left, 0);
	  }
	  var offsets = getClientRect({
	    top: childrenRect.top - parentRect.top - borderTopWidth,
	    left: childrenRect.left - parentRect.left - borderLeftWidth,
	    width: childrenRect.width,
	    height: childrenRect.height
	  });
	  offsets.marginTop = 0;
	  offsets.marginLeft = 0;

	  // Subtract margins of documentElement in case it's being used as parent
	  // we do this only on HTML because it's the only element that behaves
	  // differently when margins are applied to it. The margins are included in
	  // the box of the documentElement, in the other cases not.
	  if (!isIE10 && isHTML) {
	    var marginTop = parseFloat(styles.marginTop, 10);
	    var marginLeft = parseFloat(styles.marginLeft, 10);

	    offsets.top -= borderTopWidth - marginTop;
	    offsets.bottom -= borderTopWidth - marginTop;
	    offsets.left -= borderLeftWidth - marginLeft;
	    offsets.right -= borderLeftWidth - marginLeft;

	    // Attach marginTop and marginLeft because in some circumstances we may need them
	    offsets.marginTop = marginTop;
	    offsets.marginLeft = marginLeft;
	  }

	  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
	    offsets = includeScroll(offsets, parent);
	  }

	  return offsets;
	}

	function getViewportOffsetRectRelativeToArtbitraryNode(element) {
	  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  var html = element.ownerDocument.documentElement;
	  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
	  var width = Math.max(html.clientWidth, window.innerWidth || 0);
	  var height = Math.max(html.clientHeight, window.innerHeight || 0);

	  var scrollTop = !excludeScroll ? getScroll(html) : 0;
	  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

	  var offset = {
	    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
	    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
	    width: width,
	    height: height
	  };

	  return getClientRect(offset);
	}

	/**
	 * Check if the given element is fixed or is inside a fixed parent
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {Element} customContainer
	 * @returns {Boolean} answer to "isFixed?"
	 */
	function isFixed(element) {
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    return false;
	  }
	  if (getStyleComputedProperty(element, 'position') === 'fixed') {
	    return true;
	  }
	  var parentNode = getParentNode(element);
	  if (!parentNode) {
	    return false;
	  }
	  return isFixed(parentNode);
	}

	/**
	 * Finds the first parent of an element that has a transformed property defined
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} first transformed parent or documentElement
	 */

	function getFixedPositionOffsetParent(element) {
	  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
	  if (!element || !element.parentElement || isIE$1()) {
	    return document.documentElement;
	  }
	  var el = element.parentElement;
	  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
	    el = el.parentElement;
	  }
	  return el || document.documentElement;
	}

	/**
	 * Computed the boundaries limits and return them
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} popper
	 * @param {HTMLElement} reference
	 * @param {number} padding
	 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
	 * @param {Boolean} fixedPosition - Is in fixed position mode
	 * @returns {Object} Coordinates of the boundaries
	 */
	function getBoundaries(popper, reference, padding, boundariesElement) {
	  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

	  // NOTE: 1 DOM access here

	  var boundaries = { top: 0, left: 0 };
	  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

	  // Handle viewport case
	  if (boundariesElement === 'viewport') {
	    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
	  } else {
	    // Handle other cases based on DOM element used as boundaries
	    var boundariesNode = void 0;
	    if (boundariesElement === 'scrollParent') {
	      boundariesNode = getScrollParent(getParentNode(reference));
	      if (boundariesNode.nodeName === 'BODY') {
	        boundariesNode = popper.ownerDocument.documentElement;
	      }
	    } else if (boundariesElement === 'window') {
	      boundariesNode = popper.ownerDocument.documentElement;
	    } else {
	      boundariesNode = boundariesElement;
	    }

	    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

	    // In case of HTML, we need a different computation
	    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
	      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
	          height = _getWindowSizes.height,
	          width = _getWindowSizes.width;

	      boundaries.top += offsets.top - offsets.marginTop;
	      boundaries.bottom = height + offsets.top;
	      boundaries.left += offsets.left - offsets.marginLeft;
	      boundaries.right = width + offsets.left;
	    } else {
	      // for all the other DOM elements, this one is good
	      boundaries = offsets;
	    }
	  }

	  // Add paddings
	  padding = padding || 0;
	  var isPaddingNumber = typeof padding === 'number';
	  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
	  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
	  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
	  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

	  return boundaries;
	}

	function getArea(_ref) {
	  var width = _ref.width,
	      height = _ref.height;

	  return width * height;
	}

	/**
	 * Utility used to transform the `auto` placement to the placement with more
	 * available space.
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
	  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

	  if (placement.indexOf('auto') === -1) {
	    return placement;
	  }

	  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

	  var rects = {
	    top: {
	      width: boundaries.width,
	      height: refRect.top - boundaries.top
	    },
	    right: {
	      width: boundaries.right - refRect.right,
	      height: boundaries.height
	    },
	    bottom: {
	      width: boundaries.width,
	      height: boundaries.bottom - refRect.bottom
	    },
	    left: {
	      width: refRect.left - boundaries.left,
	      height: boundaries.height
	    }
	  };

	  var sortedAreas = Object.keys(rects).map(function (key) {
	    return _extends({
	      key: key
	    }, rects[key], {
	      area: getArea(rects[key])
	    });
	  }).sort(function (a, b) {
	    return b.area - a.area;
	  });

	  var filteredAreas = sortedAreas.filter(function (_ref2) {
	    var width = _ref2.width,
	        height = _ref2.height;
	    return width >= popper.clientWidth && height >= popper.clientHeight;
	  });

	  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

	  var variation = placement.split('-')[1];

	  return computedPlacement + (variation ? '-' + variation : '');
	}

	/**
	 * Get offsets to the reference element
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} state
	 * @param {Element} popper - the popper element
	 * @param {Element} reference - the reference element (the popper will be relative to this)
	 * @param {Element} fixedPosition - is in fixed position mode
	 * @returns {Object} An object containing the offsets which will be applied to the popper
	 */
	function getReferenceOffsets(state, popper, reference) {
	  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
	  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
	}

	/**
	 * Get the outer sizes of the given element (offset size + margins)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Object} object containing width and height properties
	 */
	function getOuterSizes(element) {
	  var window = element.ownerDocument.defaultView;
	  var styles = window.getComputedStyle(element);
	  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
	  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
	  var result = {
	    width: element.offsetWidth + y,
	    height: element.offsetHeight + x
	  };
	  return result;
	}

	/**
	 * Get the opposite placement of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement
	 * @returns {String} flipped placement
	 */
	function getOppositePlacement(placement) {
	  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
	  return placement.replace(/left|right|bottom|top/g, function (matched) {
	    return hash[matched];
	  });
	}

	/**
	 * Get offsets to the popper
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} position - CSS position the Popper will get applied
	 * @param {HTMLElement} popper - the popper element
	 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
	 * @param {String} placement - one of the valid placement options
	 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
	 */
	function getPopperOffsets(popper, referenceOffsets, placement) {
	  placement = placement.split('-')[0];

	  // Get popper node sizes
	  var popperRect = getOuterSizes(popper);

	  // Add position, width and height to our offsets object
	  var popperOffsets = {
	    width: popperRect.width,
	    height: popperRect.height
	  };

	  // depending by the popper placement we have to compute its offsets slightly differently
	  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
	  var mainSide = isHoriz ? 'top' : 'left';
	  var secondarySide = isHoriz ? 'left' : 'top';
	  var measurement = isHoriz ? 'height' : 'width';
	  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

	  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
	  if (placement === secondarySide) {
	    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
	  } else {
	    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
	  }

	  return popperOffsets;
	}

	/**
	 * Mimics the `find` method of Array
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function find(arr, check) {
	  // use native find if supported
	  if (Array.prototype.find) {
	    return arr.find(check);
	  }

	  // use `filter` to obtain the same behavior of `find`
	  return arr.filter(check)[0];
	}

	/**
	 * Return the index of the matching object
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function findIndex(arr, prop, value) {
	  // use native findIndex if supported
	  if (Array.prototype.findIndex) {
	    return arr.findIndex(function (cur) {
	      return cur[prop] === value;
	    });
	  }

	  // use `find` + `indexOf` if `findIndex` isn't supported
	  var match = find(arr, function (obj) {
	    return obj[prop] === value;
	  });
	  return arr.indexOf(match);
	}

	/**
	 * Loop trough the list of modifiers and run them in order,
	 * each of them will then edit the data object.
	 * @method
	 * @memberof Popper.Utils
	 * @param {dataObject} data
	 * @param {Array} modifiers
	 * @param {String} ends - Optional modifier name used as stopper
	 * @returns {dataObject}
	 */
	function runModifiers(modifiers, data, ends) {
	  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

	  modifiersToRun.forEach(function (modifier) {
	    if (modifier['function']) {
	      // eslint-disable-line dot-notation
	      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
	    }
	    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
	    if (modifier.enabled && isFunction$1(fn)) {
	      // Add properties to offsets to make them a complete clientRect object
	      // we do this before each modifier to make sure the previous one doesn't
	      // mess with these values
	      data.offsets.popper = getClientRect(data.offsets.popper);
	      data.offsets.reference = getClientRect(data.offsets.reference);

	      data = fn(data, modifier);
	    }
	  });

	  return data;
	}

	/**
	 * Updates the position of the popper, computing the new offsets and applying
	 * the new style.<br />
	 * Prefer `scheduleUpdate` over `update` because of performance reasons.
	 * @method
	 * @memberof Popper
	 */
	function update() {
	  // if popper is destroyed, don't perform any further update
	  if (this.state.isDestroyed) {
	    return;
	  }

	  var data = {
	    instance: this,
	    styles: {},
	    arrowStyles: {},
	    attributes: {},
	    flipped: false,
	    offsets: {}
	  };

	  // compute reference element offsets
	  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit `placement` if needed
	  // and refer to originalPlacement to know the original value
	  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

	  // store the computed placement inside `originalPlacement`
	  data.originalPlacement = data.placement;

	  data.positionFixed = this.options.positionFixed;

	  // compute the popper offsets
	  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

	  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

	  // run the modifiers
	  data = runModifiers(this.modifiers, data);

	  // the first `update` will call `onCreate` callback
	  // the other ones will call `onUpdate` callback
	  if (!this.state.isCreated) {
	    this.state.isCreated = true;
	    this.options.onCreate(data);
	  } else {
	    this.options.onUpdate(data);
	  }
	}

	/**
	 * Helper used to know if the given modifier is enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @returns {Boolean}
	 */
	function isModifierEnabled(modifiers, modifierName) {
	  return modifiers.some(function (_ref) {
	    var name = _ref.name,
	        enabled = _ref.enabled;
	    return enabled && name === modifierName;
	  });
	}

	/**
	 * Get the prefixed supported property name
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} property (camelCase)
	 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
	 */
	function getSupportedPropertyName(property) {
	  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
	  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

	  for (var i = 0; i < prefixes.length; i++) {
	    var prefix = prefixes[i];
	    var toCheck = prefix ? '' + prefix + upperProp : property;
	    if (typeof document.body.style[toCheck] !== 'undefined') {
	      return toCheck;
	    }
	  }
	  return null;
	}

	/**
	 * Destroys the popper.
	 * @method
	 * @memberof Popper
	 */
	function destroy$1() {
	  this.state.isDestroyed = true;

	  // touch DOM only if `applyStyle` modifier is enabled
	  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
	    this.popper.removeAttribute('x-placement');
	    this.popper.style.position = '';
	    this.popper.style.top = '';
	    this.popper.style.left = '';
	    this.popper.style.right = '';
	    this.popper.style.bottom = '';
	    this.popper.style.willChange = '';
	    this.popper.style[getSupportedPropertyName('transform')] = '';
	  }

	  this.disableEventListeners();

	  // remove the popper if user explicitly asked for the deletion on destroy
	  // do not use `remove` because IE11 doesn't support it
	  if (this.options.removeOnDestroy) {
	    this.popper.parentNode.removeChild(this.popper);
	  }
	  return this;
	}

	/**
	 * Get the window associated with the element
	 * @argument {Element} element
	 * @returns {Window}
	 */
	function getWindow(element) {
	  var ownerDocument = element.ownerDocument;
	  return ownerDocument ? ownerDocument.defaultView : window;
	}

	function attachToScrollParents(scrollParent, event, callback, scrollParents) {
	  var isBody = scrollParent.nodeName === 'BODY';
	  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
	  target.addEventListener(event, callback, { passive: true });

	  if (!isBody) {
	    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
	  }
	  scrollParents.push(target);
	}

	/**
	 * Setup needed event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function setupEventListeners(reference, options, state, updateBound) {
	  // Resize event listener on window
	  state.updateBound = updateBound;
	  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

	  // Scroll event listener on scroll parents
	  var scrollElement = getScrollParent(reference);
	  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
	  state.scrollElement = scrollElement;
	  state.eventsEnabled = true;

	  return state;
	}

	/**
	 * It will add resize/scroll events and start recalculating
	 * position of the popper element when they are triggered.
	 * @method
	 * @memberof Popper
	 */
	function enableEventListeners() {
	  if (!this.state.eventsEnabled) {
	    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
	  }
	}

	/**
	 * Remove event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function removeEventListeners(reference, state) {
	  // Remove resize event listener on window
	  getWindow(reference).removeEventListener('resize', state.updateBound);

	  // Remove scroll event listener on scroll parents
	  state.scrollParents.forEach(function (target) {
	    target.removeEventListener('scroll', state.updateBound);
	  });

	  // Reset state
	  state.updateBound = null;
	  state.scrollParents = [];
	  state.scrollElement = null;
	  state.eventsEnabled = false;
	  return state;
	}

	/**
	 * It will remove resize/scroll events and won't recalculate popper position
	 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
	 * unless you call `update` method manually.
	 * @method
	 * @memberof Popper
	 */
	function disableEventListeners() {
	  if (this.state.eventsEnabled) {
	    cancelAnimationFrame(this.scheduleUpdate);
	    this.state = removeEventListeners(this.reference, this.state);
	  }
	}

	/**
	 * Tells if a given input is a number
	 * @method
	 * @memberof Popper.Utils
	 * @param {*} input to check
	 * @return {Boolean}
	 */
	function isNumeric(n) {
	  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
	}

	/**
	 * Set the style to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the style to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setStyles(element, styles) {
	  Object.keys(styles).forEach(function (prop) {
	    var unit = '';
	    // add unit if the value is numeric and is one of the following
	    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
	      unit = 'px';
	    }
	    element.style[prop] = styles[prop] + unit;
	  });
	}

	/**
	 * Set the attributes to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the attributes to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setAttributes(element, attributes) {
	  Object.keys(attributes).forEach(function (prop) {
	    var value = attributes[prop];
	    if (value !== false) {
	      element.setAttribute(prop, attributes[prop]);
	    } else {
	      element.removeAttribute(prop);
	    }
	  });
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} data.styles - List of style properties - values to apply to popper element
	 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The same data object
	 */
	function applyStyle(data) {
	  // any property present in `data.styles` will be applied to the popper,
	  // in this way we can make the 3rd party modifiers add custom styles to it
	  // Be aware, modifiers could override the properties defined in the previous
	  // lines of this modifier!
	  setStyles(data.instance.popper, data.styles);

	  // any property present in `data.attributes` will be applied to the popper,
	  // they will be set as HTML attributes of the element
	  setAttributes(data.instance.popper, data.attributes);

	  // if arrowElement is defined and arrowStyles has some properties
	  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
	    setStyles(data.arrowElement, data.arrowStyles);
	  }

	  return data;
	}

	/**
	 * Set the x-placement attribute before everything else because it could be used
	 * to add margins to the popper margins needs to be calculated to get the
	 * correct popper offsets.
	 * @method
	 * @memberof Popper.modifiers
	 * @param {HTMLElement} reference - The reference element used to position the popper
	 * @param {HTMLElement} popper - The HTML element used as popper
	 * @param {Object} options - Popper.js options
	 */
	function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
	  // compute reference element offsets
	  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit `placement` if needed
	  // and refer to originalPlacement to know the original value
	  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

	  popper.setAttribute('x-placement', placement);

	  // Apply `position` to popper before anything else because
	  // without the position applied we can't guarantee correct computations
	  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

	  return options;
	}

	/**
	 * @function
	 * @memberof Popper.Utils
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
	 * @returns {Object} The popper's position offsets rounded
	 *
	 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
	 * good as it can be within reason.
	 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
	 *
	 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
	 * as well on High DPI screens).
	 *
	 * Firefox prefers no rounding for positioning and does not have blurriness on
	 * high DPI screens.
	 *
	 * Only horizontal placement and left/right values need to be considered.
	 */
	function getRoundedOffsets(data, shouldRound) {
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;
	  var round = Math.round,
	      floor = Math.floor;

	  var noRound = function noRound(v) {
	    return v;
	  };

	  var referenceWidth = round(reference.width);
	  var popperWidth = round(popper.width);

	  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
	  var isVariation = data.placement.indexOf('-') !== -1;
	  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
	  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

	  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
	  var verticalToInteger = !shouldRound ? noRound : round;

	  return {
	    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
	    top: verticalToInteger(popper.top),
	    bottom: verticalToInteger(popper.bottom),
	    right: horizontalToInteger(popper.right)
	  };
	}

	var isFirefox = isBrowser$1 && /Firefox/i.test(navigator.userAgent);

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeStyle(data, options) {
	  var x = options.x,
	      y = options.y;
	  var popper = data.offsets.popper;

	  // Remove this legacy support in Popper.js v2

	  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'applyStyle';
	  }).gpuAcceleration;
	  if (legacyGpuAccelerationOption !== undefined) {
	    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
	  }
	  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

	  var offsetParent = getOffsetParent(data.instance.popper);
	  var offsetParentRect = getBoundingClientRect(offsetParent);

	  // Styles
	  var styles = {
	    position: popper.position
	  };

	  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

	  var sideA = x === 'bottom' ? 'top' : 'bottom';
	  var sideB = y === 'right' ? 'left' : 'right';

	  // if gpuAcceleration is set to `true` and transform is supported,
	  //  we use `translate3d` to apply the position to the popper we
	  // automatically use the supported prefixed version if needed
	  var prefixedProperty = getSupportedPropertyName('transform');

	  // now, let's make a step back and look at this code closely (wtf?)
	  // If the content of the popper grows once it's been positioned, it
	  // may happen that the popper gets misplaced because of the new content
	  // overflowing its reference element
	  // To avoid this problem, we provide two options (x and y), which allow
	  // the consumer to define the offset origin.
	  // If we position a popper on top of a reference element, we can set
	  // `x` to `top` to make the popper grow towards its top instead of
	  // its bottom.
	  var left = void 0,
	      top = void 0;
	  if (sideA === 'bottom') {
	    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
	    // and not the bottom of the html element
	    if (offsetParent.nodeName === 'HTML') {
	      top = -offsetParent.clientHeight + offsets.bottom;
	    } else {
	      top = -offsetParentRect.height + offsets.bottom;
	    }
	  } else {
	    top = offsets.top;
	  }
	  if (sideB === 'right') {
	    if (offsetParent.nodeName === 'HTML') {
	      left = -offsetParent.clientWidth + offsets.right;
	    } else {
	      left = -offsetParentRect.width + offsets.right;
	    }
	  } else {
	    left = offsets.left;
	  }
	  if (gpuAcceleration && prefixedProperty) {
	    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
	    styles[sideA] = 0;
	    styles[sideB] = 0;
	    styles.willChange = 'transform';
	  } else {
	    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
	    var invertTop = sideA === 'bottom' ? -1 : 1;
	    var invertLeft = sideB === 'right' ? -1 : 1;
	    styles[sideA] = top * invertTop;
	    styles[sideB] = left * invertLeft;
	    styles.willChange = sideA + ', ' + sideB;
	  }

	  // Attributes
	  var attributes = {
	    'x-placement': data.placement
	  };

	  // Update `data` attributes, styles and arrowStyles
	  data.attributes = _extends({}, attributes, data.attributes);
	  data.styles = _extends({}, styles, data.styles);
	  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

	  return data;
	}

	/**
	 * Helper used to know if the given modifier depends from another one.<br />
	 * It checks if the needed modifier is listed and enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @param {Array} modifiers - list of modifiers
	 * @param {String} requestingName - name of requesting modifier
	 * @param {String} requestedName - name of requested modifier
	 * @returns {Boolean}
	 */
	function isModifierRequired(modifiers, requestingName, requestedName) {
	  var requesting = find(modifiers, function (_ref) {
	    var name = _ref.name;
	    return name === requestingName;
	  });

	  var isRequired = !!requesting && modifiers.some(function (modifier) {
	    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
	  });

	  if (!isRequired) {
	    var _requesting = '`' + requestingName + '`';
	    var requested = '`' + requestedName + '`';
	    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
	  }
	  return isRequired;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function arrow(data, options) {
	  var _data$offsets$arrow;

	  // arrow depends on keepTogether in order to work
	  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
	    return data;
	  }

	  var arrowElement = options.element;

	  // if arrowElement is a string, suppose it's a CSS selector
	  if (typeof arrowElement === 'string') {
	    arrowElement = data.instance.popper.querySelector(arrowElement);

	    // if arrowElement is not found, don't run the modifier
	    if (!arrowElement) {
	      return data;
	    }
	  } else {
	    // if the arrowElement isn't a query selector we must check that the
	    // provided DOM node is child of its popper node
	    if (!data.instance.popper.contains(arrowElement)) {
	      console.warn('WARNING: `arrow.element` must be child of its popper element!');
	      return data;
	    }
	  }

	  var placement = data.placement.split('-')[0];
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

	  var len = isVertical ? 'height' : 'width';
	  var sideCapitalized = isVertical ? 'Top' : 'Left';
	  var side = sideCapitalized.toLowerCase();
	  var altSide = isVertical ? 'left' : 'top';
	  var opSide = isVertical ? 'bottom' : 'right';
	  var arrowElementSize = getOuterSizes(arrowElement)[len];

	  //
	  // extends keepTogether behavior making sure the popper and its
	  // reference have enough pixels in conjunction
	  //

	  // top/left side
	  if (reference[opSide] - arrowElementSize < popper[side]) {
	    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
	  }
	  // bottom/right side
	  if (reference[side] + arrowElementSize > popper[opSide]) {
	    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
	  }
	  data.offsets.popper = getClientRect(data.offsets.popper);

	  // compute center of the popper
	  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

	  // Compute the sideValue using the updated popper offsets
	  // take popper margin in account because we don't have this info available
	  var css = getStyleComputedProperty(data.instance.popper);
	  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
	  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
	  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

	  // prevent arrowElement from being placed not contiguously to its popper
	  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

	  data.arrowElement = arrowElement;
	  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$2(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$2(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

	  return data;
	}

	/**
	 * Get the opposite placement variation of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement variation
	 * @returns {String} flipped placement variation
	 */
	function getOppositeVariation(variation) {
	  if (variation === 'end') {
	    return 'start';
	  } else if (variation === 'start') {
	    return 'end';
	  }
	  return variation;
	}

	/**
	 * List of accepted placements to use as values of the `placement` option.<br />
	 * Valid placements are:
	 * - `auto`
	 * - `top`
	 * - `right`
	 * - `bottom`
	 * - `left`
	 *
	 * Each placement can have a variation from this list:
	 * - `-start`
	 * - `-end`
	 *
	 * Variations are interpreted easily if you think of them as the left to right
	 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
	 * is right.<br />
	 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
	 *
	 * Some valid examples are:
	 * - `top-end` (on top of reference, right aligned)
	 * - `right-start` (on right of reference, top aligned)
	 * - `bottom` (on bottom, centered)
	 * - `auto-end` (on the side with more space available, alignment depends by placement)
	 *
	 * @static
	 * @type {Array}
	 * @enum {String}
	 * @readonly
	 * @method placements
	 * @memberof Popper
	 */
	var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

	// Get rid of `auto` `auto-start` and `auto-end`
	var validPlacements = placements.slice(3);

	/**
	 * Given an initial placement, returns all the subsequent placements
	 * clockwise (or counter-clockwise).
	 *
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement - A valid placement (it accepts variations)
	 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
	 * @returns {Array} placements including their variations
	 */
	function clockwise(placement) {
	  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  var index = validPlacements.indexOf(placement);
	  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
	  return counter ? arr.reverse() : arr;
	}

	var BEHAVIORS = {
	  FLIP: 'flip',
	  CLOCKWISE: 'clockwise',
	  COUNTERCLOCKWISE: 'counterclockwise'
	};

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function flip(data, options) {
	  // if `inner` modifier is enabled, we can't use the `flip` modifier
	  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
	    return data;
	  }

	  if (data.flipped && data.placement === data.originalPlacement) {
	    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
	    return data;
	  }

	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

	  var placement = data.placement.split('-')[0];
	  var placementOpposite = getOppositePlacement(placement);
	  var variation = data.placement.split('-')[1] || '';

	  var flipOrder = [];

	  switch (options.behavior) {
	    case BEHAVIORS.FLIP:
	      flipOrder = [placement, placementOpposite];
	      break;
	    case BEHAVIORS.CLOCKWISE:
	      flipOrder = clockwise(placement);
	      break;
	    case BEHAVIORS.COUNTERCLOCKWISE:
	      flipOrder = clockwise(placement, true);
	      break;
	    default:
	      flipOrder = options.behavior;
	  }

	  flipOrder.forEach(function (step, index) {
	    if (placement !== step || flipOrder.length === index + 1) {
	      return data;
	    }

	    placement = data.placement.split('-')[0];
	    placementOpposite = getOppositePlacement(placement);

	    var popperOffsets = data.offsets.popper;
	    var refOffsets = data.offsets.reference;

	    // using floor because the reference offsets may contain decimals we are not going to consider here
	    var floor = Math.floor;
	    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

	    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
	    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
	    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
	    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

	    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

	    // flip the variation if required
	    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

	    // flips variation if reference element overflows boundaries
	    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

	    // flips variation if popper content overflows boundaries
	    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

	    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

	    if (overlapsRef || overflowsBoundaries || flippedVariation) {
	      // this boolean to detect any flip loop
	      data.flipped = true;

	      if (overlapsRef || overflowsBoundaries) {
	        placement = flipOrder[index + 1];
	      }

	      if (flippedVariation) {
	        variation = getOppositeVariation(variation);
	      }

	      data.placement = placement + (variation ? '-' + variation : '');

	      // this object contains `position`, we want to preserve it along with
	      // any additional property we may add in the future
	      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

	      data = runModifiers(data.instance.modifiers, data, 'flip');
	    }
	  });
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function keepTogether(data) {
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var placement = data.placement.split('-')[0];
	  var floor = Math.floor;
	  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	  var side = isVertical ? 'right' : 'bottom';
	  var opSide = isVertical ? 'left' : 'top';
	  var measurement = isVertical ? 'width' : 'height';

	  if (popper[side] < floor(reference[opSide])) {
	    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
	  }
	  if (popper[opSide] > floor(reference[side])) {
	    data.offsets.popper[opSide] = floor(reference[side]);
	  }

	  return data;
	}

	/**
	 * Converts a string containing value + unit into a px value number
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} str - Value + unit string
	 * @argument {String} measurement - `height` or `width`
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @returns {Number|String}
	 * Value in pixels, or original string if no values were extracted
	 */
	function toValue(str, measurement, popperOffsets, referenceOffsets) {
	  // separate value from unit
	  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
	  var value = +split[1];
	  var unit = split[2];

	  // If it's not a number it's an operator, I guess
	  if (!value) {
	    return str;
	  }

	  if (unit.indexOf('%') === 0) {
	    var element = void 0;
	    switch (unit) {
	      case '%p':
	        element = popperOffsets;
	        break;
	      case '%':
	      case '%r':
	      default:
	        element = referenceOffsets;
	    }

	    var rect = getClientRect(element);
	    return rect[measurement] / 100 * value;
	  } else if (unit === 'vh' || unit === 'vw') {
	    // if is a vh or vw, we calculate the size based on the viewport
	    var size = void 0;
	    if (unit === 'vh') {
	      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	    } else {
	      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	    }
	    return size / 100 * value;
	  } else {
	    // if is an explicit pixel unit, we get rid of the unit and keep the value
	    // if is an implicit unit, it's px, and we return just the value
	    return value;
	  }
	}

	/**
	 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} offset
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @argument {String} basePlacement
	 * @returns {Array} a two cells array with x and y offsets in numbers
	 */
	function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
	  var offsets = [0, 0];

	  // Use height if placement is left or right and index is 0 otherwise use width
	  // in this way the first offset will use an axis and the second one
	  // will use the other one
	  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

	  // Split the offset string to obtain a list of values and operands
	  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
	  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
	    return frag.trim();
	  });

	  // Detect if the offset string contains a pair of values or a single one
	  // they could be separated by comma or space
	  var divider = fragments.indexOf(find(fragments, function (frag) {
	    return frag.search(/,|\s/) !== -1;
	  }));

	  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
	    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
	  }

	  // If divider is found, we divide the list of values and operands to divide
	  // them by ofset X and Y.
	  var splitRegex = /\s*,\s*|\s+/;
	  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

	  // Convert the values with units to absolute pixels to allow our computations
	  ops = ops.map(function (op, index) {
	    // Most of the units rely on the orientation of the popper
	    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
	    var mergeWithPrevious = false;
	    return op
	    // This aggregates any `+` or `-` sign that aren't considered operators
	    // e.g.: 10 + +5 => [10, +, +5]
	    .reduce(function (a, b) {
	      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
	        a[a.length - 1] = b;
	        mergeWithPrevious = true;
	        return a;
	      } else if (mergeWithPrevious) {
	        a[a.length - 1] += b;
	        mergeWithPrevious = false;
	        return a;
	      } else {
	        return a.concat(b);
	      }
	    }, [])
	    // Here we convert the string values into number values (in px)
	    .map(function (str) {
	      return toValue(str, measurement, popperOffsets, referenceOffsets);
	    });
	  });

	  // Loop trough the offsets arrays and execute the operations
	  ops.forEach(function (op, index) {
	    op.forEach(function (frag, index2) {
	      if (isNumeric(frag)) {
	        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
	      }
	    });
	  });
	  return offsets;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @argument {Number|String} options.offset=0
	 * The offset value as described in the modifier description
	 * @returns {Object} The data object, properly modified
	 */
	function offset$1(data, _ref) {
	  var offset = _ref.offset;
	  var placement = data.placement,
	      _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var basePlacement = placement.split('-')[0];

	  var offsets = void 0;
	  if (isNumeric(+offset)) {
	    offsets = [+offset, 0];
	  } else {
	    offsets = parseOffset(offset, popper, reference, basePlacement);
	  }

	  if (basePlacement === 'left') {
	    popper.top += offsets[0];
	    popper.left -= offsets[1];
	  } else if (basePlacement === 'right') {
	    popper.top += offsets[0];
	    popper.left += offsets[1];
	  } else if (basePlacement === 'top') {
	    popper.left += offsets[0];
	    popper.top -= offsets[1];
	  } else if (basePlacement === 'bottom') {
	    popper.left += offsets[0];
	    popper.top += offsets[1];
	  }

	  data.popper = popper;
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function preventOverflow(data, options) {
	  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

	  // If offsetParent is the reference element, we really want to
	  // go one step up and use the next offsetParent as reference to
	  // avoid to make this modifier completely useless and look like broken
	  if (data.instance.reference === boundariesElement) {
	    boundariesElement = getOffsetParent(boundariesElement);
	  }

	  // NOTE: DOM access here
	  // resets the popper's position so that the document size can be calculated excluding
	  // the size of the popper element itself
	  var transformProp = getSupportedPropertyName('transform');
	  var popperStyles = data.instance.popper.style; // assignment to help minification
	  var top = popperStyles.top,
	      left = popperStyles.left,
	      transform = popperStyles[transformProp];

	  popperStyles.top = '';
	  popperStyles.left = '';
	  popperStyles[transformProp] = '';

	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

	  // NOTE: DOM access here
	  // restores the original style properties after the offsets have been computed
	  popperStyles.top = top;
	  popperStyles.left = left;
	  popperStyles[transformProp] = transform;

	  options.boundaries = boundaries;

	  var order = options.priority;
	  var popper = data.offsets.popper;

	  var check = {
	    primary: function primary(placement) {
	      var value = popper[placement];
	      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
	        value = Math.max(popper[placement], boundaries[placement]);
	      }
	      return defineProperty$2({}, placement, value);
	    },
	    secondary: function secondary(placement) {
	      var mainSide = placement === 'right' ? 'left' : 'top';
	      var value = popper[mainSide];
	      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
	        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
	      }
	      return defineProperty$2({}, mainSide, value);
	    }
	  };

	  order.forEach(function (placement) {
	    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
	    popper = _extends({}, popper, check[side](placement));
	  });

	  data.offsets.popper = popper;

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function shift(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var shiftvariation = placement.split('-')[1];

	  // if shift shiftvariation is specified, run the modifier
	  if (shiftvariation) {
	    var _data$offsets = data.offsets,
	        reference = _data$offsets.reference,
	        popper = _data$offsets.popper;

	    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
	    var side = isVertical ? 'left' : 'top';
	    var measurement = isVertical ? 'width' : 'height';

	    var shiftOffsets = {
	      start: defineProperty$2({}, side, reference[side]),
	      end: defineProperty$2({}, side, reference[side] + reference[measurement] - popper[measurement])
	    };

	    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function hide(data) {
	  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
	    return data;
	  }

	  var refRect = data.offsets.reference;
	  var bound = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'preventOverflow';
	  }).boundaries;

	  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
	    // Avoid unnecessary DOM access if visibility hasn't changed
	    if (data.hide === true) {
	      return data;
	    }

	    data.hide = true;
	    data.attributes['x-out-of-boundaries'] = '';
	  } else {
	    // Avoid unnecessary DOM access if visibility hasn't changed
	    if (data.hide === false) {
	      return data;
	    }

	    data.hide = false;
	    data.attributes['x-out-of-boundaries'] = false;
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function inner(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

	  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

	  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

	  data.placement = getOppositePlacement(placement);
	  data.offsets.popper = getClientRect(popper);

	  return data;
	}

	/**
	 * Modifier function, each modifier can have a function of this type assigned
	 * to its `fn` property.<br />
	 * These functions will be called on each update, this means that you must
	 * make sure they are performant enough to avoid performance bottlenecks.
	 *
	 * @function ModifierFn
	 * @argument {dataObject} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {dataObject} The data object, properly modified
	 */

	/**
	 * Modifiers are plugins used to alter the behavior of your poppers.<br />
	 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
	 * needed by the library.
	 *
	 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
	 * All the other properties are configurations that could be tweaked.
	 * @namespace modifiers
	 */
	var modifiers = {
	  /**
	   * Modifier used to shift the popper on the start or end of its reference
	   * element.<br />
	   * It will read the variation of the `placement` property.<br />
	   * It can be one either `-end` or `-start`.
	   * @memberof modifiers
	   * @inner
	   */
	  shift: {
	    /** @prop {number} order=100 - Index used to define the order of execution */
	    order: 100,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: shift
	  },

	  /**
	   * The `offset` modifier can shift your popper on both its axis.
	   *
	   * It accepts the following units:
	   * - `px` or unit-less, interpreted as pixels
	   * - `%` or `%r`, percentage relative to the length of the reference element
	   * - `%p`, percentage relative to the length of the popper element
	   * - `vw`, CSS viewport width unit
	   * - `vh`, CSS viewport height unit
	   *
	   * For length is intended the main axis relative to the placement of the popper.<br />
	   * This means that if the placement is `top` or `bottom`, the length will be the
	   * `width`. In case of `left` or `right`, it will be the `height`.
	   *
	   * You can provide a single value (as `Number` or `String`), or a pair of values
	   * as `String` divided by a comma or one (or more) white spaces.<br />
	   * The latter is a deprecated method because it leads to confusion and will be
	   * removed in v2.<br />
	   * Additionally, it accepts additions and subtractions between different units.
	   * Note that multiplications and divisions aren't supported.
	   *
	   * Valid examples are:
	   * ```
	   * 10
	   * '10%'
	   * '10, 10'
	   * '10%, 10'
	   * '10 + 10%'
	   * '10 - 5vh + 3%'
	   * '-10px + 5vh, 5px - 6%'
	   * ```
	   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
	   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
	   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  offset: {
	    /** @prop {number} order=200 - Index used to define the order of execution */
	    order: 200,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: offset$1,
	    /** @prop {Number|String} offset=0
	     * The offset value as described in the modifier description
	     */
	    offset: 0
	  },

	  /**
	   * Modifier used to prevent the popper from being positioned outside the boundary.
	   *
	   * A scenario exists where the reference itself is not within the boundaries.<br />
	   * We can say it has "escaped the boundaries" — or just "escaped".<br />
	   * In this case we need to decide whether the popper should either:
	   *
	   * - detach from the reference and remain "trapped" in the boundaries, or
	   * - if it should ignore the boundary and "escape with its reference"
	   *
	   * When `escapeWithReference` is set to`true` and reference is completely
	   * outside its boundaries, the popper will overflow (or completely leave)
	   * the boundaries in order to remain attached to the edge of the reference.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  preventOverflow: {
	    /** @prop {number} order=300 - Index used to define the order of execution */
	    order: 300,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: preventOverflow,
	    /**
	     * @prop {Array} [priority=['left','right','top','bottom']]
	     * Popper will try to prevent overflow following these priorities by default,
	     * then, it could overflow on the left and on top of the `boundariesElement`
	     */
	    priority: ['left', 'right', 'top', 'bottom'],
	    /**
	     * @prop {number} padding=5
	     * Amount of pixel used to define a minimum distance between the boundaries
	     * and the popper. This makes sure the popper always has a little padding
	     * between the edges of its container
	     */
	    padding: 5,
	    /**
	     * @prop {String|HTMLElement} boundariesElement='scrollParent'
	     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
	     * `viewport` or any DOM element.
	     */
	    boundariesElement: 'scrollParent'
	  },

	  /**
	   * Modifier used to make sure the reference and its popper stay near each other
	   * without leaving any gap between the two. Especially useful when the arrow is
	   * enabled and you want to ensure that it points to its reference element.
	   * It cares only about the first axis. You can still have poppers with margin
	   * between the popper and its reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  keepTogether: {
	    /** @prop {number} order=400 - Index used to define the order of execution */
	    order: 400,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: keepTogether
	  },

	  /**
	   * This modifier is used to move the `arrowElement` of the popper to make
	   * sure it is positioned between the reference element and its popper element.
	   * It will read the outer size of the `arrowElement` node to detect how many
	   * pixels of conjunction are needed.
	   *
	   * It has no effect if no `arrowElement` is provided.
	   * @memberof modifiers
	   * @inner
	   */
	  arrow: {
	    /** @prop {number} order=500 - Index used to define the order of execution */
	    order: 500,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: arrow,
	    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
	    element: '[x-arrow]'
	  },

	  /**
	   * Modifier used to flip the popper's placement when it starts to overlap its
	   * reference element.
	   *
	   * Requires the `preventOverflow` modifier before it in order to work.
	   *
	   * **NOTE:** this modifier will interrupt the current update cycle and will
	   * restart it if it detects the need to flip the placement.
	   * @memberof modifiers
	   * @inner
	   */
	  flip: {
	    /** @prop {number} order=600 - Index used to define the order of execution */
	    order: 600,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: flip,
	    /**
	     * @prop {String|Array} behavior='flip'
	     * The behavior used to change the popper's placement. It can be one of
	     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
	     * placements (with optional variations)
	     */
	    behavior: 'flip',
	    /**
	     * @prop {number} padding=5
	     * The popper will flip if it hits the edges of the `boundariesElement`
	     */
	    padding: 5,
	    /**
	     * @prop {String|HTMLElement} boundariesElement='viewport'
	     * The element which will define the boundaries of the popper position.
	     * The popper will never be placed outside of the defined boundaries
	     * (except if `keepTogether` is enabled)
	     */
	    boundariesElement: 'viewport',
	    /**
	     * @prop {Boolean} flipVariations=false
	     * The popper will switch placement variation between `-start` and `-end` when
	     * the reference element overlaps its boundaries.
	     *
	     * The original placement should have a set variation.
	     */
	    flipVariations: false,
	    /**
	     * @prop {Boolean} flipVariationsByContent=false
	     * The popper will switch placement variation between `-start` and `-end` when
	     * the popper element overlaps its reference boundaries.
	     *
	     * The original placement should have a set variation.
	     */
	    flipVariationsByContent: false
	  },

	  /**
	   * Modifier used to make the popper flow toward the inner of the reference element.
	   * By default, when this modifier is disabled, the popper will be placed outside
	   * the reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  inner: {
	    /** @prop {number} order=700 - Index used to define the order of execution */
	    order: 700,
	    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
	    enabled: false,
	    /** @prop {ModifierFn} */
	    fn: inner
	  },

	  /**
	   * Modifier used to hide the popper when its reference element is outside of the
	   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
	   * be used to hide with a CSS selector the popper when its reference is
	   * out of boundaries.
	   *
	   * Requires the `preventOverflow` modifier before it in order to work.
	   * @memberof modifiers
	   * @inner
	   */
	  hide: {
	    /** @prop {number} order=800 - Index used to define the order of execution */
	    order: 800,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: hide
	  },

	  /**
	   * Computes the style that will be applied to the popper element to gets
	   * properly positioned.
	   *
	   * Note that this modifier will not touch the DOM, it just prepares the styles
	   * so that `applyStyle` modifier can apply it. This separation is useful
	   * in case you need to replace `applyStyle` with a custom implementation.
	   *
	   * This modifier has `850` as `order` value to maintain backward compatibility
	   * with previous versions of Popper.js. Expect the modifiers ordering method
	   * to change in future major versions of the library.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  computeStyle: {
	    /** @prop {number} order=850 - Index used to define the order of execution */
	    order: 850,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: computeStyle,
	    /**
	     * @prop {Boolean} gpuAcceleration=true
	     * If true, it uses the CSS 3D transformation to position the popper.
	     * Otherwise, it will use the `top` and `left` properties
	     */
	    gpuAcceleration: true,
	    /**
	     * @prop {string} [x='bottom']
	     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
	     * Change this if your popper should grow in a direction different from `bottom`
	     */
	    x: 'bottom',
	    /**
	     * @prop {string} [x='left']
	     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
	     * Change this if your popper should grow in a direction different from `right`
	     */
	    y: 'right'
	  },

	  /**
	   * Applies the computed styles to the popper element.
	   *
	   * All the DOM manipulations are limited to this modifier. This is useful in case
	   * you want to integrate Popper.js inside a framework or view library and you
	   * want to delegate all the DOM manipulations to it.
	   *
	   * Note that if you disable this modifier, you must make sure the popper element
	   * has its position set to `absolute` before Popper.js can do its work!
	   *
	   * Just disable this modifier and define your own to achieve the desired effect.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  applyStyle: {
	    /** @prop {number} order=900 - Index used to define the order of execution */
	    order: 900,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: applyStyle,
	    /** @prop {Function} */
	    onLoad: applyStyleOnLoad,
	    /**
	     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
	     * @prop {Boolean} gpuAcceleration=true
	     * If true, it uses the CSS 3D transformation to position the popper.
	     * Otherwise, it will use the `top` and `left` properties
	     */
	    gpuAcceleration: undefined
	  }
	};

	/**
	 * The `dataObject` is an object containing all the information used by Popper.js.
	 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
	 * @name dataObject
	 * @property {Object} data.instance The Popper.js instance
	 * @property {String} data.placement Placement applied to popper
	 * @property {String} data.originalPlacement Placement originally defined on init
	 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
	 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
	 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
	 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
	 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
	 * @property {Object} data.boundaries Offsets of the popper boundaries
	 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
	 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
	 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
	 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
	 */

	/**
	 * Default options provided to Popper.js constructor.<br />
	 * These can be overridden using the `options` argument of Popper.js.<br />
	 * To override an option, simply pass an object with the same
	 * structure of the `options` object, as the 3rd argument. For example:
	 * ```
	 * new Popper(ref, pop, {
	 *   modifiers: {
	 *     preventOverflow: { enabled: false }
	 *   }
	 * })
	 * ```
	 * @type {Object}
	 * @static
	 * @memberof Popper
	 */
	var Defaults = {
	  /**
	   * Popper's placement.
	   * @prop {Popper.placements} placement='bottom'
	   */
	  placement: 'bottom',

	  /**
	   * Set this to true if you want popper to position it self in 'fixed' mode
	   * @prop {Boolean} positionFixed=false
	   */
	  positionFixed: false,

	  /**
	   * Whether events (resize, scroll) are initially enabled.
	   * @prop {Boolean} eventsEnabled=true
	   */
	  eventsEnabled: true,

	  /**
	   * Set to true if you want to automatically remove the popper when
	   * you call the `destroy` method.
	   * @prop {Boolean} removeOnDestroy=false
	   */
	  removeOnDestroy: false,

	  /**
	   * Callback called when the popper is created.<br />
	   * By default, it is set to no-op.<br />
	   * Access Popper.js instance with `data.instance`.
	   * @prop {onCreate}
	   */
	  onCreate: function onCreate() {},

	  /**
	   * Callback called when the popper is updated. This callback is not called
	   * on the initialization/creation of the popper, but only on subsequent
	   * updates.<br />
	   * By default, it is set to no-op.<br />
	   * Access Popper.js instance with `data.instance`.
	   * @prop {onUpdate}
	   */
	  onUpdate: function onUpdate() {},

	  /**
	   * List of modifiers used to modify the offsets before they are applied to the popper.
	   * They provide most of the functionalities of Popper.js.
	   * @prop {modifiers}
	   */
	  modifiers: modifiers
	};

	/**
	 * @callback onCreate
	 * @param {dataObject} data
	 */

	/**
	 * @callback onUpdate
	 * @param {dataObject} data
	 */

	// Utils
	// Methods
	var Popper = function () {
	  /**
	   * Creates a new Popper.js instance.
	   * @class Popper
	   * @param {Element|referenceObject} reference - The reference element used to position the popper
	   * @param {Element} popper - The HTML / XML element used as the popper
	   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
	   * @return {Object} instance - The generated Popper.js instance
	   */
	  function Popper(reference, popper) {
	    var _this = this;

	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    classCallCheck(this, Popper);

	    this.scheduleUpdate = function () {
	      return requestAnimationFrame(_this.update);
	    };

	    // make update() debounced, so that it only runs at most once-per-tick
	    this.update = debounce(this.update.bind(this));

	    // with {} we create a new object with the options inside it
	    this.options = _extends({}, Popper.Defaults, options);

	    // init state
	    this.state = {
	      isDestroyed: false,
	      isCreated: false,
	      scrollParents: []
	    };

	    // get reference and popper elements (allow jQuery wrappers)
	    this.reference = reference && reference.jquery ? reference[0] : reference;
	    this.popper = popper && popper.jquery ? popper[0] : popper;

	    // Deep merge modifiers options
	    this.options.modifiers = {};
	    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
	      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
	    });

	    // Refactoring modifiers' list (Object => Array)
	    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
	      return _extends({
	        name: name
	      }, _this.options.modifiers[name]);
	    })
	    // sort the modifiers by order
	    .sort(function (a, b) {
	      return a.order - b.order;
	    });

	    // modifiers have the ability to execute arbitrary code when Popper.js get inited
	    // such code is executed in the same order of its modifier
	    // they could add new properties to their options configuration
	    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
	    this.modifiers.forEach(function (modifierOptions) {
	      if (modifierOptions.enabled && isFunction$1(modifierOptions.onLoad)) {
	        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
	      }
	    });

	    // fire the first update to position the popper in the right place
	    this.update();

	    var eventsEnabled = this.options.eventsEnabled;
	    if (eventsEnabled) {
	      // setup event listeners, they will take care of update the position in specific situations
	      this.enableEventListeners();
	    }

	    this.state.eventsEnabled = eventsEnabled;
	  }

	  // We can't use class properties because they don't get listed in the
	  // class prototype and break stuff like Sinon stubs


	  createClass(Popper, [{
	    key: 'update',
	    value: function update$$1() {
	      return update.call(this);
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy$$1() {
	      return destroy$1.call(this);
	    }
	  }, {
	    key: 'enableEventListeners',
	    value: function enableEventListeners$$1() {
	      return enableEventListeners.call(this);
	    }
	  }, {
	    key: 'disableEventListeners',
	    value: function disableEventListeners$$1() {
	      return disableEventListeners.call(this);
	    }

	    /**
	     * Schedules an update. It will run on the next UI update available.
	     * @method scheduleUpdate
	     * @memberof Popper
	     */


	    /**
	     * Collection of utilities useful when writing custom modifiers.
	     * Starting from version 1.7, this method is available only if you
	     * include `popper-utils.js` before `popper.js`.
	     *
	     * **DEPRECATION**: This way to access PopperUtils is deprecated
	     * and will be removed in v2! Use the PopperUtils module directly instead.
	     * Due to the high instability of the methods contained in Utils, we can't
	     * guarantee them to follow semver. Use them at your own risk!
	     * @static
	     * @private
	     * @type {Object}
	     * @deprecated since version 1.8
	     * @member Utils
	     * @memberof Popper
	     */

	  }]);
	  return Popper;
	}();

	/**
	 * The `referenceObject` is an object that provides an interface compatible with Popper.js
	 * and lets you use it as replacement of a real DOM node.<br />
	 * You can use this method to position a popper relatively to a set of coordinates
	 * in case you don't have a DOM node to use as reference.
	 *
	 * ```
	 * new Popper(referenceObject, popperNode);
	 * ```
	 *
	 * NB: This feature isn't supported in Internet Explorer 10.
	 * @name referenceObject
	 * @property {Function} data.getBoundingClientRect
	 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
	 * @property {number} data.clientWidth
	 * An ES6 getter that will return the width of the virtual reference element.
	 * @property {number} data.clientHeight
	 * An ES6 getter that will return the height of the virtual reference element.
	 */


	Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
	Popper.placements = placements;
	Popper.Defaults = Defaults;

	function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) { _defineProperties$2(Constructor.prototype, protoProps); } if (staticProps) { _defineProperties$2(Constructor, staticProps); } return Constructor; }

	var BvEvent =
	/*#__PURE__*/
	function () {
	  function BvEvent(type) {
	    var eventInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck$3(this, BvEvent);

	    // Start by emulating native Event constructor
	    if (!type) {
	      /* istanbul ignore next */
	      throw new TypeError("Failed to construct '".concat(this.constructor.name, "'. 1 argument required, ").concat(arguments.length, " given."));
	    } // Merge defaults first, the eventInit, and the type last
	    // so it can't be overwritten


	    assign(this, BvEvent.Defaults, this.constructor.Defaults, eventInit, {
	      type: type
	    }); // Freeze some props as readonly, but leave them enumerable

	    defineProperties(this, {
	      type: readonlyDescriptor(),
	      cancelable: readonlyDescriptor(),
	      nativeEvent: readonlyDescriptor(),
	      target: readonlyDescriptor(),
	      relatedTarget: readonlyDescriptor(),
	      vueTarget: readonlyDescriptor(),
	      componentId: readonlyDescriptor()
	    }); // Create a private variable using closure scoping

	    var defaultPrevented = false; // Recreate preventDefault method. One way setter

	    this.preventDefault = function preventDefault() {
	      if (this.cancelable) {
	        defaultPrevented = true;
	      }
	    }; // Create `defaultPrevented` publicly accessible prop that
	    // can only be altered by the preventDefault method


	    defineProperty$1(this, 'defaultPrevented', {
	      enumerable: true,
	      get: function get() {
	        return defaultPrevented;
	      }
	    });
	  }

	  _createClass$2(BvEvent, null, [{
	    key: "Defaults",
	    get: function get() {
	      return {
	        type: '',
	        cancelable: true,
	        nativeEvent: null,
	        target: null,
	        relatedTarget: null,
	        vueTarget: null,
	        componentId: null
	      };
	    }
	  }]);

	  return BvEvent;
	}(); // Named Exports

	var eventOptions = {
	  passive: true,
	  capture: false
	}; // @vue/component

	var clickOutMixin = {
	  data: function data() {
	    return {
	      listenForClickOut: false
	    };
	  },
	  watch: {
	    listenForClickOut: function listenForClickOut(newValue, oldValue) {
	      if (newValue !== oldValue) {
	        eventOff(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, eventOptions);

	        if (newValue) {
	          eventOn(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, eventOptions);
	        }
	      }
	    }
	  },
	  beforeCreate: function beforeCreate() {
	    // Declare non-reactive properties
	    this.clickOutElement = null;
	    this.clickOutEventName = null;
	  },
	  mounted: function mounted() {
	    if (!this.clickOutElement) {
	      this.clickOutElement = document;
	    }

	    if (!this.clickOutEventName) {
	      this.clickOutEventName = 'ontouchstart' in document.documentElement ? 'touchstart' : 'click';
	    }

	    if (this.listenForClickOut) {
	      eventOn(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, eventOptions);
	    }
	  },
	  beforeDestroy: function beforeDestroy()
	  /* istanbul ignore next */
	  {
	    eventOff(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, eventOptions);
	  },
	  methods: {
	    isClickOut: function isClickOut(evt) {
	      return !contains(this.$el, evt.target);
	    },
	    _clickOutHandler: function _clickOutHandler(evt) {
	      if (this.clickOutHandler && this.isClickOut(evt)) {
	        this.clickOutHandler(evt);
	      }
	    }
	  }
	};

	var eventOptions$1 = {
	  passive: true,
	  capture: false
	}; // @vue/component

	var focusInMixin = {
	  data: function data() {
	    return {
	      listenForFocusIn: false
	    };
	  },
	  watch: {
	    listenForFocusIn: function listenForFocusIn(newValue, oldValue) {
	      if (newValue !== oldValue) {
	        eventOff(this.focusInElement, 'focusin', this._focusInHandler, eventOptions$1);

	        if (newValue) {
	          eventOn(this.focusInElement, 'focusin', this._focusInHandler, eventOptions$1);
	        }
	      }
	    }
	  },
	  beforeCreate: function beforeCreate() {
	    // Declare non-reactive properties
	    this.focusInElement = null;
	  },
	  mounted: function mounted() {
	    if (!this.focusInElement) {
	      this.focusInElement = document;
	    }

	    if (this.listenForFocusIn) {
	      eventOn(this.focusInElement, 'focusin', this._focusInHandler, eventOptions$1);
	    }
	  },
	  beforeDestroy: function beforeDestroy()
	  /* istanbul ignore next */
	  {
	    eventOff(this.focusInElement, 'focusin', this._focusInHandler, eventOptions$1);
	  },
	  methods: {
	    _focusInHandler: function _focusInHandler(evt) {
	      if (this.focusInHandler) {
	        this.focusInHandler(evt);
	      }
	    }
	  }
	};

	function ownKeys$f(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$f(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$f(source, true).forEach(function (key) { _defineProperty$k(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$f(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$k(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var filterVisibles = function filterVisibles(els) {
	  return (els || []).filter(isVisible);
	}; // Root dropdown event names


	var ROOT_DROPDOWN_PREFIX = 'bv::dropdown::';
	var ROOT_DROPDOWN_SHOWN = "".concat(ROOT_DROPDOWN_PREFIX, "shown");
	var ROOT_DROPDOWN_HIDDEN = "".concat(ROOT_DROPDOWN_PREFIX, "hidden"); // Delay when loosing focus before closing menu (in ms)

	var FOCUSOUT_DELAY = hasTouchSupport ? 450 : 150; // Dropdown item CSS selectors

	var Selector = {
	  FORM_CHILD: '.dropdown form',
	  ITEM_SELECTOR: ['.dropdown-item', '.b-dropdown-form'].map(function (selector) {
	    return "".concat(selector, ":not(.disabled):not([disabled])");
	  }).join(', ')
	}; // Popper attachment positions

	var AttachmentMap = {
	  // Dropup left align
	  TOP: 'top-start',
	  // Dropup right align
	  TOPEND: 'top-end',
	  // Dropdown left align
	  BOTTOM: 'bottom-start',
	  // Dropdown right align
	  BOTTOMEND: 'bottom-end',
	  // Dropright left align
	  RIGHT: 'right-start',
	  // Dropright right align
	  RIGHTEND: 'right-end',
	  // Dropleft left align
	  LEFT: 'left-start',
	  // Dropleft right align
	  LEFTEND: 'left-end'
	}; // @vue/component

	var dropdownMixin = {
	  mixins: [idMixin, clickOutMixin, focusInMixin],
	  provide: function provide() {
	    return {
	      bvDropdown: this
	    };
	  },
	  props: {
	    disabled: {
	      type: Boolean,
	      default: false
	    },
	    text: {
	      // Button label
	      type: String,
	      default: ''
	    },
	    html: {
	      // Button label
	      type: String
	    },
	    dropup: {
	      // place on top if possible
	      type: Boolean,
	      default: false
	    },
	    dropright: {
	      // place right if possible
	      type: Boolean,
	      default: false
	    },
	    dropleft: {
	      // place left if possible
	      type: Boolean,
	      default: false
	    },
	    right: {
	      // Right align menu (default is left align)
	      type: Boolean,
	      default: false
	    },
	    offset: {
	      // Number of pixels to offset menu, or a CSS unit value (i.e. 1px, 1rem, etc)
	      type: [Number, String],
	      default: 0
	    },
	    noFlip: {
	      // Disable auto-flipping of menu from bottom<=>top
	      type: Boolean,
	      default: false
	    },
	    lazy: {
	      // If true, only render menu contents when open
	      type: Boolean,
	      default: false
	    },
	    popperOpts: {
	      // type: Object,
	      default: function _default() {}
	    }
	  },
	  data: function data() {
	    return {
	      visible: false,
	      inNavbar: null,
	      visibleChangePrevented: false
	    };
	  },
	  computed: {
	    toggler: function toggler() {
	      var toggle = this.$refs.toggle;
	      return toggle ? toggle.$el || toggle : null;
	    },
	    directionClass: function directionClass() {
	      if (this.dropup) {
	        return 'dropup';
	      } else if (this.dropright) {
	        return 'dropright';
	      } else if (this.dropleft) {
	        return 'dropleft';
	      }

	      return '';
	    }
	  },
	  watch: {
	    visible: function visible(newValue, oldValue) {
	      if (this.visibleChangePrevented) {
	        this.visibleChangePrevented = false;
	        return;
	      }

	      if (newValue !== oldValue) {
	        var evtName = newValue ? 'show' : 'hide';
	        var bvEvt = new BvEvent(evtName, {
	          cancelable: true,
	          vueTarget: this,
	          target: this.$refs.menu,
	          relatedTarget: null,
	          componentId: this.safeId ? this.safeId() : this.id || null
	        });
	        this.emitEvent(bvEvt);

	        if (bvEvt.defaultPrevented) {
	          // Reset value and exit if canceled
	          this.visibleChangePrevented = true;
	          this.visible = oldValue; // Just in case a child element triggered this.hide(true)

	          this.$off('hidden', this.focusToggler);
	          return;
	        }

	        if (evtName === 'show') {
	          this.showMenu();
	        } else {
	          this.hideMenu();
	        }
	      }
	    },
	    disabled: function disabled(newValue, oldValue) {
	      if (newValue !== oldValue && newValue && this.visible) {
	        // Hide dropdown if disabled changes to true
	        this.visible = false;
	      }
	    }
	  },
	  created: function created() {
	    // Create non-reactive property
	    this.$_popper = null;
	    this.$_hideTimeout = null;

	    this.$_noop = function () {};
	  },
	  deactivated: function deactivated()
	  /* istanbul ignore next: not easy to test */
	  {
	    // In case we are inside a `<keep-alive>`
	    this.visible = false;
	    this.whileOpenListen(false);
	    this.destroyPopper();
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.visible = false;
	    this.whileOpenListen(false);
	    this.destroyPopper();
	    this.clearHideTimeout();
	  },
	  methods: {
	    // Event emitter
	    emitEvent: function emitEvent(bvEvt) {
	      var type = bvEvt.type;
	      this.$emit(type, bvEvt);
	      this.$root.$emit("".concat(ROOT_DROPDOWN_PREFIX).concat(type), bvEvt);
	    },
	    showMenu: function showMenu() {
	      var _this = this;

	      if (this.disabled) {
	        /* istanbul ignore next */
	        return;
	      } // Are we in a navbar ?


	      if (isNull(this.inNavbar) && this.isNav) {
	        // We should use an injection for this

	        /* istanbul ignore next */
	        this.inNavbar = Boolean(closest('.navbar', this.$el));
	      } // Disable totally Popper.js for Dropdown in Navbar


	      if (!this.inNavbar) {
	        if (typeof Popper === 'undefined') {
	          /* istanbul ignore next */
	          warn('b-dropdown: Popper.js not found. Falling back to CSS positioning.');
	        } else {
	          // for dropup with alignment we use the parent element as popper container
	          var element = this.dropup && this.right || this.split ? this.$el : this.$refs.toggle; // Make sure we have a reference to an element, not a component!

	          element = element.$el || element; // Instantiate popper.js

	          this.createPopper(element);
	        }
	      } // Ensure other menus are closed


	      this.$root.$emit(ROOT_DROPDOWN_SHOWN, this);
	      this.whileOpenListen(true); // Wrap in nextTick to ensure menu is fully rendered/shown

	      this.$nextTick(function () {
	        // Focus on the menu container on show
	        _this.focusMenu(); // Emit the shown event


	        _this.$emit('shown');
	      });
	    },
	    hideMenu: function hideMenu() {
	      this.whileOpenListen(false);
	      this.$root.$emit(ROOT_DROPDOWN_HIDDEN, this);
	      this.$emit('hidden');
	      this.destroyPopper();
	    },
	    createPopper: function createPopper(element) {
	      this.destroyPopper();
	      this.$_popper = new Popper(element, this.$refs.menu, this.getPopperConfig());
	    },
	    destroyPopper: function destroyPopper() {
	      if (this.$_popper) {
	        // Ensure popper event listeners are removed cleanly
	        this.$_popper.destroy();
	      }

	      this.$_popper = null;
	    },
	    clearHideTimeout: function clearHideTimeout() {
	      /* istanbul ignore next */
	      if (this.$_hideTimeout) {
	        clearTimeout(this.$_hideTimeout);
	        this.$_hideTimeout = null;
	      }
	    },
	    getPopperConfig: function getPopperConfig() {
	      var placement = AttachmentMap.BOTTOM;

	      if (this.dropup) {
	        placement = this.right ? AttachmentMap.TOPEND : AttachmentMap.TOP;
	      } else if (this.dropright) {
	        placement = AttachmentMap.RIGHT;
	      } else if (this.dropleft) {
	        placement = AttachmentMap.LEFT;
	      } else if (this.right) {
	        placement = AttachmentMap.BOTTOMEND;
	      }

	      var popperConfig = {
	        placement: placement,
	        modifiers: {
	          offset: {
	            offset: this.offset || 0
	          },
	          flip: {
	            enabled: !this.noFlip
	          }
	        }
	      };

	      if (this.boundary) {
	        popperConfig.modifiers.preventOverflow = {
	          boundariesElement: this.boundary
	        };
	      }

	      return _objectSpread$f({}, popperConfig, {}, this.popperOpts || {});
	    },
	    // Turn listeners on/off while open
	    whileOpenListen: function whileOpenListen(isOpen) {
	      // Hide the dropdown when clicked outside
	      this.listenForClickOut = isOpen; // Hide the dropdown when it loses focus

	      this.listenForFocusIn = isOpen; // Hide the dropdown when another dropdown is opened

	      var method = isOpen ? '$on' : '$off';
	      this.$root[method](ROOT_DROPDOWN_SHOWN, this.rootCloseListener);
	    },
	    rootCloseListener: function rootCloseListener(vm) {
	      if (vm !== this) {
	        this.visible = false;
	      }
	    },
	    show: function show() {
	      var _this2 = this;

	      // Public method to show dropdown
	      if (this.disabled) {
	        return;
	      } // Wrap in a requestAnimationFrame to allow any previous
	      // click handling to occur first


	      requestAF(function () {
	        _this2.visible = true;
	      });
	    },
	    hide: function hide() {
	      var refocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      // Public method to hide dropdown
	      if (this.disabled) {
	        /* istanbul ignore next */
	        return;
	      }

	      this.visible = false;

	      if (refocus) {
	        // Child element is closing the dropdown on click
	        this.$once('hidden', this.focusToggler);
	      }
	    },
	    // Called only by a button that toggles the menu
	    toggle: function toggle(evt) {
	      evt = evt || {};
	      var type = evt.type;
	      var key = evt.keyCode;

	      if (type !== 'click' && !(type === 'keydown' && (key === KEY_CODES.ENTER || key === KEY_CODES.SPACE || key === KEY_CODES.DOWN))) {
	        // We only toggle on Click, Enter, Space, and Arrow Down

	        /* istanbul ignore next */
	        return;
	      }
	      /* istanbul ignore next */


	      if (this.disabled) {
	        this.visible = false;
	        return;
	      }

	      this.$emit('toggle', evt);
	      evt.preventDefault();
	      evt.stopPropagation(); // Toggle visibility

	      if (this.visible) {
	        this.hide(true);
	      } else {
	        this.show();
	      }
	    },
	    // Called only in split button mode, for the split button
	    click: function click(evt) {
	      /* istanbul ignore next */
	      if (this.disabled) {
	        this.visible = false;
	        return;
	      }

	      this.$emit('click', evt);
	    },
	    // Called from dropdown menu context
	    onKeydown: function onKeydown(evt) {
	      var key = evt.keyCode;

	      if (key === KEY_CODES.ESC) {
	        // Close on ESC
	        this.onEsc(evt);
	      } else if (key === KEY_CODES.DOWN) {
	        // Down Arrow
	        this.focusNext(evt, false);
	      } else if (key === KEY_CODES.UP) {
	        // Up Arrow
	        this.focusNext(evt, true);
	      }
	    },
	    // If uses presses ESC to close menu
	    onEsc: function onEsc(evt) {
	      if (this.visible) {
	        this.visible = false;
	        evt.preventDefault();
	        evt.stopPropagation(); // Return focus to original trigger button

	        this.$once('hidden', this.focusToggler);
	      }
	    },
	    // Document click out listener
	    clickOutHandler: function clickOutHandler(evt) {
	      var _this3 = this;

	      var target = evt.target;

	      if (this.visible && !contains(this.$refs.menu, target) && !contains(this.toggler, target)) {
	        var doHide = function doHide() {
	          _this3.visible = false;
	          return null;
	        }; // When we are in a navbar (which has been responsively stacked), we
	        // delay the dropdown's closing so that the next element has a chance
	        // to have it's click handler fired (in case it's position moves on
	        // the screen do to a navbar menu above it collapsing)
	        // https://github.com/bootstrap-vue/bootstrap-vue/issues/4113


	        this.clearHideTimeout();
	        this.$_hideTimeout = this.inNavbar ? setTimeout(doHide, FOCUSOUT_DELAY) : doHide();
	      }
	    },
	    // Document focusin listener
	    focusInHandler: function focusInHandler(evt) {
	      // Shared logic with click-out handler
	      this.clickOutHandler(evt);
	    },
	    // Keyboard nav
	    focusNext: function focusNext(evt, up) {
	      var _this4 = this;

	      // Ignore key up/down on form elements
	      if (!this.visible || evt && closest(Selector.FORM_CHILD, evt.target)) {
	        /* istanbul ignore next: should never happen */
	        return;
	      }

	      evt.preventDefault();
	      evt.stopPropagation();
	      this.$nextTick(function () {
	        var items = _this4.getItems();

	        if (items.length < 1) {
	          /* istanbul ignore next: should never happen */
	          return;
	        }

	        var index = items.indexOf(evt.target);

	        if (up && index > 0) {
	          index--;
	        } else if (!up && index < items.length - 1) {
	          index++;
	        }

	        if (index < 0) {
	          /* istanbul ignore next: should never happen */
	          index = 0;
	        }

	        _this4.focusItem(index, items);
	      });
	    },
	    focusItem: function focusItem(idx, items) {
	      var el = items.find(function (el, i) {
	        return i === idx;
	      });

	      if (el && el.focus) {
	        el.focus();
	      }
	    },
	    getItems: function getItems() {
	      // Get all items
	      return filterVisibles(selectAll(Selector.ITEM_SELECTOR, this.$refs.menu));
	    },
	    focusMenu: function focusMenu() {
	      this.$refs.menu.focus && this.$refs.menu.focus();
	    },
	    focusToggler: function focusToggler() {
	      var _this5 = this;

	      this.$nextTick(function () {
	        var toggler = _this5.toggler;

	        if (toggler && toggler.focus) {
	          toggler.focus();
	        }
	      });
	    }
	  }
	};

	var NAME$b = 'BDropdown';
	var props$j = {
	  toggleText: {
	    // This really should be toggleLabel
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$b, 'toggleText');
	    }
	  },
	  size: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$b, 'size');
	    }
	  },
	  variant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$b, 'variant');
	    }
	  },
	  block: {
	    type: Boolean,
	    default: false
	  },
	  menuClass: {
	    type: [String, Array],
	    default: null
	  },
	  toggleTag: {
	    type: String,
	    default: 'button'
	  },
	  toggleClass: {
	    type: [String, Array],
	    default: null
	  },
	  noCaret: {
	    type: Boolean,
	    default: false
	  },
	  split: {
	    type: Boolean,
	    default: false
	  },
	  splitHref: {
	    type: String // default: undefined

	  },
	  splitTo: {
	    type: [String, Object] // default: undefined

	  },
	  splitVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$b, 'splitVariant');
	    }
	  },
	  splitButtonType: {
	    type: String,
	    default: 'button',
	    validator: function validator(value) {
	      return arrayIncludes(['button', 'submit', 'reset'], value);
	    }
	  },
	  role: {
	    type: String,
	    default: 'menu'
	  },
	  boundary: {
	    // String: `scrollParent`, `window` or `viewport`
	    // HTMLElement: HTML Element reference
	    type: [String, HTMLElement$1],
	    default: 'scrollParent'
	  }
	}; // @vue/component

	var BDropdown =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$b,
	  mixins: [idMixin, dropdownMixin, normalizeSlotMixin],
	  props: props$j,
	  computed: {
	    dropdownClasses: function dropdownClasses() {
	      return [this.directionClass, {
	        show: this.visible,
	        // The 'btn-group' class is required in `split` mode for button alignment
	        // It needs also to be applied when `block` is disabled to allow multiple
	        // dropdowns to be aligned one line
	        'btn-group': this.split || !this.block,
	        // When `block` is enabled and we are in `split` mode the 'd-flex' class
	        // needs to be applied to allow the buttons to stretch to full width
	        'd-flex': this.block && this.split,
	        // Position `static` is needed to allow menu to "breakout" of the `scrollParent`
	        // boundaries when boundary is anything other than `scrollParent`
	        // See: https://github.com/twbs/bootstrap/issues/24251#issuecomment-341413786
	        'position-static': this.boundary !== 'scrollParent' || !this.boundary
	      }];
	    },
	    menuClasses: function menuClasses() {
	      return [this.menuClass, {
	        'dropdown-menu-right': this.right,
	        show: this.visible
	      }];
	    },
	    toggleClasses: function toggleClasses() {
	      return [this.toggleClass, {
	        'dropdown-toggle-split': this.split,
	        'dropdown-toggle-no-caret': this.noCaret && !this.split
	      }];
	    }
	  },
	  render: function render(h) {
	    var split = h();
	    var buttonContent = this.normalizeSlot('button-content') || this.html || stripTags(this.text);

	    if (this.split) {
	      var btnProps = {
	        variant: this.splitVariant || this.variant,
	        size: this.size,
	        block: this.block,
	        disabled: this.disabled
	      }; // We add these as needed due to router-link issues with defined property with undefined/null values

	      if (this.splitTo) {
	        btnProps.to = this.splitTo;
	      } else if (this.splitHref) {
	        btnProps.href = this.splitHref;
	      } else if (this.splitButtonType) {
	        btnProps.type = this.splitButtonType;
	      }

	      split = h(BButton, {
	        ref: 'button',
	        props: btnProps,
	        attrs: {
	          id: this.safeId('_BV_button_')
	        },
	        on: {
	          click: this.click
	        }
	      }, [buttonContent]);
	    }

	    var toggle = h(BButton, {
	      ref: 'toggle',
	      staticClass: 'dropdown-toggle',
	      class: this.toggleClasses,
	      props: {
	        tag: this.toggleTag,
	        variant: this.variant,
	        size: this.size,
	        block: this.block && !this.split,
	        disabled: this.disabled
	      },
	      attrs: {
	        id: this.safeId('_BV_toggle_'),
	        'aria-haspopup': 'true',
	        'aria-expanded': this.visible ? 'true' : 'false'
	      },
	      on: {
	        click: this.toggle,
	        // click
	        keydown: this.toggle // enter, space, down

	      }
	    }, [this.split ? h('span', {
	      class: ['sr-only']
	    }, [this.toggleText]) : buttonContent]);
	    var menu = h('ul', {
	      ref: 'menu',
	      staticClass: 'dropdown-menu',
	      class: this.menuClasses,
	      attrs: {
	        role: this.role,
	        tabindex: '-1',
	        'aria-labelledby': this.safeId(this.split ? '_BV_button_' : '_BV_toggle_')
	      },
	      on: {
	        keydown: this.onKeydown // up, down, esc

	      }
	    }, !this.lazy || this.visible ? this.normalizeSlot('default', {
	      hide: this.hide
	    }) : [h()]);
	    return h('div', {
	      staticClass: 'dropdown b-dropdown',
	      class: this.dropdownClasses,
	      attrs: {
	        id: this.safeId()
	      }
	    }, [split, toggle, menu]);
	  }
	});

	function ownKeys$g(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$g(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$g(source, true).forEach(function (key) { _defineProperty$l(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$g(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$l(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$k = propsFactory(); // @vue/component

	var BDropdownItem =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BDropdownItem',
	  mixins: [normalizeSlotMixin],
	  inheritAttrs: false,
	  inject: {
	    bvDropdown: {
	      default: null
	    }
	  },
	  props: _objectSpread$g({}, props$k, {
	    variant: {
	      type: String,
	      default: null
	    }
	  }),
	  methods: {
	    closeDropdown: function closeDropdown() {
	      var _this = this;

	      // Close on next animation frame to allow <b-link> time to process
	      requestAF(function () {
	        if (_this.bvDropdown) {
	          _this.bvDropdown.hide(true);
	        }
	      });
	    },
	    onClick: function onClick(evt) {
	      this.$emit('click', evt);
	      this.closeDropdown();
	    }
	  },
	  render: function render(h) {
	    return h('li', {
	      attrs: {
	        role: 'presentation'
	      }
	    }, [h(BLink, {
	      props: this.$props,
	      staticClass: 'dropdown-item',
	      class: _defineProperty$l({}, "text-".concat(this.variant), this.variant && !(this.active || this.disabled)),
	      attrs: _objectSpread$g({}, this.$attrs, {
	        role: 'menuitem'
	      }),
	      on: {
	        click: this.onClick
	      },
	      ref: 'item'
	    }, this.normalizeSlot('default'))]);
	  }
	});

	function ownKeys$h(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$h(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$h(source, true).forEach(function (key) { _defineProperty$m(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$h(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$m(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$l = {
	  active: {
	    type: Boolean,
	    default: false
	  },
	  activeClass: {
	    type: String,
	    default: 'active'
	  },
	  disabled: {
	    type: Boolean,
	    default: false
	  },
	  variant: {
	    type: String,
	    default: null
	  }
	}; // @vue/component

	var BDropdownItemButton =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BDropdownItemButton',
	  mixins: [normalizeSlotMixin],
	  inheritAttrs: false,
	  inject: {
	    bvDropdown: {
	      default: null
	    }
	  },
	  props: props$l,
	  methods: {
	    closeDropdown: function closeDropdown() {
	      if (this.bvDropdown) {
	        this.bvDropdown.hide(true);
	      }
	    },
	    onClick: function onClick(evt) {
	      this.$emit('click', evt);
	      this.closeDropdown();
	    }
	  },
	  render: function render(h) {
	    var _class;

	    return h('li', {
	      attrs: {
	        role: 'presentation'
	      }
	    }, [h('button', {
	      staticClass: 'dropdown-item',
	      class: (_class = {}, _defineProperty$m(_class, this.activeClass, this.active), _defineProperty$m(_class, "text-".concat(this.variant), this.variant && !(this.active || this.disabled)), _class),
	      attrs: _objectSpread$h({}, this.$attrs, {
	        role: 'menuitem',
	        type: 'button',
	        disabled: this.disabled
	      }),
	      on: {
	        click: this.onClick
	      },
	      ref: 'button'
	    }, this.normalizeSlot('default'))]);
	  }
	});

	function ownKeys$i(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$i(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$i(source, true).forEach(function (key) { _defineProperty$n(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$i(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$n(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$m = {
	  id: {
	    type: String,
	    default: null
	  },
	  tag: {
	    type: String,
	    default: 'header'
	  },
	  variant: {
	    type: String,
	    default: null
	  }
	}; // @vue/component

	var BDropdownHeader =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BDropdownHeader',
	  functional: true,
	  props: props$m,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var $attrs = data.attrs || {};
	    data.attrs = {};
	    return h('li', a(data, {
	      attrs: {
	        role: 'presentation'
	      }
	    }), [h(props.tag, {
	      staticClass: 'dropdown-header',
	      class: _defineProperty$n({}, "text-".concat(props.variant), props.variant),
	      attrs: _objectSpread$i({}, $attrs, {
	        id: props.id || null,
	        role: 'heading'
	      }),
	      ref: 'header'
	    }, children)]);
	  }
	});

	function ownKeys$j(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$j(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$j(source, true).forEach(function (key) { _defineProperty$o(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$j(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$o(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$n = {
	  tag: {
	    type: String,
	    default: 'hr'
	  }
	}; // @vue/component

	var BDropdownDivider =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BDropdownDivider',
	  functional: true,
	  props: props$n,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data;
	    var $attrs = data.attrs || {};
	    data.attrs = {};
	    return h('li', a(data, {
	      attrs: {
	        role: 'presentation'
	      }
	    }), [h(props.tag, {
	      staticClass: 'dropdown-divider',
	      attrs: _objectSpread$j({}, $attrs, {
	        role: 'separator',
	        'aria-orientation': 'horizontal'
	      }),
	      ref: 'divider'
	    })]);
	  }
	});

	var props$o = {
	  id: {
	    type: String,
	    default: null
	  },
	  inline: {
	    type: Boolean,
	    default: false
	  },
	  novalidate: {
	    type: Boolean,
	    default: false
	  },
	  validated: {
	    type: Boolean,
	    default: false
	  }
	}; // @vue/component

	var BForm =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BForm',
	  functional: true,
	  props: props$o,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h('form', a(data, {
	      class: {
	        'form-inline': props.inline,
	        'was-validated': props.validated
	      },
	      attrs: {
	        id: props.id,
	        novalidate: props.novalidate
	      }
	    }), children);
	  }
	});

	function ownKeys$k(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$k(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$k(source, true).forEach(function (key) { _defineProperty$p(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$k(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$p(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var BDropdownForm =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BDropdownForm',
	  functional: true,
	  props: _objectSpread$k({}, props$o, {
	    disabled: {
	      type: Boolean,
	      default: false
	    }
	  }),
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var $attrs = data.attrs || {};
	    var $listeners = data.on || {};
	    data.attrs = {};
	    data.on = {};
	    return h('li', a(data, {
	      attrs: {
	        role: 'presentation'
	      }
	    }), [h(BForm, {
	      ref: 'form',
	      staticClass: 'b-dropdown-form',
	      class: {
	        disabled: props.disabled
	      },
	      props: props,
	      attrs: _objectSpread$k({}, $attrs, {
	        disabled: props.disabled,
	        // Tab index of -1 for keyboard navigation
	        tabindex: props.disabled ? null : '-1'
	      }),
	      on: $listeners
	    }, children)]);
	  }
	});

	function _defineProperty$q(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var BDropdownText =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BDropdownText',
	  functional: true,
	  props: {
	    tag: {
	      type: String,
	      default: 'p'
	    },
	    variant: {
	      type: String,
	      default: null
	    }
	  },
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var $attrs = data.attrs || {};
	    data.attrs = {};
	    return h('li', a(data, {
	      attrs: {
	        role: 'presentation'
	      }
	    }), [h(props.tag, {
	      staticClass: 'b-dropdown-text',
	      class: _defineProperty$q({}, "text-".concat(props.variant), props.variant),
	      props: props,
	      attrs: $attrs,
	      ref: 'text'
	    }, children)]);
	  }
	});

	function ownKeys$l(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$l(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$l(source, true).forEach(function (key) { _defineProperty$r(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$l(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$r(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$p = {
	  id: {
	    type: String,
	    default: null
	  },
	  header: {
	    type: String,
	    default: null
	  },
	  headerTag: {
	    type: String,
	    default: 'header'
	  },
	  headerVariant: {
	    type: String,
	    default: null
	  },
	  headerClasses: {
	    type: [String, Array, Object],
	    default: null
	  },
	  ariaDescribedby: {
	    type: String,
	    default: null
	  }
	}; // @vue/component

	var BDropdownGroup =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BDropdownGroup',
	  functional: true,
	  props: props$p,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        slots = _ref.slots,
	        scopedSlots = _ref.scopedSlots;
	    var $slots = slots();
	    var $scopedSlots = scopedSlots || {};
	    var $attrs = data.attrs || {};
	    data.attrs = {};
	    var header;
	    var headerId = null;

	    if (hasNormalizedSlot('header', $scopedSlots, $slots) || props.header) {
	      headerId = props.id ? "_bv_".concat(props.id, "_group_dd_header") : null;
	      header = h(props.headerTag, {
	        staticClass: 'dropdown-header',
	        class: [props.headerClasses, _defineProperty$r({}, "text-".concat(props.variant), props.variant)],
	        attrs: {
	          id: headerId,
	          role: 'heading'
	        }
	      }, normalizeSlot('header', {}, $scopedSlots, $slots) || props.header);
	    }

	    var adb = [headerId, props.ariaDescribedBy].filter(Boolean).join(' ').trim();
	    return h('li', a(data, {
	      attrs: {
	        role: 'presentation'
	      }
	    }), [header || h(), h('ul', {
	      staticClass: 'list-unstyled',
	      attrs: _objectSpread$l({}, $attrs, {
	        id: props.id || null,
	        role: 'group',
	        'aria-describedby': adb || null
	      })
	    }, normalizeSlot('default', {}, $scopedSlots, $slots))]);
	  }
	});

	var DropdownPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BDropdown: BDropdown,
	    BDd: BDropdown,
	    BDropdownItem: BDropdownItem,
	    BDdItem: BDropdownItem,
	    BDropdownItemButton: BDropdownItemButton,
	    BDropdownItemBtn: BDropdownItemButton,
	    BDdItemButton: BDropdownItemButton,
	    BDdItemBtn: BDropdownItemButton,
	    BDropdownHeader: BDropdownHeader,
	    BDdHeader: BDropdownHeader,
	    BDropdownDivider: BDropdownDivider,
	    BDdDivider: BDropdownDivider,
	    BDropdownForm: BDropdownForm,
	    BDdForm: BDropdownForm,
	    BDropdownText: BDropdownText,
	    BDdText: BDropdownText,
	    BDropdownGroup: BDropdownGroup,
	    BDdGroup: BDropdownGroup
	  }
	});

	function _defineProperty$s(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$q = {
	  type: {
	    type: String,
	    default: 'iframe',
	    validator: function validator(str) {
	      return arrayIncludes(['iframe', 'embed', 'video', 'object', 'img', 'b-img', 'b-img-lazy'], str);
	    }
	  },
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  aspect: {
	    type: String,
	    default: '16by9'
	  }
	}; // @vue/component

	var BEmbed =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BEmbed',
	  functional: true,
	  props: props$q,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.tag, {
	      ref: data.ref,
	      staticClass: 'embed-responsive',
	      class: _defineProperty$s({}, "embed-responsive-".concat(props.aspect), Boolean(props.aspect))
	    }, [h(props.type, a(data, {
	      ref: '',
	      staticClass: 'embed-responsive-item'
	    }), children)]);
	  }
	});

	var EmbedPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BEmbed: BEmbed
	  }
	});

	var formOptionsMixin = {
	  props: {
	    options: {
	      type: [Array, Object],
	      default: function _default() {
	        return [];
	      }
	    },
	    valueField: {
	      type: String,
	      default: 'value'
	    },
	    textField: {
	      type: String,
	      default: 'text'
	    },
	    htmlField: {
	      type: String,
	      default: 'html'
	    },
	    disabledField: {
	      type: String,
	      default: 'disabled'
	    }
	  },
	  computed: {
	    formOptions: function formOptions() {
	      var options = this.options;
	      var valueField = this.valueField;
	      var textField = this.textField;
	      var htmlField = this.htmlField;
	      var disabledField = this.disabledField;

	      if (isArray(options)) {
	        // Normalize flat-ish arrays to Array of Objects
	        return options.map(function (option) {
	          if (isPlainObject(option)) {
	            var value = option[valueField];
	            var text = String(option[textField]);
	            return {
	              value: isUndefined(value) ? text : value,
	              text: stripTags(text),
	              html: option[htmlField],
	              disabled: Boolean(option[disabledField])
	            };
	          }

	          return {
	            value: option,
	            text: stripTags(String(option)),
	            disabled: false
	          };
	        });
	      } else {
	        // options is Object
	        // Normalize Objects to Array of Objects
	        return keys$2(options).map(function (key) {
	          var option = options[key] || {};

	          if (isPlainObject(option)) {
	            var value = option[valueField];
	            var text = option[textField];
	            return {
	              value: isUndefined(value) ? key : value,
	              text: isUndefined(text) ? stripTags(String(key)) : stripTags(String(text)),
	              html: option[htmlField],
	              disabled: Boolean(option[disabledField])
	            };
	          }

	          return {
	            value: key,
	            text: stripTags(String(option)),
	            disabled: false
	          };
	        });
	      }
	    }
	  }
	};

	function ownKeys$m(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$m(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$m(source, true).forEach(function (key) { _defineProperty$t(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$m(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$t(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var BFormDatalist =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BFormDatalist',
	  mixins: [formOptionsMixin, normalizeSlotMixin],
	  props: {
	    id: {
	      type: String,
	      default: null,
	      required: true
	    }
	  },
	  render: function render(h) {
	    var options = this.formOptions.map(function (option, index) {
	      return h('option', {
	        key: "option_".concat(index, "_opt"),
	        attrs: {
	          disabled: option.disabled
	        },
	        domProps: _objectSpread$m({}, htmlOrText(option.html, option.text), {
	          value: option.value
	        })
	      });
	    });
	    return h('datalist', {
	      attrs: {
	        id: this.id
	      }
	    }, [options, this.normalizeSlot('default')]);
	  }
	});

	function _defineProperty$u(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$c = 'BFormText';
	var props$r = {
	  id: {
	    type: String,
	    default: null
	  },
	  tag: {
	    type: String,
	    default: 'small'
	  },
	  textVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$c, 'textVariant');
	    }
	  },
	  inline: {
	    type: Boolean,
	    default: false
	  }
	}; // @vue/component

	var BFormText =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$c,
	  functional: true,
	  props: props$r,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.tag, a(data, {
	      class: _defineProperty$u({
	        'form-text': !props.inline
	      }, "text-".concat(props.textVariant), Boolean(props.textVariant)),
	      attrs: {
	        id: props.id
	      }
	    }), children);
	  }
	});

	var props$s = {
	  id: {
	    type: String,
	    default: null
	  },
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  tooltip: {
	    type: Boolean,
	    default: false
	  },
	  forceShow: {
	    type: Boolean,
	    default: false
	  },
	  state: {
	    type: Boolean,
	    default: null
	  },
	  ariaLive: {
	    type: String,
	    default: null
	  },
	  role: {
	    type: String,
	    default: null
	  }
	}; // @vue/component

	var BFormInvalidFeedback =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BFormInvalidFeedback',
	  functional: true,
	  props: props$s,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var show = props.forceShow === true || props.state === false;
	    return h(props.tag, a(data, {
	      class: {
	        'invalid-feedback': !props.tooltip,
	        'invalid-tooltip': props.tooltip,
	        'd-block': show
	      },
	      attrs: {
	        id: props.id,
	        role: props.role,
	        'aria-live': props.ariaLive,
	        'aria-atomic': props.ariaLive ? 'true' : null
	      }
	    }), children);
	  }
	});

	var props$t = {
	  id: {
	    type: String,
	    default: null
	  },
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  tooltip: {
	    type: Boolean,
	    default: false
	  },
	  forceShow: {
	    type: Boolean,
	    default: false
	  },
	  state: {
	    type: Boolean,
	    default: null
	  },
	  ariaLive: {
	    type: String,
	    default: null
	  },
	  role: {
	    type: String,
	    default: null
	  }
	}; // @vue/component

	var BFormValidFeedback =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BFormValidFeedback',
	  functional: true,
	  props: props$t,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var show = props.forceShow === true || props.state === true;
	    return h(props.tag, a(data, {
	      class: {
	        'valid-feedback': !props.tooltip,
	        'valid-tooltip': props.tooltip,
	        'd-block': show
	      },
	      attrs: {
	        id: props.id,
	        role: props.role,
	        'aria-live': props.ariaLive,
	        'aria-atomic': props.ariaLive ? 'true' : null
	      }
	    }), children);
	  }
	});

	var props$u = {
	  tag: {
	    type: String,
	    default: 'div'
	  }
	}; // @vue/component

	var BFormRow =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BFormRow',
	  functional: true,
	  props: props$u,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.tag, a(data, {
	      staticClass: 'form-row'
	    }), children);
	  }
	});

	var FormPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BForm: BForm,
	    BFormDatalist: BFormDatalist,
	    BDatalist: BFormDatalist,
	    BFormText: BFormText,
	    BFormInvalidFeedback: BFormInvalidFeedback,
	    BFormFeedback: BFormInvalidFeedback,
	    BFormValidFeedback: BFormValidFeedback,
	    // Added here for convenience
	    BFormRow: BFormRow
	  }
	}); // BFormRow is not exported here as a named export, as it is exported by Layout

	/* Form control contextual state class computation
	 *
	 * Returned class is either 'is-valid' or 'is-invalid' based on the 'state' prop
	 * state can be one of five values:
	 *  - true for is-valid
	 *  - false for is-invalid
	 *  - null for no contextual state
	 */

	var formStateMixin = {
	  props: {
	    state: {
	      // Tri-state prop: true, false, null (or undefined)
	      type: Boolean,
	      default: null
	    }
	  },
	  computed: {
	    computedState: function computedState() {
	      // If not a boolean, ensure that value is null
	      return isBoolean(this.state) ? this.state : null;
	    },
	    stateClass: function stateClass() {
	      var state = this.computedState;

	      if (state === true) {
	        return 'is-valid';
	      } else if (state === false) {
	        return 'is-invalid';
	      }

	      return null;
	    }
	  }
	};

	/**
	 * Suffix can be a falsey value so nothing is appended to string.
	 * (helps when looping over props & some shouldn't change)
	 * Use data last parameters to allow for currying.
	 * @param {string} suffix
	 * @param {string} str
	 */

	var suffixPropName = function suffixPropName(suffix, str) {
	  return str + (suffix ? upperFirst(suffix) : '');
	};

	function ownKeys$n(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$n(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$n(source, true).forEach(function (key) { _defineProperty$v(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$n(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$v(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var boolStrNum = function boolStrNum() {
	  return {
	    type: [Boolean, String, Number],
	    default: false
	  };
	}; // Generates a prop object with a type of `[String, Number]`


	var strNum = function strNum() {
	  return {
	    type: [String, Number],
	    default: null
	  };
	}; // Compute a breakpoint class name


	var computeBreakpoint = function computeBreakpoint(type, breakpoint, val) {
	  var className = type;

	  if (isUndefined(val) || isNull(val) || val === false) {
	    return undefined;
	  }

	  if (breakpoint) {
	    className += "-".concat(breakpoint);
	  } // Handling the boolean style prop when accepting [Boolean, String, Number]
	  // means Vue will not convert <b-col sm></b-col> to sm: true for us.
	  // Since the default is false, an empty string indicates the prop's presence.


	  if (type === 'col' && (val === '' || val === true)) {
	    // .col-md
	    return className.toLowerCase();
	  } // .order-md-6


	  className += "-".concat(val);
	  return className.toLowerCase();
	}; // Memoized function for better performance on generating class names


	var computeBreakpointClass = memoize(computeBreakpoint); // Cached copy of the breakpoint prop names

	var breakpointPropMap = create(null); // Lazy evaled props factory for BCol

	var generateProps = function generateProps() {
	  // Grab the breakpoints from the cached config (exclude the '' (xs) breakpoint)
	  var breakpoints = getBreakpointsUpCached().filter(Boolean); // Supports classes like: .col-sm, .col-md-6, .col-lg-auto

	  var breakpointCol = breakpoints.reduce(function (propMap, breakpoint) {
	    if (breakpoint) {
	      // We filter out the '' breakpoint (xs), as making a prop name ''
	      // would not work. The `cols` prop is used for `xs`
	      propMap[breakpoint] = boolStrNum();
	    }

	    return propMap;
	  }, create(null)); // Supports classes like: .offset-md-1, .offset-lg-12

	  var breakpointOffset = breakpoints.reduce(function (propMap, breakpoint) {
	    propMap[suffixPropName(breakpoint, 'offset')] = strNum();
	    return propMap;
	  }, create(null)); // Supports classes like: .order-md-1, .order-lg-12

	  var breakpointOrder = breakpoints.reduce(function (propMap, breakpoint) {
	    propMap[suffixPropName(breakpoint, 'order')] = strNum();
	    return propMap;
	  }, create(null)); // For loop doesn't need to check hasOwnProperty
	  // when using an object created from null

	  breakpointPropMap = assign(create(null), {
	    col: keys$2(breakpointCol),
	    offset: keys$2(breakpointOffset),
	    order: keys$2(breakpointOrder)
	  }); // Return the generated props

	  return _objectSpread$n({
	    // Generic flexbox .col (xs)
	    col: {
	      type: Boolean,
	      default: false
	    },
	    // .col-[1-12]|auto  (xs)
	    cols: strNum()
	  }, breakpointCol, {
	    offset: strNum()
	  }, breakpointOffset, {
	    order: strNum()
	  }, breakpointOrder, {
	    // Flex alignment
	    alignSelf: {
	      type: String,
	      default: null,
	      validator: function validator(str) {
	        return arrayIncludes(['auto', 'start', 'end', 'center', 'baseline', 'stretch'], str);
	      }
	    },
	    tag: {
	      type: String,
	      default: 'div'
	    }
	  });
	}; // We do not use Vue.extend here as that would evaluate the props
	// immediately, which we do not want to happen
	// @vue/component


	var BCol = {
	  name: 'BCol',
	  functional: true,

	  get props() {
	    // Allow props to be lazy evaled on first access and
	    // then they become a non-getter afterwards.
	    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#Smart_self-overwriting_lazy_getters
	    delete this.props; // eslint-disable-next-line no-return-assign

	    return this.props = generateProps();
	  },

	  render: function render(h, _ref) {
	    var _classList$push;

	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var classList = []; // Loop through `col`, `offset`, `order` breakpoint props

	    for (var type in breakpointPropMap) {
	      // Returns colSm, offset, offsetSm, orderMd, etc.
	      var _keys = breakpointPropMap[type];

	      for (var i = 0; i < _keys.length; i++) {
	        // computeBreakpoint(col, colSm => Sm, value=[String, Number, Boolean])
	        var c = computeBreakpointClass(type, _keys[i].replace(type, ''), props[_keys[i]]); // If a class is returned, push it onto the array.

	        if (c) {
	          classList.push(c);
	        }
	      }
	    }

	    var hasColClasses = classList.some(function (className) {
	      return /^col-/.test(className);
	    });
	    classList.push((_classList$push = {
	      // Default to .col if no other col-{bp}-* classes generated nor `cols` specified.
	      col: props.col || !hasColClasses && !props.cols
	    }, _defineProperty$v(_classList$push, "col-".concat(props.cols), props.cols), _defineProperty$v(_classList$push, "offset-".concat(props.offset), props.offset), _defineProperty$v(_classList$push, "order-".concat(props.order), props.order), _defineProperty$v(_classList$push, "align-self-".concat(props.alignSelf), props.alignSelf), _classList$push));
	    return h(props.tag, a(data, {
	      class: classList
	    }), children);
	  }
	};

	function ownKeys$o(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$o(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$o(source, true).forEach(function (key) { _defineProperty$w(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$o(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$w(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var NAME$d = 'BFormGroup'; // Selector for finding first input in the form-group

	var SELECTOR = 'input:not([disabled]),textarea:not([disabled]),select:not([disabled])'; // Render helper functions (here rather than polluting the instance with more methods)

	var renderInvalidFeedback = function renderInvalidFeedback(h, ctx) {
	  var content = ctx.normalizeSlot('invalid-feedback') || ctx.invalidFeedback;
	  var invalidFeedback = h();

	  if (content) {
	    invalidFeedback = h(BFormInvalidFeedback, {
	      props: {
	        id: ctx.invalidFeedbackId,
	        // If state is explicitly false, always show the feedback
	        state: ctx.computedState,
	        tooltip: ctx.tooltip,
	        ariaLive: ctx.feedbackAriaLive,
	        role: ctx.feedbackAriaLive ? 'alert' : null
	      },
	      attrs: {
	        tabindex: content ? '-1' : null
	      }
	    }, [content]);
	  }

	  return invalidFeedback;
	};

	var renderValidFeedback = function renderValidFeedback(h, ctx) {
	  var content = ctx.normalizeSlot('valid-feedback') || ctx.validFeedback;
	  var validFeedback = h();

	  if (content) {
	    validFeedback = h(BFormValidFeedback, {
	      props: {
	        id: ctx.validFeedbackId,
	        // If state is explicitly true, always show the feedback
	        state: ctx.computedState,
	        tooltip: ctx.tooltip,
	        ariaLive: ctx.feedbackAriaLive,
	        role: ctx.feedbackAriaLive ? 'alert' : null
	      },
	      attrs: {
	        tabindex: content ? '-1' : null
	      }
	    }, [content]);
	  }

	  return validFeedback;
	};

	var renderHelpText = function renderHelpText(h, ctx) {
	  // Form help text (description)
	  var content = ctx.normalizeSlot('description') || ctx.description;
	  var description = h();

	  if (content) {
	    description = h(BFormText, {
	      attrs: {
	        id: ctx.descriptionId,
	        tabindex: content ? '-1' : null
	      }
	    }, [content]);
	  }

	  return description;
	};

	var renderLabel = function renderLabel(h, ctx) {
	  // Render label/legend inside b-col if necessary
	  var content = ctx.normalizeSlot('label') || ctx.label;
	  var labelFor = ctx.labelFor;
	  var isLegend = !labelFor;
	  var isHorizontal = ctx.isHorizontal;
	  var labelTag = isLegend ? 'legend' : 'label';

	  if (!content && !isHorizontal) {
	    return h();
	  } else if (ctx.labelSrOnly) {
	    var label = h();

	    if (content) {
	      label = h(labelTag, {
	        class: 'sr-only',
	        attrs: {
	          id: ctx.labelId,
	          for: labelFor || null
	        }
	      }, [content]);
	    }

	    return h(isHorizontal ? BCol : 'div', {
	      props: isHorizontal ? ctx.labelColProps : {}
	    }, [label]);
	  } else {
	    return h(isHorizontal ? BCol : labelTag, {
	      on: isLegend ? {
	        click: ctx.legendClick
	      } : {},
	      props: isHorizontal ? _objectSpread$o({
	        tag: labelTag
	      }, ctx.labelColProps) : {},
	      attrs: {
	        id: ctx.labelId,
	        for: labelFor || null,
	        // We add a tab index to legend so that screen readers
	        // will properly read the aria-labelledby in IE.
	        tabindex: isLegend ? '-1' : null
	      },
	      class: [// When horizontal or if a legend is rendered, add col-form-label
	      // for correct sizing as Bootstrap has inconsistent font styling
	      // for legend in non-horizontal form-groups.
	      // See: https://github.com/twbs/bootstrap/issues/27805
	      isHorizontal || isLegend ? 'col-form-label' : '', // Emulate label padding top of 0 on legend when not horizontal
	      !isHorizontal && isLegend ? 'pt-0' : '', // If not horizontal and not a legend, we add d-block to label
	      // so that label-align works
	      !isHorizontal && !isLegend ? 'd-block' : '', ctx.labelSize ? "col-form-label-".concat(ctx.labelSize) : '', ctx.labelAlignClasses, ctx.labelClass]
	    }, [content]);
	  }
	}; // -- BFormGroup Prop factory -- used for lazy generation of props
	// Memoize this function to return cached values to
	// save time in computed functions


	var makePropName = memoize(function () {
	  var breakpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	  var prefix = arguments.length > 1 ? arguments[1] : undefined;
	  return "".concat(prefix).concat(upperFirst(breakpoint));
	}); // BFormGroup prop generator for lazy generation of props

	var generateProps$1 = function generateProps() {
	  var BREAKPOINTS = getBreakpointsUpCached(); // Generate the labelCol breakpoint props

	  var bpLabelColProps = BREAKPOINTS.reduce(function (props, breakpoint) {
	    // i.e. label-cols, label-cols-sm, label-cols-md, ...
	    props[makePropName(breakpoint, 'labelCols')] = {
	      type: [Number, String, Boolean],
	      default: breakpoint ? false : null
	    };
	    return props;
	  }, create(null)); // Generate the labelAlign breakpoint props

	  var bpLabelAlignProps = BREAKPOINTS.reduce(function (props, breakpoint) {
	    // label-align, label-align-sm, label-align-md, ...
	    props[makePropName(breakpoint, 'labelAlign')] = {
	      type: String,
	      // left, right, center
	      default: null
	    };
	    return props;
	  }, create(null));
	  return _objectSpread$o({
	    label: {
	      type: String,
	      default: null
	    },
	    labelFor: {
	      type: String,
	      default: null
	    },
	    labelSize: {
	      type: String,
	      default: null
	    },
	    labelSrOnly: {
	      type: Boolean,
	      default: false
	    }
	  }, bpLabelColProps, {}, bpLabelAlignProps, {
	    labelClass: {
	      type: [String, Array, Object],
	      default: null
	    },
	    description: {
	      type: String,
	      default: null
	    },
	    invalidFeedback: {
	      type: String,
	      default: null
	    },
	    validFeedback: {
	      type: String,
	      default: null
	    },
	    tooltip: {
	      // Enable tooltip style feedback
	      type: Boolean,
	      default: false
	    },
	    feedbackAriaLive: {
	      type: String,
	      default: 'assertive'
	    },
	    validated: {
	      type: Boolean,
	      default: false
	    },
	    disabled: {
	      type: Boolean,
	      default: false
	    }
	  });
	}; // We do not use Vue.extend here as that would evaluate the props
	// immediately, which we do not want to happen
	// @vue/component


	var BFormGroup = {
	  name: NAME$d,
	  mixins: [idMixin, formStateMixin, normalizeSlotMixin],

	  get props() {
	    // Allow props to be lazy evaled on first access and
	    // then they become a non-getter afterwards.
	    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#Smart_self-overwriting_lazy_getters
	    delete this.props; // eslint-disable-next-line no-return-assign

	    return this.props = generateProps$1();
	  },

	  computed: {
	    labelColProps: function labelColProps() {
	      var _this = this;

	      var props = {};
	      getBreakpointsUpCached().forEach(function (breakpoint) {
	        // Grab the value if the label column breakpoint prop
	        var propVal = _this[makePropName(breakpoint, 'labelCols')]; // Handle case where the prop's value is an empty string,
	        // which represents true


	        propVal = propVal === '' ? true : propVal || false;

	        if (!isBoolean(propVal) && propVal !== 'auto') {
	          // Convert to column size to number
	          propVal = parseInt(propVal, 10) || 0; // Ensure column size is greater than 0

	          propVal = propVal > 0 ? propVal : false;
	        }

	        if (propVal) {
	          // Add the prop to the list of props to give to b-col
	          // If breakpoint is '' (labelCols=true), then we use the
	          // col prop to make equal width at xs
	          var bColPropName = breakpoint || (isBoolean(propVal) ? 'col' : 'cols'); // Add it to the props

	          props[bColPropName] = propVal;
	        }
	      });
	      return props;
	    },
	    labelAlignClasses: function labelAlignClasses() {
	      var _this2 = this;

	      var classes = [];
	      getBreakpointsUpCached().forEach(function (breakpoint) {
	        // Assemble the label column breakpoint align classes
	        var propVal = _this2[makePropName(breakpoint, 'labelAlign')] || null;

	        if (propVal) {
	          var className = breakpoint ? "text-".concat(breakpoint, "-").concat(propVal) : "text-".concat(propVal);
	          classes.push(className);
	        }
	      });
	      return classes;
	    },
	    isHorizontal: function isHorizontal() {
	      // Determine if the resultant form-group will be rendered
	      // horizontal (meaning it has label-col breakpoints)
	      return keys$2(this.labelColProps).length > 0;
	    },
	    labelId: function labelId() {
	      return this.hasNormalizedSlot('label') || this.label ? this.safeId('_BV_label_') : null;
	    },
	    descriptionId: function descriptionId() {
	      return this.hasNormalizedSlot('description') || this.description ? this.safeId('_BV_description_') : null;
	    },
	    hasInvalidFeedback: function hasInvalidFeedback() {
	      // Used for computing aria-describedby
	      return this.computedState === false && (this.hasNormalizedSlot('invalid-feedback') || this.invalidFeedback);
	    },
	    invalidFeedbackId: function invalidFeedbackId() {
	      return this.hasInvalidFeedback ? this.safeId('_BV_feedback_invalid_') : null;
	    },
	    hasValidFeedback: function hasValidFeedback() {
	      // Used for computing aria-describedby
	      return this.computedState === true && (this.hasNormalizedSlot('valid-feedback') || this.validFeedback);
	    },
	    validFeedbackId: function validFeedbackId() {
	      return this.hasValidFeedback ? this.safeId('_BV_feedback_valid_') : null;
	    },
	    describedByIds: function describedByIds() {
	      // Screen readers will read out any content linked to by aria-describedby
	      // even if the content is hidden with `display: none;`, hence we only include
	      // feedback IDs if the form-group's state is explicitly valid or invalid.
	      return [this.descriptionId, this.invalidFeedbackId, this.validFeedbackId].filter(Boolean).join(' ') || null;
	    }
	  },
	  watch: {
	    describedByIds: function describedByIds(add, remove) {
	      if (add !== remove) {
	        this.setInputDescribedBy(add, remove);
	      }
	    }
	  },
	  mounted: function mounted() {
	    var _this3 = this;

	    this.$nextTick(function () {
	      // Set the aria-describedby IDs on the input specified by label-for
	      // We do this in a nextTick to ensure the children have finished rendering
	      _this3.setInputDescribedBy(_this3.describedByIds);
	    });
	  },
	  methods: {
	    legendClick: function legendClick(evt) {
	      if (this.labelFor) {
	        // Don't do anything if labelFor is set

	        /* istanbul ignore next: clicking a label will focus the input, so no need to test */
	        return;
	      }

	      var tagName = evt.target ? evt.target.tagName : '';

	      if (/^(input|select|textarea|label|button|a)$/i.test(tagName)) {
	        // If clicked an interactive element inside legend,
	        // we just let the default happen

	        /* istanbul ignore next */
	        return;
	      }

	      var inputs = selectAll(SELECTOR, this.$refs.content).filter(isVisible);

	      if (inputs && inputs.length === 1 && inputs[0].focus) {
	        // if only a single input, focus it, emulating label behaviour
	        inputs[0].focus();
	      }
	    },
	    setInputDescribedBy: function setInputDescribedBy(add, remove) {
	      // Sets the `aria-describedby` attribute on the input if label-for is set.
	      // Optionally accepts a string of IDs to remove as the second parameter.
	      // Preserves any aria-describedby value(s) user may have on input.
	      if (this.labelFor && isBrowser) {
	        var input = select("#".concat(this.labelFor), this.$refs.content);

	        if (input) {
	          var adb = 'aria-describedby';
	          var ids = (getAttr(input, adb) || '').split(/\s+/);
	          add = (add || '').split(/\s+/);
	          remove = (remove || '').split(/\s+/); // Update ID list, preserving any original IDs
	          // and ensuring the ID's are unique

	          ids = ids.filter(function (id) {
	            return !arrayIncludes(remove, id);
	          }).concat(add).filter(Boolean);
	          ids = keys$2(ids.reduce(function (memo, id) {
	            return _objectSpread$o({}, memo, _defineProperty$w({}, id, true));
	          }, {})).join(' ').trim();

	          if (ids) {
	            setAttr(input, adb, ids);
	          } else {
	            // No IDs, so remove the attribute
	            removeAttr(input, adb);
	          }
	        }
	      }
	    }
	  },
	  render: function render(h) {
	    var isFieldset = !this.labelFor;
	    var isHorizontal = this.isHorizontal; // Generate the label

	    var label = renderLabel(h, this); // Generate the content

	    var content = h(isHorizontal ? BCol : 'div', {
	      ref: 'content',
	      attrs: {
	        tabindex: isFieldset ? '-1' : null,
	        role: isFieldset ? 'group' : null
	      }
	    }, [this.normalizeSlot('default') || h(), renderInvalidFeedback(h, this), renderValidFeedback(h, this), renderHelpText(h, this)]); // Create the form-group

	    var data = {
	      staticClass: 'form-group',
	      class: [this.validated ? 'was-validated' : null, this.stateClass],
	      attrs: {
	        id: this.safeId(),
	        disabled: isFieldset ? this.disabled : null,
	        role: isFieldset ? null : 'group',
	        'aria-invalid': this.computedState === false ? 'true' : null,
	        // Only apply aria-labelledby if we are a horizontal fieldset
	        // as the legend is no longer a direct child of fieldset
	        'aria-labelledby': isFieldset && isHorizontal ? this.labelId : null,
	        // Only apply aria-describedby IDs if we are a fieldset
	        // as the input will have the IDs when not a fieldset
	        'aria-describedby': isFieldset ? this.describedByIds : null
	      }
	    }; // Return it wrapped in a form-group
	    // Note: Fieldsets do not support adding `row` or `form-row` directly
	    // to them due to browser specific render issues, so we move the `form-row`
	    // to an inner wrapper div when horizontal and using a fieldset

	    return h(isFieldset ? 'fieldset' : isHorizontal ? BFormRow : 'div', data, isHorizontal && isFieldset ? [h(BFormRow, {}, [label, content])] : [label, content]);
	  }
	};

	var FormGroupPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BFormGroup: BFormGroup,
	    BFormFieldset: BFormGroup
	  }
	});

	var looseIndexOf = function looseIndexOf(arr, val) {
	  // Assumes that the first argument is an array
	  for (var i = 0; i < arr.length; i++) {
	    if (looseEqual(arr[i], val)) {
	      return i;
	    }
	  }

	  return -1;
	};

	var SELECTOR$1 = 'input, textarea, select'; // @vue/component

	var formMixin = {
	  props: {
	    name: {
	      type: String // default: undefined

	    },
	    id: {
	      type: String // default: undefined

	    },
	    disabled: {
	      type: Boolean
	    },
	    required: {
	      type: Boolean,
	      default: false
	    },
	    form: {
	      type: String,
	      default: null
	    },
	    autofocus: {
	      type: Boolean,
	      default: false
	    }
	  },
	  mounted: function mounted() {
	    this.handleAutofocus();
	  },
	  activated: function activated()
	  /* istanbul ignore next */
	  {
	    this.handleAutofocus();
	  },
	  methods: {
	    handleAutofocus: function handleAutofocus() {
	      var _this = this;

	      this.$nextTick(function () {
	        requestAF(function () {
	          var el = _this.$el;

	          if (_this.autofocus && isVisible(el)) {
	            if (!matches(el, SELECTOR$1)) {
	              el = select(SELECTOR$1, el);
	            }

	            el && el.focus && el.focus();
	          }
	        });
	      });
	    }
	  }
	};

	function ownKeys$p(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$p(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$p(source, true).forEach(function (key) { _defineProperty$x(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$p(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$x(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var formRadioCheckMixin = {
	  mixins: [normalizeSlotMixin],
	  inheritAttrs: false,
	  model: {
	    prop: 'checked',
	    event: 'input'
	  },
	  props: {
	    value: {// Value when checked
	      // type: Object,
	      // default: undefined
	    },
	    checked: {// This is the v-model
	      // type: Object,
	      // default: undefined
	    },
	    inline: {
	      type: Boolean,
	      default: false
	    },
	    plain: {
	      type: Boolean,
	      default: false
	    },
	    button: {
	      // Only applicable in standalone mode (non group)
	      type: Boolean,
	      default: false
	    },
	    buttonVariant: {
	      // Only applicable when rendered with button style
	      type: String,
	      default: null
	    },
	    ariaLabel: {
	      // Placed on the input if present.
	      type: String,
	      default: null
	    },
	    ariaLabelledby: {
	      // Placed on the input if present.
	      type: String,
	      default: null
	    }
	  },
	  data: function data() {
	    return {
	      localChecked: this.isGroup ? this.bvGroup.checked : this.checked,
	      hasFocus: false
	    };
	  },
	  computed: {
	    computedLocalChecked: {
	      get: function get() {
	        return this.isGroup ? this.bvGroup.localChecked : this.localChecked;
	      },
	      set: function set(val) {
	        if (this.isGroup) {
	          this.bvGroup.localChecked = val;
	        } else {
	          this.localChecked = val;
	        }
	      }
	    },
	    isGroup: function isGroup() {
	      // Is this check/radio a child of check-group or radio-group?
	      return Boolean(this.bvGroup);
	    },
	    isBtnMode: function isBtnMode() {
	      // Support button style in single input mode
	      return this.isGroup ? this.bvGroup.buttons : this.button;
	    },
	    isPlain: function isPlain() {
	      return this.isBtnMode ? false : this.isGroup ? this.bvGroup.plain : this.plain;
	    },
	    isCustom: function isCustom() {
	      return this.isBtnMode ? false : !this.isPlain;
	    },
	    isSwitch: function isSwitch() {
	      // Custom switch styling (checkboxes only)
	      return this.isBtnMode || this.isRadio || this.isPlain ? false : this.isGroup ? this.bvGroup.switches : this.switch;
	    },
	    isInline: function isInline() {
	      return this.isGroup ? this.bvGroup.inline : this.inline;
	    },
	    isDisabled: function isDisabled() {
	      // Child can be disabled while parent isn't, but is always disabled if group is
	      return this.isGroup ? this.bvGroup.disabled || this.disabled : this.disabled;
	    },
	    isRequired: function isRequired() {
	      // Required only works when a name is provided for the input(s)
	      // Child can only be required when parent is
	      // Groups will always have a name (either user supplied or auto generated)
	      return Boolean(this.getName && (this.isGroup ? this.bvGroup.required : this.required));
	    },
	    getName: function getName() {
	      // Group name preferred over local name
	      return (this.isGroup ? this.bvGroup.groupName : this.name) || null;
	    },
	    getForm: function getForm() {
	      return (this.isGroup ? this.bvGroup.form : this.form) || null;
	    },
	    getSize: function getSize() {
	      return (this.isGroup ? this.bvGroup.size : this.size) || '';
	    },
	    getState: function getState() {
	      return this.isGroup ? this.bvGroup.computedState : this.computedState;
	    },
	    getButtonVariant: function getButtonVariant() {
	      // Local variant preferred over group variant
	      if (this.buttonVariant) {
	        return this.buttonVariant;
	      } else if (this.isGroup && this.bvGroup.buttonVariant) {
	        return this.bvGroup.buttonVariant;
	      } // default variant


	      return 'secondary';
	    },
	    buttonClasses: function buttonClasses() {
	      var _ref;

	      // Same for radio & check
	      return ['btn', "btn-".concat(this.getButtonVariant), (_ref = {}, _defineProperty$x(_ref, "btn-".concat(this.getSize), this.getSize), _defineProperty$x(_ref, "disabled", this.isDisabled), _defineProperty$x(_ref, "active", this.isChecked), _defineProperty$x(_ref, "focus", this.hasFocus), _ref)];
	    }
	  },
	  watch: {
	    checked: function checked(newVal, oldVal) {
	      this.computedLocalChecked = newVal;
	    }
	  },
	  methods: {
	    handleFocus: function handleFocus(evt) {
	      // When in buttons mode, we need to add 'focus' class to label when input focused
	      // As it is the hidden input which has actual focus
	      if (evt.target) {
	        if (evt.type === 'focus') {
	          this.hasFocus = true;
	        } else if (evt.type === 'blur') {
	          this.hasFocus = false;
	        }
	      }
	    },
	    // Convenience methods for focusing the input
	    focus: function focus() {
	      if (!this.isDisabled && this.$refs.input && this.$refs.input.focus) {
	        this.$refs.input.focus();
	      }
	    },
	    blur: function blur() {
	      if (!this.isDisabled && this.$refs.input && this.$refs.input.blur) {
	        this.$refs.input.blur();
	      }
	    }
	  },
	  render: function render(h) {
	    var defaultSlot = this.normalizeSlot('default'); // Generate the input element

	    var on = {
	      change: this.handleChange
	    };

	    if (this.isBtnMode) {
	      // Handlers for focus styling when in button mode
	      on.focus = on.blur = this.handleFocus;
	    }

	    var input = h('input', {
	      ref: 'input',
	      key: 'input',
	      on: on,
	      class: {
	        'form-check-input': this.isPlain,
	        'custom-control-input': this.isCustom,
	        'is-valid': this.getState === true && !this.isBtnMode,
	        'is-invalid': this.getState === false && !this.isBtnMode,
	        // https://github.com/bootstrap-vue/bootstrap-vue/issues/2911
	        'position-static': this.isPlain && !defaultSlot
	      },
	      directives: [{
	        name: 'model',
	        rawName: 'v-model',
	        value: this.computedLocalChecked,
	        expression: 'computedLocalChecked'
	      }],
	      attrs: _objectSpread$p({}, this.$attrs, {
	        id: this.safeId(),
	        type: this.isRadio ? 'radio' : 'checkbox',
	        name: this.getName,
	        form: this.getForm,
	        disabled: this.isDisabled,
	        required: this.isRequired,
	        autocomplete: 'off',
	        'aria-required': this.isRequired || null,
	        'aria-label': this.ariaLabel || null,
	        'aria-labelledby': this.ariaLabelledby || null
	      }),
	      domProps: {
	        value: this.value,
	        checked: this.isChecked
	      }
	    });

	    if (this.isBtnMode) {
	      // Button mode
	      var button = h('label', {
	        class: this.buttonClasses
	      }, [input, defaultSlot]);

	      if (!this.isGroup) {
	        // Standalone button mode, so wrap in 'btn-group-toggle'
	        // and flag it as inline-block to mimic regular buttons
	        button = h('div', {
	          class: ['btn-group-toggle', 'd-inline-block']
	        }, [button]);
	      }

	      return button;
	    } else {
	      // Not button mode
	      var label = h(); // If no label content in plain mode we dont render the label
	      // https://github.com/bootstrap-vue/bootstrap-vue/issues/2911

	      if (!(this.isPlain && !defaultSlot)) {
	        label = h('label', {
	          class: {
	            'form-check-label': this.isPlain,
	            'custom-control-label': this.isCustom
	          },
	          attrs: {
	            for: this.safeId()
	          }
	        }, defaultSlot);
	      } // Wrap it in a div


	      return h('div', {
	        class: _defineProperty$x({
	          'form-check': this.isPlain,
	          'form-check-inline': this.isPlain && this.isInline,
	          'custom-control': this.isCustom,
	          'custom-control-inline': this.isCustom && this.isInline,
	          'custom-checkbox': this.isCustom && this.isCheck && !this.isSwitch,
	          'custom-switch': this.isSwitch,
	          'custom-radio': this.isCustom && this.isRadio
	        }, "b-custom-control-".concat(this.getSize), Boolean(this.getSize && !this.isBtnMode))
	      }, [input, label]);
	    }
	  }
	};

	var formSizeMixin = {
	  props: {
	    size: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig('formControls', 'size');
	      }
	    }
	  },
	  computed: {
	    sizeFormClass: function sizeFormClass() {
	      return [this.size ? "form-control-".concat(this.size) : null];
	    },
	    sizeBtnClass: function sizeBtnClass()
	    /* istanbul ignore next: don't think this is used */
	    {
	      return [this.size ? "btn-".concat(this.size) : null];
	    }
	  }
	};

	var BFormCheckbox =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BFormCheckbox',
	  mixins: [formRadioCheckMixin, // Includes shared render function
	  idMixin, formMixin, formSizeMixin, formStateMixin],
	  inject: {
	    bvGroup: {
	      from: 'bvCheckGroup',
	      default: false
	    }
	  },
	  props: {
	    value: {
	      // type: [String, Number, Boolean, Object],
	      default: true
	    },
	    uncheckedValue: {
	      // type: [String, Number, Boolean, Object],
	      // Not applicable in multi-check mode
	      default: false
	    },
	    indeterminate: {
	      // Not applicable in multi-check mode
	      type: Boolean,
	      default: false
	    },
	    switch: {
	      // Custom switch styling
	      type: Boolean,
	      default: false
	    },
	    checked: {
	      // v-model (Array when multiple checkboxes have same name)
	      // type: [String, Number, Boolean, Object, Array],
	      default: null
	    }
	  },
	  computed: {
	    isChecked: function isChecked() {
	      var checked = this.computedLocalChecked;
	      var value = this.value;

	      if (isArray(checked)) {
	        return looseIndexOf(checked, value) > -1;
	      } else {
	        return looseEqual(checked, value);
	      }
	    },
	    isRadio: function isRadio() {
	      return false;
	    },
	    isCheck: function isCheck() {
	      return true;
	    }
	  },
	  watch: {
	    computedLocalChecked: function computedLocalChecked(newVal, oldVal) {
	      this.$emit('input', newVal);

	      if (this.$refs && this.$refs.input) {
	        this.$emit('update:indeterminate', this.$refs.input.indeterminate);
	      }
	    },
	    indeterminate: function indeterminate(newVal, oldVal) {
	      this.setIndeterminate(newVal);
	    }
	  },
	  mounted: function mounted() {
	    // Set initial indeterminate state
	    this.setIndeterminate(this.indeterminate);
	  },
	  methods: {
	    handleChange: function handleChange(_ref) {
	      var _ref$target = _ref.target,
	          checked = _ref$target.checked,
	          indeterminate = _ref$target.indeterminate;
	      var localChecked = this.computedLocalChecked;
	      var value = this.value;
	      var isArr = isArray(localChecked);
	      var uncheckedValue = isArr ? null : this.uncheckedValue; // Update computedLocalChecked

	      if (isArr) {
	        var idx = looseIndexOf(localChecked, value);

	        if (checked && idx < 0) {
	          // Add value to array
	          localChecked = localChecked.concat(value);
	        } else if (!checked && idx > -1) {
	          // Remove value from array
	          localChecked = localChecked.slice(0, idx).concat(localChecked.slice(idx + 1));
	        }
	      } else {
	        localChecked = checked ? value : uncheckedValue;
	      }

	      this.computedLocalChecked = localChecked; // Change is only emitted on user interaction

	      this.$emit('change', checked ? value : uncheckedValue); // If this is a child of form-checkbox-group, we emit a change event on it as well

	      if (this.isGroup) {
	        this.bvGroup.$emit('change', localChecked);
	      }

	      this.$emit('update:indeterminate', indeterminate);
	    },
	    setIndeterminate: function setIndeterminate(state) {
	      // Indeterminate only supported in single checkbox mode
	      if (isArray(this.computedLocalChecked)) {
	        state = false;
	      }

	      if (this.$refs && this.$refs.input) {
	        this.$refs.input.indeterminate = state; // Emit update event to prop

	        this.$emit('update:indeterminate', state);
	      }
	    }
	  }
	});

	var BFormRadio =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BFormRadio',
	  mixins: [idMixin, formRadioCheckMixin, // Includes shared render function
	  formMixin, formSizeMixin, formStateMixin],
	  inject: {
	    bvGroup: {
	      from: 'bvRadioGroup',
	      default: false
	    }
	  },
	  props: {
	    checked: {
	      // v-model
	      // type: [String, Number, Boolean, Object],
	      default: null
	    }
	  },
	  computed: {
	    // Radio Groups can only have a single value, so determining if checked is simple
	    isChecked: function isChecked() {
	      return looseEqual(this.value, this.computedLocalChecked);
	    },
	    // Flags for form-radio-check mixin
	    isRadio: function isRadio() {
	      return true;
	    },
	    isCheck: function isCheck() {
	      return false;
	    }
	  },
	  watch: {
	    // Radio Groups can only have a single value, so our watchers are simple
	    computedLocalChecked: function computedLocalChecked(newVal, oldVal) {
	      this.$emit('input', this.computedLocalChecked);
	    }
	  },
	  methods: {
	    handleChange: function handleChange(_ref) {
	      var checked = _ref.target.checked;
	      var value = this.value;
	      this.computedLocalChecked = value; // Change is only emitted on user interaction

	      this.$emit('change', checked ? value : null); // If this is a child of form-radio-group, we emit a change event on it as well

	      if (this.isGroup) {
	        this.bvGroup.$emit('change', checked ? value : null);
	      }
	    }
	  }
	});

	var formRadioCheckGroupMixin = {
	  mixins: [normalizeSlotMixin],
	  model: {
	    prop: 'checked',
	    event: 'input'
	  },
	  props: {
	    validated: {
	      type: Boolean,
	      default: false
	    },
	    ariaInvalid: {
	      type: [Boolean, String],
	      default: false
	    },
	    stacked: {
	      type: Boolean,
	      default: false
	    },
	    plain: {
	      type: Boolean,
	      default: false
	    },
	    buttons: {
	      // Render as button style
	      type: Boolean,
	      default: false
	    },
	    buttonVariant: {
	      // Only applicable when rendered with button style
	      type: String,
	      default: 'secondary'
	    }
	  },
	  computed: {
	    inline: function inline() {
	      return !this.stacked;
	    },
	    groupName: function groupName() {
	      // Checks/Radios tied to the same model must have the same name,
	      // especially for ARIA accessibility.
	      return this.name || this.safeId();
	    },
	    groupClasses: function groupClasses() {
	      if (this.buttons) {
	        return ['btn-group-toggle', this.inline ? 'btn-group' : 'btn-group-vertical', this.size ? "btn-group-".concat(this.size) : '', this.validated ? "was-validated" : ''];
	      }

	      return [this.validated ? "was-validated" : ''];
	    },
	    computedAriaInvalid: function computedAriaInvalid() {
	      var ariaInvalid = this.ariaInvalid;

	      if (ariaInvalid === true || ariaInvalid === 'true' || ariaInvalid === '') {
	        return 'true';
	      }

	      return this.computedState === false ? 'true' : null;
	    }
	  },
	  watch: {
	    checked: function checked(newVal, oldVal) {
	      this.localChecked = newVal;
	    },
	    localChecked: function localChecked(newVal, oldVal) {
	      this.$emit('input', newVal);
	    }
	  },
	  render: function render(h) {
	    var _this = this;

	    var inputs = this.formOptions.map(function (option, idx) {
	      var uid = "_BV_option_".concat(idx, "_");
	      return h(_this.isRadioGroup ? BFormRadio : BFormCheckbox, {
	        key: uid,
	        props: {
	          id: _this.safeId(uid),
	          value: option.value,
	          // Individual radios or checks can be disabled in a group
	          disabled: option.disabled || false // We don't need to include these, since the input's will know they are inside here
	          // name: this.groupName,
	          // form: this.form || null,
	          // required: Boolean(this.name && this.required)

	        }
	      }, [h('span', {
	        domProps: htmlOrText(option.html, option.text)
	      })]);
	    });
	    return h('div', {
	      class: this.groupClasses,
	      attrs: {
	        id: this.safeId(),
	        role: this.isRadioGroup ? 'radiogroup' : 'group',
	        // Tabindex to allow group to be focused if needed
	        tabindex: '-1',
	        'aria-required': this.required ? 'true' : null,
	        'aria-invalid': this.computedAriaInvalid
	      }
	    }, [this.normalizeSlot('first'), inputs, this.normalizeSlot('default')]);
	  }
	};

	var props$v = {
	  switches: {
	    // Custom switch styling
	    type: Boolean,
	    default: false
	  },
	  checked: {
	    type: Array,
	    default: null
	  }
	}; // @vue/component

	var BFormCheckboxGroup =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BFormCheckboxGroup',
	  mixins: [idMixin, formMixin, formRadioCheckGroupMixin, // Includes render function
	  formOptionsMixin, formSizeMixin, formStateMixin],
	  provide: function provide() {
	    return {
	      bvCheckGroup: this
	    };
	  },
	  props: props$v,
	  data: function data() {
	    return {
	      localChecked: this.checked || []
	    };
	  },
	  computed: {
	    isRadioGroup: function isRadioGroup() {
	      return false;
	    }
	  }
	});

	var FormCheckboxPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BFormCheckbox: BFormCheckbox,
	    BCheckbox: BFormCheckbox,
	    BCheck: BFormCheckbox,
	    BFormCheckboxGroup: BFormCheckboxGroup,
	    BCheckboxGroup: BFormCheckboxGroup,
	    BCheckGroup: BFormCheckboxGroup
	  }
	});

	var props$w = {
	  checked: {
	    // type: [String, Number, Boolean, Object],
	    default: null
	  }
	}; // @vue/component

	var BFormRadioGroup =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BFormRadioGroup',
	  mixins: [idMixin, formMixin, formRadioCheckGroupMixin, // Includes render function
	  formOptionsMixin, formSizeMixin, formStateMixin],
	  provide: function provide() {
	    return {
	      bvRadioGroup: this
	    };
	  },
	  props: props$w,
	  data: function data() {
	    return {
	      localChecked: this.checked
	    };
	  },
	  computed: {
	    isRadioGroup: function isRadioGroup() {
	      return true;
	    }
	  }
	});

	var FormRadioPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BFormRadio: BFormRadio,
	    BRadio: BFormRadio,
	    BFormRadioGroup: BFormRadioGroup,
	    BRadioGroup: BFormRadioGroup
	  }
	});

	var formTextMixin = {
	  model: {
	    prop: 'value',
	    event: 'update'
	  },
	  props: {
	    value: {
	      type: [String, Number],
	      default: ''
	    },
	    ariaInvalid: {
	      type: [Boolean, String],
	      default: false
	    },
	    readonly: {
	      type: Boolean,
	      default: false
	    },
	    plaintext: {
	      type: Boolean,
	      default: false
	    },
	    autocomplete: {
	      type: String,
	      default: null
	    },
	    placeholder: {
	      type: String,
	      default: null
	    },
	    formatter: {
	      type: Function,
	      default: null
	    },
	    lazyFormatter: {
	      type: Boolean,
	      default: false
	    },
	    trim: {
	      type: Boolean,
	      default: false
	    },
	    number: {
	      type: Boolean,
	      default: false
	    },
	    lazy: {
	      // Only update the `v-model` on blur/change events
	      type: Boolean,
	      default: false
	    },
	    debounce: {
	      // Debounce timout (in ms). Not applicable with `lazy` prop
	      type: [Number, String],
	      default: 0
	    }
	  },
	  data: function data() {
	    return {
	      localValue: this.stringifyValue(this.value),
	      vModelValue: this.value
	    };
	  },
	  computed: {
	    computedDebounce: function computedDebounce() {
	      // Ensure we have a positive number equal to or greater than 0
	      return Math.max(parseInt(this.debounce, 10) || 0, 0);
	    },
	    computedClass: function computedClass() {
	      return [{
	        // Range input needs class `custom-range`
	        'custom-range': this.type === 'range',
	        // `plaintext` not supported by `type="range"` or `type="color"`
	        'form-control-plaintext': this.plaintext && this.type !== 'range' && this.type !== 'color',
	        // `form-control` not used by `type="range"` or `plaintext`
	        // Always used by `type="color"`
	        'form-control': !this.plaintext && this.type !== 'range' || this.type === 'color'
	      }, this.sizeFormClass, this.stateClass];
	    },
	    computedAriaInvalid: function computedAriaInvalid() {
	      if (!this.ariaInvalid || this.ariaInvalid === 'false') {
	        // `this.ariaInvalid` is `null` or `false` or 'false'
	        return this.computedState === false ? 'true' : null;
	      }

	      if (this.ariaInvalid === true) {
	        // User wants explicit `:aria-invalid="true"`
	        return 'true';
	      } // Most likely a string value (which could be the string 'true')


	      return this.ariaInvalid;
	    }
	  },
	  watch: {
	    value: function value(newVal) {
	      var stringifyValue = this.stringifyValue(newVal);

	      if (stringifyValue !== this.localValue && newVal !== this.vModelValue) {
	        // Clear any pending debounce timeout, as we are overwriting the user input
	        this.clearDebounce(); // Update the local values

	        this.localValue = stringifyValue;
	        this.vModelValue = newVal;
	      }
	    }
	  },
	  mounted: function mounted() {
	    // Create non-reactive property and set up destroy handler
	    this.$_inputDebounceTimer = null;
	    this.$on('hook:beforeDestroy', this.clearDebounce); // Preset the internal state

	    var value = this.value;
	    var stringifyValue = this.stringifyValue(value);
	    /* istanbul ignore next */

	    if (stringifyValue !== this.localValue && value !== this.vModelValue) {
	      this.localValue = stringifyValue;
	      this.vModelValue = value;
	    }
	  },
	  methods: {
	    clearDebounce: function clearDebounce() {
	      clearTimeout(this.$_inputDebounceTimer);
	      this.$_inputDebounceTimer = null;
	    },
	    stringifyValue: function stringifyValue(value) {
	      return isUndefinedOrNull(value) ? '' : String(value);
	    },
	    formatValue: function formatValue(value, evt) {
	      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      value = this.stringifyValue(value);

	      if ((!this.lazyFormatter || force) && isFunction(this.formatter)) {
	        value = this.formatter(value, evt);
	      }

	      return value;
	    },
	    modifyValue: function modifyValue(value) {
	      // Emulate `.trim` modifier behaviour
	      if (this.trim) {
	        value = value.trim();
	      } // Emulate `.number` modifier behaviour


	      if (this.number) {
	        var number = parseFloat(value);
	        value = isNaN(number) ? value : number;
	      }

	      return value;
	    },
	    updateValue: function updateValue(value) {
	      var _this = this;

	      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var lazy = this.lazy;
	      var ms = this.computedDebounce;

	      if (lazy && !force) {
	        return;
	      }

	      value = this.modifyValue(value);

	      if (value !== this.vModelValue) {
	        this.clearDebounce();

	        var doUpdate = function doUpdate() {
	          _this.vModelValue = value;

	          _this.$emit('update', value);
	        };

	        if (ms > 0 && !lazy && !force) {
	          // Change/Blur/Force will not be debounced
	          this.$_inputDebounceTimer = setTimeout(doUpdate, ms);
	        } else {
	          // Immediately update the v-model
	          doUpdate();
	        }
	      }
	    },
	    onInput: function onInput(evt) {
	      // `evt.target.composing` is set by Vue
	      // https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js

	      /* istanbul ignore if: hard to test composition events */
	      if (evt.target.composing) {
	        return;
	      }

	      var value = evt.target.value;
	      var formattedValue = this.formatValue(value, evt); // Exit when the `formatter` function strictly returned `false`
	      // or prevented the input event

	      /* istanbul ignore next */

	      if (formattedValue === false || evt.defaultPrevented) {
	        evt.preventDefault();
	        return;
	      }

	      this.localValue = formattedValue;
	      this.updateValue(formattedValue);
	      this.$emit('input', formattedValue);
	    },
	    onChange: function onChange(evt) {
	      // `evt.target.composing` is set by Vue
	      // https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js

	      /* istanbul ignore if: hard to test composition events */
	      if (evt.target.composing) {
	        return;
	      }

	      var value = evt.target.value;
	      var formattedValue = this.formatValue(value, evt); // Exit when the `formatter` function strictly returned `false`
	      // or prevented the input event

	      /* istanbul ignore next */

	      if (formattedValue === false || evt.defaultPrevented) {
	        evt.preventDefault();
	        return;
	      }

	      this.localValue = formattedValue;
	      this.updateValue(formattedValue, true);
	      this.$emit('change', formattedValue);
	    },
	    onBlur: function onBlur(evt) {
	      // Apply the `localValue` on blur to prevent cursor jumps
	      // on mobile browsers (e.g. caused by autocomplete)
	      var value = evt.target.value;
	      var formattedValue = this.formatValue(value, evt, true);

	      if (formattedValue !== false) {
	        // We need to use the modified value here to apply the
	        // `.trim` and `.number` modifiers properly
	        this.localValue = this.stringifyValue(this.modifyValue(formattedValue)); // We pass the formatted value here since the `updateValue` method
	        // handles the modifiers itself

	        this.updateValue(formattedValue, true);
	      } // Emit native blur event


	      this.$emit('blur', evt);
	    },
	    focus: function focus() {
	      // For external handler that may want a focus method
	      if (!this.disabled) {
	        this.$el.focus();
	      }
	    },
	    blur: function blur() {
	      // For external handler that may want a blur method
	      if (!this.disabled) {
	        this.$el.blur();
	      }
	    }
	  }
	};

	// @vue/component
	var formSelectionMixin = {
	  computed: {
	    selectionStart: {
	      // Expose selectionStart for formatters, etc
	      cache: false,
	      get: function get()
	      /* istanbul ignore next */
	      {
	        return this.$refs.input.selectionStart;
	      },
	      set: function set(val)
	      /* istanbul ignore next */
	      {
	        this.$refs.input.selectionStart = val;
	      }
	    },
	    selectionEnd: {
	      // Expose selectionEnd for formatters, etc
	      cache: false,
	      get: function get()
	      /* istanbul ignore next */
	      {
	        return this.$refs.input.selectionEnd;
	      },
	      set: function set(val)
	      /* istanbul ignore next */
	      {
	        this.$refs.input.selectionEnd = val;
	      }
	    },
	    selectionDirection: {
	      // Expose selectionDirection for formatters, etc
	      cache: false,
	      get: function get()
	      /* istanbul ignore next */
	      {
	        return this.$refs.input.selectionDirection;
	      },
	      set: function set(val)
	      /* istanbul ignore next */
	      {
	        this.$refs.input.selectionDirection = val;
	      }
	    }
	  },
	  methods: {
	    select: function select()
	    /* istanbul ignore next */
	    {
	      var _this$$refs$input;

	      // For external handler that may want a select() method
	      (_this$$refs$input = this.$refs.input).select.apply(_this$$refs$input, arguments);
	    },
	    setSelectionRange: function setSelectionRange()
	    /* istanbul ignore next */
	    {
	      var _this$$refs$input2;

	      // For external handler that may want a setSelectionRange(a,b,c) method
	      (_this$$refs$input2 = this.$refs.input).setSelectionRange.apply(_this$$refs$input2, arguments);
	    },
	    setRangeText: function setRangeText()
	    /* istanbul ignore next */
	    {
	      var _this$$refs$input3;

	      // For external handler that may want a setRangeText(a,b,c) method
	      (_this$$refs$input3 = this.$refs.input).setRangeText.apply(_this$$refs$input3, arguments);
	    }
	  }
	};

	// @vue/component
	var formValidityMixin = {
	  computed: {
	    validity: {
	      // Expose validity property
	      cache: false,
	      get: function get()
	      /* istanbul ignore next */
	      {
	        return this.$refs.input.validity;
	      }
	    },
	    validationMessage: {
	      // Expose validationMessage property
	      cache: false,
	      get: function get()
	      /* istanbul ignore next */
	      {
	        return this.$refs.input.validationMessage;
	      }
	    },
	    willValidate: {
	      // Expose willValidate property
	      cache: false,
	      get: function get()
	      /* istanbul ignore next */
	      {
	        return this.$refs.input.willValidate;
	      }
	    }
	  },
	  methods: {
	    setCustomValidity: function setCustomValidity()
	    /* istanbul ignore next */
	    {
	      var _this$$refs$input;

	      // For external handler that may want a setCustomValidity(...) method
	      return (_this$$refs$input = this.$refs.input).setCustomValidity.apply(_this$$refs$input, arguments);
	    },
	    checkValidity: function checkValidity()
	    /* istanbul ignore next */
	    {
	      var _this$$refs$input2;

	      // For external handler that may want a checkValidity(...) method
	      return (_this$$refs$input2 = this.$refs.input).checkValidity.apply(_this$$refs$input2, arguments);
	    },
	    reportValidity: function reportValidity()
	    /* istanbul ignore next */
	    {
	      var _this$$refs$input3;

	      // For external handler that may want a reportValidity(...) method
	      return (_this$$refs$input3 = this.$refs.input).reportValidity.apply(_this$$refs$input3, arguments);
	    }
	  }
	};

	function ownKeys$q(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$q(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$q(source, true).forEach(function (key) { _defineProperty$y(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$q(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$y(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var TYPES = ['text', 'password', 'email', 'number', 'url', 'tel', 'search', 'range', 'color', 'date', 'time', 'datetime', 'datetime-local', 'month', 'week']; // @vue/component

	var BFormInput =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BFormInput',
	  mixins: [idMixin, formMixin, formSizeMixin, formStateMixin, formTextMixin, formSelectionMixin, formValidityMixin],
	  props: {
	    // value prop defined in form-text mixin
	    // value: { },
	    type: {
	      type: String,
	      default: 'text',
	      validator: function validator(type) {
	        return arrayIncludes(TYPES, type);
	      }
	    },
	    noWheel: {
	      // Disable mousewheel to prevent wheel from changing values (i.e. number/date).
	      type: Boolean,
	      default: false
	    },
	    min: {
	      type: [String, Number],
	      default: null
	    },
	    max: {
	      type: [String, Number],
	      default: null
	    },
	    step: {
	      type: [String, Number],
	      default: null
	    },
	    list: {
	      type: String,
	      default: null
	    }
	  },
	  computed: {
	    localType: function localType() {
	      // We only allow certain types
	      return arrayIncludes(TYPES, this.type) ? this.type : 'text';
	    }
	  },
	  watch: {
	    noWheel: function noWheel(newVal) {
	      this.setWheelStopper(newVal);
	    }
	  },
	  mounted: function mounted() {
	    this.setWheelStopper(this.noWheel);
	  },
	  deactivated: function deactivated() {
	    // Turn off listeners when keep-alive component deactivated

	    /* istanbul ignore next */
	    this.setWheelStopper(false);
	  },
	  activated: function activated() {
	    // Turn on listeners (if no-wheel) when keep-alive component activated

	    /* istanbul ignore next */
	    this.setWheelStopper(this.noWheel);
	  },
	  beforeDestroy: function beforeDestroy() {
	    /* istanbul ignore next */
	    this.setWheelStopper(false);
	  },
	  methods: {
	    setWheelStopper: function setWheelStopper(on) {
	      var input = this.$el; // We use native events, so that we don't interfere with propgation

	      if (on) {
	        eventOn(input, 'focus', this.onWheelFocus);
	        eventOn(input, 'blur', this.onWheelBlur);
	      } else {
	        eventOff(input, 'focus', this.onWheelFocus);
	        eventOff(input, 'blur', this.onWheelBlur);
	        eventOff(document, 'wheel', this.stopWheel);
	      }
	    },
	    onWheelFocus: function onWheelFocus(evt) {
	      eventOn(document, 'wheel', this.stopWheel);
	    },
	    onWheelBlur: function onWheelBlur(evt) {
	      eventOff(document, 'wheel', this.stopWheel);
	    },
	    stopWheel: function stopWheel(evt) {
	      evt.preventDefault();
	      this.$el.blur();
	    }
	  },
	  render: function render(h) {
	    var self = this;
	    return h('input', {
	      ref: 'input',
	      class: self.computedClass,
	      directives: [{
	        name: 'model',
	        rawName: 'v-model',
	        value: self.localValue,
	        expression: 'localValue'
	      }],
	      attrs: {
	        id: self.safeId(),
	        name: self.name,
	        form: self.form || null,
	        type: self.localType,
	        disabled: self.disabled,
	        placeholder: self.placeholder,
	        required: self.required,
	        autocomplete: self.autocomplete || null,
	        readonly: self.readonly || self.plaintext,
	        min: self.min,
	        max: self.max,
	        step: self.step,
	        list: self.localType !== 'password' ? self.list : null,
	        'aria-required': self.required ? 'true' : null,
	        'aria-invalid': self.computedAriaInvalid
	      },
	      domProps: {
	        value: self.localValue
	      },
	      on: _objectSpread$q({}, self.$listeners, {
	        input: self.onInput,
	        change: self.onChange,
	        blur: self.onBlur
	      })
	    });
	  }
	});

	var FormInputPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BFormInput: BFormInput,
	    BInput: BFormInput
	  }
	});

	function ownKeys$r(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$r(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$r(source, true).forEach(function (key) { _defineProperty$z(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$r(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$z(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var BFormTextarea =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BFormTextarea',
	  directives: {
	    'b-visible': VBVisible
	  },
	  mixins: [idMixin, listenOnRootMixin, formMixin, formSizeMixin, formStateMixin, formTextMixin, formSelectionMixin, formValidityMixin],
	  props: {
	    rows: {
	      type: [Number, String],
	      default: 2
	    },
	    maxRows: {
	      type: [Number, String],
	      default: null
	    },
	    wrap: {
	      // 'soft', 'hard' or 'off'. Browser default is 'soft'
	      type: String,
	      default: 'soft'
	    },
	    noResize: {
	      // Disable the resize handle of textarea
	      type: Boolean,
	      default: false
	    },
	    noAutoShrink: {
	      // When in auto resize mode, disable shrinking to content height
	      type: Boolean,
	      default: false
	    }
	  },
	  data: function data() {
	    return {
	      heightInPx: null
	    };
	  },
	  computed: {
	    computedStyle: function computedStyle() {
	      var styles = {
	        // Setting `noResize` to true will disable the ability for the user to
	        // manually resize the textarea. We also disable when in auto height mode
	        resize: !this.computedRows || this.noResize ? 'none' : null
	      };

	      if (!this.computedRows) {
	        // Conditionally set the computed CSS height when auto rows/height is enabled
	        // We avoid setting the style to `null`, which can override user manual resize handle
	        styles.height = this.heightInPx; // We always add a vertical scrollbar to the textarea when auto-height is
	        // enabled so that the computed height calculation returns a stable value

	        styles.overflowY = 'scroll';
	      }

	      return styles;
	    },
	    computedMinRows: function computedMinRows() {
	      // Ensure rows is at least 2 and positive (2 is the native textarea value)
	      // A value of 1 can cause issues in some browsers, and most browsers
	      // only support 2 as the smallest value
	      return Math.max(parseInt(this.rows, 10) || 2, 2);
	    },
	    computedMaxRows: function computedMaxRows() {
	      return Math.max(this.computedMinRows, parseInt(this.maxRows, 10) || 0);
	    },
	    computedRows: function computedRows() {
	      // This is used to set the attribute 'rows' on the textarea
	      // If auto-height is enabled, then we return `null` as we use CSS to control height
	      return this.computedMinRows === this.computedMaxRows ? this.computedMinRows : null;
	    }
	  },
	  watch: {
	    localValue: function localValue(newVal, oldVal) {
	      this.setHeight();
	    }
	  },
	  mounted: function mounted() {
	    this.setHeight();
	  },
	  methods: {
	    // Called by intersection observer directive
	    visibleCallback: function visibleCallback(visible)
	    /* istanbul ignore next */
	    {
	      if (visible) {
	        // We use a `$nextTick()` here just to make sure any
	        // transitions or portalling have completed
	        this.$nextTick(this.setHeight);
	      }
	    },
	    setHeight: function setHeight() {
	      var _this = this;

	      this.$nextTick(function () {
	        requestAF(function () {
	          _this.heightInPx = _this.computeHeight();
	        });
	      });
	    },
	    computeHeight: function computeHeight()
	    /* istanbul ignore next: can't test getComputedStyle in JSDOM */
	    {
	      if (this.$isServer || !isNull(this.computedRows)) {
	        return null;
	      }

	      var el = this.$el; // Element must be visible (not hidden) and in document
	      // Must be checked after above checks

	      if (!isVisible(el)) {
	        return null;
	      } // Get current computed styles


	      var computedStyle = getCS(el); // Height of one line of text in px

	      var lineHeight = parseFloat(computedStyle.lineHeight); // Calculate height of border and padding

	      var border = (parseFloat(computedStyle.borderTopWidth) || 0) + (parseFloat(computedStyle.borderBottomWidth) || 0);
	      var padding = (parseFloat(computedStyle.paddingTop) || 0) + (parseFloat(computedStyle.paddingBottom) || 0); // Calculate offset

	      var offset = border + padding; // Minimum height for min rows (which must be 2 rows or greater for cross-browser support)

	      var minHeight = lineHeight * this.computedMinRows + offset; // Get the current style height (with `px` units)

	      var oldHeight = el.style.height || computedStyle.height; // Probe scrollHeight by temporarily changing the height to `auto`

	      el.style.height = 'auto';
	      var scrollHeight = el.scrollHeight; // Place the original old height back on the element, just in case `computedProp`
	      // returns the same value as before

	      el.style.height = oldHeight; // Calculate content height in 'rows' (scrollHeight includes padding but not border)

	      var contentRows = Math.max((scrollHeight - padding) / lineHeight, 2); // Calculate number of rows to display (limited within min/max rows)

	      var rows = Math.min(Math.max(contentRows, this.computedMinRows), this.computedMaxRows); // Calculate the required height of the textarea including border and padding (in pixels)

	      var height = Math.max(Math.ceil(rows * lineHeight + offset), minHeight); // Computed height remains the larger of `oldHeight` and new `height`,
	      // when height is in `sticky` mode (prop `no-auto-shrink` is true)

	      if (this.noAutoShrink && (parseFloat(oldHeight) || 0) > height) {
	        return oldHeight;
	      } // Return the new computed CSS height in px units


	      return "".concat(height, "px");
	    }
	  },
	  render: function render(h) {
	    // Using self instead of this helps reduce code size during minification
	    var self = this;
	    return h('textarea', {
	      ref: 'input',
	      class: self.computedClass,
	      style: self.computedStyle,
	      directives: [{
	        name: 'model',
	        value: self.localValue
	      }, {
	        name: 'b-visible',
	        value: this.visibleCallback,
	        // If textarea is within 640px of viewport, consider it visible
	        modifiers: {
	          '640': true
	        }
	      }],
	      attrs: {
	        id: self.safeId(),
	        name: self.name,
	        form: self.form || null,
	        disabled: self.disabled,
	        placeholder: self.placeholder,
	        required: self.required,
	        autocomplete: self.autocomplete || null,
	        readonly: self.readonly || self.plaintext,
	        rows: self.computedRows,
	        wrap: self.wrap || null,
	        'aria-required': self.required ? 'true' : null,
	        'aria-invalid': self.computedAriaInvalid
	      },
	      domProps: {
	        value: self.localValue
	      },
	      on: _objectSpread$r({}, self.$listeners, {
	        input: self.onInput,
	        change: self.onChange,
	        blur: self.onBlur
	      })
	    });
	  }
	});

	var FormTextareaPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BFormTextarea: BFormTextarea,
	    BTextarea: BFormTextarea
	  }
	});

	// @vue/component
	var formCustomMixin = {
	  props: {
	    plain: {
	      type: Boolean,
	      default: false
	    }
	  },
	  computed: {
	    custom: function custom() {
	      return !this.plain;
	    }
	  }
	};

	function ownKeys$s(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$s(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$s(source, true).forEach(function (key) { _defineProperty$A(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$s(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$A(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$e = 'BFormFile'; // @vue/component

	var BFormFile =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$e,
	  mixins: [idMixin, formMixin, formStateMixin, formCustomMixin, normalizeSlotMixin],
	  inheritAttrs: false,
	  model: {
	    prop: 'value',
	    event: 'input'
	  },
	  props: {
	    size: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig('BFormControl', 'size');
	      }
	    },
	    value: {
	      type: [File, Array],
	      default: null,
	      validator: function validator(val) {
	        /* istanbul ignore next */
	        if (val === '') {
	          warn("".concat(NAME$e, " - setting value/v-model to an empty string for reset is deprecated. Set to 'null' instead"));
	          return true;
	        }

	        return isUndefinedOrNull(val) || isFile(val) || isArray(val) && (val.length === 0 || val.every(isFile));
	      }
	    },
	    accept: {
	      type: String,
	      default: ''
	    },
	    // Instruct input to capture from camera
	    capture: {
	      type: Boolean,
	      default: false
	    },
	    placeholder: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$e, 'placeholder');
	      }
	    },
	    browseText: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$e, 'browseText');
	      }
	    },
	    dropPlaceholder: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$e, 'dropPlaceholder');
	      }
	    },
	    multiple: {
	      type: Boolean,
	      default: false
	    },
	    directory: {
	      type: Boolean,
	      default: false
	    },
	    noTraverse: {
	      type: Boolean,
	      default: false
	    },
	    noDrop: {
	      type: Boolean,
	      default: false
	    },
	    fileNameFormatter: {
	      type: Function,
	      default: null
	    }
	  },
	  data: function data() {
	    return {
	      selectedFile: null,
	      dragging: false,
	      hasFocus: false
	    };
	  },
	  computed: {
	    selectLabel: function selectLabel() {
	      // Draging active
	      if (this.dragging && this.dropPlaceholder) {
	        return this.dropPlaceholder;
	      } // No file chosen


	      if (!this.selectedFile || this.selectedFile.length === 0) {
	        return this.placeholder;
	      } // Convert selectedFile to an array (if not already one)


	      var files = concat(this.selectedFile).filter(Boolean);

	      if (this.hasNormalizedSlot('file-name')) {
	        // There is a slot for formatting the files/names
	        return [this.normalizeSlot('file-name', {
	          files: files,
	          names: files.map(function (f) {
	            return f.name;
	          })
	        })];
	      } else {
	        // Use the user supplied formatter, or the built in one.
	        return isFunction(this.fileNameFormatter) ? String(this.fileNameFormatter(files)) : files.map(function (file) {
	          return file.name;
	        }).join(', ');
	      }
	    }
	  },
	  watch: {
	    selectedFile: function selectedFile(newVal, oldVal) {
	      // The following test is needed when the file input is "reset" or the
	      // exact same file(s) are selected to prevent an infinite loop.
	      // When in `multiple` mode we need to check for two empty arrays or
	      // two arrays with identical files
	      if (newVal === oldVal || isArray(newVal) && isArray(oldVal) && newVal.length === oldVal.length && newVal.every(function (v, i) {
	        return v === oldVal[i];
	      })) {
	        return;
	      }

	      if (!newVal && this.multiple) {
	        this.$emit('input', []);
	      } else {
	        this.$emit('input', newVal);
	      }
	    },
	    value: function value(newVal) {
	      if (!newVal || isArray(newVal) && newVal.length === 0) {
	        this.reset();
	      }
	    }
	  },
	  methods: {
	    focusHandler: function focusHandler(evt) {
	      // Bootstrap v4 doesn't have focus styling for custom file input
	      // Firefox has a '[type=file]:focus ~ sibling' selector issue,
	      // so we add a 'focus' class to get around these bugs
	      if (this.plain || evt.type === 'focusout') {
	        this.hasFocus = false;
	      } else {
	        // Add focus styling for custom file input
	        this.hasFocus = true;
	      }
	    },
	    reset: function reset() {
	      try {
	        // Wrapped in try in case IE 11 craps out
	        this.$refs.input.value = '';
	      } catch (e) {} // IE 11 doesn't support setting `input.value` to '' or null
	      // So we use this little extra hack to reset the value, just in case.
	      // This also appears to work on modern browsers as well.


	      this.$refs.input.type = '';
	      this.$refs.input.type = 'file';
	      this.selectedFile = this.multiple ? [] : null;
	    },
	    onFileChange: function onFileChange(evt) {
	      var _this = this;

	      // Always emit original event
	      this.$emit('change', evt); // Check if special `items` prop is available on event (drop mode)
	      // Can be disabled by setting no-traverse

	      var items = evt.dataTransfer && evt.dataTransfer.items;
	      /* istanbul ignore next: not supported in JSDOM */

	      if (items && !this.noTraverse) {
	        var queue = [];

	        for (var i = 0; i < items.length; i++) {
	          var item = items[i].webkitGetAsEntry();

	          if (item) {
	            queue.push(this.traverseFileTree(item));
	          }
	        }

	        Promise.all(queue).then(function (filesArr) {
	          _this.setFiles(from(filesArr));
	        });
	        return;
	      } // Normal handling


	      this.setFiles(evt.target.files || evt.dataTransfer.files);
	    },
	    setFiles: function setFiles() {
	      var files = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

	      if (!files) {
	        /* istanbul ignore next: this will probably not happen */
	        this.selectedFile = null;
	      } else if (this.multiple) {
	        // Convert files to array
	        var filesArray = [];

	        for (var i = 0; i < files.length; i++) {
	          filesArray.push(files[i]);
	        } // Return file(s) as array


	        this.selectedFile = filesArray;
	      } else {
	        // Return single file object
	        this.selectedFile = files[0] || null;
	      }
	    },
	    onReset: function onReset() {
	      // Triggered when the parent form (if any) is reset
	      this.selectedFile = this.multiple ? [] : null;
	    },
	    onDragover: function onDragover(evt)
	    /* istanbul ignore next: difficult to test in JSDOM */
	    {
	      evt.preventDefault();
	      evt.stopPropagation();

	      if (this.noDrop || !this.custom) {
	        return;
	      }

	      this.dragging = true;
	      evt.dataTransfer.dropEffect = 'copy';
	    },
	    onDragleave: function onDragleave(evt)
	    /* istanbul ignore next: difficult to test in JSDOM */
	    {
	      evt.preventDefault();
	      evt.stopPropagation();
	      this.dragging = false;
	    },
	    onDrop: function onDrop(evt)
	    /* istanbul ignore next: difficult to test in JSDOM */
	    {
	      evt.preventDefault();
	      evt.stopPropagation();

	      if (this.noDrop) {
	        return;
	      }

	      this.dragging = false;

	      if (evt.dataTransfer.files && evt.dataTransfer.files.length > 0) {
	        this.onFileChange(evt);
	      }
	    },
	    traverseFileTree: function traverseFileTree(item, path)
	    /* istanbul ignore next: not supported in JSDOM */
	    {
	      var _this2 = this;

	      // Based on http://stackoverflow.com/questions/3590058
	      return new Promise(function (resolve) {
	        path = path || '';

	        if (item.isFile) {
	          // Get file
	          item.file(function (file) {
	            file.$path = path; // Inject $path to file obj

	            resolve(file);
	          });
	        } else if (item.isDirectory) {
	          // Get folder contents
	          item.createReader().readEntries(function (entries) {
	            var queue = [];

	            for (var i = 0; i < entries.length; i++) {
	              queue.push(_this2.traverseFileTree(entries[i], path + item.name + '/'));
	            }

	            Promise.all(queue).then(function (filesArr) {
	              resolve(from(filesArr));
	            });
	          });
	        }
	      });
	    }
	  },
	  render: function render(h) {
	    // Form Input
	    var input = h('input', {
	      ref: 'input',
	      class: [{
	        'form-control-file': this.plain,
	        'custom-file-input': this.custom,
	        focus: this.custom && this.hasFocus
	      }, this.stateClass],
	      attrs: _objectSpread$s({}, this.$attrs, {
	        type: 'file',
	        id: this.safeId(),
	        name: this.name,
	        disabled: this.disabled,
	        required: this.required,
	        form: this.form || null,
	        capture: this.capture || null,
	        accept: this.accept || null,
	        multiple: this.multiple,
	        webkitdirectory: this.directory,
	        'aria-required': this.required ? 'true' : null
	      }),
	      on: {
	        change: this.onFileChange,
	        focusin: this.focusHandler,
	        focusout: this.focusHandler,
	        reset: this.onReset
	      }
	    });

	    if (this.plain) {
	      return input;
	    } // Overlay Labels


	    var label = h('label', {
	      staticClass: 'custom-file-label',
	      class: [this.dragging ? 'dragging' : null],
	      attrs: {
	        for: this.safeId(),
	        'data-browse': this.browseText || null
	      }
	    }, this.selectLabel); // Return rendered custom file input

	    return h('div', {
	      staticClass: 'custom-file b-form-file',
	      class: [this.stateClass, _defineProperty$A({}, "b-custom-control-".concat(this.size), Boolean(this.size))],
	      attrs: {
	        id: this.safeId('_BV_file_outer_')
	      },
	      on: {
	        dragover: this.onDragover,
	        dragleave: this.onDragleave,
	        drop: this.onDrop
	      }
	    }, [input, label]);
	  }
	});

	var FormFilePlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BFormFile: BFormFile,
	    BFile: BFormFile
	  }
	});

	function ownKeys$t(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$t(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$t(source, true).forEach(function (key) { _defineProperty$B(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$t(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$B(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var BFormSelect =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BFormSelect',
	  mixins: [idMixin, normalizeSlotMixin, formMixin, formSizeMixin, formStateMixin, formCustomMixin, formOptionsMixin],
	  model: {
	    prop: 'value',
	    event: 'input'
	  },
	  props: {
	    value: {// type: [Object, Array, String, Number, Boolean],
	      // default: undefined
	    },
	    multiple: {
	      type: Boolean,
	      default: false
	    },
	    selectSize: {
	      // Browsers default size to 0, which shows 4 rows in most browsers in multiple mode
	      // Size of 1 can bork out Firefox
	      type: Number,
	      default: 0
	    },
	    ariaInvalid: {
	      type: [Boolean, String],
	      default: false
	    }
	  },
	  data: function data() {
	    return {
	      localValue: this.value
	    };
	  },
	  computed: {
	    computedSelectSize: function computedSelectSize() {
	      // Custom selects with a size of zero causes the arrows to be hidden,
	      // so dont render the size attribute in this case
	      return !this.plain && this.selectSize === 0 ? null : this.selectSize;
	    },
	    inputClass: function inputClass() {
	      return [this.plain ? 'form-control' : 'custom-select', this.size && this.plain ? "form-control-".concat(this.size) : null, this.size && !this.plain ? "custom-select-".concat(this.size) : null, this.stateClass];
	    },
	    computedAriaInvalid: function computedAriaInvalid() {
	      if (this.ariaInvalid === true || this.ariaInvalid === 'true') {
	        return 'true';
	      }

	      return this.stateClass === 'is-invalid' ? 'true' : null;
	    }
	  },
	  watch: {
	    value: function value(newVal, oldVal) {
	      this.localValue = newVal;
	    },
	    localValue: function localValue(newVal, oldVal) {
	      this.$emit('input', this.localValue);
	    }
	  },
	  methods: {
	    focus: function focus() {
	      this.$refs.input.focus();
	    },
	    blur: function blur() {
	      this.$refs.input.blur();
	    }
	  },
	  render: function render(h) {
	    var _this = this;

	    var options = this.formOptions.map(function (option, index) {
	      return h('option', {
	        key: "option_".concat(index, "_opt"),
	        attrs: {
	          disabled: Boolean(option.disabled)
	        },
	        domProps: _objectSpread$t({}, htmlOrText(option.html, option.text), {
	          value: option.value
	        })
	      });
	    });
	    return h('select', {
	      ref: 'input',
	      class: this.inputClass,
	      directives: [{
	        name: 'model',
	        rawName: 'v-model',
	        value: this.localValue,
	        expression: 'localValue'
	      }],
	      attrs: {
	        id: this.safeId(),
	        name: this.name,
	        form: this.form || null,
	        multiple: this.multiple || null,
	        size: this.computedSelectSize,
	        disabled: this.disabled,
	        required: this.required,
	        'aria-required': this.required ? 'true' : null,
	        'aria-invalid': this.computedAriaInvalid
	      },
	      on: {
	        change: function change(evt) {
	          var target = evt.target;
	          var selectedVal = from(target.options).filter(function (o) {
	            return o.selected;
	          }).map(function (o) {
	            return '_value' in o ? o._value : o.value;
	          });
	          _this.localValue = target.multiple ? selectedVal : selectedVal[0];

	          _this.$nextTick(function () {
	            _this.$emit('change', _this.localValue);
	          });
	        }
	      }
	    }, [this.normalizeSlot('first'), options, this.normalizeSlot('default')]);
	  }
	});

	var FormSelectPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BFormSelect: BFormSelect,
	    BSelect: BFormSelect
	  }
	});

	var ImagePlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BImg: BImg,
	    BImgLazy: BImgLazy
	  }
	});

	var props$x = {
	  tag: {
	    type: String,
	    default: 'div'
	  }
	}; // @vue/component

	var BInputGroupText =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BInputGroupText',
	  functional: true,
	  props: props$x,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.tag, a(data, {
	      staticClass: 'input-group-text'
	    }), children);
	  }
	});

	function ownKeys$u(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$u(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$u(source, true).forEach(function (key) { _defineProperty$C(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$u(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$C(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var commonProps = {
	  id: {
	    type: String,
	    default: null
	  },
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  isText: {
	    type: Boolean,
	    default: false
	  }
	}; // @vue/component

	var BInputGroupAddon =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BInputGroupAddon',
	  functional: true,
	  props: _objectSpread$u({}, commonProps, {
	    append: {
	      type: Boolean,
	      default: false
	    }
	  }),
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.tag, a(data, {
	      class: {
	        'input-group-append': props.append,
	        'input-group-prepend': !props.append
	      },
	      attrs: {
	        id: props.id
	      }
	    }), props.isText ? [h(BInputGroupText, children)] : children);
	  }
	});

	function ownKeys$v(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$v(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$v(source, true).forEach(function (key) { _defineProperty$D(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$v(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$D(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var BInputGroupPrepend =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BInputGroupPrepend',
	  functional: true,
	  props: commonProps,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    // pass all our props/attrs down to child, and set`append` to false
	    return h(BInputGroupAddon, a(data, {
	      props: _objectSpread$v({}, props, {
	        append: false
	      })
	    }), children);
	  }
	});

	function ownKeys$w(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$w(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$w(source, true).forEach(function (key) { _defineProperty$E(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$w(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$E(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var BInputGroupAppend =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BInputGroupAppend',
	  functional: true,
	  props: commonProps,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    // pass all our props/attrs down to child, and set`append` to true
	    return h(BInputGroupAddon, a(data, {
	      props: _objectSpread$w({}, props, {
	        append: true
	      })
	    }), children);
	  }
	});

	function _defineProperty$F(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _toConsumableArray$4(arr) { return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _nonIterableSpread$4(); }

	function _nonIterableSpread$4() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray$4(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") { return Array.from(iter); } }

	function _arrayWithoutHoles$4(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }
	var NAME$f = 'BInputGroup';
	var props$y = {
	  id: {
	    type: String
	  },
	  size: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$f, 'size');
	    }
	  },
	  prepend: {
	    type: String
	  },
	  prependHtml: {
	    type: String
	  },
	  append: {
	    type: String
	  },
	  appendHtml: {
	    type: String
	  },
	  tag: {
	    type: String,
	    default: 'div'
	  }
	}; // @vue/component

	var BInputGroup =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$f,
	  functional: true,
	  props: props$y,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        slots = _ref.slots,
	        scopedSlots = _ref.scopedSlots;
	    var $slots = slots();
	    var $scopedSlots = scopedSlots || {};
	    var childNodes = []; // Prepend prop/slot

	    if (props.prepend || props.prependHtml || hasNormalizedSlot('prepend', $scopedSlots, $slots)) {
	      childNodes.push(h(BInputGroupPrepend, [// Prop
	      props.prepend || props.prependHtml ? h(BInputGroupText, {
	        domProps: htmlOrText(props.prependHtml, props.prepend)
	      }) : h(), // Slot
	      normalizeSlot('prepend', {}, $scopedSlots, $slots) || h()]));
	    } else {
	      childNodes.push(h());
	    } // Default slot


	    if (hasNormalizedSlot('default', $scopedSlots, $slots)) {
	      childNodes.push.apply(childNodes, _toConsumableArray$4(normalizeSlot('default', {}, $scopedSlots, $slots)));
	    } else {
	      childNodes.push(h());
	    } // Append prop


	    if (props.append || props.appendHtml || hasNormalizedSlot('append', $scopedSlots, $slots)) {
	      childNodes.push(h(BInputGroupAppend, [// prop
	      props.append || props.appendHtml ? h(BInputGroupText, {
	        domProps: htmlOrText(props.appendHtml, props.append)
	      }) : h(), // Slot
	      normalizeSlot('append', {}, $scopedSlots, $slots) || h()]));
	    } else {
	      childNodes.push(h());
	    }

	    return h(props.tag, a(data, {
	      staticClass: 'input-group',
	      class: _defineProperty$F({}, "input-group-".concat(props.size), Boolean(props.size)),
	      attrs: {
	        id: props.id || null,
	        role: 'group'
	      }
	    }), childNodes);
	  }
	});

	var InputGroupPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BInputGroup: BInputGroup,
	    BInputGroupAddon: BInputGroupAddon,
	    BInputGroupPrepend: BInputGroupPrepend,
	    BInputGroupAppend: BInputGroupAppend,
	    BInputGroupText: BInputGroupText
	  }
	});

	var props$z = {
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  fluid: {
	    type: Boolean,
	    default: false
	  }
	}; // @vue/component

	var BContainer =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BContainer',
	  functional: true,
	  props: props$z,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.tag, a(data, {
	      class: {
	        container: !props.fluid,
	        'container-fluid': props.fluid
	      }
	    }), children);
	  }
	});

	function _defineProperty$G(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$g = 'BJumbotron';
	var props$A = {
	  fluid: {
	    type: Boolean,
	    default: false
	  },
	  containerFluid: {
	    type: Boolean,
	    default: false
	  },
	  header: {
	    type: String,
	    default: null
	  },
	  headerHtml: {
	    type: String,
	    default: null
	  },
	  headerTag: {
	    type: String,
	    default: 'h1'
	  },
	  headerLevel: {
	    type: [Number, String],
	    default: '3'
	  },
	  lead: {
	    type: String,
	    default: null
	  },
	  leadHtml: {
	    type: String,
	    default: null
	  },
	  leadTag: {
	    type: String,
	    default: 'p'
	  },
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  bgVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$g, 'bgVariant');
	    }
	  },
	  borderVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$g, 'borderVariant');
	    }
	  },
	  textVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$g, 'textVariant');
	    }
	  }
	}; // @vue/component

	var BJumbotron =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$g,
	  functional: true,
	  props: props$A,
	  render: function render(h, _ref) {
	    var _class2;

	    var props = _ref.props,
	        data = _ref.data,
	        slots = _ref.slots,
	        scopedSlots = _ref.scopedSlots;
	    // The order of the conditionals matter.
	    // We are building the component markup in order.
	    var childNodes = [];
	    var $slots = slots();
	    var $scopedSlots = scopedSlots || {}; // Header

	    if (props.header || hasNormalizedSlot('header', $scopedSlots, $slots) || props.headerHtml) {
	      childNodes.push(h(props.headerTag, {
	        class: _defineProperty$G({}, "display-".concat(props.headerLevel), Boolean(props.headerLevel))
	      }, normalizeSlot('header', {}, $scopedSlots, $slots) || props.headerHtml || stripTags(props.header)));
	    } // Lead


	    if (props.lead || hasNormalizedSlot('lead', $scopedSlots, $slots) || props.leadHtml) {
	      childNodes.push(h(props.leadTag, {
	        staticClass: 'lead'
	      }, normalizeSlot('lead', {}, $scopedSlots, $slots) || props.leadHtml || stripTags(props.lead)));
	    } // Default slot


	    if (hasNormalizedSlot('default', $scopedSlots, $slots)) {
	      childNodes.push(normalizeSlot('default', {}, $scopedSlots, $slots));
	    } // If fluid, wrap content in a container/container-fluid


	    if (props.fluid) {
	      // Children become a child of a container
	      childNodes = [h(BContainer, {
	        props: {
	          fluid: props.containerFluid
	        }
	      }, childNodes)];
	    } // Return the jumbotron


	    return h(props.tag, a(data, {
	      staticClass: 'jumbotron',
	      class: (_class2 = {
	        'jumbotron-fluid': props.fluid
	      }, _defineProperty$G(_class2, "text-".concat(props.textVariant), Boolean(props.textVariant)), _defineProperty$G(_class2, "bg-".concat(props.bgVariant), Boolean(props.bgVariant)), _defineProperty$G(_class2, "border-".concat(props.borderVariant), Boolean(props.borderVariant)), _defineProperty$G(_class2, "border", Boolean(props.borderVariant)), _class2)
	    }), childNodes);
	  }
	});

	var JumbotronPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BJumbotron: BJumbotron
	  }
	});

	function _defineProperty$H(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var COMMON_ALIGNMENT = ['start', 'end', 'center'];
	var props$B = {
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  noGutters: {
	    type: Boolean,
	    default: false
	  },
	  alignV: {
	    type: String,
	    default: null,
	    validator: function validator(str) {
	      return arrayIncludes(COMMON_ALIGNMENT.concat(['baseline', 'stretch']), str);
	    }
	  },
	  alignH: {
	    type: String,
	    default: null,
	    validator: function validator(str) {
	      return arrayIncludes(COMMON_ALIGNMENT.concat(['between', 'around']), str);
	    }
	  },
	  alignContent: {
	    type: String,
	    default: null,
	    validator: function validator(str) {
	      return arrayIncludes(COMMON_ALIGNMENT.concat(['between', 'around', 'stretch']), str);
	    }
	  }
	}; // @vue/component

	var BRow =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BRow',
	  functional: true,
	  props: props$B,
	  render: function render(h, _ref) {
	    var _class;

	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.tag, a(data, {
	      staticClass: 'row',
	      class: (_class = {
	        'no-gutters': props.noGutters
	      }, _defineProperty$H(_class, "align-items-".concat(props.alignV), props.alignV), _defineProperty$H(_class, "justify-content-".concat(props.alignH), props.alignH), _defineProperty$H(_class, "align-content-".concat(props.alignContent), props.alignContent), _class)
	    }), children);
	  }
	});

	var LayoutPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BContainer: BContainer,
	    BRow: BRow,
	    BCol: BCol,
	    BFormRow: BFormRow
	  }
	});

	var LinkPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BLink: BLink
	  }
	});

	function _defineProperty$I(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$C = {
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  flush: {
	    type: Boolean,
	    default: false
	  },
	  horizontal: {
	    type: [Boolean, String],
	    default: false
	  }
	}; // @vue/component

	var BListGroup =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BListGroup',
	  functional: true,
	  props: props$C,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var horizontal = props.horizontal === '' ? true : props.horizontal;
	    horizontal = props.flush ? false : horizontal;
	    var componentData = {
	      staticClass: 'list-group',
	      class: _defineProperty$I({
	        'list-group-flush': props.flush,
	        'list-group-horizontal': horizontal === true
	      }, "list-group-horizontal-".concat(horizontal), isString(horizontal))
	    };
	    return h(props.tag, a(data, componentData), children);
	  }
	});

	function ownKeys$x(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$x(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$x(source, true).forEach(function (key) { _defineProperty$J(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$x(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$J(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$h = 'BListGroupItem';
	var actionTags = ['a', 'router-link', 'button', 'b-link'];
	var linkProps$2 = propsFactory();
	delete linkProps$2.href.default;
	delete linkProps$2.to.default;
	var props$D = _objectSpread$x({
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  action: {
	    type: Boolean,
	    default: null
	  },
	  button: {
	    type: Boolean,
	    default: null
	  },
	  variant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$h, 'variant');
	    }
	  }
	}, linkProps$2); // @vue/component

	var BListGroupItem =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$h,
	  functional: true,
	  props: props$D,
	  render: function render(h, _ref) {
	    var _class;

	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var tag = props.button ? 'button' : !props.href && !props.to ? props.tag : BLink;
	    var isAction = Boolean(props.href || props.to || props.action || props.button || arrayIncludes(actionTags, props.tag));
	    var attrs = {};
	    var itemProps = {};

	    if (tag === 'button') {
	      if (!data.attrs || !data.attrs.type) {
	        // Add a type for button is one not provided in passed attributes
	        attrs.type = 'button';
	      }

	      if (props.disabled) {
	        // Set disabled attribute if button and disabled
	        attrs.disabled = true;
	      }
	    } else {
	      itemProps = pluckProps(linkProps$2, props);
	    }

	    var componentData = {
	      attrs: attrs,
	      props: itemProps,
	      staticClass: 'list-group-item',
	      class: (_class = {}, _defineProperty$J(_class, "list-group-item-".concat(props.variant), Boolean(props.variant)), _defineProperty$J(_class, 'list-group-item-action', isAction), _defineProperty$J(_class, "active", props.active), _defineProperty$J(_class, "disabled", props.disabled), _class)
	    };
	    return h(tag, a(data, componentData), children);
	  }
	});

	var ListGroupPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BListGroup: BListGroup,
	    BListGroupItem: BListGroupItem
	  }
	});

	var props$E = {
	  tag: {
	    type: String,
	    default: 'div'
	  }
	}; // @vue/component

	var BMediaBody =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BMediaBody',
	  functional: true,
	  props: props$E,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.tag, a(data, {
	      staticClass: 'media-body'
	    }), children);
	  }
	});

	function _defineProperty$K(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$F = {
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  verticalAlign: {
	    type: String,
	    default: 'top'
	  }
	}; // @vue/component

	var BMediaAside =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BMediaAside',
	  functional: true,
	  props: props$F,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var align = props.verticalAlign === 'top' ? 'start' : props.verticalAlign === 'bottom' ? 'end' : props.verticalAlign;
	    return h(props.tag, a(data, {
	      staticClass: 'd-flex',
	      class: _defineProperty$K({}, "align-self-".concat(align), align)
	    }), children);
	  }
	});

	var props$G = {
	  tag: {
	    type: String,
	    default: 'div'
	  },
	  rightAlign: {
	    type: Boolean,
	    default: false
	  },
	  verticalAlign: {
	    type: String,
	    default: 'top'
	  },
	  noBody: {
	    type: Boolean,
	    default: false
	  }
	}; // @vue/component

	var BMedia =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BMedia',
	  functional: true,
	  props: props$G,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        slots = _ref.slots,
	        scopedSlots = _ref.scopedSlots,
	        children = _ref.children;
	    var childNodes = props.noBody ? children : [];

	    if (!props.noBody) {
	      var $slots = slots();
	      var $scopedSlots = scopedSlots || {};
	      var $aside = normalizeSlot('aside', {}, $scopedSlots, $slots);
	      var $default = normalizeSlot('default', {}, $scopedSlots, $slots);

	      if ($aside && !props.rightAlign) {
	        childNodes.push(h(BMediaAside, {
	          staticClass: 'mr-3',
	          props: {
	            verticalAlign: props.verticalAlign
	          }
	        }, $aside));
	      }

	      childNodes.push(h(BMediaBody, {}, $default));

	      if ($aside && props.rightAlign) {
	        childNodes.push(h(BMediaAside, {
	          staticClass: 'ml-3',
	          props: {
	            verticalAlign: props.verticalAlign
	          }
	        }, $aside));
	      }
	    }

	    return h(props.tag, a(data, {
	      staticClass: 'media'
	    }), childNodes);
	  }
	});

	var MediaPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BMedia: BMedia,
	    BMediaAside: BMediaAside,
	    BMediaBody: BMediaBody
	  }
	});

	//
	// Single root node portaling of content, which retains parent/child hierarchy
	// Unlike Portal-Vue where portaled content is no longer a descendent of it's
	// intended parent components
	//
	// Private components for use by Tooltips, Popovers and Modals
	//
	// Based on vue-simple-portal
	// https://github.com/LinusBorg/vue-simple-portal
	// Transporter target used by BTransporterSingle
	// Supports only a single root element
	// @vue/component

	var BTransporterTargetSingle =
	/*#__PURE__*/
	Vue.extend({
	  // As an abstract component, it doesn't appear in the $parent chain of
	  // components, which means the next parent of any component rendered inside
	  // of this one will be the parent from which is was portal'd
	  abstract: true,
	  name: 'BTransporterTargetSingle',
	  props: {
	    nodes: {
	      // Even though we only support a single root element,
	      // VNodes are always passed as an array
	      type: [Array, Function] // default: undefined

	    }
	  },
	  data: function data(vm) {
	    return {
	      updatedNodes: vm.nodes
	    };
	  },
	  destroyed: function destroyed() {
	    var el = this.$el;
	    el && el.parentNode && el.parentNode.removeChild(el);
	  },
	  render: function render(h) {
	    var nodes = isFunction(this.updatedNodes) ? this.updatedNodes({}) : this.updatedNodes;
	    nodes = concat(nodes).filter(Boolean);
	    /* istanbul ignore else */

	    if (nodes && nodes.length > 0 && !nodes[0].text) {
	      return nodes[0];
	    } else {
	      /* istanbul ignore next */
	      return h();
	    }
	  }
	}); // This component has no root element, so only a single VNode is allowed
	// @vue/component

	var BTransporterSingle =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTransporterSingle',
	  mixins: [normalizeSlotMixin],
	  props: {
	    disabled: {
	      type: Boolean,
	      default: false
	    },
	    container: {
	      // String: CSS selector,
	      // HTMLElement: Element reference
	      // Mainly needed for tooltips/popovers inside modals
	      type: [String, HTMLElement$1],
	      default: 'body'
	    },
	    tag: {
	      // This should be set to match the root element type
	      type: String,
	      default: 'div'
	    }
	  },
	  watch: {
	    disabled: {
	      immediate: true,
	      handler: function handler(disabled) {
	        disabled ? this.unmountTarget() : this.$nextTick(this.mountTarget);
	      }
	    }
	  },
	  created: function created() {
	    this._bv_defaultFn = null;
	    this._bv_target = null;
	  },
	  beforeMount: function beforeMount() {
	    this.mountTarget();
	  },
	  updated: function updated() {
	    var _this = this;

	    // Placed in a nextTick to ensure that children have completed
	    // updating before rendering in the target
	    this.$nextTick(function () {
	      _this.updateTarget();
	    });
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.unmountTarget();
	    this._bv_defaultFn = null;
	  },
	  methods: {
	    // Get the element which the target should be appended to
	    getContainer: function getContainer() {
	      /* istanbul ignore else */
	      if (isBrowser) {
	        var container = this.container;
	        return isString(container) ? select(container) : container;
	      } else {
	        return null;
	      }
	    },
	    // Mount the target
	    mountTarget: function mountTarget() {
	      if (!this._bv_target) {
	        var container = this.getContainer();

	        if (container) {
	          var el = document.createElement('div');
	          container.appendChild(el);
	          this._bv_target = new BTransporterTargetSingle({
	            el: el,
	            parent: this,
	            propsData: {
	              // Initial nodes to be rendered
	              nodes: concat(this.normalizeSlot('default'))
	            }
	          });
	        }
	      }
	    },
	    // Update the content of the target
	    updateTarget: function updateTarget() {
	      if (isBrowser && this._bv_target) {
	        var defaultFn = this.$scopedSlots.default;

	        if (!this.disabled) {
	          /* istanbul ignore else: only applicable in Vue 2.5.x */
	          if (defaultFn && this._bv_defaultFn !== defaultFn) {
	            // We only update the target component if the scoped slot
	            // function is a fresh one. The new slot syntax (since Vue 2.6)
	            // can cache unchanged slot functions and we want to respect that here
	            this._bv_target.updatedNodes = defaultFn;
	          } else if (!defaultFn) {
	            // We also need to be back compatible with non-scoped default slot (i.e. 2.5.x)
	            this._bv_target.updatedNodes = this.$slots.default;
	          }
	        } // Update the scoped slot function cache


	        this._bv_defaultFn = defaultFn;
	      }
	    },
	    // Unmount the target
	    unmountTarget: function unmountTarget() {
	      if (this._bv_target) {
	        this._bv_target.$destroy();

	        this._bv_target = null;
	      }
	    }
	  },
	  render: function render(h) {
	    if (this.disabled) {
	      var nodes = concat(this.normalizeSlot('default')).filter(Boolean);

	      if (nodes.length > 0 && !nodes[0].text) {
	        return nodes[0];
	      }
	    }

	    return h();
	  }
	});

	// This method returns a component's scoped style attribute name: `data-v-xxxxxxx`
	// The `_scopeId` options property is added by vue-loader when using scoped styles
	// and will be `undefined` if no scoped styles are in use
	var getScopeId = function getScopeId(vm) {
	  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	  return vm ? vm.$options._scopeId || defaultValue : defaultValue;
	};

	function _defineProperty$L(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var scopedStyleAttrsMixin = {
	  computed: {
	    scopedStyleAttrs: function scopedStyleAttrs() {
	      var scopeId = getScopeId(this.$parent);
	      return scopeId ? _defineProperty$L({}, scopeId, '') : {};
	    }
	  }
	};

	/**
	 * Private ModalManager helper
	 * Handles controlling modal stacking zIndexes and body adjustments/classes
	 */
	// Default modal backdrop z-index

	var DEFAULT_ZINDEX = 1040; // Selectors for padding/margin adjustments

	var Selector$1 = {
	  FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
	  STICKY_CONTENT: '.sticky-top',
	  NAVBAR_TOGGLER: '.navbar-toggler'
	}; // @vue/component

	var ModalManager =
	/*#__PURE__*/
	Vue.extend({
	  data: function data() {
	    return {
	      modals: [],
	      baseZIndex: null,
	      scrollbarWidth: null,
	      isBodyOverflowing: false
	    };
	  },
	  computed: {
	    modalCount: function modalCount() {
	      return this.modals.length;
	    },
	    modalsAreOpen: function modalsAreOpen() {
	      return this.modalCount > 0;
	    }
	  },
	  watch: {
	    modalCount: function modalCount(newCount, oldCount) {
	      if (isBrowser) {
	        this.getScrollbarWidth();

	        if (newCount > 0 && oldCount === 0) {
	          // Transitioning to modal(s) open
	          this.checkScrollbar();
	          this.setScrollbar();
	          addClass(document.body, 'modal-open');
	        } else if (newCount === 0 && oldCount > 0) {
	          // Transitioning to modal(s) closed
	          this.resetScrollbar();
	          removeClass(document.body, 'modal-open');
	        }

	        setAttr(document.body, 'data-modal-open-count', String(newCount));
	      }
	    },
	    modals: function modals(newVal, oldVal) {
	      var _this = this;

	      this.checkScrollbar();
	      requestAF(function () {
	        _this.updateModals(newVal || []);
	      });
	    }
	  },
	  methods: {
	    // Public methods
	    registerModal: function registerModal(modal) {
	      var _this2 = this;

	      // Register the modal if not already registered
	      if (modal && this.modals.indexOf(modal) === -1) {
	        // Add modal to modals array
	        this.modals.push(modal);
	        modal.$once('hook:beforeDestroy', function () {
	          _this2.unregisterModal(modal);
	        });
	      }
	    },
	    unregisterModal: function unregisterModal(modal) {
	      var index = this.modals.indexOf(modal);

	      if (index > -1) {
	        // Remove modal from modals array
	        this.modals.splice(index, 1); // Reset the modal's data

	        if (!(modal._isBeingDestroyed || modal._isDestroyed)) {
	          this.resetModal(modal);
	        }
	      }
	    },
	    getBaseZIndex: function getBaseZIndex() {
	      if (isNull(this.baseZIndex) && isBrowser) {
	        // Create a temporary `div.modal-backdrop` to get computed z-index
	        var div = document.createElement('div');
	        div.className = 'modal-backdrop d-none';
	        div.style.display = 'none';
	        document.body.appendChild(div);
	        this.baseZIndex = parseInt(getCS(div).zIndex || DEFAULT_ZINDEX, 10);
	        document.body.removeChild(div);
	      }

	      return this.baseZIndex || DEFAULT_ZINDEX;
	    },
	    getScrollbarWidth: function getScrollbarWidth() {
	      if (isNull(this.scrollbarWidth) && isBrowser) {
	        // Create a temporary `div.measure-scrollbar` to get computed z-index
	        var div = document.createElement('div');
	        div.className = 'modal-scrollbar-measure';
	        document.body.appendChild(div);
	        this.scrollbarWidth = getBCR(div).width - div.clientWidth;
	        document.body.removeChild(div);
	      }

	      return this.scrollbarWidth || 0;
	    },
	    // Private methods
	    updateModals: function updateModals(modals) {
	      var _this3 = this;

	      var baseZIndex = this.getBaseZIndex();
	      var scrollbarWidth = this.getScrollbarWidth();
	      modals.forEach(function (modal, index) {
	        // We update data values on each modal
	        modal.zIndex = baseZIndex + index;
	        modal.scrollbarWidth = scrollbarWidth;
	        modal.isTop = index === _this3.modals.length - 1;
	        modal.isBodyOverflowing = _this3.isBodyOverflowing;
	      });
	    },
	    resetModal: function resetModal(modal) {
	      if (modal) {
	        modal.zIndex = this.getBaseZIndex();
	        modal.isTop = true;
	        modal.isBodyOverflowing = false;
	      }
	    },
	    checkScrollbar: function checkScrollbar() {
	      // Determine if the body element is overflowing
	      var _getBCR = getBCR(document.body),
	          left = _getBCR.left,
	          right = _getBCR.right;

	      this.isBodyOverflowing = left + right < window.innerWidth;
	    },
	    setScrollbar: function setScrollbar() {
	      var body = document.body; // Storage place to cache changes to margins and padding
	      // Note: This assumes the following element types are not added to the
	      // document after the modal has opened.

	      body._paddingChangedForModal = body._paddingChangedForModal || [];
	      body._marginChangedForModal = body._marginChangedForModal || [];

	      if (this.isBodyOverflowing) {
	        var scrollbarWidth = this.scrollbarWidth; // Adjust fixed content padding

	        /* istanbul ignore next: difficult to test in JSDOM */

	        selectAll(Selector$1.FIXED_CONTENT).forEach(function (el) {
	          var actualPadding = el.style.paddingRight;
	          var calculatedPadding = getCS(el).paddingRight || 0;
	          setAttr(el, 'data-padding-right', actualPadding);
	          el.style.paddingRight = "".concat(parseFloat(calculatedPadding) + scrollbarWidth, "px");

	          body._paddingChangedForModal.push(el);
	        }); // Adjust sticky content margin

	        /* istanbul ignore next: difficult to test in JSDOM */

	        selectAll(Selector$1.STICKY_CONTENT).forEach(function (el)
	        /* istanbul ignore next */
	        {
	          var actualMargin = el.style.marginRight;
	          var calculatedMargin = getCS(el).marginRight || 0;
	          setAttr(el, 'data-margin-right', actualMargin);
	          el.style.marginRight = "".concat(parseFloat(calculatedMargin) - scrollbarWidth, "px");

	          body._marginChangedForModal.push(el);
	        }); // Adjust <b-navbar-toggler> margin

	        /* istanbul ignore next: difficult to test in JSDOM */

	        selectAll(Selector$1.NAVBAR_TOGGLER).forEach(function (el)
	        /* istanbul ignore next */
	        {
	          var actualMargin = el.style.marginRight;
	          var calculatedMargin = getCS(el).marginRight || 0;
	          setAttr(el, 'data-margin-right', actualMargin);
	          el.style.marginRight = "".concat(parseFloat(calculatedMargin) + scrollbarWidth, "px");

	          body._marginChangedForModal.push(el);
	        }); // Adjust body padding

	        var actualPadding = body.style.paddingRight;
	        var calculatedPadding = getCS(body).paddingRight;
	        setAttr(body, 'data-padding-right', actualPadding);
	        body.style.paddingRight = "".concat(parseFloat(calculatedPadding) + scrollbarWidth, "px");
	      }
	    },
	    resetScrollbar: function resetScrollbar() {
	      var body = document.body;

	      if (body._paddingChangedForModal) {
	        // Restore fixed content padding
	        body._paddingChangedForModal.forEach(function (el) {
	          /* istanbul ignore next: difficult to test in JSDOM */
	          if (hasAttr(el, 'data-padding-right')) {
	            el.style.paddingRight = getAttr(el, 'data-padding-right') || '';
	            removeAttr(el, 'data-padding-right');
	          }
	        });
	      }

	      if (body._marginChangedForModal) {
	        // Restore sticky content and navbar-toggler margin
	        body._marginChangedForModal.forEach(function (el) {
	          /* istanbul ignore next: difficult to test in JSDOM */
	          if (hasAttr(el, 'data-margin-right')) {
	            el.style.marginRight = getAttr(el, 'data-margin-right') || '';
	            removeAttr(el, 'data-margin-right');
	          }
	        });
	      }

	      body._paddingChangedForModal = null;
	      body._marginChangedForModal = null; // Restore body padding

	      if (hasAttr(body, 'data-padding-right')) {
	        body.style.paddingRight = getAttr(body, 'data-padding-right') || '';
	        removeAttr(body, 'data-padding-right');
	      }
	    }
	  }
	}); // Create and export our modal manager instance

	var modalManager = new ModalManager();

	function _typeof$3(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$3(obj); }

	function ownKeys$y(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$y(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$y(source, true).forEach(function (key) { _defineProperty$M(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$y(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$M(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) { _defineProperties$3(Constructor.prototype, protoProps); } if (staticProps) { _defineProperties$3(Constructor, staticProps); } return Constructor; }

	function _possibleConstructorReturn$1(self, call) { if (call && (_typeof$3(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$1(self); }

	function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) { return; } var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

	function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf$1(object); if (object === null) { break; } } return object; }

	function _getPrototypeOf$1(o) { _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$1(o); }

	function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) { _setPrototypeOf$1(subClass, superClass); } }

	function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }

	var BvModalEvent =
	/*#__PURE__*/
	function (_BvEvent) {
	  _inherits$1(BvModalEvent, _BvEvent);

	  function BvModalEvent(type) {
	    var _this;

	    var eventInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck$4(this, BvModalEvent);

	    _this = _possibleConstructorReturn$1(this, _getPrototypeOf$1(BvModalEvent).call(this, type, eventInit)); // Freeze our new props as readonly, but leave them enumerable

	    defineProperties(_assertThisInitialized$1(_this), {
	      trigger: readonlyDescriptor()
	    });
	    return _this;
	  }

	  _createClass$3(BvModalEvent, null, [{
	    key: "Defaults",
	    get: function get() {
	      return _objectSpread$y({}, _get(_getPrototypeOf$1(BvModalEvent), "Defaults", this), {
	        trigger: null
	      });
	    }
	  }]);

	  return BvModalEvent;
	}(BvEvent); // Named exports

	function ownKeys$z(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$z(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$z(source, true).forEach(function (key) { _defineProperty$N(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$z(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$N(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var NAME$i = 'BModal'; // ObserveDom config to detect changes in modal content
	// so that we can adjust the modal padding if needed

	var OBSERVER_CONFIG = {
	  subtree: true,
	  childList: true,
	  characterData: true,
	  attributes: true,
	  attributeFilter: ['style', 'class']
	}; // Options for DOM event listeners

	var EVT_OPTIONS = {
	  passive: true,
	  capture: false
	}; // Query selector to find all tabbable elements
	// (includes tabindex="-1", which we filter out after)

	var TABABLE_SELECTOR = ['button', '[href]:not(.disabled)', 'input', 'select', 'textarea', '[tabindex]', '[contenteditable]'].map(function (s) {
	  return "".concat(s, ":not(:disabled):not([disabled])");
	}).join(', '); // --- Utility methods ---
	// Attempt to focus an element, and return true if successful

	var attemptFocus = function attemptFocus(el) {
	  if (el && isVisible(el) && el.focus) {
	    try {
	      el.focus();
	    } catch (_unused) {}
	  } // If the element has focus, then return true


	  return document.activeElement === el;
	}; // --- Props ---


	var props$H = {
	  size: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'size');
	    }
	  },
	  centered: {
	    type: Boolean,
	    default: false
	  },
	  scrollable: {
	    type: Boolean,
	    default: false
	  },
	  buttonSize: {
	    type: String,
	    default: ''
	  },
	  noStacking: {
	    type: Boolean,
	    default: false
	  },
	  noFade: {
	    type: Boolean,
	    default: false
	  },
	  noCloseOnBackdrop: {
	    type: Boolean,
	    default: false
	  },
	  noCloseOnEsc: {
	    type: Boolean,
	    default: false
	  },
	  noEnforceFocus: {
	    type: Boolean,
	    default: false
	  },
	  title: {
	    type: String,
	    default: ''
	  },
	  titleHtml: {
	    type: String
	  },
	  titleTag: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'titleTag');
	    }
	  },
	  titleClass: {
	    type: [String, Array, Object],
	    default: null
	  },
	  titleSrOnly: {
	    type: Boolean,
	    default: false
	  },
	  ariaLabel: {
	    type: String,
	    default: null
	  },
	  headerBgVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'headerBgVariant');
	    }
	  },
	  headerBorderVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'headerBorderVariant');
	    }
	  },
	  headerTextVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'headerTextVariant');
	    }
	  },
	  headerCloseVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'headerCloseVariant');
	    }
	  },
	  headerClass: {
	    type: [String, Array, Object],
	    default: null
	  },
	  bodyBgVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'bodyBgVariant');
	    }
	  },
	  bodyTextVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'bodyTextVariant');
	    }
	  },
	  modalClass: {
	    type: [String, Array, Object],
	    default: null
	  },
	  dialogClass: {
	    type: [String, Array, Object],
	    default: null
	  },
	  contentClass: {
	    type: [String, Array, Object],
	    default: null
	  },
	  bodyClass: {
	    type: [String, Array, Object],
	    default: null
	  },
	  footerBgVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'footerBgVariant');
	    }
	  },
	  footerBorderVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'footerBorderVariant');
	    }
	  },
	  footerTextVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'footerTextVariant');
	    }
	  },
	  footerClass: {
	    type: [String, Array, Object],
	    default: null
	  },
	  hideHeader: {
	    type: Boolean,
	    default: false
	  },
	  hideFooter: {
	    type: Boolean,
	    default: false
	  },
	  hideHeaderClose: {
	    type: Boolean,
	    default: false
	  },
	  hideBackdrop: {
	    type: Boolean,
	    default: false
	  },
	  okOnly: {
	    type: Boolean,
	    default: false
	  },
	  okDisabled: {
	    type: Boolean,
	    default: false
	  },
	  cancelDisabled: {
	    type: Boolean,
	    default: false
	  },
	  visible: {
	    type: Boolean,
	    default: false
	  },
	  returnFocus: {
	    // HTML Element, CSS selector string or Vue component instance
	    type: [HTMLElement$1, String, Object],
	    default: null
	  },
	  headerCloseLabel: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'headerCloseLabel');
	    }
	  },
	  cancelTitle: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'cancelTitle');
	    }
	  },
	  cancelTitleHtml: {
	    type: String
	  },
	  okTitle: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'okTitle');
	    }
	  },
	  okTitleHtml: {
	    type: String
	  },
	  cancelVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'cancelVariant');
	    }
	  },
	  okVariant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$i, 'okVariant');
	    }
	  },
	  lazy: {
	    type: Boolean,
	    default: false
	  },
	  busy: {
	    type: Boolean,
	    default: false
	  },
	  static: {
	    type: Boolean,
	    default: false
	  },
	  autoFocusButton: {
	    type: String,
	    default: null,
	    validator: function validator(val) {
	      /* istanbul ignore next */
	      return isUndefinedOrNull(val) || arrayIncludes(['ok', 'cancel', 'close'], val);
	    }
	  }
	}; // @vue/component

	var BModal =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$i,
	  mixins: [idMixin, listenOnRootMixin, normalizeSlotMixin, scopedStyleAttrsMixin],
	  inheritAttrs: false,
	  model: {
	    prop: 'visible',
	    event: 'change'
	  },
	  props: props$H,
	  data: function data() {
	    return {
	      isHidden: true,
	      // If modal should not be in document
	      isVisible: false,
	      // Controls modal visible state
	      isTransitioning: false,
	      // Used for style control
	      isShow: false,
	      // Used for style control
	      isBlock: false,
	      // Used for style control
	      isOpening: false,
	      // To signal that the modal is in the process of opening
	      isClosing: false,
	      // To signal that the modal is in the process of closing
	      ignoreBackdropClick: false,
	      // Used to signify if click out listener should ignore the click
	      isModalOverflowing: false,
	      return_focus: this.returnFocus || null,
	      // The following items are controlled by the modalManager instance
	      scrollbarWidth: 0,
	      zIndex: modalManager.getBaseZIndex(),
	      isTop: true,
	      isBodyOverflowing: false
	    };
	  },
	  computed: {
	    modalClasses: function modalClasses() {
	      return [{
	        fade: !this.noFade,
	        show: this.isShow
	      }, this.modalClass];
	    },
	    modalStyles: function modalStyles() {
	      var sbWidth = "".concat(this.scrollbarWidth, "px");
	      return {
	        paddingLeft: !this.isBodyOverflowing && this.isModalOverflowing ? sbWidth : '',
	        paddingRight: this.isBodyOverflowing && !this.isModalOverflowing ? sbWidth : '',
	        // Needed to fix issue https://github.com/bootstrap-vue/bootstrap-vue/issues/3457
	        // Even though we are using v-show, we must ensure 'none' is restored in the styles
	        display: this.isBlock ? 'block' : 'none'
	      };
	    },
	    dialogClasses: function dialogClasses() {
	      var _ref;

	      return [(_ref = {}, _defineProperty$N(_ref, "modal-".concat(this.size), Boolean(this.size)), _defineProperty$N(_ref, 'modal-dialog-centered', this.centered), _defineProperty$N(_ref, 'modal-dialog-scrollable', this.scrollable), _ref), this.dialogClass];
	    },
	    headerClasses: function headerClasses() {
	      var _ref2;

	      return [(_ref2 = {}, _defineProperty$N(_ref2, "bg-".concat(this.headerBgVariant), Boolean(this.headerBgVariant)), _defineProperty$N(_ref2, "text-".concat(this.headerTextVariant), Boolean(this.headerTextVariant)), _defineProperty$N(_ref2, "border-".concat(this.headerBorderVariant), Boolean(this.headerBorderVariant)), _ref2), this.headerClass];
	    },
	    titleClasses: function titleClasses() {
	      return [{
	        'sr-only': this.titleSrOnly
	      }, this.titleClass];
	    },
	    bodyClasses: function bodyClasses() {
	      var _ref3;

	      return [(_ref3 = {}, _defineProperty$N(_ref3, "bg-".concat(this.bodyBgVariant), Boolean(this.bodyBgVariant)), _defineProperty$N(_ref3, "text-".concat(this.bodyTextVariant), Boolean(this.bodyTextVariant)), _ref3), this.bodyClass];
	    },
	    footerClasses: function footerClasses() {
	      var _ref4;

	      return [(_ref4 = {}, _defineProperty$N(_ref4, "bg-".concat(this.footerBgVariant), Boolean(this.footerBgVariant)), _defineProperty$N(_ref4, "text-".concat(this.footerTextVariant), Boolean(this.footerTextVariant)), _defineProperty$N(_ref4, "border-".concat(this.footerBorderVariant), Boolean(this.footerBorderVariant)), _ref4), this.footerClass];
	    },
	    modalOuterStyle: function modalOuterStyle() {
	      // Styles needed for proper stacking of modals
	      return {
	        position: 'absolute',
	        zIndex: this.zIndex
	      };
	    },
	    slotScope: function slotScope() {
	      return {
	        ok: this.onOk,
	        cancel: this.onCancel,
	        close: this.onClose,
	        hide: this.hide,
	        visible: this.isVisible
	      };
	    }
	  },
	  watch: {
	    visible: function visible(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        this[newVal ? 'show' : 'hide']();
	      }
	    }
	  },
	  created: function created() {
	    // Define non-reactive properties
	    this._observer = null;
	  },
	  mounted: function mounted() {
	    // Set initial z-index as queried from the DOM
	    this.zIndex = modalManager.getBaseZIndex(); // Listen for events from others to either open or close ourselves
	    // and listen to all modals to enable/disable enforce focus

	    this.listenOnRoot('bv::show::modal', this.showHandler);
	    this.listenOnRoot('bv::hide::modal', this.hideHandler);
	    this.listenOnRoot('bv::toggle::modal', this.toggleHandler); // Listen for `bv:modal::show events`, and close ourselves if the
	    // opening modal not us

	    this.listenOnRoot('bv::modal::show', this.modalListener); // Initially show modal?

	    if (this.visible === true) {
	      this.$nextTick(this.show);
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    // Ensure everything is back to normal
	    if (this._observer) {
	      this._observer.disconnect();

	      this._observer = null;
	    }

	    this.setEnforceFocus(false);
	    this.setResizeEvent(false);

	    if (this.isVisible) {
	      this.isVisible = false;
	      this.isShow = false;
	      this.isTransitioning = false;
	    }
	  },
	  methods: {
	    // Private method to update the v-model
	    updateModel: function updateModel(val) {
	      if (val !== this.visible) {
	        this.$emit('change', val);
	      }
	    },
	    // Private method to create a BvModalEvent object
	    buildEvent: function buildEvent(type) {
	      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return new BvModalEvent(type, _objectSpread$z({
	        // Default options
	        cancelable: false,
	        target: this.$refs.modal || this.$el || null,
	        relatedTarget: null,
	        trigger: null
	      }, opts, {
	        // Options that can't be overridden
	        vueTarget: this,
	        componentId: this.safeId()
	      }));
	    },
	    // Public method to show modal
	    show: function show() {
	      if (this.isVisible || this.isOpening) {
	        // If already open, or in the process of opening, do nothing

	        /* istanbul ignore next */
	        return;
	      }
	      /* istanbul ignore next */


	      if (this.isClosing) {
	        // If we are in the process of closing, wait until hidden before re-opening

	        /* istanbul ignore next */
	        this.$once('hidden', this.show);
	        /* istanbul ignore next */

	        return;
	      }

	      this.isOpening = true; // Set the element to return focus to when closed

	      this.return_focus = this.return_focus || this.getActiveElement();
	      var showEvt = this.buildEvent('show', {
	        cancelable: true
	      });
	      this.emitEvent(showEvt); // Don't show if canceled

	      if (showEvt.defaultPrevented || this.isVisible) {
	        this.isOpening = false; // Ensure the v-model reflects the current state

	        this.updateModel(false);
	        return;
	      } // Show the modal


	      this.doShow();
	    },
	    // Public method to hide modal
	    hide: function hide() {
	      var trigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	      if (!this.isVisible || this.isClosing) {
	        /* istanbul ignore next */
	        return;
	      }

	      this.isClosing = true;
	      var hideEvt = this.buildEvent('hide', {
	        cancelable: trigger !== 'FORCE',
	        trigger: trigger || null
	      }); // We emit specific event for one of the three built-in buttons

	      if (trigger === 'ok') {
	        this.$emit('ok', hideEvt);
	      } else if (trigger === 'cancel') {
	        this.$emit('cancel', hideEvt);
	      } else if (trigger === 'headerclose') {
	        this.$emit('close', hideEvt);
	      }

	      this.emitEvent(hideEvt); // Hide if not canceled

	      if (hideEvt.defaultPrevented || !this.isVisible) {
	        this.isClosing = false; // Ensure v-model reflects current state

	        this.updateModel(true);
	        return;
	      } // Stop observing for content changes


	      if (this._observer) {
	        this._observer.disconnect();

	        this._observer = null;
	      } // Trigger the hide transition


	      this.isVisible = false; // Update the v-model

	      this.updateModel(false);
	    },
	    // Public method to toggle modal visibility
	    toggle: function toggle(triggerEl) {
	      if (triggerEl) {
	        this.return_focus = triggerEl;
	      }

	      if (this.isVisible) {
	        this.hide('toggle');
	      } else {
	        this.show();
	      }
	    },
	    // Private method to get the current document active element
	    getActiveElement: function getActiveElement() {
	      if (isBrowser) {
	        var activeElement = document.activeElement; // Note: On IE11, `document.activeElement` may be null.
	        // So we test it for truthiness first.
	        // https://github.com/bootstrap-vue/bootstrap-vue/issues/3206
	        // Returning focus to document.body may cause unwanted scrolls, so we
	        // exclude setting focus on body

	        if (activeElement && activeElement !== document.body && activeElement.focus) {
	          // Preset the fallback return focus value if it is not set
	          // `document.activeElement` should be the trigger element that was clicked or
	          // in the case of using the v-model, which ever element has current focus
	          // Will be overridden by some commands such as toggle, etc.
	          return activeElement;
	        }
	      }

	      return null;
	    },
	    // Private method to get a list of all tabable elements within modal content
	    getTabables: function getTabables() {
	      // Find all tabable elements in the modal content
	      // Assumes users have not used tabindex > 0 on elements!
	      return selectAll(TABABLE_SELECTOR, this.$refs.content).filter(isVisible).filter(function (i) {
	        return i.tabIndex > -1 && !i.disabled;
	      });
	    },
	    // Private method to finish showing modal
	    doShow: function doShow() {
	      var _this = this;

	      /* istanbul ignore next: commenting out for now until we can test stacking */
	      if (modalManager.modalsAreOpen && this.noStacking) {
	        // If another modal(s) is already open, wait for it(them) to close
	        this.listenOnRootOnce('bv::modal::hidden', this.doShow);
	        return;
	      }

	      modalManager.registerModal(this); // Place modal in DOM

	      this.isHidden = false;
	      this.$nextTick(function () {
	        // We do this in `$nextTick()` to ensure the modal is in DOM first
	        // before we show it
	        _this.isVisible = true;
	        _this.isOpening = false; // Update the v-model

	        _this.updateModel(true);

	        _this.$nextTick(function () {
	          // In a nextTick in case modal content is lazy
	          // Observe changes in modal content and adjust if necessary
	          _this._observer = observeDom(_this.$refs.content, _this.checkModalOverflow.bind(_this), OBSERVER_CONFIG);
	        });
	      });
	    },
	    // Transition handlers
	    onBeforeEnter: function onBeforeEnter() {
	      this.isTransitioning = true;
	      this.setResizeEvent(true);
	    },
	    onEnter: function onEnter() {
	      this.isBlock = true;
	    },
	    onAfterEnter: function onAfterEnter() {
	      var _this2 = this;

	      this.checkModalOverflow();
	      this.isShow = true;
	      this.isTransitioning = false; // We use `requestAF()` to allow transition hooks to complete
	      // before passing control over to the other handlers
	      // This will allow users to not have to use `$nextTick()` or `requestAF()`
	      // when trying to pre-focus an element

	      requestAF(function () {
	        _this2.emitEvent(_this2.buildEvent('shown'));

	        _this2.setEnforceFocus(true);

	        _this2.$nextTick(function () {
	          // Delayed in a `$nextTick()` to allow users time to pre-focus
	          // an element if the wish
	          _this2.focusFirst();
	        });
	      });
	    },
	    onBeforeLeave: function onBeforeLeave() {
	      this.isTransitioning = true;
	      this.setResizeEvent(false);
	      this.setEnforceFocus(false);
	    },
	    onLeave: function onLeave() {
	      // Remove the 'show' class
	      this.isShow = false;
	    },
	    onAfterLeave: function onAfterLeave() {
	      var _this3 = this;

	      this.isBlock = false;
	      this.isTransitioning = false;
	      this.isModalOverflowing = false;
	      this.isHidden = true;
	      this.$nextTick(function () {
	        _this3.isClosing = false;
	        modalManager.unregisterModal(_this3);

	        _this3.returnFocusTo(); // TODO: Need to find a way to pass the `trigger` property
	        //       to the `hidden` event, not just only the `hide` event


	        _this3.emitEvent(_this3.buildEvent('hidden'));
	      });
	    },
	    // Event emitter
	    emitEvent: function emitEvent(bvModalEvt) {
	      var type = bvModalEvt.type; // We emit on root first incase a global listener wants to cancel
	      // the event first before the instance emits it's event

	      this.emitOnRoot("bv::modal::".concat(type), bvModalEvt, bvModalEvt.componentId);
	      this.$emit(type, bvModalEvt);
	    },
	    // UI event handlers
	    onDialogMousedown: function onDialogMousedown() {
	      var _this4 = this;

	      // Watch to see if the matching mouseup event occurs outside the dialog
	      // And if it does, cancel the clickOut handler
	      var modal = this.$refs.modal;

	      var onceModalMouseup = function onceModalMouseup(evt) {
	        eventOff(modal, 'mouseup', onceModalMouseup, EVT_OPTIONS);

	        if (evt.target === modal) {
	          _this4.ignoreBackdropClick = true;
	        }
	      };

	      eventOn(modal, 'mouseup', onceModalMouseup, EVT_OPTIONS);
	    },
	    onClickOut: function onClickOut(evt) {
	      if (this.ignoreBackdropClick) {
	        // Click was initiated inside the modal content, but finished outside.
	        // Set by the above onDialogMousedown handler
	        this.ignoreBackdropClick = false;
	        return;
	      } // Do nothing if not visible, backdrop click disabled, or element
	      // that generated click event is no longer in document body


	      if (!this.isVisible || this.noCloseOnBackdrop || !contains(document.body, evt.target)) {
	        return;
	      } // If backdrop clicked, hide modal


	      if (!contains(this.$refs.content, evt.target)) {
	        this.hide('backdrop');
	      }
	    },
	    onOk: function onOk() {
	      this.hide('ok');
	    },
	    onCancel: function onCancel() {
	      this.hide('cancel');
	    },
	    onClose: function onClose() {
	      this.hide('headerclose');
	    },
	    onEsc: function onEsc(evt) {
	      // If ESC pressed, hide modal
	      if (evt.keyCode === KEY_CODES.ESC && this.isVisible && !this.noCloseOnEsc) {
	        this.hide('esc');
	      }
	    },
	    // Document focusin listener
	    focusHandler: function focusHandler(evt) {
	      // If focus leaves modal content, bring it back
	      var content = this.$refs.content;
	      var target = evt.target;

	      if (!this.noEnforceFocus && this.isTop && this.isVisible && content && document !== target && !contains(content, target)) {
	        var tabables = this.getTabables();

	        if (this.$refs.bottomTrap && target === this.$refs.bottomTrap) {
	          // If user pressed TAB out of modal into our bottom trab trap element
	          // Find the first tabable element in the modal content and focus it
	          if (attemptFocus(tabables[0])) {
	            // Focus was successful
	            return;
	          }
	        } else if (this.$refs.topTrap && target === this.$refs.topTrap) {
	          // If user pressed CTRL-TAB out of modal and into our top tab trap element
	          // Find the last tabable element in the modal content and focus it
	          if (attemptFocus(tabables[tabables.length - 1])) {
	            // Focus was successful
	            return;
	          }
	        } // Otherwise focus the modal content container


	        content.focus({
	          preventScroll: true
	        });
	      }
	    },
	    // Turn on/off focusin listener
	    setEnforceFocus: function setEnforceFocus(on) {
	      var method = on ? eventOn : eventOff;
	      method(document, 'focusin', this.focusHandler, EVT_OPTIONS);
	    },
	    // Resize listener
	    setResizeEvent: function setResizeEvent(on) {
	      var method = on ? eventOn : eventOff; // These events should probably also check if
	      // body is overflowing

	      method(window, 'resize', this.checkModalOverflow, EVT_OPTIONS);
	      method(window, 'orientationchange', this.checkModalOverflow, EVT_OPTIONS);
	    },
	    // Root listener handlers
	    showHandler: function showHandler(id, triggerEl) {
	      if (id === this.safeId()) {
	        this.return_focus = triggerEl || this.getActiveElement();
	        this.show();
	      }
	    },
	    hideHandler: function hideHandler(id) {
	      if (id === this.safeId()) {
	        this.hide('event');
	      }
	    },
	    toggleHandler: function toggleHandler(id, triggerEl) {
	      if (id === this.safeId()) {
	        this.toggle(triggerEl);
	      }
	    },
	    modalListener: function modalListener(bvEvt) {
	      // If another modal opens, close this one if stacking not permitted
	      if (this.noStacking && bvEvt.vueTarget !== this) {
	        this.hide();
	      }
	    },
	    // Focus control handlers
	    focusFirst: function focusFirst() {
	      var _this5 = this;

	      // Don't try and focus if we are SSR
	      if (isBrowser) {
	        requestAF(function () {
	          var modal = _this5.$refs.modal;
	          var content = _this5.$refs.content;

	          var activeElement = _this5.getActiveElement(); // If the modal contains the activeElement, we don't do anything


	          if (modal && content && !(activeElement && contains(content, activeElement))) {
	            var ok = _this5.$refs['ok-button'];
	            var cancel = _this5.$refs['cancel-button'];
	            var close = _this5.$refs['close-button']; // Focus the appropriate button or modal content wrapper

	            var autoFocus = _this5.autoFocusButton;
	            var el = autoFocus === 'ok' && ok ? ok.$el || ok : autoFocus === 'cancel' && cancel ? cancel.$el || cancel : autoFocus === 'close' && close ? close.$el || close : content; // Focus the element

	            attemptFocus(el);

	            if (el === content) {
	              // Make sure top of modal is showing (if longer than the viewport)
	              _this5.$nextTick(function () {
	                modal.scrollTop = 0;
	              });
	            }
	          }
	        });
	      }
	    },
	    returnFocusTo: function returnFocusTo() {
	      // Prefer `returnFocus` prop over event specified
	      // `return_focus` value
	      var el = this.returnFocus || this.return_focus || null;
	      this.return_focus = null;
	      this.$nextTick(function () {
	        // Is el a string CSS selector?
	        el = isString(el) ? select(el) : el;

	        if (el) {
	          // Possibly could be a component reference
	          el = el.$el || el;
	          attemptFocus(el);
	        }
	      });
	    },
	    checkModalOverflow: function checkModalOverflow() {
	      if (this.isVisible) {
	        var modal = this.$refs.modal;
	        this.isModalOverflowing = modal.scrollHeight > document.documentElement.clientHeight;
	      }
	    },
	    makeModal: function makeModal(h) {
	      // Modal header
	      var header = h();

	      if (!this.hideHeader) {
	        var modalHeader = this.normalizeSlot('modal-header', this.slotScope);

	        if (!modalHeader) {
	          var closeButton = h();

	          if (!this.hideHeaderClose) {
	            closeButton = h(BButtonClose, {
	              ref: 'close-button',
	              props: {
	                disabled: this.isTransitioning,
	                ariaLabel: this.headerCloseLabel,
	                textVariant: this.headerCloseVariant || this.headerTextVariant
	              },
	              on: {
	                click: this.onClose
	              }
	            }, [this.normalizeSlot('modal-header-close')]);
	          }

	          var domProps = !this.hasNormalizedSlot('modal-title') && this.titleHtml ? {
	            innerHTML: this.titleHtml
	          } : {};
	          modalHeader = [h(this.titleTag, {
	            staticClass: 'modal-title',
	            class: this.titleClasses,
	            attrs: {
	              id: this.safeId('__BV_modal_title_')
	            },
	            domProps: domProps
	          }, [this.normalizeSlot('modal-title', this.slotScope) || stripTags(this.title)]), closeButton];
	        }

	        header = h('header', {
	          ref: 'header',
	          staticClass: 'modal-header',
	          class: this.headerClasses,
	          attrs: {
	            id: this.safeId('__BV_modal_header_')
	          }
	        }, [modalHeader]);
	      } // Modal body


	      var body = h('div', {
	        ref: 'body',
	        staticClass: 'modal-body',
	        class: this.bodyClasses,
	        attrs: {
	          id: this.safeId('__BV_modal_body_')
	        }
	      }, this.normalizeSlot('default', this.slotScope)); // Modal footer

	      var footer = h();

	      if (!this.hideFooter) {
	        var modalFooter = this.normalizeSlot('modal-footer', this.slotScope);

	        if (!modalFooter) {
	          var cancelButton = h();

	          if (!this.okOnly) {
	            var cancelHtml = this.cancelTitleHtml ? {
	              innerHTML: this.cancelTitleHtml
	            } : null;
	            cancelButton = h(BButton, {
	              ref: 'cancel-button',
	              props: {
	                variant: this.cancelVariant,
	                size: this.buttonSize,
	                disabled: this.cancelDisabled || this.busy || this.isTransitioning
	              },
	              on: {
	                click: this.onCancel
	              }
	            }, [this.normalizeSlot('modal-cancel') || (cancelHtml ? h('span', {
	              domProps: cancelHtml
	            }) : stripTags(this.cancelTitle))]);
	          }

	          var okHtml = this.okTitleHtml ? {
	            innerHTML: this.okTitleHtml
	          } : null;
	          var okButton = h(BButton, {
	            ref: 'ok-button',
	            props: {
	              variant: this.okVariant,
	              size: this.buttonSize,
	              disabled: this.okDisabled || this.busy || this.isTransitioning
	            },
	            on: {
	              click: this.onOk
	            }
	          }, [this.normalizeSlot('modal-ok') || (okHtml ? h('span', {
	            domProps: okHtml
	          }) : stripTags(this.okTitle))]);
	          modalFooter = [cancelButton, okButton];
	        }

	        footer = h('footer', {
	          ref: 'footer',
	          staticClass: 'modal-footer',
	          class: this.footerClasses,
	          attrs: {
	            id: this.safeId('__BV_modal_footer_')
	          }
	        }, [modalFooter]);
	      } // Assemble modal content


	      var modalContent = h('div', {
	        ref: 'content',
	        staticClass: 'modal-content',
	        class: this.contentClass,
	        attrs: {
	          role: 'document',
	          id: this.safeId('__BV_modal_content_'),
	          tabindex: '-1'
	        }
	      }, [header, body, footer]); // Tab trap to prevent page from scrolling to next element in
	      // tab index during enforce focus tab cycle

	      var tabTrapTop = h();
	      var tabTrapBottom = h();

	      if (this.isVisible && !this.noEnforceFocus) {
	        tabTrapTop = h('span', {
	          ref: 'topTrap',
	          attrs: {
	            tabindex: '0'
	          }
	        });
	        tabTrapBottom = h('span', {
	          ref: 'bottomTrap',
	          attrs: {
	            tabindex: '0'
	          }
	        });
	      } // Modal dialog wrapper


	      var modalDialog = h('div', {
	        ref: 'dialog',
	        staticClass: 'modal-dialog',
	        class: this.dialogClasses,
	        on: {
	          mousedown: this.onDialogMousedown
	        }
	      }, [tabTrapTop, modalContent, tabTrapBottom]); // Modal

	      var modal = h('div', {
	        ref: 'modal',
	        staticClass: 'modal',
	        class: this.modalClasses,
	        style: this.modalStyles,
	        directives: [{
	          name: 'show',
	          rawName: 'v-show',
	          value: this.isVisible,
	          expression: 'isVisible'
	        }],
	        attrs: {
	          id: this.safeId(),
	          role: 'dialog',
	          'aria-hidden': this.isVisible ? null : 'true',
	          'aria-modal': this.isVisible ? 'true' : null,
	          'aria-label': this.ariaLabel,
	          'aria-labelledby': this.hideHeader || this.ariaLabel || !(this.hasNormalizedSlot('modal-title') || this.titleHtml || this.title) ? null : this.safeId('__BV_modal_title_'),
	          'aria-describedby': this.safeId('__BV_modal_body_')
	        },
	        on: {
	          keydown: this.onEsc,
	          click: this.onClickOut
	        }
	      }, [modalDialog]); // Wrap modal in transition
	      // Sadly, we can't use BVTransition here due to the differences in
	      // transition durations for .modal and .modal-dialog. Not until
	      // issue https://github.com/vuejs/vue/issues/9986 is resolved

	      modal = h('transition', {
	        props: {
	          enterClass: '',
	          enterToClass: '',
	          enterActiveClass: '',
	          leaveClass: '',
	          leaveActiveClass: '',
	          leaveToClass: ''
	        },
	        on: {
	          beforeEnter: this.onBeforeEnter,
	          enter: this.onEnter,
	          afterEnter: this.onAfterEnter,
	          beforeLeave: this.onBeforeLeave,
	          leave: this.onLeave,
	          afterLeave: this.onAfterLeave
	        }
	      }, [modal]); // Modal backdrop

	      var backdrop = h();

	      if (!this.hideBackdrop && this.isVisible) {
	        backdrop = h('div', {
	          staticClass: 'modal-backdrop',
	          attrs: {
	            id: this.safeId('__BV_modal_backdrop_')
	          }
	        }, [this.normalizeSlot('modal-backdrop')]);
	      }

	      backdrop = h(BVTransition, {
	        props: {
	          noFade: this.noFade
	        }
	      }, [backdrop]); // If the parent has a scoped style attribute, and the modal
	      // is portalled, add the scoped attribute to the modal wrapper

	      var scopedStyleAttrs = !this.static ? this.scopedStyleAttrs : {}; // Assemble modal and backdrop in an outer <div>

	      return h('div', {
	        key: "modal-outer-".concat(this._uid),
	        style: this.modalOuterStyle,
	        attrs: _objectSpread$z({}, scopedStyleAttrs, {}, this.$attrs, {
	          id: this.safeId('__BV_modal_outer_')
	        })
	      }, [modal, backdrop]);
	    }
	  },
	  render: function render(h) {
	    if (this.static) {
	      return this.lazy && this.isHidden ? h() : this.makeModal(h);
	    } else {
	      return this.isHidden ? h() : h(BTransporterSingle, {}, [this.makeModal(h)]);
	    }
	  }
	});

	var EVENT_SHOW = 'bv::show::modal'; // Prop name we use to store info on root element

	var HANDLER = '__bv_modal_directive__';
	var EVENT_OPTS = {
	  passive: true
	};

	var getTarget = function getTarget(_ref) {
	  var _ref$modifiers = _ref.modifiers,
	      modifiers = _ref$modifiers === void 0 ? {} : _ref$modifiers,
	      arg = _ref.arg,
	      value = _ref.value;
	  // Try value, then arg, otherwise pick last modifier
	  return isString(value) ? value : isString(arg) ? arg : keys$2(modifiers).reverse()[0];
	};

	var getTriggerElement = function getTriggerElement(el) {
	  // If root element is a dropdown-item or nav-item, we
	  // need to target the inner link or button instead
	  return el && matches(el, '.dropdown-menu > li, li.nav-item') ? select('a, button', el) || el : el;
	};

	var setRole = function setRole(trigger) {
	  // Ensure accessibility on non button elements
	  if (trigger && trigger.tagName !== 'BUTTON') {
	    // Only set a role if the trigger element doesn't have one
	    if (!hasAttr(trigger, 'role')) {
	      setAttr(trigger, 'role', 'button');
	    } // Add a tabindex is not a button or link, and tabindex is not provided


	    if (trigger.tagName !== 'A' && !hasAttr(trigger, 'tabindex')) {
	      setAttr(trigger, 'tabindex', '0');
	    }
	  }
	};

	var bind$1 = function bind(el, binding, vnode) {
	  var target = getTarget(binding);
	  var trigger = getTriggerElement(el);

	  if (target && trigger) {
	    var handler = function handler(evt) {
	      // `currentTarget` is the element with the listener on it
	      var currentTarget = evt.currentTarget;

	      if (!isDisabled(currentTarget)) {
	        var type = evt.type;
	        var key = evt.keyCode; // Open modal only if trigger is not disabled

	        if (type === 'click' || type === 'keydown' && (key === KEY_CODES.ENTER || key === KEY_CODES.SPACE)) {
	          vnode.context.$root.$emit(EVENT_SHOW, target, currentTarget);
	        }
	      }
	    };

	    el[HANDLER] = handler; // If element is not a button, we add `role="button"` for accessibility

	    setRole(trigger); // Listen for click events

	    eventOn(trigger, 'click', handler, EVENT_OPTS);

	    if (trigger.tagName !== 'BUTTON' && getAttr(trigger, 'role') === 'button') {
	      // If trigger isn't a button but has role button,
	      // we also listen for `keydown.space` && `keydown.enter`
	      eventOn(trigger, 'keydown', handler, EVENT_OPTS);
	    }
	  }
	};

	var unbind$1 = function unbind(el) {
	  var trigger = getTriggerElement(el);
	  var handler = el ? el[HANDLER] : null;

	  if (trigger && handler) {
	    eventOff(trigger, 'click', handler, EVENT_OPTS);
	    eventOff(trigger, 'keydown', handler, EVENT_OPTS);
	  }

	  delete el[HANDLER];
	};

	var componentUpdated$1 = function componentUpdated(el, binding, vnode) {
	  // We bind and rebind just in case target changes
	  unbind$1(el);
	  bind$1(el, binding, vnode);
	};

	var updated = function updated() {};
	/*
	 * Export our directive
	 */


	var VBModal = {
	  inserted: componentUpdated$1,
	  updated: updated,
	  componentUpdated: componentUpdated$1,
	  unbind: unbind$1
	};

	function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) { _defineProperties$4(Constructor.prototype, protoProps); } if (staticProps) { _defineProperties$4(Constructor, staticProps); } return Constructor; }

	function ownKeys$A(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$A(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$A(source, true).forEach(function (key) { _defineProperty$O(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$A(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$O(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _toConsumableArray$5(arr) { return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _nonIterableSpread$5(); }

	function _nonIterableSpread$5() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray$5(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") { return Array.from(iter); } }

	function _arrayWithoutHoles$5(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	var PROP_NAME$2 = '$bvModal';
	var PROP_NAME_PRIV = '_bv__modal'; // Base modal props that are allowed
	// Some may be ignored or overridden on some message boxes
	// Prop ID is allowed, but really only should be used for testing
	// We need to add it in explicitly as it comes from the `idMixin`

	var BASE_PROPS = ['id'].concat(_toConsumableArray$5(keys$2(omit(props$H, ['busy', 'lazy', 'noStacking', "static", 'visible'])))); // Fallback event resolver (returns undefined)

	var defaultResolver = function defaultResolver(bvModalEvt) {}; // Map prop names to modal slot names


	var propsToSlots = {
	  msgBoxContent: 'default',
	  title: 'modal-title',
	  okTitle: 'modal-ok',
	  cancelTitle: 'modal-cancel'
	}; // --- Utility methods ---
	// Method to filter only recognized props that are not undefined

	var filterOptions = function filterOptions(options) {
	  return BASE_PROPS.reduce(function (memo, key) {
	    if (!isUndefined(options[key])) {
	      memo[key] = options[key];
	    }

	    return memo;
	  }, {});
	}; // Method to install `$bvModal` VM injection


	var plugin = function plugin(Vue) {
	  // Create a private sub-component that extends BModal
	  // which self-destructs after hidden
	  // @vue/component
	  var BMsgBox = Vue.extend({
	    name: 'BMsgBox',
	    extends: BModal,
	    destroyed: function destroyed() {
	      // Make sure we not in document any more
	      if (this.$el && this.$el.parentNode) {
	        this.$el.parentNode.removeChild(this.$el);
	      }
	    },
	    mounted: function mounted() {
	      var _this = this;

	      // Self destruct handler
	      var handleDestroy = function handleDestroy() {
	        var self = _this;

	        _this.$nextTick(function () {
	          // In a `setTimeout()` to release control back to application
	          setTimeout(function () {
	            return self.$destroy();
	          }, 0);
	        });
	      }; // Self destruct if parent destroyed


	      this.$parent.$once('hook:destroyed', handleDestroy); // Self destruct after hidden

	      this.$once('hidden', handleDestroy); // Self destruct on route change

	      /* istanbul ignore if */

	      if (this.$router && this.$route) {
	        // Destroy ourselves if route changes

	        /* istanbul ignore next */
	        this.$once('hook:beforeDestroy', this.$watch('$router', handleDestroy));
	      } // Show the `BMsgBox`


	      this.show();
	    }
	  }); // Method to generate the on-demand modal message box
	  // Returns a promise that resolves to a value returned by the resolve

	  var asyncMsgBox = function asyncMsgBox($parent, props) {
	    var resolver = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultResolver;

	    if (warnNotClient(PROP_NAME$2) || warnNoPromiseSupport(PROP_NAME$2)) {
	      /* istanbul ignore next */
	      return;
	    } // Create an instance of `BMsgBox` component


	    var msgBox = new BMsgBox({
	      // We set parent as the local VM so these modals can emit events on
	      // the app `$root`, as needed by things like tooltips and popovers
	      // And it helps to ensure `BMsgBox` is destroyed when parent is destroyed
	      parent: $parent,
	      // Preset the prop values
	      propsData: _objectSpread$A({}, filterOptions(getComponentConfig('BModal') || {}), {
	        // Defaults that user can override
	        hideHeaderClose: true,
	        hideHeader: !(props.title || props.titleHtml)
	      }, omit(props, keys$2(propsToSlots)), {
	        // Props that can't be overridden
	        lazy: false,
	        busy: false,
	        visible: false,
	        noStacking: false,
	        noEnforceFocus: false
	      })
	    }); // Convert certain props to scoped slots

	    keys$2(propsToSlots).forEach(function (prop) {
	      if (!isUndefined(props[prop])) {
	        // Can be a string, or array of VNodes.
	        // Alternatively, user can use HTML version of prop to pass an HTML string.
	        msgBox.$slots[propsToSlots[prop]] = concat(props[prop]);
	      }
	    }); // Return a promise that resolves when hidden, or rejects on destroyed

	    return new Promise(function (resolve, reject) {
	      var resolved = false;
	      msgBox.$once('hook:destroyed', function () {
	        if (!resolved) {
	          /* istanbul ignore next */
	          reject(new Error('BootstrapVue MsgBox destroyed before resolve'));
	        }
	      });
	      msgBox.$on('hide', function (bvModalEvt) {
	        if (!bvModalEvt.defaultPrevented) {
	          var result = resolver(bvModalEvt); // If resolver didn't cancel hide, we resolve

	          if (!bvModalEvt.defaultPrevented) {
	            resolved = true;
	            resolve(result);
	          }
	        }
	      }); // Create a mount point (a DIV) and mount the msgBo which will trigger it to show

	      var div = document.createElement('div');
	      document.body.appendChild(div);
	      msgBox.$mount(div);
	    });
	  }; // Private utility method to open a user defined message box and returns a promise.
	  // Not to be used directly by consumers, as this method may change calling syntax


	  var makeMsgBox = function makeMsgBox($parent, content) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    var resolver = arguments.length > 3 ? arguments[3] : undefined;

	    if (!content || warnNoPromiseSupport(PROP_NAME$2) || warnNotClient(PROP_NAME$2) || !isFunction(resolver)) {
	      /* istanbul ignore next */
	      return;
	    }

	    return asyncMsgBox($parent, _objectSpread$A({}, filterOptions(options), {
	      msgBoxContent: content
	    }), resolver);
	  }; // BvModal instance class


	  var BvModal =
	  /*#__PURE__*/
	  function () {
	    function BvModal(vm) {
	      _classCallCheck$5(this, BvModal);

	      // Assign the new properties to this instance
	      assign(this, {
	        _vm: vm,
	        _root: vm.$root
	      }); // Set these properties as read-only and non-enumerable

	      defineProperties(this, {
	        _vm: readonlyDescriptor(),
	        _root: readonlyDescriptor()
	      });
	    } // --- Instance methods ---
	    // Show modal with the specified ID args are for future use


	    _createClass$4(BvModal, [{
	      key: "show",
	      value: function show(id) {
	        var arguments$1 = arguments;

	        if (id && this._root) {
	          var _this$_root;

	          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            args[_key - 1] = arguments$1[_key];
	          }

	          (_this$_root = this._root).$emit.apply(_this$_root, ['bv::show::modal', id].concat(args));
	        }
	      } // Hide modal with the specified ID args are for future use

	    }, {
	      key: "hide",
	      value: function hide(id) {
	        var arguments$1 = arguments;

	        if (id && this._root) {
	          var _this$_root2;

	          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	            args[_key2 - 1] = arguments$1[_key2];
	          }

	          (_this$_root2 = this._root).$emit.apply(_this$_root2, ['bv::hide::modal', id].concat(args));
	        }
	      } // The following methods require Promise support!
	      // IE 11 and others do not support Promise natively, so users
	      // should have a Polyfill loaded (which they need anyways for IE 11 support)
	      // Open a message box with OK button only and returns a promise

	    }, {
	      key: "msgBoxOk",
	      value: function msgBoxOk(message) {
	        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	        // Pick the modal props we support from options
	        var props = _objectSpread$A({}, options, {
	          // Add in overrides and our content prop
	          okOnly: true,
	          okDisabled: false,
	          hideFooter: false,
	          msgBoxContent: message
	        });

	        return makeMsgBox(this._vm, message, props, function (bvModalEvt) {
	          // Always resolve to true for OK
	          return true;
	        });
	      } // Open a message box modal with OK and CANCEL buttons
	      // and returns a promise

	    }, {
	      key: "msgBoxConfirm",
	      value: function msgBoxConfirm(message) {
	        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	        // Set the modal props we support from options
	        var props = _objectSpread$A({}, options, {
	          // Add in overrides and our content prop
	          okOnly: false,
	          okDisabled: false,
	          cancelDisabled: false,
	          hideFooter: false
	        });

	        return makeMsgBox(this._vm, message, props, function (bvModalEvt) {
	          var trigger = bvModalEvt.trigger;
	          return trigger === 'ok' ? true : trigger === 'cancel' ? false : null;
	        });
	      }
	    }]);

	    return BvModal;
	  }(); // Add our instance mixin


	  Vue.mixin({
	    beforeCreate: function beforeCreate() {
	      // Because we need access to `$root` for `$emits`, and VM for parenting,
	      // we have to create a fresh instance of `BvModal` for each VM
	      this[PROP_NAME_PRIV] = new BvModal(this);
	    }
	  }); // Define our read-only `$bvModal` instance property
	  // Placed in an if just in case in HMR mode
	  // eslint-disable-next-line no-prototype-builtins

	  if (!Vue.prototype.hasOwnProperty(PROP_NAME$2)) {
	    defineProperty$1(Vue.prototype, PROP_NAME$2, {
	      get: function get() {
	        /* istanbul ignore next */
	        if (!this || !this[PROP_NAME_PRIV]) {
	          warn("'".concat(PROP_NAME$2, "' must be accessed from a Vue instance 'this' context"));
	        }

	        return this[PROP_NAME_PRIV];
	      }
	    });
	  }
	};

	var BVModalPlugin =
	/*#__PURE__*/
	pluginFactory({
	  plugins: {
	    plugin: plugin
	  }
	});

	var ModalPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BModal: BModal
	  },
	  directives: {
	    VBModal: VBModal
	  },
	  // $bvModal injection
	  plugins: {
	    BVModalPlugin: BVModalPlugin
	  }
	});

	function _defineProperty$P(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var props$I = {
	  tag: {
	    type: String,
	    default: 'ul'
	  },
	  fill: {
	    type: Boolean,
	    default: false
	  },
	  justified: {
	    type: Boolean,
	    default: false
	  },
	  align: {
	    type: String,
	    default: null
	  },
	  tabs: {
	    type: Boolean,
	    default: false
	  },
	  pills: {
	    type: Boolean,
	    default: false
	  },
	  vertical: {
	    type: Boolean,
	    default: false
	  },
	  small: {
	    type: Boolean,
	    default: false
	  },
	  cardHeader: {
	    // Set to true if placing in a card header
	    type: Boolean,
	    default: false
	  }
	}; // -- Utils --

	var computeJustifyContent = function computeJustifyContent(value) {
	  // Normalize value
	  value = value === 'left' ? 'start' : value === 'right' ? 'end' : value;
	  return "justify-content-".concat(value);
	}; // @vue/component


	var BNav =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BNav',
	  functional: true,
	  props: props$I,
	  render: function render(h, _ref) {
	    var _class;

	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.tag, a(data, {
	      staticClass: 'nav',
	      class: (_class = {
	        'nav-tabs': props.tabs,
	        'nav-pills': props.pills && !props.tabs,
	        'card-header-tabs': !props.vertical && props.cardHeader && props.tabs,
	        'card-header-pills': !props.vertical && props.cardHeader && props.pills && !props.tabs,
	        'flex-column': props.vertical,
	        'nav-fill': !props.vertical && props.fill,
	        'nav-justified': !props.vertical && props.justified
	      }, _defineProperty$P(_class, computeJustifyContent(props.align), !props.vertical && props.align), _defineProperty$P(_class, "small", props.small), _class)
	    }), children);
	  }
	});

	function ownKeys$B(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$B(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$B(source, true).forEach(function (key) { _defineProperty$Q(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$B(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$Q(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$J = propsFactory(); // @vue/component

	var BNavItem =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BNavItem',
	  functional: true,
	  props: _objectSpread$B({}, props$J, {
	    linkAttrs: {
	      type: Object,
	      default: function _default() {}
	    },
	    linkClasses: {
	      type: [String, Object, Array],
	      default: null
	    }
	  }),
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        listeners = _ref.listeners,
	        children = _ref.children;
	    // We transfer the listeners to the link
	    delete data.on;
	    return h('li', a(data, {
	      staticClass: 'nav-item'
	    }), [h(BLink, {
	      staticClass: 'nav-link',
	      class: props.linkClasses,
	      attrs: props.linkAttrs,
	      props: props,
	      on: listeners
	    }, children)]);
	  }
	});

	var props$K = {}; // @vue/component

	var BNavText =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BNavText',
	  functional: true,
	  props: props$K,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h('li', a(data, {
	      staticClass: 'navbar-text'
	    }), children);
	  }
	});

	function ownKeys$C(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$C(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$C(source, true).forEach(function (key) { _defineProperty$R(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$C(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$R(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$L = _objectSpread$C({}, omit(props$o, ['inline']), {
	  formClass: {
	    type: [String, Array, Object],
	    default: null
	  }
	}); // @vue/component

	var BNavForm =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BNavForm',
	  functional: true,
	  props: props$L,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children,
	        _ref$listeners = _ref.listeners,
	        listeners = _ref$listeners === void 0 ? {} : _ref$listeners;
	    var attrs = data.attrs; // The following data properties are cleared out
	    // as they will be passed to BForm directly

	    data.attrs = {};
	    data.on = {};
	    var $form = h(BForm, {
	      class: props.formClass,
	      props: _objectSpread$C({}, props, {
	        inline: true
	      }),
	      attrs: attrs,
	      on: listeners
	    }, children);
	    return h('li', a(data, {
	      staticClass: 'form-inline'
	    }), [$form]);
	  }
	});

	var props$M = pluckProps(['menuClass', 'toggleClass', 'noCaret', 'role'], props$j); // @vue/component

	var BNavItemDropdown =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BNavItemDropdown',
	  mixins: [idMixin, dropdownMixin, normalizeSlotMixin],
	  props: props$M,
	  computed: {
	    isNav: function isNav() {
	      // Signal to dropdown mixin that we are in a navbar
	      return true;
	    },
	    dropdownClasses: function dropdownClasses() {
	      return [this.directionClass, {
	        show: this.visible
	      }];
	    },
	    menuClasses: function menuClasses() {
	      return [this.menuClass, {
	        'dropdown-menu-right': this.right,
	        show: this.visible
	      }];
	    },
	    toggleClasses: function toggleClasses() {
	      return [this.toggleClass, {
	        'dropdown-toggle-no-caret': this.noCaret
	      }];
	    }
	  },
	  render: function render(h) {
	    var button = h(BLink, {
	      ref: 'toggle',
	      staticClass: 'nav-link dropdown-toggle',
	      class: this.toggleClasses,
	      props: {
	        href: '#',
	        disabled: this.disabled
	      },
	      attrs: {
	        id: this.safeId('_BV_button_'),
	        'aria-haspopup': 'true',
	        'aria-expanded': this.visible ? 'true' : 'false'
	      },
	      on: {
	        click: this.toggle,
	        keydown: this.toggle // space, enter, down

	      }
	    }, [this.$slots['button-content'] || this.$slots.text || h('span', {
	      domProps: htmlOrText(this.html, this.text)
	    })]);
	    var menu = h('ul', {
	      staticClass: 'dropdown-menu',
	      class: this.menuClasses,
	      ref: 'menu',
	      attrs: {
	        tabindex: '-1',
	        'aria-labelledby': this.safeId('_BV_button_')
	      },
	      on: {
	        keydown: this.onKeydown // up, down, esc

	      }
	    }, !this.lazy || this.visible ? this.normalizeSlot('default', {
	      hide: this.hide
	    }) : [h()]);
	    return h('li', {
	      staticClass: 'nav-item b-nav-dropdown dropdown',
	      class: this.dropdownClasses,
	      attrs: {
	        id: this.safeId()
	      }
	    }, [button, menu]);
	  }
	});

	var NavPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BNav: BNav,
	    BNavItem: BNavItem,
	    BNavText: BNavText,
	    BNavForm: BNavForm,
	    BNavItemDropdown: BNavItemDropdown,
	    BNavItemDd: BNavItemDropdown,
	    BNavDropdown: BNavItemDropdown,
	    BNavDd: BNavItemDropdown
	  },
	  plugins: {
	    DropdownPlugin: DropdownPlugin
	  }
	});

	function _defineProperty$S(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$j = 'BNavbar';
	var props$N = {
	  tag: {
	    type: String,
	    default: 'nav'
	  },
	  type: {
	    type: String,
	    default: 'light'
	  },
	  variant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$j, 'variant');
	    }
	  },
	  toggleable: {
	    type: [Boolean, String],
	    default: false
	  },
	  fixed: {
	    type: String
	  },
	  sticky: {
	    type: Boolean,
	    default: false
	  },
	  print: {
	    type: Boolean,
	    default: false
	  }
	}; // @vue/component

	var BNavbar =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$j,
	  functional: true,
	  props: props$N,
	  render: function render(h, _ref) {
	    var _class;

	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var breakpoint = '';
	    var xs = getBreakpoints()[0];

	    if (props.toggleable && isString(props.toggleable) && props.toggleable !== xs) {
	      breakpoint = "navbar-expand-".concat(props.toggleable);
	    } else if (props.toggleable === false) {
	      breakpoint = 'navbar-expand';
	    }

	    return h(props.tag, a(data, {
	      staticClass: 'navbar',
	      class: (_class = {
	        'd-print': props.print,
	        'sticky-top': props.sticky
	      }, _defineProperty$S(_class, "navbar-".concat(props.type), Boolean(props.type)), _defineProperty$S(_class, "bg-".concat(props.variant), Boolean(props.variant)), _defineProperty$S(_class, "fixed-".concat(props.fixed), Boolean(props.fixed)), _defineProperty$S(_class, "".concat(breakpoint), Boolean(breakpoint)), _class),
	      attrs: {
	        role: props.tag === 'nav' ? null : 'navigation'
	      }
	    }), children);
	  }
	});

	function _defineProperty$T(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var props$O = pluckProps(['tag', 'fill', 'justified', 'align', 'small'], props$I); // -- Utils --

	var computeJustifyContent$1 = function computeJustifyContent(value) {
	  // Normalize value
	  value = value === 'left' ? 'start' : value === 'right' ? 'end' : value;
	  return "justify-content-".concat(value);
	}; // @vue/component


	var BNavbarNav =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BNavbarNav',
	  functional: true,
	  props: props$O,
	  render: function render(h, _ref) {
	    var _class;

	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    return h(props.tag, a(data, {
	      staticClass: 'navbar-nav',
	      class: (_class = {
	        'nav-fill': props.fill,
	        'nav-justified': props.justified
	      }, _defineProperty$T(_class, computeJustifyContent$1(props.align), props.align), _defineProperty$T(_class, "small", props.small), _class)
	    }), children);
	  }
	});

	function ownKeys$D(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$D(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$D(source, true).forEach(function (key) { _defineProperty$U(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$D(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$U(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var linkProps$3 = propsFactory();
	linkProps$3.href.default = undefined;
	linkProps$3.to.default = undefined;
	var props$P = _objectSpread$D({}, linkProps$3, {
	  tag: {
	    type: String,
	    default: 'div'
	  }
	}); // @vue/component

	var BNavbarBrand =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BNavbarBrand',
	  functional: true,
	  props: props$P,
	  render: function render(h, _ref) {
	    var props = _ref.props,
	        data = _ref.data,
	        children = _ref.children;
	    var isLink = Boolean(props.to || props.href);
	    var tag = isLink ? BLink : props.tag;
	    return h(tag, a(data, {
	      staticClass: 'navbar-brand',
	      props: isLink ? pluckProps(linkProps$3, props) : {}
	    }), children);
	  }
	});

	var NAME$k = 'BNavbarToggle'; // TODO: Switch to using VBToggle directive, will reduce code footprint
	// Events we emit on $root

	var EVENT_TOGGLE$2 = 'bv::toggle::collapse'; // Events we listen to on $root

	var EVENT_STATE$2 = 'bv::collapse::state'; // This private event is NOT to be documented as people should not be using it.

	var EVENT_STATE_SYNC$2 = 'bv::collapse::sync::state'; // @vue/component

	var BNavbarToggle =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$k,
	  mixins: [listenOnRootMixin, normalizeSlotMixin],
	  props: {
	    label: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$k, 'label');
	      }
	    },
	    target: {
	      type: String,
	      required: true
	    }
	  },
	  data: function data() {
	    return {
	      toggleState: false
	    };
	  },
	  created: function created() {
	    this.listenOnRoot(EVENT_STATE$2, this.handleStateEvt);
	    this.listenOnRoot(EVENT_STATE_SYNC$2, this.handleStateEvt);
	  },
	  methods: {
	    onClick: function onClick(evt) {
	      this.$emit('click', evt);

	      if (!evt.defaultPrevented) {
	        this.$root.$emit(EVENT_TOGGLE$2, this.target);
	      }
	    },
	    handleStateEvt: function handleStateEvt(id, state) {
	      if (id === this.target) {
	        this.toggleState = state;
	      }
	    }
	  },
	  render: function render(h) {
	    return h('button', {
	      class: ['navbar-toggler'],
	      attrs: {
	        type: 'button',
	        'aria-label': this.label,
	        'aria-controls': this.target,
	        'aria-expanded': this.toggleState ? 'true' : 'false'
	      },
	      on: {
	        click: this.onClick
	      }
	    }, [this.normalizeSlot('default') || h('span', {
	      class: ['navbar-toggler-icon']
	    })]);
	  }
	});

	var NavbarPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BNavbar: BNavbar,
	    BNavbarNav: BNavbarNav,
	    BNavbarBrand: BNavbarBrand,
	    BNavbarToggle: BNavbarToggle,
	    BNavToggle: BNavbarToggle
	  },
	  plugins: {
	    NavPlugin: NavPlugin,
	    CollapsePlugin: CollapsePlugin,
	    DropdownPlugin: DropdownPlugin
	  }
	});

	/**
	 * @param {number} length
	 * @return {Array}
	 */
	var range = function range(length) {
	  return Array.apply(null, {
	    length: length
	  });
	};

	// for <b-pagination> and <b-pagination-nav>
	// Threshold of limit size when we start/stop showing ellipsis

	var ELLIPSIS_THRESHOLD = 3; // Default # of buttons limit

	var DEFAULT_LIMIT = 5; // Make an array of N to N+X

	var makePageArray = function makePageArray(startNumber, numberOfPages) {
	  return range(numberOfPages).map(function (val, i) {
	    return {
	      number: startNumber + i,
	      classes: null
	    };
	  });
	}; // Sanitize the provided limit value (converting to a number)


	var sanitizeLimit = function sanitizeLimit(val) {
	  var limit = parseInt(val, 10) || 1;
	  return limit < 1 ? DEFAULT_LIMIT : limit;
	}; // Sanitize the provided current page number (converting to a number)


	var sanitizeCurrentPage = function sanitizeCurrentPage(val, numberOfPages) {
	  var page = parseInt(val, 10) || 1;
	  return page > numberOfPages ? numberOfPages : page < 1 ? 1 : page;
	}; // Links don't normally respond to SPACE, so we add that
	// functionality via this handler


	var onSpaceKey = function onSpaceKey(evt) {
	  if (evt.keyCode === KEY_CODES.SPACE) {
	    evt.preventDefault(); // Stop page from scrolling

	    evt.stopImmediatePropagation();
	    evt.stopPropagation(); // Trigger the click event on the link

	    evt.currentTarget.click();
	    return false;
	  }
	};

	var props$Q = {
	  disabled: {
	    type: Boolean,
	    default: false
	  },
	  value: {
	    type: [Number, String],
	    default: null,
	    validator: function validator(value)
	    /* istanbul ignore next */
	    {
	      var num = parseInt(value, 10);

	      if (!isNull(value) && (isNaN(num) || num < 1)) {
	        warn('pagination: v-model value must be a number greater than 0');
	        return false;
	      }

	      return true;
	    }
	  },
	  limit: {
	    type: [Number, String],
	    default: DEFAULT_LIMIT,
	    validator: function validator(value)
	    /* istanbul ignore next */
	    {
	      var num = parseInt(value, 10);

	      if (isNaN(num) || num < 1) {
	        warn('pagination: prop "limit" must be a number greater than 0');
	        return false;
	      }

	      return true;
	    }
	  },
	  align: {
	    type: String,
	    default: 'left'
	  },
	  pills: {
	    type: Boolean,
	    default: false
	  },
	  hideGotoEndButtons: {
	    type: Boolean,
	    default: false
	  },
	  ariaLabel: {
	    type: String,
	    default: 'Pagination'
	  },
	  labelFirstPage: {
	    type: String,
	    default: 'Go to first page'
	  },
	  firstText: {
	    type: String,
	    default: "\xAB" // '«'

	  },
	  labelPrevPage: {
	    type: String,
	    default: 'Go to previous page'
	  },
	  prevText: {
	    type: String,
	    default: "\u2039" // '‹'

	  },
	  labelNextPage: {
	    type: String,
	    default: 'Go to next page'
	  },
	  nextText: {
	    type: String,
	    default: "\u203A" // '›'

	  },
	  labelLastPage: {
	    type: String,
	    default: 'Go to last page'
	  },
	  lastText: {
	    type: String,
	    default: "\xBB" // '»'

	  },
	  labelPage: {
	    type: [String, Function],
	    default: 'Go to page'
	  },
	  hideEllipsis: {
	    type: Boolean,
	    default: false
	  },
	  ellipsisText: {
	    type: String,
	    default: "\u2026" // '…'

	  }
	}; // @vue/component

	var paginationMixin = {
	  mixins: [normalizeSlotMixin],
	  model: {
	    prop: 'value',
	    event: 'input'
	  },
	  props: props$Q,
	  data: function data() {
	    var curr = parseInt(this.value, 10);
	    return {
	      // -1 signifies no page initially selected
	      currentPage: curr > 0 ? curr : -1,
	      localNumberOfPages: 1,
	      localLimit: DEFAULT_LIMIT
	    };
	  },
	  computed: {
	    btnSize: function btnSize() {
	      return this.size ? "pagination-".concat(this.size) : '';
	    },
	    alignment: function alignment() {
	      var align = this.align;

	      if (align === 'center') {
	        return 'justify-content-center';
	      } else if (align === 'end' || align === 'right') {
	        return 'justify-content-end';
	      } else if (align === 'fill') {
	        // The page-items will also have 'flex-fill' added.
	        // We ad text centering to make the button appearance better in fill mode.
	        return 'text-center';
	      }

	      return '';
	    },
	    styleClass: function styleClass() {
	      return this.pills ? 'b-pagination-pills' : '';
	    },
	    computedCurrentPage: function computedCurrentPage() {
	      return sanitizeCurrentPage(this.currentPage, this.localNumberOfPages);
	    },
	    paginationParams: function paginationParams() {
	      // Determine if we should show the the ellipsis
	      var limit = this.limit;
	      var numberOfPages = this.localNumberOfPages;
	      var currentPage = this.computedCurrentPage;
	      var hideEllipsis = this.hideEllipsis;
	      var showFirstDots = false;
	      var showLastDots = false;
	      var numberOfLinks = limit;
	      var startNumber = 1;

	      if (numberOfPages <= limit) {
	        // Special Case: Less pages available than the limit of displayed pages
	        numberOfLinks = numberOfPages;
	      } else if (currentPage < limit - 1 && limit > ELLIPSIS_THRESHOLD) {
	        // We are near the beginning of the page list
	        if (!hideEllipsis) {
	          showLastDots = true;
	          numberOfLinks = limit - 1;
	        }
	      } else if (numberOfPages - currentPage + 2 < limit && limit > ELLIPSIS_THRESHOLD) {
	        // We are near the end of the list
	        if (!hideEllipsis) {
	          numberOfLinks = limit - 1;
	          showFirstDots = true;
	        }

	        startNumber = numberOfPages - numberOfLinks + 1;
	      } else {
	        // We are somewhere in the middle of the page list
	        if (limit > ELLIPSIS_THRESHOLD && !hideEllipsis) {
	          numberOfLinks = limit - 2;
	          showFirstDots = showLastDots = true;
	        }

	        startNumber = currentPage - Math.floor(numberOfLinks / 2);
	      } // Sanity checks


	      if (startNumber < 1) {
	        /* istanbul ignore next */
	        startNumber = 1;
	      } else if (startNumber > numberOfPages - numberOfLinks) {
	        startNumber = numberOfPages - numberOfLinks + 1;
	      }

	      return {
	        showFirstDots: showFirstDots,
	        showLastDots: showLastDots,
	        numberOfLinks: numberOfLinks,
	        startNumber: startNumber
	      };
	    },
	    pageList: function pageList() {
	      // Generates the pageList array
	      var _this$paginationParam = this.paginationParams,
	          numberOfLinks = _this$paginationParam.numberOfLinks,
	          startNumber = _this$paginationParam.startNumber;
	      var currentPage = this.computedCurrentPage; // Generate list of page numbers

	      var pages = makePageArray(startNumber, numberOfLinks); // We limit to a total of 3 page buttons on XS screens
	      // So add classes to page links to hide them for XS breakpoint
	      // Note: Ellipsis will also be hidden on XS screens
	      // TODO: Make this visual limit configurable based on breakpoint(s)

	      if (pages.length > 3) {
	        var idx = currentPage - startNumber; // THe following is a bootstrap-vue custom utility class

	        var classes = 'bv-d-xs-down-none';

	        if (idx === 0) {
	          // Keep leftmost 3 buttons visible when current page is first page
	          for (var i = 3; i < pages.length; i++) {
	            pages[i].classes = classes;
	          }
	        } else if (idx === pages.length - 1) {
	          // Keep rightmost 3 buttons visible when current page is last page
	          for (var _i = 0; _i < pages.length - 3; _i++) {
	            pages[_i].classes = classes;
	          }
	        } else {
	          // Hide all except current page, current page - 1 and current page + 1
	          for (var _i2 = 0; _i2 < idx - 1; _i2++) {
	            // hide some left button(s)
	            pages[_i2].classes = classes;
	          }

	          for (var _i3 = pages.length - 1; _i3 > idx + 1; _i3--) {
	            // hide some right button(s)
	            pages[_i3].classes = classes;
	          }
	        }
	      }

	      return pages;
	    }
	  },
	  watch: {
	    value: function value(newValue, oldValue) {
	      if (newValue !== oldValue) {
	        this.currentPage = sanitizeCurrentPage(newValue, this.localNumberOfPages);
	      }
	    },
	    currentPage: function currentPage(newValue, oldValue) {
	      if (newValue !== oldValue) {
	        // Emit null if no page selected
	        this.$emit('input', newValue > 0 ? newValue : null);
	      }
	    },
	    limit: function limit(newValue, oldValue) {
	      if (newValue !== oldValue) {
	        this.localLimit = sanitizeLimit(newValue);
	      }
	    }
	  },
	  created: function created() {
	    var _this = this;

	    // Set our default values in data
	    this.localLimit = sanitizeLimit(this.limit);
	    this.$nextTick(function () {
	      // Sanity check
	      _this.currentPage = _this.currentPage > _this.localNumberOfPages ? _this.localNumberOfPages : _this.currentPage;
	    });
	  },
	  methods: {
	    handleKeyNav: function handleKeyNav(evt) {
	      var keyCode = evt.keyCode;
	      var shift = evt.shiftKey;

	      if (keyCode === KEY_CODES.LEFT || keyCode === KEY_CODES.UP) {
	        evt.preventDefault();
	        shift ? this.focusFirst() : this.focusPrev();
	      } else if (keyCode === KEY_CODES.RIGHT || keyCode === KEY_CODES.DOWN) {
	        evt.preventDefault();
	        shift ? this.focusLast() : this.focusNext();
	      }
	    },
	    getButtons: function getButtons() {
	      // Return only buttons that are visible
	      return selectAll('a.page-link', this.$el).filter(function (btn) {
	        return isVisible(btn);
	      });
	    },
	    setBtnFocus: function setBtnFocus(btn) {
	      btn.focus();
	    },
	    focusCurrent: function focusCurrent() {
	      var _this2 = this;

	      // We do this in next tick to ensure buttons have finished rendering
	      this.$nextTick(function () {
	        var btn = _this2.getButtons().find(function (el) {
	          return parseInt(getAttr(el, 'aria-posinset'), 10) === _this2.computedCurrentPage;
	        });

	        if (btn && btn.focus) {
	          _this2.setBtnFocus(btn);
	        } else {
	          // Fallback if current page is not in button list
	          _this2.focusFirst();
	        }
	      });
	    },
	    focusFirst: function focusFirst() {
	      var _this3 = this;

	      // We do this in next tick to ensure buttons have finished rendering
	      this.$nextTick(function () {
	        var btn = _this3.getButtons().find(function (el) {
	          return !isDisabled(el);
	        });

	        if (btn && btn.focus && btn !== document.activeElement) {
	          _this3.setBtnFocus(btn);
	        }
	      });
	    },
	    focusLast: function focusLast() {
	      var _this4 = this;

	      // We do this in next tick to ensure buttons have finished rendering
	      this.$nextTick(function () {
	        var btn = _this4.getButtons().reverse().find(function (el) {
	          return !isDisabled(el);
	        });

	        if (btn && btn.focus && btn !== document.activeElement) {
	          _this4.setBtnFocus(btn);
	        }
	      });
	    },
	    focusPrev: function focusPrev() {
	      var _this5 = this;

	      // We do this in next tick to ensure buttons have finished rendering
	      this.$nextTick(function () {
	        var buttons = _this5.getButtons();

	        var idx = buttons.indexOf(document.activeElement);

	        if (idx > 0 && !isDisabled(buttons[idx - 1]) && buttons[idx - 1].focus) {
	          _this5.setBtnFocus(buttons[idx - 1]);
	        }
	      });
	    },
	    focusNext: function focusNext() {
	      var _this6 = this;

	      // We do this in next tick to ensure buttons have finished rendering
	      this.$nextTick(function () {
	        var buttons = _this6.getButtons();

	        var idx = buttons.indexOf(document.activeElement);
	        var cnt = buttons.length - 1;

	        if (idx < cnt && !isDisabled(buttons[idx + 1]) && buttons[idx + 1].focus) {
	          _this6.setBtnFocus(buttons[idx + 1]);
	        }
	      });
	    }
	  },
	  render: function render(h) {
	    var _this7 = this;

	    var buttons = [];
	    var numberOfPages = this.localNumberOfPages;
	    var disabled = this.disabled;
	    var _this$paginationParam2 = this.paginationParams,
	        showFirstDots = _this$paginationParam2.showFirstDots,
	        showLastDots = _this$paginationParam2.showLastDots;
	    var currentPage = this.computedCurrentPage;
	    var fill = this.align === 'fill'; // Helper function and flag

	    var isActivePage = function isActivePage(pageNum) {
	      return pageNum === currentPage;
	    };

	    var noCurrPage = this.currentPage < 1; // Factory function for prev/next/first/last buttons

	    var makeEndBtn = function makeEndBtn(linkTo, ariaLabel, btnSlot, btnText, pageTest, key) {
	      var isDisabled = disabled || isActivePage(pageTest) || noCurrPage || linkTo < 1 || linkTo > numberOfPages;
	      var pageNum = linkTo < 1 ? 1 : linkTo > numberOfPages ? numberOfPages : linkTo;
	      var scope = {
	        disabled: isDisabled,
	        page: pageNum,
	        index: pageNum - 1
	      };
	      var btnContent = _this7.normalizeSlot(btnSlot, scope) || toString$3(btnText) || h();
	      var inner = h(isDisabled ? 'span' : BLink, {
	        staticClass: 'page-link',
	        props: isDisabled ? {} : _this7.linkProps(linkTo),
	        attrs: {
	          role: 'menuitem',
	          tabindex: isDisabled ? null : '-1',
	          'aria-label': ariaLabel,
	          'aria-controls': _this7.ariaControls || null,
	          'aria-disabled': isDisabled ? 'true' : null
	        },
	        on: isDisabled ? {} : {
	          click: function click(evt) {
	            _this7.onClick(linkTo, evt);
	          },
	          keydown: onSpaceKey
	        }
	      }, [btnContent]);
	      return h('li', {
	        key: key,
	        staticClass: 'page-item',
	        class: {
	          disabled: isDisabled,
	          'flex-fill': fill
	        },
	        attrs: {
	          role: 'presentation',
	          'aria-hidden': isDisabled ? 'true' : null
	        }
	      }, [inner]);
	    }; // Ellipsis factory


	    var makeEllipsis = function makeEllipsis(isLast) {
	      return h('li', {
	        key: "ellipsis-".concat(isLast ? 'last' : 'first'),
	        staticClass: 'page-item',
	        class: ['disabled', 'bv-d-xs-down-none', fill ? 'flex-fill' : ''],
	        attrs: {
	          role: 'separator'
	        }
	      }, [h('span', {
	        staticClass: 'page-link'
	      }, [_this7.normalizeSlot('ellipsis-text') || toString$3(_this7.ellipsisText) || h()])]);
	    }; // Goto First Page button bookend


	    buttons.push(this.hideGotoEndButtons ? h() : makeEndBtn(1, this.labelFirstPage, 'first-text', this.firstText, 1, 'bookend-goto-first')); // Goto Previous page button bookend

	    buttons.push(makeEndBtn(currentPage - 1, this.labelPrevPage, 'prev-text', this.prevText, 1, 'bookend-goto-prev')); // First Ellipsis Bookend

	    buttons.push(showFirstDots ? makeEllipsis(false) : h()); // Individual Page links

	    this.pageList.forEach(function (page, idx) {
	      var active = isActivePage(page.number) && !noCurrPage; // Active page will have tabindex of 0, or if no current page and first page button

	      var tabIndex = disabled ? null : active || noCurrPage && idx === 0 ? '0' : '-1';
	      var attrs = {
	        role: 'menuitemradio',
	        'aria-disabled': disabled ? 'true' : null,
	        'aria-controls': _this7.ariaControls || null,
	        'aria-label': isFunction(_this7.labelPage) ? _this7.labelPage(page.number) : "".concat(_this7.labelPage, " ").concat(page.number),
	        'aria-checked': active ? 'true' : 'false',
	        'aria-posinset': page.number,
	        'aria-setsize': numberOfPages,
	        // ARIA "roving tabindex" method
	        tabindex: tabIndex
	      };
	      var btnContent = toString$3(_this7.makePage(page.number));
	      var scope = {
	        page: page.number,
	        index: page.number - 1,
	        content: btnContent,
	        active: active,
	        disabled: disabled
	      };
	      var inner = h(disabled ? 'span' : BLink, {
	        props: disabled ? {} : _this7.linkProps(page.number),
	        staticClass: 'page-link',
	        attrs: attrs,
	        on: disabled ? {} : {
	          click: function click(evt) {
	            _this7.onClick(page.number, evt);
	          },
	          keydown: onSpaceKey
	        }
	      }, [_this7.normalizeSlot('page', scope) || btnContent]);
	      buttons.push(h('li', {
	        key: "page-".concat(page.number),
	        staticClass: 'page-item',
	        class: [{
	          disabled: disabled,
	          active: active,
	          'flex-fill': fill
	        }, page.classes],
	        attrs: {
	          role: 'presentation'
	        }
	      }, [inner]));
	    }); // Last Ellipsis Bookend

	    buttons.push(showLastDots ? makeEllipsis(true) : h()); // Goto Next page button bookend

	    buttons.push(makeEndBtn(currentPage + 1, this.labelNextPage, 'next-text', this.nextText, numberOfPages, 'bookend-goto-next')); // Goto Last Page button bookend

	    buttons.push(this.hideGotoEndButtons ? h() : makeEndBtn(numberOfPages, this.labelLastPage, 'last-text', this.lastText, numberOfPages, 'bookend-goto-last')); // Assemble the pagination buttons

	    var pagination = h('ul', {
	      ref: 'ul',
	      staticClass: 'pagination',
	      class: ['b-pagination', this.btnSize, this.alignment, this.styleClass],
	      attrs: {
	        role: 'menubar',
	        'aria-disabled': disabled ? 'true' : 'false',
	        'aria-label': this.ariaLabel || null
	      },
	      on: {
	        keydown: this.handleKeyNav
	      }
	    }, buttons); // if we are pagination-nav, wrap in '<nav>' wrapper

	    if (this.isNav) {
	      return h('nav', {
	        attrs: {
	          'aria-disabled': disabled ? 'true' : null,
	          'aria-hidden': disabled ? 'true' : 'false'
	        }
	      }, [pagination]);
	    } else {
	      return pagination;
	    }
	  }
	};

	var NAME$l = 'BPagination';
	var DEFAULT_PER_PAGE = 20;
	var DEFAULT_TOTAL_ROWS = 0;
	var props$R = {
	  size: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$l, 'size');
	    }
	  },
	  perPage: {
	    type: [Number, String],
	    default: DEFAULT_PER_PAGE
	  },
	  totalRows: {
	    type: [Number, String],
	    default: DEFAULT_TOTAL_ROWS
	  },
	  ariaControls: {
	    type: String,
	    default: null
	  }
	}; // --- Helper functions ---
	// Sanitize the provided per page number (converting to a number)

	var sanitizePerPage = function sanitizePerPage(val) {
	  var perPage = parseInt(val, 10) || DEFAULT_PER_PAGE;
	  return perPage < 1 ? 1 : perPage;
	}; // Sanitize the provided total rows number (converting to a number)


	var sanitizeTotalRows = function sanitizeTotalRows(val) {
	  var totalRows = parseInt(val, 10) || DEFAULT_TOTAL_ROWS;
	  return totalRows < 0 ? 0 : totalRows;
	}; // The render function is brought in via the `paginationMixin`
	// @vue/component


	var BPagination =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$l,
	  mixins: [paginationMixin],
	  props: props$R,
	  computed: {
	    numberOfPages: function numberOfPages() {
	      var result = Math.ceil(sanitizeTotalRows(this.totalRows) / sanitizePerPage(this.perPage));
	      return result < 1 ? 1 : result;
	    },
	    pageSizeNumberOfPages: function pageSizeNumberOfPages() {
	      // Used for watching changes to `perPage` and `numberOfPages`
	      return {
	        perPage: sanitizePerPage(this.perPage),
	        totalRows: sanitizeTotalRows(this.totalRows),
	        numberOfPages: this.numberOfPages
	      };
	    }
	  },
	  watch: {
	    pageSizeNumberOfPages: function pageSizeNumberOfPages(newVal, oldVal) {
	      if (!isUndefinedOrNull(oldVal)) {
	        if (newVal.perPage !== oldVal.perPage && newVal.totalRows === oldVal.totalRows) {
	          // If the page size changes, reset to page 1
	          this.currentPage = 1;
	        } else if (newVal.numberOfPages !== oldVal.numberOfPages && this.currentPage > newVal.numberOfPages) {
	          // If `numberOfPages` changes and is less than
	          // the `currentPage` number, reset to page 1
	          this.currentPage = 1;
	        }
	      }

	      this.localNumberOfPages = newVal.numberOfPages;
	    }
	  },
	  created: function created() {
	    var _this = this;

	    // Set the initial page count
	    this.localNumberOfPages = this.numberOfPages; // Set the initial page value

	    var currentPage = parseInt(this.value, 10) || 0;

	    if (currentPage > 0) {
	      this.currentPage = currentPage;
	    } else {
	      this.$nextTick(function () {
	        // If this value parses to NaN or a value less than 1
	        // Trigger an initial emit of 'null' if no page specified
	        _this.currentPage = 0;
	      });
	    }
	  },
	  mounted: function mounted() {
	    // Set the initial page count
	    this.localNumberOfPages = this.numberOfPages;
	  },
	  methods: {
	    // These methods are used by the render function
	    onClick: function onClick(num, evt) {
	      var _this2 = this;

	      // Handle edge cases where number of pages has changed (i.e. if perPage changes)
	      // This should normally not happen, but just in case.
	      if (num > this.numberOfPages) {
	        /* istanbul ignore next */
	        num = this.numberOfPages;
	      } else if (num < 1) {
	        /* istanbul ignore next */
	        num = 1;
	      } // Update the v-model


	      this.currentPage = num; // Emit event triggered by user interaction

	      this.$emit('change', this.currentPage);
	      this.$nextTick(function () {
	        // Keep the current button focused if possible
	        var target = evt.target;

	        if (isVisible(target) && _this2.$el.contains(target) && target.focus) {
	          target.focus();
	        } else {
	          _this2.focusCurrent();
	        }
	      });
	    },
	    makePage: function makePage(pageNum) {
	      return pageNum;
	    },
	    linkProps: function linkProps(pageNum) {
	      // Always '#' for pagination component
	      return {
	        href: '#'
	      };
	    }
	  }
	});

	var PaginationPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BPagination: BPagination
	  }
	});

	var NAME$m = 'BPaginationNav'; // Sanitize the provided number of pages (converting to a number)

	var sanitizeNumberOfPages = function sanitizeNumberOfPages(value) {
	  var numberOfPages = parseInt(value, 10) || 1;
	  return numberOfPages < 1 ? 1 : numberOfPages;
	};
	var props$S = {
	  size: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$m, 'size');
	    }
	  },
	  numberOfPages: {
	    type: [Number, String],
	    default: 1,
	    validator: function validator(value)
	    /* istanbul ignore next */
	    {
	      var num = parseInt(value, 10);

	      if (isNaN(num) || num < 1) {
	        warn('b-pagination: prop "number-of-pages" must be a number greater than 0');
	        return false;
	      }

	      return true;
	    }
	  },
	  baseUrl: {
	    type: String,
	    default: '/'
	  },
	  useRouter: {
	    type: Boolean,
	    default: false
	  },
	  linkGen: {
	    type: Function,
	    default: null
	  },
	  pageGen: {
	    type: Function,
	    default: null
	  },
	  pages: {
	    // Optional array of page links
	    type: Array,
	    default: null
	  },
	  noPageDetect: {
	    // Disable auto page number detection if true
	    type: Boolean,
	    default: false
	  },
	  // router-link specific props
	  activeClass: {
	    type: String // default: undefined

	  },
	  exact: {
	    type: Boolean,
	    default: false
	  },
	  exactActiveClass: {
	    type: String // default: undefined

	  },
	  // nuxt-link specific prop(s)
	  noPrefetch: {
	    type: Boolean,
	    default: false
	  }
	}; // The render function is brought in via the pagination mixin
	// @vue/component

	var BPaginationNav =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$m,
	  mixins: [paginationMixin],
	  props: props$S,
	  computed: {
	    // Used by render function to trigger wrapping in '<nav>' element
	    isNav: function isNav() {
	      return true;
	    },
	    computedValue: function computedValue() {
	      // Returns the value prop as a number or `null` if undefined or < 1
	      var val = parseInt(this.value, 10);
	      return isNaN(val) || val < 1 ? null : val;
	    }
	  },
	  watch: {
	    numberOfPages: function numberOfPages(newVal, oldVal) {
	      var _this = this;

	      this.$nextTick(function () {
	        _this.setNumberOfPages();
	      });
	    },
	    pages: function pages(newVal, oldVal) {
	      var _this2 = this;

	      this.$nextTick(function () {
	        _this2.setNumberOfPages();
	      });
	    }
	  },
	  created: function created() {
	    this.setNumberOfPages();
	  },
	  mounted: function mounted() {
	    var _this3 = this;

	    if (this.$router) {
	      // We only add the watcher if vue router is detected
	      this.$watch('$route', function (to, from) {
	        _this3.$nextTick(function () {
	          requestAF(function () {
	            _this3.guessCurrentPage();
	          });
	        });
	      });
	    }
	  },
	  methods: {
	    setNumberOfPages: function setNumberOfPages() {
	      var _this4 = this;

	      if (isArray(this.pages) && this.pages.length > 0) {
	        this.localNumberOfPages = this.pages.length;
	      } else {
	        this.localNumberOfPages = sanitizeNumberOfPages(this.numberOfPages);
	      }

	      this.$nextTick(function () {
	        _this4.guessCurrentPage();
	      });
	    },
	    onClick: function onClick(pageNum, evt) {
	      var _this5 = this;

	      // Dont do anything if clicking the current active page
	      if (pageNum === this.currentPage) {
	        return;
	      }

	      requestAF(function () {
	        // Update the v-model
	        // Done in in requestAF() to allow browser to complete the
	        // native browser click handling of a link
	        _this5.currentPage = pageNum;

	        _this5.$emit('change', pageNum);
	      });
	      this.$nextTick(function () {
	        // Done in a nextTick() to ensure rendering complete
	        try {
	          // Emulate native link click page reloading behaviour by blurring the
	          // paginator and returning focus to the document
	          var target = evt.currentTarget || evt.target;
	          target.blur();
	        } catch (e) {}
	      });
	    },
	    getPageInfo: function getPageInfo(pageNum) {
	      if (!isArray(this.pages) || this.pages.length === 0 || isUndefined(this.pages[pageNum - 1])) {
	        var link = "".concat(this.baseUrl).concat(pageNum);
	        return {
	          link: this.useRouter ? {
	            path: link
	          } : link,
	          text: toString$3(pageNum)
	        };
	      }

	      var info = this.pages[pageNum - 1];

	      if (isObject(info)) {
	        var _link = info.link;
	        return {
	          // Normalize link for router use
	          link: isObject(_link) ? _link : this.useRouter ? {
	            path: _link
	          } : _link,
	          // Make sure text has a value
	          text: toString$3(info.text || pageNum)
	        };
	      } else {
	        return {
	          link: toString$3(info),
	          text: toString$3(pageNum)
	        };
	      }
	    },
	    makePage: function makePage(pageNum) {
	      var info = this.getPageInfo(pageNum);

	      if (this.pageGen && isFunction(this.pageGen)) {
	        return this.pageGen(pageNum, info);
	      }

	      return info.text;
	    },
	    makeLink: function makeLink(pageNum) {
	      var info = this.getPageInfo(pageNum);

	      if (this.linkGen && isFunction(this.linkGen)) {
	        return this.linkGen(pageNum, info);
	      }

	      return info.link;
	    },
	    linkProps: function linkProps(pageNum) {
	      var link = this.makeLink(pageNum);
	      var props = {
	        target: this.target || null,
	        rel: this.rel || null,
	        disabled: this.disabled,
	        // The following props are only used if BLink detects router
	        exact: this.exact,
	        activeClass: this.activeClass,
	        exactActiveClass: this.exactActiveClass,
	        append: this.append,
	        replace: this.replace,
	        // nuxt-link specific prop
	        noPrefetch: this.noPrefetch
	      };

	      if (this.useRouter || isObject(link)) {
	        props.to = link;
	      } else {
	        props.href = link;
	      }

	      return props;
	    },
	    resolveLink: function resolveLink() {
	      var to = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      // Given a to (or href string), convert to normalized route-like structure
	      // Works only client side!!
	      var link;

	      try {
	        // Convert the `to` to a HREF via a temporary `a` tag
	        link = document.createElement('a');
	        link.href = computeHref({
	          to: to
	        }, 'a', '/', '/'); // We need to add the anchor to the document to make sure the
	        // `pathname` is correctly detected in any browser (i.e. IE)

	        document.body.appendChild(link); // Once href is assigned, the link will be normalized to the full URL bits

	        var _link2 = link,
	            pathname = _link2.pathname,
	            hash = _link2.hash,
	            search = _link2.search; // Remove link from document

	        document.body.removeChild(link); // Return the location in a route-like object

	        return {
	          path: pathname,
	          hash: hash,
	          query: parseQuery(search)
	        };
	      } catch (e) {
	        /* istanbul ignore next */
	        try {
	          link && link.parentNode && link.parentNode.removeChild(link);
	        } catch (e) {}
	        /* istanbul ignore next */


	        return {};
	      }
	    },
	    resolveRoute: function resolveRoute() {
	      var to = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	      // Given a to (or href string), convert to normalized route location structure
	      // works only when router available!!
	      try {
	        var route = this.$router.resolve(to, this.$route).route;
	        return {
	          path: route.path,
	          hash: route.hash,
	          query: route.query
	        };
	      } catch (e) {
	        /* istanbul ignore next */
	        return {};
	      }
	    },
	    guessCurrentPage: function guessCurrentPage() {
	      var guess = this.computedValue;
	      var $router = this.$router;
	      var $route = this.$route; // This section only occurs if we are client side, or server-side with $router

	      /* istanbul ignore else */

	      if (!this.noPageDetect && !guess && (isBrowser || !isBrowser && $router)) {
	        // Current route (if router available)
	        var currRoute = $router && $route ? {
	          path: $route.path,
	          hash: $route.hash,
	          query: $route.query
	        } : {}; // Current page full HREF (if client side). Can't be done as a computed prop!

	        var loc = isBrowser ? window.location || document.location : null;
	        var currLink = loc ? {
	          path: loc.pathname,
	          hash: loc.hash,
	          query: parseQuery(loc.search)
	        } : {}; // Loop through the possible pages looking for a match until found

	        for (var page = 1; !guess && page <= this.localNumberOfPages; page++) {
	          var to = this.makeLink(page);

	          if ($router && (isObject(to) || this.useRouter)) {
	            // Resolve the page via the $router
	            guess = looseEqual(this.resolveRoute(to), currRoute) ? page : null;
	          } else if (isBrowser) {
	            // If no $router available (or !this.useRouter when `to` is a string)
	            // we compare using parsed URIs
	            guess = looseEqual(this.resolveLink(to), currLink) ? page : null;
	          } else {
	            // probably SSR, but no $router so we can't guess, so lets break out of
	            // the loop early

	            /* istanbul ignore next */
	            guess = -1;
	          }
	        }
	      } // We set currentPage to 0 to trigger an $emit('input', null)
	      // As the default for this.currentPage is -1 when no value is specified
	      // And valid page numbers are greater than 0


	      this.currentPage = guess > 0 ? guess : 0;
	    }
	  }
	});

	var PaginationNavPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BPaginationNav: BPaginationNav
	  }
	});

	// Base on-demand component for tooltip / popover templates
	var NAME$n = 'BVPopper';
	var AttachmentMap$1 = {
	  AUTO: 'auto',
	  TOP: 'top',
	  RIGHT: 'right',
	  BOTTOM: 'bottom',
	  LEFT: 'left',
	  TOPLEFT: 'top',
	  TOPRIGHT: 'top',
	  RIGHTTOP: 'right',
	  RIGHTBOTTOM: 'right',
	  BOTTOMLEFT: 'bottom',
	  BOTTOMRIGHT: 'bottom',
	  LEFTTOP: 'left',
	  LEFTBOTTOM: 'left'
	};
	var OffsetMap = {
	  AUTO: 0,
	  TOPLEFT: -1,
	  TOP: 0,
	  TOPRIGHT: +1,
	  RIGHTTOP: -1,
	  RIGHT: 0,
	  RIGHTBOTTOM: +1,
	  BOTTOMLEFT: -1,
	  BOTTOM: 0,
	  BOTTOMRIGHT: +1,
	  LEFTTOP: -1,
	  LEFT: 0,
	  LEFTBOTTOM: +1
	}; // @vue/component

	var BVPopper =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$n,
	  props: {
	    target: {
	      // Element that the tooltip/popover is positioned relative to
	      type: [HTMLElement$1, SVGElement],
	      default: null
	    },
	    placement: {
	      type: String,
	      default: 'top'
	    },
	    fallbackPlacement: {
	      type: [String, Array],
	      default: 'flip'
	    },
	    offset: {
	      type: Number,
	      default: 0
	    },
	    boundary: {
	      // 'scrollParent', 'viewport', 'window', or Element
	      type: [String, HTMLElement$1],
	      default: 'scrollParent'
	    },
	    boundaryPadding: {
	      // Tooltip/popover will try and stay away from
	      // boundary edge by this many pixels
	      type: Number,
	      default: 5
	    },
	    arrowPadding: {
	      // The minimum distance (in `px`) from the edge of the
	      // tooltip/popover that the arrow can be positioned
	      type: Number,
	      default: 6
	    }
	  },
	  data: function data() {
	    return {
	      // reactive props set by parent
	      noFade: false,
	      // State related data
	      localShow: true,
	      attachment: this.getAttachment(this.placement)
	    };
	  },
	  computed: {
	    templateType: function templateType()
	    /* istanbul ignore next */
	    {
	      // Overridden by template component
	      return 'unknown';
	    },
	    popperConfig: function popperConfig() {
	      var _this = this;

	      var placement = this.placement;
	      return {
	        placement: this.getAttachment(placement),
	        modifiers: {
	          offset: {
	            offset: this.getOffset(placement)
	          },
	          flip: {
	            behavior: this.fallbackPlacement
	          },
	          // `arrow.element` can also be a reference to an HTML Element
	          // maybe we should make this a `$ref` in the templates?
	          arrow: {
	            element: '.arrow'
	          },
	          preventOverflow: {
	            padding: this.boundaryPadding,
	            boundariesElement: this.boundary
	          }
	        },
	        onCreate: function onCreate(data) {
	          // Handle flipping arrow classes
	          if (data.originalPlacement !== data.placement) {
	            /* istanbul ignore next: can't test in JSDOM */
	            _this.popperPlacementChange(data);
	          }
	        },
	        onUpdate: function onUpdate(data) {
	          // Handle flipping arrow classes
	          _this.popperPlacementChange(data);
	        }
	      };
	    }
	  },
	  created: function created() {
	    var _this2 = this;

	    // Note: We are created on-demand, and should be guaranteed that
	    // DOM is rendered/ready by the time the created hook runs
	    this.$_popper = null; // Ensure we show as we mount

	    this.localShow = true; // Create popper instance before shown

	    this.$on('show', function (el) {
	      _this2.popperCreate(el);
	    }); // Self destruct once hidden

	    this.$on('hidden', function () {
	      _this2.$nextTick(_this2.$destroy);
	    }); // If parent is destroyed, ensure we are destroyed

	    this.$parent.$once('hook:destroyed', this.$destroy);
	  },
	  beforeMount: function beforeMount() {
	    // Ensure that the attachment position is correct before mounting
	    // as our propsData is added after `new Template({...})`
	    this.attachment = this.getAttachment(this.placement);
	  },
	  mounted: function mounted() {// TBD
	  },
	  updated: function updated() {
	    // Update popper if needed
	    // TODO: Should this be a watcher on `this.popperConfig` instead?
	    this.popperUpdate();
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.popperDestroy();
	  },
	  destroyed: function destroyed() {
	    // Make sure template is removed from DOM
	    var el = this.$el;
	    el && el.parentNode && el.parentNode.removeChild(el);
	  },
	  methods: {
	    // "Public" method to trigger hide template
	    hide: function hide() {
	      this.localShow = false;
	    },
	    // Private
	    getAttachment: function getAttachment(placement) {
	      return AttachmentMap$1[String(placement).toUpperCase()] || 'auto';
	    },
	    getOffset: function getOffset(placement) {
	      if (!this.offset) {
	        // Could set a ref for the arrow element
	        var arrow = this.$refs.arrow || select('.arrow', this.$el);
	        var arrowOffset = (parseFloat(getCS(arrow).width) || 0) + (parseFloat(this.arrowPadding) || 0);

	        switch (OffsetMap[String(placement).toUpperCase()] || 0) {
	          case +1:
	            /* istanbul ignore next: can't test in JSDOM */
	            return "+50%p - ".concat(arrowOffset, "px");

	          case -1:
	            /* istanbul ignore next: can't test in JSDOM */
	            return "-50%p + ".concat(arrowOffset, "px");

	          default:
	            return 0;
	        }
	      }
	      /* istanbul ignore next */


	      return this.offset;
	    },
	    popperCreate: function popperCreate(el) {
	      this.popperDestroy(); // We use `el` rather than `this.$el` just in case the original
	      // mountpoint root element type was changed by the template

	      this.$_popper = new Popper(this.target, el, this.popperConfig);
	    },
	    popperDestroy: function popperDestroy() {
	      this.$_popper && this.$_popper.destroy();
	      this.$_popper = null;
	    },
	    popperUpdate: function popperUpdate() {
	      this.$_popper && this.$_popper.scheduleUpdate();
	    },
	    popperPlacementChange: function popperPlacementChange(data) {
	      // Callback used by popper to adjust the arrow placement
	      this.attachment = this.getAttachment(data.placement);
	    },
	    renderTemplate: function renderTemplate(h)
	    /* istanbul ignore next */
	    {
	      // Will be overridden by templates
	      return h('div');
	    }
	  },
	  render: function render(h) {
	    var _this3 = this;

	    // Note: `show` and 'fade' classes are only appled during transition
	    return h(BVTransition, {
	      // Transitions as soon as mounted
	      props: {
	        appear: true,
	        noFade: this.noFade
	      },
	      on: {
	        // Events used by parent component/instance
	        beforeEnter: function beforeEnter(el) {
	          return _this3.$emit('show', el);
	        },
	        afterEnter: function afterEnter(el) {
	          return _this3.$emit('shown', el);
	        },
	        beforeLeave: function beforeLeave(el) {
	          return _this3.$emit('hide', el);
	        },
	        afterLeave: function afterLeave(el) {
	          return _this3.$emit('hidden', el);
	        }
	      }
	    }, [this.localShow ? this.renderTemplate(h) : h()]);
	  }
	});

	function ownKeys$E(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$E(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$E(source, true).forEach(function (key) { _defineProperty$V(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$E(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$V(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$o = 'BVTooltipTemplate'; // @vue/component

	var BVTooltipTemplate =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$o,
	  extends: BVPopper,
	  mixins: [scopedStyleAttrsMixin],
	  props: {
	    // Other non-reactive (while open) props are pulled in from BVPopper
	    id: {
	      type: String,
	      default: null
	    },
	    html: {
	      // Used only by the directive versions
	      type: Boolean,
	      default: false
	    }
	  },
	  data: function data() {
	    // We use data, rather than props to ensure reactivity
	    // Parent component will directly set this data
	    return {
	      title: '',
	      content: '',
	      variant: null,
	      customClass: null
	    };
	  },
	  computed: {
	    templateType: function templateType() {
	      return 'tooltip';
	    },
	    templateClasses: function templateClasses() {
	      var _ref;

	      return [(_ref = {}, _defineProperty$V(_ref, "b-".concat(this.templateType, "-").concat(this.variant), this.variant), _defineProperty$V(_ref, "bs-".concat(this.templateType, "-").concat(this.attachment), this.attachment), _ref), this.customClass];
	    },
	    templateAttributes: function templateAttributes() {
	      return _objectSpread$E({
	        id: this.id,
	        role: 'tooltip',
	        tabindex: '-1'
	      }, this.scopedStyleAttrs);
	    },
	    templateListeners: function templateListeners() {
	      var _this = this;

	      // Used for hover/focus trigger listeners
	      return {
	        mouseenter: function mouseenter(evt) {
	          /* istanbul ignore next: difficult to test in JSDOM */
	          _this.$emit('mouseenter', evt);
	        },
	        mouseleave: function mouseleave(evt) {
	          /* istanbul ignore next: difficult to test in JSDOM */
	          _this.$emit('mouseleave', evt);
	        },
	        focusin: function focusin(evt) {
	          /* istanbul ignore next: difficult to test in JSDOM */
	          _this.$emit('focusin', evt);
	        },
	        focusout: function focusout(evt) {
	          /* istanbul ignore next: difficult to test in JSDOM */
	          _this.$emit('focusout', evt);
	        }
	      };
	    }
	  },
	  methods: {
	    renderTemplate: function renderTemplate(h) {
	      // Title can be a scoped slot function
	      var $title = isFunction(this.title) ? this.title({}) : isUndefinedOrNull(this.title) ? h() : this.title; // Directive versions only

	      var domProps = this.html && !isFunction(this.title) ? {
	        innerHTML: this.title
	      } : {};
	      return h('div', {
	        staticClass: 'tooltip b-tooltip',
	        class: this.templateClasses,
	        attrs: this.templateAttributes,
	        on: this.templateListeners
	      }, [h('div', {
	        ref: 'arrow',
	        staticClass: 'arrow'
	      }), h('div', {
	        staticClass: 'tooltip-inner',
	        domProps: domProps
	      }, [$title])]);
	    }
	  }
	});

	function ownKeys$F(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$F(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$F(source, true).forEach(function (key) { _defineProperty$W(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$F(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$W(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$p = 'BVTooltip'; // Modal container selector for appending tooltip/popover

	var MODAL_SELECTOR = '.modal-content'; // Modal `$root` hidden event

	var MODAL_CLOSE_EVENT = 'bv::modal::hidden'; // For dropdown sniffing

	var DROPDOWN_CLASS = 'dropdown';
	var DROPDOWN_OPEN_SELECTOR = '.dropdown-menu.show'; // Options for Native Event Listeners (since we never call preventDefault)

	var EvtOpts = {
	  passive: true,
	  capture: false
	}; // Data specific to popper and template
	// We don't use props, as we need reactivity (we can't pass reactive props)

	var templateData = {
	  // Text string or Scoped slot function
	  title: '',
	  // Text string or Scoped slot function
	  content: '',
	  // String
	  variant: null,
	  // String, Array, Object
	  customClass: null,
	  // String or array of Strings (overwritten by BVPopper)
	  triggers: '',
	  // String (overwritten by BVPopper)
	  placement: 'auto',
	  // String or array of strings
	  fallbackPlacement: 'flip',
	  // Element or Component reference (or function that returns element) of
	  // the element that will have the trigger events bound, and is also
	  // default element for positioning
	  target: null,
	  // HTML ID, Element or Component reference
	  container: null,
	  // 'body'
	  // Boolean
	  noFade: false,
	  // 'scrollParent', 'viewport', 'window', Element, or Component reference
	  boundary: 'scrollParent',
	  // Tooltip/popover will try and stay away from
	  // boundary edge by this many pixels (Number)
	  boundaryPadding: 5,
	  // Arrow offset (Number)
	  offset: 0,
	  // Hover/focus delay (Number or Object)
	  delay: 0,
	  // Arrow of Tooltip/popover will try and stay away from
	  // the edge of tooltip/popover edge by this many pixels
	  arrowPadding: 6,
	  // Disabled state (Boolean)
	  disabled: false,
	  // ID to use for tooltip/popover
	  id: null,
	  // Flag used by directives only, for HTML content
	  html: false
	}; // @vue/component

	var BVTooltip =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$p,
	  props: {// None
	  },
	  data: function data() {
	    return _objectSpread$F({}, templateData, {
	      // State management data
	      activeTrigger: {
	        // manual: false,
	        hover: false,
	        click: false,
	        focus: false
	      },
	      localShow: false
	    });
	  },
	  computed: {
	    templateType: function templateType() {
	      // Overwritten by BVPopover
	      return 'tooltip';
	    },
	    computedId: function computedId() {
	      return this.id || "__bv_".concat(this.templateType, "_").concat(this._uid, "__");
	    },
	    computedDelay: function computedDelay() {
	      // Normalizes delay into object form
	      var delay = {
	        show: 0,
	        hide: 0
	      };

	      if (isPlainObject(this.delay)) {
	        delay.show = Math.max(parseInt(this.delay.show, 10) || 0, 0);
	        delay.hide = Math.max(parseInt(this.delay.hide, 10) || 0, 0);
	      } else if (isNumber(this.delay) || isString(this.delay)) {
	        delay.show = delay.hide = Math.max(parseInt(this.delay, 10) || 0, 0);
	      }

	      return delay;
	    },
	    computedTriggers: function computedTriggers() {
	      // Returns the triggers in sorted array form
	      // TODO: Switch this to object form for easier lookup
	      return concat(this.triggers).filter(Boolean).join(' ').trim().toLowerCase().split(/\s+/).sort();
	    },
	    isWithActiveTrigger: function isWithActiveTrigger() {
	      for (var trigger in this.activeTrigger) {
	        if (this.activeTrigger[trigger]) {
	          return true;
	        }
	      }

	      return false;
	    },
	    computedTemplateData: function computedTemplateData() {
	      return {
	        title: this.title,
	        content: this.content,
	        variant: this.variant,
	        customClass: this.customClass,
	        noFade: this.noFade
	      };
	    }
	  },
	  watch: {
	    computedTriggers: function computedTriggers(newTriggers, oldTriggers) {
	      var _this = this;

	      // Triggers have changed, so re-register them

	      /* istanbul ignore next */
	      if (!looseEqual(newTriggers, oldTriggers)) {
	        this.$nextTick(function () {
	          // Disable trigger listeners
	          _this.unListen(); // Clear any active triggers that are no longer in the list of triggers


	          oldTriggers.forEach(function (trigger) {
	            if (!arrayIncludes(newTriggers, trigger)) {
	              if (_this.activeTrigger[trigger]) {
	                _this.activeTrigger[trigger] = false;
	              }
	            }
	          }); // Re-enable the trigger listeners

	          _this.listen();
	        });
	      }
	    },
	    computedTemplateData: function computedTemplateData() {
	      // If any of the while open reactive "props" change,
	      // ensure that the template updates accordingly
	      this.handleTemplateUpdate();
	    },
	    disabled: function disabled(newVal) {
	      newVal ? this.disable() : this.enable();
	    }
	  },
	  created: function created() {
	    var _this2 = this;

	    // Create non-reactive properties
	    this.$_tip = null;
	    this.$_hoverTimeout = null;
	    this.$_hoverState = '';
	    this.$_visibleInterval = null;
	    this.$_enabled = !this.disabled;

	    this.$_noop = function () {}; // Destroy ourselves when the parent is destroyed


	    if (this.$parent) {
	      this.$parent.$once('hook:beforeDestroy', this.$destroy);
	    }

	    this.$nextTick(function () {
	      var target = _this2.getTarget();

	      if (target && contains(document.body, target)) {
	        // Copy the parent's scoped style attribute
	        _this2.scopeId = getScopeId(_this2.$parent); // Set up all trigger handlers and listeners

	        _this2.listen();
	      } else {
	        /* istanbul ignore next */
	        warn("".concat(_this2.templateType, " unable to find target element in document"));
	      }
	    });
	  },
	  updated: function updated()
	  /* istanbul ignore next */
	  {
	    // Usually called when the slots/data changes
	    this.$nextTick(this.handleTemplateUpdate);
	  },
	  deactivated: function deactivated()
	  /* istanbul ignore next */
	  {
	    // In a keepalive that has been deactivated, so hide
	    // the tooltip/popover if it is showing
	    this.forceHide();
	  },
	  beforeDestroy: function beforeDestroy()
	  /* istanbul ignore next */
	  {
	    // Remove all handler/listeners
	    this.unListen();
	    this.setWhileOpenListeners(false); // Clear any timeouts/Timers

	    clearTimeout(this.$_hoverTimeout);
	    this.$_hoverTimeout = null;
	    this.destroyTemplate();
	    this.restoreTitle();
	  },
	  methods: {
	    //
	    // Methods for creating and destroying the template
	    //
	    getTemplate: function getTemplate() {
	      // Overridden by BVPopover
	      return BVTooltipTemplate;
	    },
	    updateData: function updateData() {
	      var _this3 = this;

	      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      // Method for updating popper/template data
	      // We only update data if it exists, and has not changed
	      var titleUpdated = false;
	      keys$2(templateData).forEach(function (prop) {
	        if (!isUndefined(data[prop]) && _this3[prop] !== data[prop]) {
	          _this3[prop] = data[prop];

	          if (prop === 'title') {
	            titleUpdated = true;
	          }
	        }
	      });

	      if (titleUpdated && this.localShow) {
	        // If the title has updated, we may need to handle the title
	        // attribute on the trigger target. We only do this while the
	        // template is open
	        this.fixTitle();
	      }
	    },
	    createTemplateAndShow: function createTemplateAndShow() {
	      // Creates the template instance and show it
	      // this.destroyTemplate()
	      var container = this.getContainer();
	      var Template = this.getTemplate();
	      var $tip = this.$_tip = new Template({
	        parent: this,
	        // The following is not reactive to changes in the props data
	        propsData: {
	          // These values cannot be changed while template is showing
	          id: this.computedId,
	          html: this.html,
	          placement: this.placement,
	          fallbackPlacement: this.fallbackPlacement,
	          target: this.getPlacementTarget(),
	          boundary: this.getBoundary(),
	          // Ensure the following are integers
	          offset: parseInt(this.offset, 10) || 0,
	          arrowPadding: parseInt(this.arrowPadding, 10) || 0,
	          boundaryPadding: parseInt(this.boundaryPadding, 10) || 0
	        }
	      }); // We set the initial reactive data (values that can be changed while open)

	      this.handleTemplateUpdate(); // Template transition phase events (handled once only)
	      // When the template has mounted, but not visibly shown yet

	      $tip.$once('show', this.onTemplateShow); // When the template has completed showing

	      $tip.$once('shown', this.onTemplateShown); // When the template has started to hide

	      $tip.$once('hide', this.onTemplateHide); // When the template has completed hiding

	      $tip.$once('hidden', this.onTemplateHidden); // When the template gets destroyed for any reason

	      $tip.$once('hook:destroyed', this.destroyTemplate); // Convenience events from template
	      // To save us from manually adding/removing DOM
	      // listeners to tip element when it is open

	      $tip.$on('focusin', this.handleEvent);
	      $tip.$on('focusout', this.handleEvent);
	      $tip.$on('mouseenter', this.handleEvent);
	      $tip.$on('mouseleave', this.handleEvent); // Mount (which triggers the `show`)

	      $tip.$mount(container.appendChild(document.createElement('div'))); // Template will automatically remove its markup from DOM when hidden
	    },
	    hideTemplate: function hideTemplate() {
	      // Trigger the template to start hiding
	      // The template will emit the `hide` event after this and
	      // then emit the `hidden` event once it is fully hidden
	      // The `hook:destroyed` will also be called (safety measure)
	      this.$_tip && this.$_tip.hide();
	    },
	    destroyTemplate: function destroyTemplate() {
	      // Destroy the template instance and reset state
	      this.setWhileOpenListeners(false);
	      clearTimeout(this.$_hoverTimeout);
	      this.$_hoverTimout = null;
	      this.$_hoverState = '';
	      this.clearActiveTriggers();
	      this.localPlacementTarget = null;

	      try {
	        this.$_tip && this.$_tip.$destroy();
	      } catch (_unused) {}

	      this.$_tip = null;
	      this.localShow = false;
	    },
	    getTemplateElement: function getTemplateElement() {
	      return this.$_tip ? this.$_tip.$el : null;
	    },
	    handleTemplateUpdate: function handleTemplateUpdate() {
	      var _this4 = this;

	      // Update our template title/content "props"
	      // So that the template updates accordingly
	      var $tip = this.$_tip;

	      if ($tip) {
	        var props = ['title', 'content', 'variant', 'customClass', 'noFade']; // Only update the values if they have changed

	        props.forEach(function (prop) {
	          if ($tip[prop] !== _this4[prop]) {
	            $tip[prop] = _this4[prop];
	          }
	        });
	      }
	    },
	    //
	    // Show and Hide handlers
	    //
	    show: function show() {
	      // Show the tooltip
	      var target = this.getTarget();

	      if (!target || !contains(document.body, target) || !isVisible(target) || this.dropdownOpen() || (isUndefinedOrNull(this.title) || this.title === '') && (isUndefinedOrNull(this.content) || this.content === '')) {
	        // If trigger element isn't in the DOM or is not visible, or
	        // is on an open dropdown toggle, or has no content, then
	        // we exit without showing
	        return;
	      }

	      if (this.$_tip || this.localShow) {
	        // If tip already exists, exit early

	        /* istanbul ignore next */
	        return;
	      } // In the process of showing


	      this.localShow = true; // Create a cancelable BvEvent

	      var showEvt = this.buildEvent('show', {
	        cancelable: true
	      });
	      this.emitEvent(showEvt);
	      /* istanbul ignore next: ignore for now */

	      if (showEvt.defaultPrevented) {
	        // Don't show if event cancelled
	        // Destroy the template (if for some reason it was created)

	        /* istanbul ignore next */
	        this.destroyTemplate(); // Clear the localShow flag

	        /* istanbul ignore next */

	        this.localShow = false;
	        /* istanbul ignore next */

	        return;
	      } // Fix the title attribute on target


	      this.fixTitle(); // Set aria-describedby on target

	      this.addAriaDescribedby(); // Create and show the tooltip

	      this.createTemplateAndShow();
	    },
	    hide: function hide() {
	      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      // Hide the tooltip
	      var tip = this.getTemplateElement();

	      if (!tip || !this.localShow) {
	        /* istanbul ignore next */
	        this.restoreTitle();
	        /* istanbul ignore next */

	        return;
	      } // Emit cancelable BvEvent 'hide'
	      // We disable cancelling if `force` is true


	      var hideEvt = this.buildEvent('hide', {
	        cancelable: !force
	      });
	      this.emitEvent(hideEvt);
	      /* istanbul ignore next: ignore for now */

	      if (hideEvt.defaultPrevented) {
	        // Don't hide if event cancelled

	        /* istanbul ignore next */
	        return;
	      } // Tell the template to hide


	      this.hideTemplate(); // TODO: The following could be added to `hideTemplate()`
	      // Clear out any stragging active triggers

	      this.clearActiveTriggers(); // Reset the hover state

	      this.$_hoverState = '';
	    },
	    forceHide: function forceHide() {
	      // Forcefully hides/destroys the template, regardless of any active triggers
	      var tip = this.getTemplateElement();

	      if (!tip || !this.localShow) {
	        /* istanbul ignore next */
	        return;
	      } // Disable while open listeners/watchers
	      // This is also done in the template `hide` evt handler


	      this.setWhileOpenListeners(false); // Clear any hover enter/leave event

	      clearTimeout(this.hoverTimeout);
	      this.$_hoverTimeout = null;
	      this.$_hoverState = '';
	      this.clearActiveTriggers(); // Disable the fade animation on the template

	      if (this.$_tip) {
	        this.$_tip.noFade = true;
	      } // Hide the tip (with force = true)


	      this.hide(true);
	    },
	    enable: function enable() {
	      this.$_enabled = true; // Create a non-cancelable BvEvent

	      this.emitEvent(this.buildEvent('enabled', {}));
	    },
	    disable: function disable() {
	      this.$_enabled = false; // Create a non-cancelable BvEvent

	      this.emitEvent(this.buildEvent('disabled', {}));
	    },
	    //
	    // Handlers for template events
	    //
	    onTemplateShow: function onTemplateShow() {
	      // When template is inserted into DOM, but not yet shown
	      // Enable while open listeners/watchers
	      this.setWhileOpenListeners(true);
	    },
	    onTemplateShown: function onTemplateShown() {
	      // When template show transition completes
	      var prevHoverState = this.$_hoverState;
	      this.$_hoverState = '';

	      if (prevHoverState === 'out') {
	        this.leave(null);
	      } // Emit a non-cancelable BvEvent 'shown'


	      this.emitEvent(this.buildEvent('shown', {}));
	    },
	    onTemplateHide: function onTemplateHide() {
	      // When template is starting to hide
	      // Disable while open listeners/watchers
	      this.setWhileOpenListeners(false);
	    },
	    onTemplateHidden: function onTemplateHidden() {
	      // When template has completed closing (just before it self destructs)
	      // TODO:
	      //   The next two lines could be moved into `destroyTemplate()`
	      this.removeAriaDescribedby();
	      this.restoreTitle();
	      this.destroyTemplate(); // Emit a non-cancelable BvEvent 'shown'

	      this.emitEvent(this.buildEvent('hidden', {}));
	    },
	    //
	    // Utility methods
	    //
	    getTarget: function getTarget() {
	      // Handle case where target may be a component ref
	      var target = this.target ? this.target.$el || this.target : null; // If an ID

	      target = isString(target) ? getById(target.replace(/^#/, '')) : target; // If a function

	      target = isFunction(target) ? target() : target; // If an element ref

	      return isElement(target) ? target : null;
	    },
	    getPlacementTarget: function getPlacementTarget() {
	      // This is the target that the tooltip will be placed on, which may not
	      // necessarily be the same element that has the trigger event listeners
	      // For now, this is the same as target
	      // TODO:
	      //   Add in child selector support
	      //   Add in visibility checks for this element
	      //   Fallback to target if not found
	      return this.getTarget();
	    },
	    getTargetId: function getTargetId() {
	      // Returns the ID of the trigger element
	      var target = this.getTarget();
	      return target && target.id ? target.id : null;
	    },
	    getContainer: function getContainer() {
	      // Handle case where container may be a component ref
	      var container = this.container ? this.container.$el || this.container : false;
	      var body = document.body;
	      var target = this.getTarget(); // If we are in a modal, we append to the modal instead
	      // of body, unless a container is specified
	      // TODO:
	      //   Template should periodically check to see if it is in dom
	      //   And if not, self destruct (if container got v-if'ed out of DOM)
	      //   Or this could possibly be part of the visibility check

	      return container === false ? closest(MODAL_SELECTOR, target) || body : isString(container) ? getById(container.replace(/^#/, '')) || body : body;
	    },
	    getBoundary: function getBoundary() {
	      return this.boundary ? this.boundary.$el || this.boundary : 'scrollParent';
	    },
	    isInModal: function isInModal() {
	      var target = this.getTarget();
	      return target && closest(MODAL_SELECTOR, target);
	    },
	    isDropdown: function isDropdown() {
	      // Returns true if trigger is a dropdown
	      var target = this.getTarget();
	      return target && hasClass(target, DROPDOWN_CLASS);
	    },
	    dropdownOpen: function dropdownOpen() {
	      // Returns true if trigger is a dropdown and the dropdown menu is open
	      var target = this.getTarget();
	      return this.isDropdown() && target && select(DROPDOWN_OPEN_SELECTOR, target);
	    },
	    clearActiveTriggers: function clearActiveTriggers() {
	      for (var trigger in this.activeTrigger) {
	        this.activeTrigger[trigger] = false;
	      }
	    },
	    addAriaDescribedby: function addAriaDescribedby() {
	      // Add aria-describedby on trigger element, without removing any other IDs
	      var target = this.getTarget();
	      var desc = getAttr(target, 'aria-describedby') || '';
	      desc = desc.split(/\s+/).concat(this.computedId).join(' ').trim(); // Update/add aria-described by

	      setAttr(target, 'aria-describedby', desc);
	    },
	    removeAriaDescribedby: function removeAriaDescribedby() {
	      var _this5 = this;

	      // Remove aria-describedby on trigger element, without removing any other IDs
	      var target = this.getTarget();
	      var desc = getAttr(target, 'aria-describedby') || '';
	      desc = desc.split(/\s+/).filter(function (d) {
	        return d !== _this5.computedId;
	      }).join(' ').trim(); // Update or remove aria-describedby

	      if (desc) {
	        /* istanbul ignore next */
	        setAttr(target, 'aria-describedby', desc);
	      } else {
	        removeAttr(target, 'aria-describedby');
	      }
	    },
	    fixTitle: function fixTitle() {
	      // If the target has a title attribute, null it out and
	      // store on data-title
	      var target = this.getTarget();

	      if (target && getAttr(target, 'title')) {
	        // We only update title attribute if it has a value
	        setAttr(target, 'data-original-title', getAttr(target, 'title') || '');
	        setAttr(target, 'title', '');
	      }
	    },
	    restoreTitle: function restoreTitle() {
	      // If target had a title, restore the title attribute
	      // and remove the data-title attribute
	      var target = this.getTarget();

	      if (target && hasAttr(target, 'data-original-title')) {
	        setAttr(target, 'title', getAttr(target, 'data-original-title') || '');
	        removeAttr(target, 'data-original-title');
	      }
	    },
	    //
	    // BvEvent helpers
	    //
	    buildEvent: function buildEvent(type) {
	      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      // Defaults to a non-cancellable event
	      return new BvEvent(type, _objectSpread$F({
	        cancelable: false,
	        target: this.getTarget(),
	        relatedTarget: this.getTemplateElement() || null,
	        componentId: this.computedId,
	        vueTarget: this
	      }, opts));
	    },
	    emitEvent: function emitEvent(bvEvt) {
	      // Emits a BvEvent on $root and this instance
	      var evtName = bvEvt.type;
	      var $root = this.$root;

	      if ($root && $root.$emit) {
	        // Emit an event on $root
	        $root.$emit("bv::".concat(this.templateType, "::").concat(evtName), bvEvt);
	      }

	      this.$emit(evtName, bvEvt);
	    },
	    //
	    // Event handler setup methods
	    //
	    listen: function listen() {
	      var _this6 = this;

	      // Enable trigger event handlers
	      var el = this.getTarget();

	      if (!el) {
	        /* istanbul ignore next */
	        return;
	      } // Listen for global show/hide events


	      this.setRootListener(true); // Set up our listeners on the target trigger element

	      this.computedTriggers.forEach(function (trigger) {
	        if (trigger === 'click') {
	          eventOn(el, 'click', _this6.handleEvent, EvtOpts);
	        } else if (trigger === 'focus') {
	          eventOn(el, 'focusin', _this6.handleEvent, EvtOpts);
	          eventOn(el, 'focusout', _this6.handleEvent, EvtOpts);
	        } else if (trigger === 'blur') {
	          // Used to close $tip when element looses focus

	          /* istanbul ignore next */
	          eventOn(el, 'focusout', _this6.handleEvent, EvtOpts);
	        } else if (trigger === 'hover') {
	          eventOn(el, 'mouseenter', _this6.handleEvent, EvtOpts);
	          eventOn(el, 'mouseleave', _this6.handleEvent, EvtOpts);
	        }
	      }, this);
	    },
	    unListen: function unListen()
	    /* istanbul ignore next */
	    {
	      var _this7 = this;

	      // Remove trigger event handlers
	      var events = ['click', 'focusin', 'focusout', 'mouseenter', 'mouseleave'];
	      var target = this.getTarget(); // Stop listening for global show/hide/enable/disable events

	      this.setRootListener(false); // Clear out any active target listeners

	      events.forEach(function (evt) {
	        target && eventOff(target, evt, _this7.handleEvent, EvtOpts);
	      }, this);
	    },
	    setRootListener: function setRootListener(on) {
	      // Listen for global `bv::{hide|show}::{tooltip|popover}` hide request event
	      var $root = this.$root;

	      if ($root) {
	        var method = on ? '$on' : '$off';
	        var type = this.templateType;
	        $root[method]("bv::hide::".concat(type), this.doHide);
	        $root[method]("bv::show::".concat(type), this.doShow);
	        $root[method]("bv::disable::".concat(type), this.doDisable);
	        $root[method]("bv::enable::".concat(type), this.doEnable);
	      }
	    },
	    setWhileOpenListeners: function setWhileOpenListeners(on) {
	      // Events that are only registered when the template is showing
	      // Modal close events
	      this.setModalListener(on); // Dropdown open events (if we are attached to a dropdown)

	      this.setDropdownListener(on); // Periodic $element visibility check
	      // For handling when tip target is in <keepalive>, tabs, carousel, etc

	      this.visibleCheck(on); // On-touch start listeners

	      this.setOnTouchStartListener(on);
	    },
	    visibleCheck: function visibleCheck(on) {
	      var _this8 = this;

	      // Handler for periodic visibility check
	      clearInterval(this.$_visibleInterval);
	      this.$_visibleInterval = null;
	      var target = this.getTarget();
	      var tip = this.getTemplateElement();

	      if (on) {
	        this.visibleInterval = setInterval(function () {
	          if (tip && _this8.localShow && (!target.parentNode || !isVisible(target))) {
	            // Target element is no longer visible or not in DOM, so force-hide the tooltip
	            _this8.forceHide();
	          }
	        }, 100);
	      }
	    },
	    setModalListener: function setModalListener(on) {
	      // Handle case where tooltip/target is in a modal
	      if (this.isInModal()) {
	        // We can listen for modal hidden events on `$root`
	        this.$root[on ? '$on' : '$off'](MODAL_CLOSE_EVENT, this.forceHide);
	      }
	    },
	    setOnTouchStartListener: function setOnTouchStartListener(on)
	    /* istanbul ignore next: JSDOM doesn't support `ontouchstart` */
	    {
	      var _this9 = this;

	      // If this is a touch-enabled device we add extra empty
	      // `mouseover` listeners to the body's immediate children
	      // Only needed because of broken event delegation on iOS
	      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
	      if ('ontouchstart' in document.documentElement) {
	        var method = on ? eventOn : eventOff;
	        from(document.body.children).forEach(function (el) {
	          method(el, 'mouseover', _this9.$_noop);
	        });
	      }
	    },
	    setDropdownListener: function setDropdownListener(on) {
	      var target = this.getTarget();

	      if (!target || !this.$root || !this.isDropdown) {
	        return;
	      } // We can listen for dropdown shown events on it's instance
	      // TODO:
	      //   We could grab the ID from the dropdown, and listen for
	      //   $root events for that particular dropdown id
	      //   Dropdown shown and hidden events will need to emit
	      //   Note: Dropdown auto-ID happens in a `$nextTick()` after mount
	      //         So the ID lookup would need to be done in a `$nextTick()`


	      if (target.__vue__) {
	        target.__vue__[on ? '$on' : '$off']('shown', this.forceHide);
	      }
	    },
	    //
	    // Event handlers
	    //
	    handleEvent: function handleEvent(evt) {
	      // General trigger event handler
	      // target is the trigger element
	      var target = this.getTarget();

	      if (!target || isDisabled(target) || !this.$_enabled || this.dropdownOpen()) {
	        // If disabled or not enabled, or if a dropdown that is open, don't do anything
	        // If tip is shown before element gets disabled, then tip will not
	        // close until no longer disabled or forcefully closed
	        return;
	      }

	      var type = evt.type;
	      var triggers = this.computedTriggers;

	      if (type === 'click' && arrayIncludes(triggers, 'click')) {
	        this.click(evt);
	      } else if (type === 'mouseenter' && arrayIncludes(triggers, 'hover')) {
	        // `mouseenter` is a non-bubbling event
	        this.enter(evt);
	      } else if (type === 'focusin' && arrayIncludes(triggers, 'focus')) {
	        // `focusin` is a bubbling event
	        // `evt` includes `relatedTarget` (element loosing focus)
	        this.enter(evt);
	      } else if (type === 'focusout' && (arrayIncludes(triggers, 'focus') || arrayIncludes(triggers, 'blur')) || type === 'mouseleave' && arrayIncludes(triggers, 'hover')) {
	        // `focusout` is a bubbling event
	        // `mouseleave` is a non-bubbling event
	        // `tip` is the template (will be null if not open)
	        var tip = this.getTemplateElement(); // `evtTarget` is the element which is loosing focus/hover and

	        var evtTarget = evt.target; // `relatedTarget` is the element gaining focus/hover

	        var relatedTarget = evt.relatedTarget;
	        /* istanbul ignore next */

	        if ( // From tip to target
	        tip && contains(tip, evtTarget) && contains(target, relatedTarget) || // From target to tip
	        tip && contains(target, evtTarget) && contains(tip, relatedTarget) || // Within tip
	        tip && contains(tip, evtTarget) && contains(tip, relatedTarget) || // Within target
	        contains(target, evtTarget) && contains(target, relatedTarget)) {
	          // If focus/hover moves within `tip` and `target`, don't trigger a leave
	          return;
	        } // Otherwise trigger a leave


	        this.leave(evt);
	      }
	    },
	    doHide: function doHide(id) {
	      // Programmatically hide tooltip or popover
	      if (!id || this.getTargetId() === id || this.computedId === id) {
	        // Close all tooltips or popovers, or this specific tip (with ID)
	        this.forceHide();
	      }
	    },
	    doShow: function doShow(id) {
	      // Programmatically show tooltip or popover
	      if (!id || this.getTargetId() === id || this.computedId === id) {
	        // Open all tooltips or popovers, or this specific tip (with ID)
	        this.show();
	      }
	    },
	    doDisable: function doDisable(id)
	    /*istanbul ignore next: ignore for now */
	    {
	      // Programmatically disable tooltip or popover
	      if (!id || this.getTargetId() === id || this.computedId === id) {
	        // Disable all tooltips or popovers (no ID), or this specific tip (with ID)
	        this.disable();
	      }
	    },
	    doEnable: function doEnable(id)
	    /*istanbul ignore next: ignore for now */
	    {
	      // Programmatically enable tooltip or popover
	      if (!id || this.getTargetId() === id || this.computedId === id) {
	        // Enable all tooltips or popovers (no ID), or this specific tip (with ID)
	        this.enable();
	      }
	    },
	    click: function click(evt) {
	      if (!this.$_enabled || this.dropdownOpen()) {
	        /* istanbul ignore next */
	        return;
	      }

	      this.activeTrigger.click = !this.activeTrigger.click;

	      if (this.isWithActiveTrigger) {
	        this.enter(null);
	      } else {
	        /* istanbul ignore next */
	        this.leave(null);
	      }
	    },
	    toggle: function toggle()
	    /* istanbul ignore next */
	    {
	      // Manual toggle handler
	      if (!this.$_enabled || this.dropdownOpen()) {
	        /* istanbul ignore next */
	        return;
	      } // Should we register as an active trigger?
	      // this.activeTrigger.manual = !this.activeTrigger.manual


	      if (this.localShow) {
	        this.leave(null);
	      } else {
	        this.enter(null);
	      }
	    },
	    enter: function enter() {
	      var _this10 = this;

	      var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	      // Opening trigger handler
	      // Note: Click events are sent with evt === null
	      if (evt) {
	        this.activeTrigger[evt.type === 'focusin' ? 'focus' : 'hover'] = true;
	      }
	      /* istanbul ignore next */


	      if (this.localShow || this.$_hoverState === 'in') {
	        this.$_hoverState = 'in';
	        return;
	      }

	      clearTimeout(this.hoverTimeout);
	      this.$_hoverState = 'in';

	      if (!this.computedDelay.show) {
	        this.show();
	      } else {
	        // Hide any title attribute while enter delay is active
	        this.fixTitle();
	        this.hoverTimeout = setTimeout(function () {
	          /* istanbul ignore else */
	          if (_this10.$_hoverState === 'in') {
	            _this10.show();
	          } else if (!_this10.localShow) {
	            _this10.restoreTitle();
	          }
	        }, this.computedDelay.show);
	      }
	    },
	    leave: function leave() {
	      var _this11 = this;

	      var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	      // Closing trigger handler
	      // Note: Click events are sent with evt === null
	      if (evt) {
	        this.activeTrigger[evt.type === 'focusout' ? 'focus' : 'hover'] = false;
	        /* istanbul ignore next */

	        if (evt.type === 'focusout' && arrayIncludes(this.computedTriggers, 'blur')) {
	          // Special case for `blur`: we clear out the other triggers
	          this.activeTrigger.click = false;
	          this.activeTrigger.hover = false;
	        }
	      }
	      /* istanbul ignore next: ignore for now */


	      if (this.isWithActiveTrigger) {
	        return;
	      }

	      clearTimeout(this.hoverTimeout);
	      this.$_hoverState = 'out';

	      if (!this.computedDelay.hide) {
	        this.hide();
	      } else {
	        this.$hoverTimeout = setTimeout(function () {
	          if (_this11.$_hoverState === 'out') {
	            _this11.hide();
	          }
	        }, this.computedDelay.hide);
	      }
	    }
	  }
	});

	var NAME$q = 'BTooltip'; // @vue/component

	var BTooltip =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$q,
	  props: {
	    title: {
	      type: String // default: undefined

	    },
	    // Added in by BPopover
	    // content: {
	    //   type: String,
	    //   default: undefined
	    // },
	    target: {
	      // String ID of element, or element/component reference
	      // Or function that returns one of the above
	      type: [String, HTMLElement$1, SVGElement, Function, Object],
	      // default: undefined,
	      required: true
	    },
	    triggers: {
	      type: [String, Array],
	      default: 'hover focus'
	    },
	    placement: {
	      type: String,
	      default: 'top'
	    },
	    fallbackPlacement: {
	      type: [String, Array],
	      default: 'flip',
	      validator: function validator(value) {
	        return isArray(value) && value.every(function (v) {
	          return isString(v);
	        }) || arrayIncludes(['flip', 'clockwise', 'counterclockwise'], value);
	      }
	    },
	    variant: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$q, 'variant');
	      }
	    },
	    customClass: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$q, 'customClass');
	      }
	    },
	    delay: {
	      type: [Number, Object, String],
	      default: function _default() {
	        return getComponentConfig(NAME$q, 'delay');
	      }
	    },
	    boundary: {
	      // String: scrollParent, window, or viewport
	      // Element: element reference
	      // Object: Vue component
	      type: [String, HTMLElement$1, Object],
	      default: function _default() {
	        return getComponentConfig(NAME$q, 'boundary');
	      }
	    },
	    boundaryPadding: {
	      type: [Number, String],
	      default: function _default() {
	        return getComponentConfig(NAME$q, 'boundaryPadding');
	      }
	    },
	    offset: {
	      type: [Number, String],
	      default: 0
	    },
	    noFade: {
	      type: Boolean,
	      default: false
	    },
	    container: {
	      // String: HTML ID of container, if null body is used (default)
	      // HTMLElement: element reference reference
	      // Object: Vue Component
	      type: [String, HTMLElement$1, Object] // default: undefined

	    },
	    show: {
	      type: Boolean,
	      default: false
	    },
	    disabled: {
	      type: Boolean,
	      default: false
	    },
	    id: {
	      // ID to use for tooltip element
	      // If not provided on will automatically be generated
	      type: String,
	      default: null
	    }
	  },
	  data: function data() {
	    return {
	      localShow: this.show,
	      localTitle: '',
	      localContent: ''
	    };
	  },
	  computed: {
	    templateData: function templateData() {
	      // Data that will be passed to the template and popper
	      return {
	        // We use massaged versions of the title and content props/slots
	        title: this.localTitle,
	        content: this.localContent,
	        // Pass these props as is
	        target: this.target,
	        triggers: this.triggers,
	        placement: this.placement,
	        fallbackPlacement: this.fallbackPlacement,
	        variant: this.variant,
	        customClass: this.customClass,
	        container: this.container,
	        boundary: this.boundary,
	        boundaryPadding: this.boundaryPadding,
	        delay: this.delay,
	        offset: this.offset,
	        noFade: this.noFade,
	        disabled: this.disabled,
	        id: this.id
	      };
	    },
	    templateTitleContent: function templateTitleContent() {
	      // Used to watch for changes to the title and content props
	      return {
	        title: this.title,
	        content: this.content
	      };
	    }
	  },
	  watch: {
	    show: function show(_show, oldVal) {
	      if (_show !== oldVal && _show !== this.localShow && this.$_bv_toolpop) {
	        if (_show) {
	          this.$_bv_toolpop.show();
	        } else {
	          // We use `forceHide()` to override any active triggers
	          this.$_bv_toolpop.forceHide();
	        }
	      }
	    },
	    disabled: function disabled(newVal, oldVal) {
	      if (newVal) {
	        this.doDisable();
	      } else {
	        this.doEnable();
	      }
	    },
	    localShow: function localShow(show, oldVal) {
	      // TODO: May need to be done in a `$nextTick()`
	      this.$emit('update:show', show);
	    },
	    templateData: function templateData(newVal, oldVal) {
	      var _this = this;

	      this.$nextTick(function () {
	        if (_this.$_bv_toolpop) {
	          _this.$_bv_toolpop.updateData(_this.templateData);
	        }
	      });
	    },
	    // Watchers for title/content props (prop changes do not trigger the `updated()` hook)
	    templateTitleContent: function templateTitleContent(newVal, oldVal) {
	      this.$nextTick(this.updateContent);
	    }
	  },
	  created: function created() {
	    // Non reactive properties
	    this.$_bv_toolpop = null;
	  },
	  updated: function updated() {
	    // Update the `propData` object
	    // Done in a `$nextTick()` to ensure slot(s) have updated
	    this.$nextTick(this.updateContent);
	  },
	  beforeDestroy: function beforeDestroy() {
	    // Shutdown our local event listeners
	    this.$off('open', this.doOpen);
	    this.$off('close', this.doClose);
	    this.$off('disable', this.doDisable);
	    this.$off('enable', this.doEnable); // Destroy the tip instance

	    this.$_bv_toolpop && this.$_bv_toolpop.$destroy();
	    this.$_bv_toolpop = null;
	  },
	  mounted: function mounted() {
	    var _this2 = this;

	    // Instantiate a new BVTooltip instance
	    // Done in a `$nextTick()` to ensure DOM has completed rendering
	    // so that target can be found
	    this.$nextTick(function () {
	      // Load the on demand child instance
	      var Component = _this2.getComponent(); // Ensure we have initial content


	      _this2.updateContent(); // Pass down the scoped style attribute if available


	      var scopeId = getScopeId(_this2) || getScopeId(_this2.$parent); // Create the instance

	      var $toolpop = _this2.$_bv_toolpop = new Component({
	        parent: _this2,
	        // Pass down the scoped style ID
	        _scopeId: scopeId || undefined
	      }); // Set the initial data

	      $toolpop.updateData(_this2.templateData); // Set listeners

	      $toolpop.$on('show', _this2.onShow);
	      $toolpop.$on('shown', _this2.onShown);
	      $toolpop.$on('hide', _this2.onHide);
	      $toolpop.$on('hidden', _this2.onHidden);
	      $toolpop.$on('disabled', _this2.onDisabled);
	      $toolpop.$on('enabled', _this2.onEnabled); // Initially disabled?

	      if (_this2.disabled) {
	        // Initially disabled
	        _this2.doDisable();
	      } // Listen to open signals from others


	      _this2.$on('open', _this2.doOpen); // Listen to close signals from others


	      _this2.$on('close', _this2.doClose); // Listen to disable signals from others


	      _this2.$on('disable', _this2.doDisable); // Listen to enable signals from others


	      _this2.$on('enable', _this2.doEnable); // Initially show tooltip?


	      if (_this2.localShow) {
	        _this2.$_bv_toolpop && _this2.$_bv_toolpop.show();
	      }
	    });
	  },
	  methods: {
	    getComponent: function getComponent() {
	      // Overridden by BPopover
	      return BVTooltip;
	    },
	    updateContent: function updateContent() {
	      // Overridden by BPopover
	      // Tooltip: Default slot is `title`
	      // Popover: Default slot is `content`, `title` slot is title
	      // We pass a scoped slot function reference by default (Vue v2.6x)
	      // And pass the title prop as a fallback
	      this.setTitle(this.$scopedSlots.default || this.title);
	    },
	    // Helper methods for `updateContent()`
	    setTitle: function setTitle(val) {
	      val = isUndefinedOrNull(val) ? '' : val; // We only update the value if it has changed

	      if (this.localTitle !== val) {
	        this.localTitle = val;
	      }
	    },
	    setContent: function setContent(val) {
	      val = isUndefinedOrNull(val) ? '' : val; // We only update the value if it has changed

	      if (this.localContent !== val) {
	        this.localContent = val;
	      }
	    },
	    // --- Template event handlers ---
	    onShow: function onShow(bvEvt) {
	      // Placeholder
	      this.$emit('show', bvEvt);

	      if (bvEvt) {
	        this.localShow = !bvEvt.defaultPrevented;
	      }
	    },
	    onShown: function onShown(bvEvt) {
	      // Tip is now showing
	      this.localShow = true;
	      this.$emit('shown', bvEvt);
	    },
	    onHide: function onHide(bvEvt) {
	      this.$emit('hide', bvEvt);
	    },
	    onHidden: function onHidden(bvEvt) {
	      // Tip is no longer showing
	      this.$emit('hidden', bvEvt);
	      this.localShow = false;
	    },
	    onDisabled: function onDisabled(bvEvt) {
	      // Prevent possible endless loop if user mistakenly
	      // fires `disabled` instead of `disable`
	      if (bvEvt && bvEvt.type === 'disabled') {
	        this.$emit('update:disabled', true);
	        this.$emit('disabled', bvEvt);
	      }
	    },
	    onEnabled: function onEnabled(bvEvt) {
	      // Prevent possible endless loop if user mistakenly
	      // fires `enabled` instead of `enable`
	      if (bvEvt && bvEvt.type === 'enabled') {
	        this.$emit('update:disabled', false);
	        this.$emit('enabled', bvEvt);
	      }
	    },
	    // --- Local event listeners ---
	    doOpen: function doOpen() {
	      !this.localShow && this.$_bv_toolpop && this.$_bv_toolpop.show();
	    },
	    doClose: function doClose() {
	      this.localShow && this.$_bv_toolpop && this.$_bv_toolpop.hide();
	    },
	    doDisable: function doDisable(evt) {
	      this.$_bv_toolpop && this.$_bv_toolpop.disable();
	    },
	    doEnable: function doEnable() {
	      this.$_bv_toolpop && this.$_bv_toolpop.enable();
	    }
	  },
	  render: function render(h) {
	    // Always renders a comment node
	    // TODO:
	    //   Future: Possibly render a target slot (single root element)
	    //   which we can apply the listeners to (pass `this.$el` to BVTooltip)
	    return h();
	  }
	});

	var NAME$r = 'BVPopoverTemplate'; // @vue/component

	var BVPopoverTemplate =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$r,
	  extends: BVTooltipTemplate,
	  computed: {
	    templateType: function templateType() {
	      return 'popover';
	    }
	  },
	  methods: {
	    renderTemplate: function renderTemplate(h) {
	      // Title and content could be a scoped slot function
	      var $title = isFunction(this.title) ? this.title({}) : this.title;
	      var $content = isFunction(this.content) ? this.content({}) : this.content; // Directive usage only

	      var titleDomProps = this.html && !isFunction(this.title) ? {
	        innerHTML: this.title
	      } : {};
	      var contentDomProps = this.html && !isFunction(this.content) ? {
	        innerHTML: this.content
	      } : {};
	      return h('div', {
	        staticClass: 'popover b-popover',
	        class: this.templateClasses,
	        attrs: this.templateAttributes,
	        on: this.templateListeners
	      }, [h('div', {
	        ref: 'arrow',
	        staticClass: 'arrow'
	      }), isUndefinedOrNull($title) || $title === '' ? h() : h('h3', {
	        staticClass: 'popover-header',
	        domProps: titleDomProps
	      }, [$title]), isUndefinedOrNull($content) || $content === '' ? h() : h('div', {
	        staticClass: 'popover-body',
	        domProps: contentDomProps
	      }, [$content])]);
	    }
	  }
	});

	// Popover "Class" (Built as a renderless Vue instance)
	var NAME$s = 'BVPopover'; // @vue/component

	var BVPopover =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$s,
	  extends: BVTooltip,
	  computed: {
	    // Overwrites BVTooltip
	    templateType: function templateType() {
	      return 'popover';
	    }
	  },
	  methods: {
	    getTemplate: function getTemplate() {
	      // Overwrites BVTooltip
	      return BVPopoverTemplate;
	    }
	  }
	});

	var NAME$t = 'BPopover';
	var BPopover =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$t,
	  extends: BTooltip,
	  inheritAttrs: false,
	  props: {
	    title: {
	      type: String // default: undefined

	    },
	    content: {
	      type: String // default: undefined

	    },
	    triggers: {
	      type: [String, Array],
	      default: 'click'
	    },
	    placement: {
	      type: String,
	      default: 'right'
	    },
	    variant: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$t, 'variant');
	      }
	    },
	    customClass: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$t, 'customClass');
	      }
	    },
	    delay: {
	      type: [Number, Object, String],
	      default: function _default() {
	        return getComponentConfig(NAME$t, 'delay');
	      }
	    },
	    boundary: {
	      // String: scrollParent, window, or viewport
	      // Element: element reference
	      // Object: Vue component
	      type: [String, HTMLElement$1, Object],
	      default: function _default() {
	        return getComponentConfig(NAME$t, 'boundary');
	      }
	    },
	    boundaryPadding: {
	      type: [Number, String],
	      default: function _default() {
	        return getComponentConfig(NAME$t, 'boundaryPadding');
	      }
	    }
	  },
	  methods: {
	    getComponent: function getComponent() {
	      // Overridden by BPopover
	      return BVPopover;
	    },
	    updateContent: function updateContent() {
	      // Tooltip: Default slot is `title`
	      // Popover: Default slot is `content`, `title` slot is title
	      // We pass a scoped slot function references by default (Vue v2.6x)
	      // And pass the title prop as a fallback
	      this.setContent(this.$scopedSlots.default || this.content);
	      this.setTitle(this.$scopedSlots.title || this.title);
	    }
	  } // Render function provided by BTooltip

	});

	function ownKeys$G(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$G(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$G(source, true).forEach(function (key) { _defineProperty$X(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$G(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$X(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var BV_POPOVER = '__BV_Popover__'; // Default trigger

	var DefaultTrigger = 'click'; // Valid event triggers

	var validTriggers = {
	  focus: true,
	  hover: true,
	  click: true,
	  blur: true,
	  manual: true
	}; // Directive modifier test regular expressions. Pre-compile for performance

	var htmlRE = /^html$/i;
	var noFadeRE = /^nofade$/i;
	var placementRE = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;
	var boundaryRE = /^(window|viewport|scrollParent)$/i;
	var delayRE = /^d\d+$/i;
	var delayShowRE = /^ds\d+$/i;
	var delayHideRE = /^dh\d+$/i;
	var offsetRE = /^o-?\d+$/i;
	var variantRE = /^v-.+$/i; // Build a Popover config based on bindings (if any)
	// Arguments and modifiers take precedence over passed value config object

	var parseBindings = function parseBindings(bindings, vnode)
	/* istanbul ignore next: not easy to test */
	{
	  // We start out with a basic config
	  var NAME = 'BPopover';
	  var config = {
	    title: undefined,
	    content: undefined,
	    trigger: '',
	    // Default set below if needed
	    placement: 'right',
	    fallbackPlacement: 'flip',
	    container: false,
	    // Default of body
	    animation: true,
	    offset: 0,
	    disabled: false,
	    id: null,
	    html: false,
	    delay: getComponentConfig(NAME, 'delay'),
	    boundary: String(getComponentConfig(NAME, 'boundary')),
	    boundaryPadding: parseInt(getComponentConfig(NAME, 'boundaryPadding'), 10) || 0,
	    variant: getComponentConfig(NAME, 'variant'),
	    customClass: getComponentConfig(NAME, 'customClass')
	  }; // Process `bindings.value`

	  if (isString(bindings.value) || isNumber(bindings.value)) {
	    // Value is popover content (html optionally supported)
	    config.content = bindings.value;
	  } else if (isFunction(bindings.value)) {
	    // Content generator function
	    config.content = bindings.value;
	  } else if (isPlainObject(bindings.value)) {
	    // Value is config object, so merge
	    config = _objectSpread$G({}, config, {}, bindings.value);
	  } // If argument, assume element ID of container element


	  if (bindings.arg) {
	    // Element ID specified as arg
	    // We must prepend '#' to become a CSS selector
	    config.container = "#".concat(bindings.arg);
	  } // If title is not provided, try title attribute


	  if (isUndefined(config.title)) {
	    // Try attribute
	    var data = vnode.data || {};
	    config.title = data.attrs && !isUndefinedOrNull(data.attrs.title) ? data.attrs.title : undefined;
	  } // Normalize delay


	  if (!isPlainObject(config.delay)) {
	    config.delay = {
	      show: parseInt(config.delay, 10) || 0,
	      hide: parseInt(config.delay, 10) || 0
	    };
	  } // Process modifiers


	  keys$2(bindings.modifiers).forEach(function (mod) {
	    if (htmlRE.test(mod)) {
	      // Title/content allows HTML
	      config.html = true;
	    } else if (noFadeRE.test(mod)) {
	      // No animation
	      config.animation = false;
	    } else if (placementRE.test(mod)) {
	      // Placement of popover
	      config.placement = mod;
	    } else if (boundaryRE.test(mod)) {
	      // Boundary of popover
	      mod = mod === 'scrollparent' ? 'scrollParent' : mod;
	      config.boundary = mod;
	    } else if (delayRE.test(mod)) {
	      // Delay value
	      var delay = parseInt(mod.slice(1), 10) || 0;
	      config.delay.show = delay;
	      config.delay.hide = delay;
	    } else if (delayShowRE.test(mod)) {
	      // Delay show value
	      config.delay.show = parseInt(mod.slice(2), 10) || 0;
	    } else if (delayHideRE.test(mod)) {
	      // Delay hide value
	      config.delay.hide = parseInt(mod.slice(2), 10) || 0;
	    } else if (offsetRE.test(mod)) {
	      // Offset value, negative allowed
	      config.offset = parseInt(mod.slice(1), 10) || 0;
	    } else if (variantRE.test(mod)) {
	      // Variant
	      config.variant = mod.slice(2) || null;
	    }
	  }); // Special handling of event trigger modifiers trigger is
	  // a space separated list

	  var selectedTriggers = {}; // Parse current config object trigger

	  concat(config.trigger || '').filter(Boolean).join(' ').trim().toLowerCase().split(/\s+/).forEach(function (trigger) {
	    if (validTriggers[trigger]) {
	      selectedTriggers[trigger] = true;
	    }
	  }); // Parse modifiers for triggers

	  keys$2(bindings.modifiers).forEach(function (mod) {
	    mod = mod.toLowerCase();

	    if (validTriggers[mod]) {
	      // If modifier is a valid trigger
	      selectedTriggers[mod] = true;
	    }
	  }); // Sanitize triggers

	  config.trigger = keys$2(selectedTriggers).join(' ');

	  if (config.trigger === 'blur') {
	    // Blur by itself is useless, so convert it to 'focus'
	    config.trigger = 'focus';
	  }

	  if (!config.trigger) {
	    // Use default trigger
	    config.trigger = DefaultTrigger;
	  }

	  return config;
	}; // Add or update Popover on our element


	var applyPopover = function applyPopover(el, bindings, vnode) {
	  if (!isBrowser) {
	    /* istanbul ignore next */
	    return;
	  }

	  var config = parseBindings(bindings, vnode);

	  if (!el[BV_POPOVER]) {
	    var $parent = vnode.context;
	    el[BV_POPOVER] = new BVPopover({
	      parent: $parent,
	      // Add the parent's scoped style attribute data
	      _scopeId: getScopeId($parent, undefined)
	    });
	    el[BV_POPOVER].__bv_prev_data__ = {};
	    el[BV_POPOVER].$on('show', function ()
	    /* istanbul ignore next: for now */
	    {
	      // Before showing the popover, we update the title
	      // and content if they are functions
	      var data = {};

	      if (isFunction(config.title)) {
	        data.title = config.title(el);
	      }

	      if (isFunction(config.content)) {
	        data.content = config.content(el);
	      }

	      if (keys$2(data).length > 0) {
	        el[BV_POPOVER].updateData(data);
	      }
	    });
	  }

	  var data = {
	    title: config.title,
	    content: config.content,
	    triggers: config.trigger,
	    placement: config.placement,
	    fallbackPlacement: config.fallbackPlacement,
	    variant: config.variant,
	    customClass: config.customClass,
	    container: config.container,
	    boundary: config.boundary,
	    delay: config.delay,
	    offset: config.offset,
	    noFade: !config.animation,
	    id: config.id,
	    disabled: config.disabled,
	    html: config.html
	  };
	  var oldData = el[BV_POPOVER].__bv_prev_data__;
	  el[BV_POPOVER].__bv_prev_data__ = data;

	  if (!looseEqual(data, oldData)) {
	    // We only update the instance if data has changed
	    var newData = {
	      target: el
	    };
	    keys$2(data).forEach(function (prop) {
	      // We only pass data properties that have changed
	      if (data[prop] !== oldData[prop]) {
	        // If title/content is a function, we execute it here
	        newData[prop] = (prop === 'title' || prop === 'content') && isFunction(data[prop]) ? data[prop](el) : data[prop];
	      }
	    });
	    el[BV_POPOVER].updateData(newData);
	  }
	}; // Remove Popover from our element


	var removePopover = function removePopover(el) {
	  if (el[BV_POPOVER]) {
	    el[BV_POPOVER].$destroy();
	    el[BV_POPOVER] = null;
	  }

	  delete el[BV_POPOVER];
	}; // Export our directive


	var VBPopover = {
	  bind: function bind(el, bindings, vnode) {
	    applyPopover(el, bindings, vnode);
	  },
	  // We use `componentUpdated` here instead of `update`, as the former
	  // waits until the containing component and children have finished updating
	  componentUpdated: function componentUpdated(el, bindings, vnode) {
	    // Performed in a `$nextTick()` to prevent endless render/update loops
	    vnode.context.$nextTick(function () {
	      applyPopover(el, bindings, vnode);
	    });
	  },
	  unbind: function unbind(el) {
	    removePopover(el);
	  }
	};

	var VBPopoverPlugin =
	/*#__PURE__*/
	pluginFactory({
	  directives: {
	    VBPopover: VBPopover
	  }
	});

	var PopoverPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BPopover: BPopover
	  },
	  plugins: {
	    VBPopoverPlugin: VBPopoverPlugin
	  }
	});

	var NAME$u = 'BProgressBar'; // @vue/component

	var BProgressBar =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$u,
	  mixins: [normalizeSlotMixin],
	  inject: {
	    bvProgress: {
	      default: function _default()
	      /* istanbul ignore next */
	      {
	        return {};
	      }
	    }
	  },
	  props: {
	    value: {
	      type: Number,
	      default: 0
	    },
	    label: {
	      type: String,
	      default: null
	    },
	    labelHtml: {
	      type: String
	    },
	    // $parent (this.bvProgress) prop values may take precedence over the following props
	    // Which is why they are defaulted to null
	    max: {
	      type: Number,
	      default: null
	    },
	    precision: {
	      type: Number,
	      default: null
	    },
	    variant: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$u, 'variant');
	      }
	    },
	    striped: {
	      type: Boolean,
	      default: null
	    },
	    animated: {
	      type: Boolean,
	      default: null
	    },
	    showProgress: {
	      type: Boolean,
	      default: null
	    },
	    showValue: {
	      type: Boolean,
	      default: null
	    }
	  },
	  computed: {
	    progressBarClasses: function progressBarClasses() {
	      return [this.computedVariant ? "bg-".concat(this.computedVariant) : '', this.computedStriped || this.computedAnimated ? 'progress-bar-striped' : '', this.computedAnimated ? 'progress-bar-animated' : ''];
	    },
	    progressBarStyles: function progressBarStyles() {
	      return {
	        width: 100 * (this.value / this.computedMax) + '%'
	      };
	    },
	    computedProgress: function computedProgress() {
	      var p = Math.pow(10, this.computedPrecision);
	      return Math.round(100 * p * this.value / this.computedMax) / p;
	    },
	    computedMax: function computedMax() {
	      // Prefer our max over parent setting
	      return isNumber(this.max) ? this.max : this.bvProgress.max || 100;
	    },
	    computedVariant: function computedVariant() {
	      // Prefer our variant over parent setting
	      return this.variant || this.bvProgress.variant;
	    },
	    computedPrecision: function computedPrecision() {
	      // Prefer our precision over parent setting
	      return isNumber(this.precision) ? this.precision : this.bvProgress.precision || 0;
	    },
	    computedStriped: function computedStriped() {
	      // Prefer our striped over parent setting
	      return isBoolean(this.striped) ? this.striped : this.bvProgress.striped || false;
	    },
	    computedAnimated: function computedAnimated() {
	      // Prefer our animated over parent setting
	      return isBoolean(this.animated) ? this.animated : this.bvProgress.animated || false;
	    },
	    computedShowProgress: function computedShowProgress() {
	      // Prefer our showProgress over parent setting
	      return isBoolean(this.showProgress) ? this.showProgress : this.bvProgress.showProgress || false;
	    },
	    computedShowValue: function computedShowValue() {
	      // Prefer our showValue over parent setting
	      return isBoolean(this.showValue) ? this.showValue : this.bvProgress.showValue || false;
	    }
	  },
	  render: function render(h) {
	    var childNodes = h();

	    if (this.hasNormalizedSlot('default')) {
	      childNodes = this.normalizeSlot('default');
	    } else if (this.label || this.labelHtml) {
	      childNodes = h('span', {
	        domProps: htmlOrText(this.labelHtml, this.label)
	      });
	    } else if (this.computedShowProgress) {
	      childNodes = this.computedProgress.toFixed(this.computedPrecision);
	    } else if (this.computedShowValue) {
	      childNodes = this.value.toFixed(this.computedPrecision);
	    }

	    return h('div', {
	      staticClass: 'progress-bar',
	      class: this.progressBarClasses,
	      style: this.progressBarStyles,
	      attrs: {
	        role: 'progressbar',
	        'aria-valuemin': '0',
	        'aria-valuemax': this.computedMax.toString(),
	        'aria-valuenow': this.value.toFixed(this.computedPrecision)
	      }
	    }, [childNodes]);
	  }
	});

	var NAME$v = 'BProgress'; // @vue/component

	var BProgress =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$v,
	  mixins: [normalizeSlotMixin],
	  provide: function provide() {
	    return {
	      bvProgress: this
	    };
	  },
	  props: {
	    // These props can be inherited via the child b-progress-bar(s)
	    variant: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$v, 'variant');
	      }
	    },
	    striped: {
	      type: Boolean,
	      default: false
	    },
	    animated: {
	      type: Boolean,
	      default: false
	    },
	    height: {
	      type: String,
	      default: null
	    },
	    precision: {
	      type: Number,
	      default: 0
	    },
	    showProgress: {
	      type: Boolean,
	      default: false
	    },
	    showValue: {
	      type: Boolean,
	      default: false
	    },
	    max: {
	      type: Number,
	      default: 100
	    },
	    // This prop is not inherited by child b-progress-bar(s)
	    value: {
	      type: Number,
	      default: 0
	    }
	  },
	  computed: {
	    progressHeight: function progressHeight() {
	      return {
	        height: this.height || null
	      };
	    }
	  },
	  render: function render(h) {
	    var childNodes = this.normalizeSlot('default');

	    if (!childNodes) {
	      childNodes = h(BProgressBar, {
	        props: {
	          value: this.value,
	          max: this.max,
	          precision: this.precision,
	          variant: this.variant,
	          animated: this.animated,
	          striped: this.striped,
	          showProgress: this.showProgress,
	          showValue: this.showValue
	        }
	      });
	    }

	    return h('div', {
	      class: ['progress'],
	      style: this.progressHeight
	    }, [childNodes]);
	  }
	});

	var ProgressPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BProgress: BProgress,
	    BProgressBar: BProgressBar
	  }
	});

	function _defineProperty$Y(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var NAME$w = 'BSpinner'; // @vue/component

	var BSpinner =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$w,
	  functional: true,
	  props: {
	    type: {
	      type: String,
	      default: 'border' // SCSS currently supports 'border' or 'grow'

	    },
	    label: {
	      type: String,
	      default: null
	    },
	    variant: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig(NAME$w, 'variant');
	      }
	    },
	    small: {
	      type: Boolean,
	      default: false
	    },
	    role: {
	      type: String,
	      default: 'status'
	    },
	    tag: {
	      type: String,
	      default: 'span'
	    }
	  },
	  render: function render(h, _ref) {
	    var _class;

	    var props = _ref.props,
	        data = _ref.data,
	        slots = _ref.slots,
	        scopedSlots = _ref.scopedSlots;
	    var $slots = slots();
	    var $scopedSlots = scopedSlots || {};
	    var label = normalizeSlot('label', {}, $scopedSlots, $slots) || props.label;

	    if (label) {
	      label = h('span', {
	        staticClass: 'sr-only'
	      }, label);
	    }

	    return h(props.tag, a(data, {
	      attrs: {
	        role: label ? props.role || 'status' : null,
	        'aria-hidden': label ? null : 'true'
	      },
	      class: (_class = {}, _defineProperty$Y(_class, "spinner-".concat(props.type), Boolean(props.type)), _defineProperty$Y(_class, "spinner-".concat(props.type, "-sm"), props.small), _defineProperty$Y(_class, "text-".concat(props.variant), Boolean(props.variant)), _class)
	    }), [label || h()]);
	  }
	});

	var SpinnerPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BSpinner: BSpinner
	  }
	});

	/**
	 * Converts a string, including strings in camelCase or snake_case, into Start Case (a variant
	 * of Title Case where all words start with a capital letter), it keeps original single quote
	 * and hyphen in the word.
	 *
	 * Copyright (c) 2017 Compass (MIT)
	 * https://github.com/UrbanCompass/to-start-case
	 * @author Zhuoyuan Zhang <https://github.com/drawyan>
	 * @author Wei Wang <https://github.com/onlywei>
	 *
	 *
	 *   'management_companies' to 'Management Companies'
	 *   'managementCompanies' to 'Management Companies'
	 *   `hell's kitchen` to `Hell's Kitchen`
	 *   `co-op` to `Co-op`
	 *
	 * @param {String} str
	 * @returns {String}
	 */
	var startCase = function startCase(str) {
	  return str.replace(/_/g, ' ').replace(/([a-z])([A-Z])/g, function (str, $1, $2) {
	    return $1 + ' ' + $2;
	  }).replace(/(\s|^)(\w)/g, function (str, $1, $2) {
	    return $1 + $2.toUpperCase();
	  });
	};

	// Constants used by table helpers
	// Object of item keys that should be ignored for headers and
	// stringification and filter events
	var IGNORED_FIELD_KEYS = {
	  _rowVariant: true,
	  _cellVariants: true,
	  _showDetails: true
	}; // Filter CSS selector for click/dblclick/etc. events
	// If any of these selectors match the clicked element, we ignore the event

	var EVENT_FILTER = ['a', 'a *', // Include content inside links
	'button', 'button *', // Include content inside buttons
	'input:not(.disabled):not([disabled])', 'select:not(.disabled):not([disabled])', 'textarea:not(.disabled):not([disabled])', '[role="link"]', '[role="link"] *', '[role="button"]', '[role="button"] *', '[tabindex]:not(.disabled):not([disabled])'].join(',');

	var processField = function processField(key, value) {
	  var field = null;

	  if (isString(value)) {
	    // Label shortcut
	    field = {
	      key: key,
	      label: value
	    };
	  } else if (isFunction(value)) {
	    // Formatter shortcut
	    field = {
	      key: key,
	      formatter: value
	    };
	  } else if (isObject(value)) {
	    field = clone(value);
	    field.key = field.key || key;
	  } else if (value !== false) {
	    // Fallback to just key

	    /* istanbul ignore next */
	    field = {
	      key: key
	    };
	  }

	  return field;
	}; // We normalize fields into an array of objects
	// [ { key:..., label:..., ...}, {...}, ..., {..}]


	var normalizeFields = function normalizeFields(origFields, items) {
	  var fields = [];

	  if (isArray(origFields)) {
	    // Normalize array Form
	    origFields.filter(function (f) {
	      return f;
	    }).forEach(function (f) {
	      if (isString(f)) {
	        fields.push({
	          key: f,
	          label: startCase(f)
	        });
	      } else if (isObject(f) && f.key && isString(f.key)) {
	        // Full object definition. We use assign so that we don't mutate the original
	        fields.push(clone(f));
	      } else if (isObject(f) && keys$2(f).length === 1) {
	        // Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }
	        var key = keys$2(f)[0];
	        var field = processField(key, f[key]);

	        if (field) {
	          fields.push(field);
	        }
	      }
	    });
	  } // If no field provided, take a sample from first record (if exits)


	  if (fields.length === 0 && isArray(items) && items.length > 0) {
	    var sample = items[0];
	    keys$2(sample).forEach(function (k) {
	      if (!IGNORED_FIELD_KEYS[k]) {
	        fields.push({
	          key: k,
	          label: startCase(k)
	        });
	      }
	    });
	  } // Ensure we have a unique array of fields and that they have String labels


	  var memo = {};
	  return fields.filter(function (f) {
	    if (!memo[f.key]) {
	      memo[f.key] = true;
	      f.label = isString(f.label) ? f.label : startCase(f.key);
	      return true;
	    }

	    return false;
	  });
	};

	var itemsMixin = {
	  props: {
	    items: {
	      // Provider mixin adds in `Function` type
	      type: Array,
	      default: function _default()
	      /* istanbul ignore next */
	      {
	        return [];
	      }
	    },
	    fields: {
	      type: Array,
	      default: null
	    },
	    primaryKey: {
	      // Primary key for record
	      // If provided the value in each row must be unique!
	      type: String,
	      default: null
	    },
	    value: {
	      // `v-model` for retrieving the current displayed rows
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    }
	  },
	  data: function data() {
	    return {
	      // Our local copy of the items
	      // Must be an array
	      localItems: isArray(this.items) ? this.items.slice() : []
	    };
	  },
	  computed: {
	    computedFields: function computedFields() {
	      // We normalize fields into an array of objects
	      // `[ { key:..., label:..., ...}, {...}, ..., {..}]`
	      return normalizeFields(this.fields, this.localItems);
	    },
	    computedFieldsObj: function computedFieldsObj() {
	      // Fields as a simple lookup hash object
	      // Mainly for formatter lookup and use in `scopedSlots` for convenience
	      // If the field has a formatter, it normalizes formatter to a
	      // function ref or `undefined` if no formatter
	      var parent = this.$parent;
	      return this.computedFields.reduce(function (obj, f) {
	        // We use object spread here so we don't mutate the original field object
	        obj[f.key] = clone(f);

	        if (f.formatter) {
	          // Normalize formatter to a function ref or `undefined`
	          var formatter = f.formatter;

	          if (isString(formatter) && isFunction(parent[formatter])) {
	            formatter = parent[formatter];
	          } else if (!isFunction(formatter)) {
	            /* istanbul ignore next */
	            formatter = undefined;
	          } // Return formatter function or `undefined` if none


	          obj[f.key].formatter = formatter;
	        }

	        return obj;
	      }, {});
	    },
	    computedItems: function computedItems() {
	      // Fallback if various mixins not provided
	      return (this.paginatedItems || this.sortedItems || this.filteredItems || this.localItems || []).slice();
	    },
	    context: function context() {
	      // Current state of sorting, filtering and pagination props/values
	      return {
	        filter: this.localFilter,
	        sortBy: this.localSortBy,
	        sortDesc: this.localSortDesc,
	        perPage: parseInt(this.perPage, 10) || 0,
	        currentPage: parseInt(this.currentPage, 10) || 1,
	        apiUrl: this.apiUrl
	      };
	    }
	  },
	  watch: {
	    items: function items(newItems) {
	      /* istanbul ignore else */
	      if (isArray(newItems)) {
	        // Set `localItems`/`filteredItems` to a copy of the provided array
	        this.localItems = newItems.slice();
	      } else if (isUndefined(newItems) || isNull(newItems)) {
	        /* istanbul ignore next */
	        this.localItems = [];
	      }
	    },
	    // Watch for changes on `computedItems` and update the `v-model`
	    computedItems: function computedItems(newVal) {
	      this.$emit('input', newVal);
	    },
	    // Watch for context changes
	    context: function context(newVal, oldVal) {
	      // Emit context information for external paging/filtering/sorting handling
	      if (!looseEqual(newVal, oldVal)) {
	        this.$emit('context-changed', newVal);
	      }
	    }
	  },
	  mounted: function mounted() {
	    // Initially update the `v-model` of displayed items
	    this.$emit('input', this.computedItems);
	  },
	  methods: {
	    // Method to get the formatter method for a given field key
	    getFieldFormatter: function getFieldFormatter(key) {
	      var field = this.computedFieldsObj[key]; // `this.computedFieldsObj` has pre-normalized the formatter to a
	      // function ref if present, otherwise `undefined`

	      return field ? field.formatter : undefined;
	    }
	  }
	};

	function _defineProperty$Z(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	// Mixin for providing stacked tables
	var stackedMixin = {
	  props: {
	    stacked: {
	      type: [Boolean, String],
	      default: false
	    }
	  },
	  computed: {
	    isStacked: function isStacked() {
	      // `true` when always stacked, or returns breakpoint specified
	      return this.stacked === '' ? true : this.stacked;
	    },
	    isStackedAlways: function isStackedAlways() {
	      return this.isStacked === true;
	    },
	    stackedTableClasses: function stackedTableClasses() {
	      return _defineProperty$Z({
	        'b-table-stacked': this.isStackedAlways
	      }, "b-table-stacked-".concat(this.stacked), !this.isStackedAlways && this.isStacked);
	    }
	  }
	};

	var sanitizeRow = function sanitizeRow(row, ignoreFields, includeFields) {
	  var fieldsObj = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	  return keys$2(row).reduce(function (obj, key) {
	    // Ignore special fields that start with `_`
	    // Ignore fields in the `ignoreFields` array
	    // Include only fields in the `includeFields` array
	    if (!IGNORED_FIELD_KEYS[key] && !(ignoreFields && ignoreFields.length > 0 && arrayIncludes(ignoreFields, key)) && !(includeFields && includeFields.length > 0 && !arrayIncludes(includeFields, key))) {
	      var f = fieldsObj[key] || {};
	      var val = row[key]; // `f.filterByFormatted` will either be a function or boolean
	      // `f.formater` will have already been noramlized into a function ref

	      var filterByFormatted = f.filterByFormatted;
	      var formatter = isFunction(filterByFormatted) ? filterByFormatted : filterByFormatted ? f.formatter : null;
	      obj[key] = isFunction(formatter) ? formatter(val, key, row) : val;
	    }

	    return obj;
	  }, {});
	};

	// SSR safe deterministic way (keys are sorted before stringification)
	//
	//   ex:
	//     { b: 3, c: { z: 'zzz', d: null, e: 2 }, d: [10, 12, 11], a: 'one' }
	//   becomes
	//     'one 3 2 zzz 10 12 11'
	//
	// Primitives (numbers/strings) are returned as-is
	// Null and undefined values are filtered out
	// Dates are converted to their native string format

	var stringifyObjectValues = function stringifyObjectValues(val) {
	  if (isUndefinedOrNull(val)) {
	    /* istanbul ignore next */
	    return '';
	  } // Arrays are also object, and keys just returns the array indexes
	  // Date objects we convert to strings


	  if (isObject(val) && !isDate(val)) {
	    return keys$2(val).sort() // Sort to prevent SSR issues on pre-rendered sorted tables
	    .filter(function (v) {
	      return !isUndefinedOrNull(v);
	    }) // Ignore undefined/null values
	    .map(function (k) {
	      return stringifyObjectValues(val[k]);
	    }).join(' ');
	  }

	  return String(val);
	};

	// TODO: Add option to stringify `scopedSlot` items

	var stringifyRecordValues = function stringifyRecordValues(row, ignoreFields, includeFields, fieldsObj) {
	  return isObject(row) ? stringifyObjectValues(sanitizeRow(row, ignoreFields, includeFields, fieldsObj)) : '';
	};

	var DEPRECATED_DEBOUNCE = 'b-table: Prop "filter-debounce" is deprecated. Use the debounce feature of <b-form-input> instead';
	var filteringMixin = {
	  props: {
	    filter: {
	      type: [String, RegExp, Object, Array],
	      default: null
	    },
	    filterFunction: {
	      type: Function,
	      default: null
	    },
	    filterIgnoredFields: {
	      type: Array // default: undefined

	    },
	    filterIncludedFields: {
	      type: Array // default: undefined

	    },
	    filterDebounce: {
	      type: [Number, String],
	      deprecated: DEPRECATED_DEBOUNCE,
	      default: 0,
	      validator: function validator(val) {
	        return /^\d+/.test(String(val));
	      }
	    }
	  },
	  data: function data() {
	    return {
	      // Flag for displaying which empty slot to show and some event triggering
	      isFiltered: false,
	      // Where we store the copy of the filter criteria after debouncing
	      // We pre-set it with the sanitized filter value
	      localFilter: this.filterSanitize(this.filter)
	    };
	  },
	  computed: {
	    computedFilterIgnored: function computedFilterIgnored() {
	      return this.filterIgnoredFields ? concat(this.filterIgnoredFields).filter(Boolean) : null;
	    },
	    computedFilterIncluded: function computedFilterIncluded() {
	      return this.filterIncludedFields ? concat(this.filterIncludedFields).filter(Boolean) : null;
	    },
	    computedFilterDebounce: function computedFilterDebounce() {
	      var ms = parseInt(this.filterDebounce, 10) || 0;
	      /* istanbul ignore next */

	      if (ms > 0) {
	        warn(DEPRECATED_DEBOUNCE);
	      }

	      return ms;
	    },
	    localFiltering: function localFiltering() {
	      return this.hasProvider ? !!this.noProviderFiltering : true;
	    },
	    // For watching changes to `filteredItems` vs `localItems`
	    filteredCheck: function filteredCheck() {
	      return {
	        filteredItems: this.filteredItems,
	        localItems: this.localItems,
	        localFilter: this.localFilter
	      };
	    },
	    // Sanitized/normalize filter-function prop
	    localFilterFn: function localFilterFn() {
	      // Return `null` to signal to use internal filter function
	      return isFunction(this.filterFunction) ? this.filterFunction : null;
	    },
	    // Returns the records in `localItems` that match the filter criteria
	    // Returns the original `localItems` array if not sorting
	    filteredItems: function filteredItems() {
	      var items = this.localItems || []; // Note the criteria is debounced and sanitized

	      var criteria = this.localFilter; // Resolve the filtering function, when requested
	      // We prefer the provided filtering function and fallback to the internal one
	      // When no filtering criteria is specified the filtering factories will return `null`

	      var filterFn = this.localFiltering ? this.filterFnFactory(this.localFilterFn, criteria) || this.defaultFilterFnFactory(criteria) : null; // We only do local filtering when requested and there are records to filter

	      return filterFn && items.length > 0 ? items.filter(filterFn) : items;
	    }
	  },
	  watch: {
	    // Watch for debounce being set to 0
	    computedFilterDebounce: function computedFilterDebounce(newVal, oldVal) {
	      if (!newVal && this.$_filterTimer) {
	        clearTimeout(this.$_filterTimer);
	        this.$_filterTimer = null;
	        this.localFilter = this.filterSanitize(this.filter);
	      }
	    },
	    // Watch for changes to the filter criteria, and debounce if necessary
	    filter: {
	      // We need a deep watcher in case the user passes
	      // an object when using `filter-function`
	      deep: true,
	      handler: function handler(newCriteria, oldCriteria) {
	        var _this = this;

	        var timeout = this.computedFilterDebounce;
	        clearTimeout(this.$_filterTimer);
	        this.$_filterTimer = null;

	        if (timeout && timeout > 0) {
	          // If we have a debounce time, delay the update of `localFilter`
	          this.$_filterTimer = setTimeout(function () {
	            _this.localFilter = _this.filterSanitize(newCriteria);
	          }, timeout);
	        } else {
	          // Otherwise, immediately update `localFilter` with `newFilter` value
	          this.localFilter = this.filterSanitize(newCriteria);
	        }
	      }
	    },
	    // Watch for changes to the filter criteria and filtered items vs `localItems`
	    // Set visual state and emit events as required
	    filteredCheck: function filteredCheck(_ref) {
	      var filteredItems = _ref.filteredItems,
	          localItems = _ref.localItems,
	          localFilter = _ref.localFilter;
	      // Determine if the dataset is filtered or not
	      var isFiltered = false;

	      if (!localFilter) {
	        // If filter criteria is falsey
	        isFiltered = false;
	      } else if (looseEqual(localFilter, []) || looseEqual(localFilter, {})) {
	        // If filter criteria is an empty array or object
	        isFiltered = false;
	      } else if (localFilter) {
	        // If filter criteria is truthy
	        isFiltered = true;
	      }

	      if (isFiltered) {
	        this.$emit('filtered', filteredItems, filteredItems.length);
	      }

	      this.isFiltered = isFiltered;
	    },
	    isFiltered: function isFiltered(newVal, oldVal) {
	      if (newVal === false && oldVal === true) {
	        // We need to emit a filtered event if isFiltered transitions from true to
	        // false so that users can update their pagination controls.
	        this.$emit('filtered', this.localItems, this.localItems.length);
	      }
	    }
	  },
	  created: function created() {
	    var _this2 = this;

	    // Create non-reactive prop where we store the debounce timer id
	    this.$_filterTimer = null; // If filter is "pre-set", set the criteria
	    // This will trigger any watchers/dependents
	    // this.localFilter = this.filterSanitize(this.filter)
	    // Set the initial filtered state in a `$nextTick()` so that
	    // we trigger a filtered event if needed

	    this.$nextTick(function () {
	      _this2.isFiltered = Boolean(_this2.localFilter);
	    });
	  },
	  beforeDestroy: function beforeDestroy()
	  /* istanbul ignore next */
	  {
	    clearTimeout(this.$_filterTimer);
	    this.$_filterTimer = null;
	  },
	  methods: {
	    filterSanitize: function filterSanitize(criteria) {
	      // Sanitizes filter criteria based on internal or external filtering
	      if (this.localFiltering && !this.localFilterFn && !(isString(criteria) || isRegExp(criteria))) {
	        // If using internal filter function, which only accepts string or RegExp,
	        // return '' to signify no filter
	        return '';
	      } // Could be a string, object or array, as needed by external filter function
	      // We use `cloneDeep` to ensure we have a new copy of an object or array
	      // without Vue's reactive observers


	      return cloneDeep(criteria);
	    },
	    // Filter Function factories
	    filterFnFactory: function filterFnFactory(filterFn, criteria) {
	      // Wrapper factory for external filter functions
	      // Wrap the provided filter-function and return a new function
	      // Returns `null` if no filter-function defined or if criteria is falsey
	      // Rather than directly grabbing `this.computedLocalFilterFn` or `this.filterFunction`
	      // we have it passed, so that the caller computed prop will be reactive to changes
	      // in the original filter-function (as this routine is a method)
	      if (!filterFn || !isFunction(filterFn) || !criteria || looseEqual(criteria, []) || looseEqual(criteria, {})) {
	        return null;
	      } // Build the wrapped filter test function, passing the criteria to the provided function


	      var fn = function fn(item) {
	        // Generated function returns true if the criteria matches part
	        // of the serialized data, otherwise false
	        return filterFn(item, criteria);
	      }; // Return the wrapped function


	      return fn;
	    },
	    defaultFilterFnFactory: function defaultFilterFnFactory(criteria) {
	      var _this3 = this;

	      // Generates the default filter function, using the given filter criteria
	      // Returns `null` if no criteria or criteria format not supported
	      if (!criteria || !(isString(criteria) || isRegExp(criteria))) {
	        // Built in filter can only support strings or RegExp criteria (at the moment)
	        return null;
	      } // Build the regexp needed for filtering


	      var regexp = criteria;

	      if (isString(regexp)) {
	        // Escape special `RegExp` characters in the string and convert contiguous
	        // whitespace to `\s+` matches
	        var pattern = criteria.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&').replace(/[\s\uFEFF\xA0]+/g, '\\s+'); // Build the `RegExp` (no need for global flag, as we only need
	        // to find the value once in the string)

	        regexp = new RegExp(".*".concat(pattern, ".*"), 'i');
	      } // Generate the wrapped filter test function to use


	      var fn = function fn(item) {
	        // This searches all row values (and sub property values) in the entire (excluding
	        // special `_` prefixed keys), because we convert the record to a space-separated
	        // string containing all the value properties (recursively), even ones that are
	        // not visible (not specified in this.fields)
	        // Users can ignore filtering on specific fields, or on only certain fields,
	        // and can optionall specify searching results of fields with formatter
	        //
	        // TODO: Enable searching on scoped slots (optional, as it will be SLOW)
	        //
	        // Generated function returns true if the criteria matches part of
	        // the serialized data, otherwise false
	        // We set `lastIndex = 0` on the `RegExp` in case someone specifies the `/g` global flag
	        regexp.lastIndex = 0;
	        return regexp.test(stringifyRecordValues(item, _this3.computedFilterIgnored, _this3.computedFilterIncluded, _this3.computedFieldsObj));
	      }; // Return the generated function


	      return fn;
	    }
	  }
	};

	/*
	 * Consistent and stable sort function across JavaScript platforms
	 *
	 * Inconsistent sorts can cause SSR problems between client and server
	 * such as in <b-table> if sortBy is applied to the data on server side render.
	 * Chrome and V8 native sorts are inconsistent/unstable
	 *
	 * This function uses native sort with fallback to index compare when the a and b
	 * compare returns 0
	 *
	 * Algorithm based on:
	 * https://stackoverflow.com/questions/1427608/fast-stable-sorting-algorithm-implementation-in-javascript/45422645#45422645
	 *
	 * @param {array} array to sort
	 * @param {function} sort compare function
	 * @return {array}
	 */
	var stableSort = function stableSort(array, compareFn) {
	  // Using `.bind(compareFn)` on the wrapped anonymous function improves
	  // performance by avoiding the function call setup. We don't use an arrow
	  // function here as it binds `this` to the `stableSort` context rather than
	  // the `compareFn` context, which wouldn't give us the performance increase.
	  return array.map(function (a, index) {
	    return [index, a];
	  }).sort(function (a, b) {
	    return this(a[1], b[1]) || a[0] - b[0];
	  }.bind(compareFn)).map(function (e) {
	    return e[1];
	  });
	};

	//
	// TODO: Add option to sort by multiple columns (tri-state per column,
	//       plus order of columns in sort)  where sortBy could be an array
	//       of objects `[ {key: 'foo', sortDir: 'asc'}, {key:'bar', sortDir: 'desc'} ...]`
	//       or an array of arrays `[ ['foo','asc'], ['bar','desc'] ]`
	//       Multisort will most likely be handled in mixin-sort.js by
	//       calling this method for each sortBy

	var defaultSortCompare = function defaultSortCompare(a, b, sortBy, sortDesc, formatter, localeOpts, locale, nullLast) {
	  var aa = get$1(a, sortBy, null);
	  var bb = get$1(b, sortBy, null);

	  if (isFunction(formatter)) {
	    aa = formatter(aa, sortBy, a);
	    bb = formatter(bb, sortBy, b);
	  }

	  aa = isUndefinedOrNull(aa) ? '' : aa;
	  bb = isUndefinedOrNull(bb) ? '' : bb;

	  if (isDate(aa) && isDate(bb) || isNumber(aa) && isNumber(bb)) {
	    // Special case for comparing dates and numbers
	    // Internally dates are compared via their epoch number values
	    return aa < bb ? -1 : aa > bb ? 1 : 0;
	  } else if (nullLast && aa === '' && bb !== '') {
	    // Special case when sorting null/undefined/empty string last
	    return 1;
	  } else if (nullLast && aa !== '' && bb === '') {
	    // Special case when sorting null/undefined/empty string last
	    return -1;
	  } // Do localized string comparison


	  return stringifyObjectValues(aa).localeCompare(stringifyObjectValues(bb), locale, localeOpts);
	};

	function ownKeys$H(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$H(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$H(source, true).forEach(function (key) { _defineProperty$_(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$H(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$_(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var sortingMixin = {
	  props: {
	    sortBy: {
	      type: String,
	      default: ''
	    },
	    sortDesc: {
	      // TODO: Make this tri-state: true, false, null
	      type: Boolean,
	      default: false
	    },
	    sortDirection: {
	      // This prop is named incorrectly
	      // It should be `initialSortDirection` as it is a bit misleading
	      // (not to mention it screws up the ARIA label on the headers)
	      type: String,
	      default: 'asc',
	      validator: function validator(direction) {
	        return arrayIncludes(['asc', 'desc', 'last'], direction);
	      }
	    },
	    sortCompare: {
	      type: Function,
	      default: null
	    },
	    sortCompareOptions: {
	      // Supported localCompare options, see `options` section of:
	      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare
	      type: Object,
	      default: function _default() {
	        return {
	          numeric: true
	        };
	      }
	    },
	    sortCompareLocale: {
	      // String: locale code
	      // Array: array of Locale strings
	      type: [String, Array] // default: undefined

	    },
	    sortNullLast: {
	      // Sort null and undefined to appear last
	      type: Boolean,
	      default: false
	    },
	    noSortReset: {
	      // Another prop that should have had a better name.
	      // It should be noSortClear (on non-sortable headers).
	      // We will need to make sure the documentation is clear on what
	      // this prop does (as well as in the code for future reference)
	      type: Boolean,
	      default: false
	    },
	    labelSortAsc: {
	      type: String,
	      default: 'Click to sort Ascending'
	    },
	    labelSortDesc: {
	      type: String,
	      default: 'Click to sort Descending'
	    },
	    labelSortClear: {
	      type: String,
	      default: 'Click to clear sorting'
	    },
	    noLocalSorting: {
	      type: Boolean,
	      default: false
	    },
	    noFooterSorting: {
	      type: Boolean,
	      default: false
	    },
	    sortIconLeft: {
	      // Place the sorting icon on the left of the header cells
	      type: Boolean,
	      default: false
	    }
	  },
	  data: function data() {
	    return {
	      localSortBy: this.sortBy || '',
	      localSortDesc: this.sortDesc || false
	    };
	  },
	  computed: {
	    localSorting: function localSorting() {
	      return this.hasProvider ? !!this.noProviderSorting : !this.noLocalSorting;
	    },
	    isSortable: function isSortable() {
	      return this.computedFields.some(function (f) {
	        return f.sortable;
	      });
	    },
	    sortedItems: function sortedItems() {
	      // Sorts the filtered items and returns a new array of the sorted items
	      // or the original items array if not sorted.
	      var items = (this.filteredItems || this.localItems || []).slice();
	      var sortBy = this.localSortBy;
	      var sortDesc = this.localSortDesc;
	      var sortCompare = this.sortCompare;
	      var localSorting = this.localSorting;

	      var sortOptions = _objectSpread$H({}, this.sortCompareOptions, {
	        usage: 'sort'
	      });

	      var sortLocale = this.sortCompareLocale || undefined;
	      var nullLast = this.sortNullLast;

	      if (sortBy && localSorting) {
	        var field = this.computedFieldsObj[sortBy] || {};
	        var sortByFormatted = field.sortByFormatted;
	        var formatter = isFunction(sortByFormatted) ? sortByFormatted : sortByFormatted ? this.getFieldFormatter(sortBy) : undefined; // `stableSort` returns a new array, and leaves the original array intact

	        return stableSort(items, function (a, b) {
	          var result = null;

	          if (isFunction(sortCompare)) {
	            // Call user provided sortCompare routine
	            result = sortCompare(a, b, sortBy, sortDesc, formatter, sortOptions, sortLocale);
	          }

	          if (isUndefinedOrNull(result) || result === false) {
	            // Fallback to built-in defaultSortCompare if sortCompare
	            // is not defined or returns null/false
	            result = defaultSortCompare(a, b, sortBy, sortDesc, formatter, sortOptions, sortLocale, nullLast);
	          } // Negate result if sorting in descending order


	          return (result || 0) * (sortDesc ? -1 : 1);
	        });
	      }

	      return items;
	    }
	  },
	  watch: {
	    isSortable: function isSortable(newVal, oldVal)
	    /* istanbul ignore next: pain in the butt to test */
	    {
	      if (newVal) {
	        if (this.isSortable) {
	          this.$on('head-clicked', this.handleSort);
	        }
	      } else {
	        this.$off('head-clicked', this.handleSort);
	      }
	    },
	    sortDesc: function sortDesc(newVal, oldVal) {
	      if (newVal === this.localSortDesc) {
	        /* istanbul ignore next */
	        return;
	      }

	      this.localSortDesc = newVal || false;
	    },
	    sortBy: function sortBy(newVal, oldVal) {
	      if (newVal === this.localSortBy) {
	        /* istanbul ignore next */
	        return;
	      }

	      this.localSortBy = newVal || '';
	    },
	    // Update .sync props
	    localSortDesc: function localSortDesc(newVal, oldVal) {
	      // Emit update to sort-desc.sync
	      if (newVal !== oldVal) {
	        this.$emit('update:sortDesc', newVal);
	      }
	    },
	    localSortBy: function localSortBy(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        this.$emit('update:sortBy', newVal);
	      }
	    }
	  },
	  created: function created() {
	    if (this.isSortable) {
	      this.$on('head-clicked', this.handleSort);
	    }
	  },
	  methods: {
	    // Handlers
	    // Need to move from thead-mixin
	    handleSort: function handleSort(key, field, evt, isFoot) {
	      var _this = this;

	      if (!this.isSortable) {
	        /* istanbul ignore next */
	        return;
	      }

	      if (isFoot && this.noFooterSorting) {
	        return;
	      } // TODO: make this tri-state sorting
	      // cycle desc => asc => none => desc => ...


	      var sortChanged = false;

	      var toggleLocalSortDesc = function toggleLocalSortDesc() {
	        var sortDirection = field.sortDirection || _this.sortDirection;

	        if (sortDirection === 'asc') {
	          _this.localSortDesc = false;
	        } else if (sortDirection === 'desc') {
	          _this.localSortDesc = true;
	        }
	      };

	      if (field.sortable) {
	        if (key === this.localSortBy) {
	          // Change sorting direction on current column
	          this.localSortDesc = !this.localSortDesc;
	        } else {
	          // Start sorting this column ascending
	          this.localSortBy = key; // this.localSortDesc = false

	          toggleLocalSortDesc();
	        }

	        sortChanged = true;
	      } else if (this.localSortBy && !this.noSortReset) {
	        this.localSortBy = '';
	        toggleLocalSortDesc();
	        sortChanged = true;
	      }

	      if (sortChanged) {
	        // Sorting parameters changed
	        this.$emit('sort-changed', this.context);
	      }
	    },
	    // methods to compute classes and attrs for thead>th cells
	    sortTheadThClasses: function sortTheadThClasses(key, field, isFoot) {
	      return {
	        // If sortable and sortIconLeft are true, then place sort icon on the left
	        'b-table-sort-icon-left': field.sortable && this.sortIconLeft && !(isFoot && this.noFooterSorting)
	      };
	    },
	    sortTheadThAttrs: function sortTheadThAttrs(key, field, isFoot) {
	      if (!this.isSortable || isFoot && this.noFooterSorting) {
	        // No attributes if not a sortable table
	        return {};
	      }

	      var sortable = field.sortable;
	      var ariaLabel = '';

	      if ((!field.label || !field.label.trim()) && !field.headerTitle) {
	        // In case field's label and title are empty/blank, we need to
	        // add a hint about what the column is about for non-sighted users.
	        // This is duplicated code from tbody-row mixin, but we need it
	        // here as well, since we overwrite the original aria-label.

	        /* istanbul ignore next */
	        ariaLabel = startCase(key);
	      } // The correctness of these labels is very important for screen-reader users.


	      var ariaLabelSorting = '';

	      if (sortable) {
	        if (this.localSortBy === key) {
	          // currently sorted sortable column.
	          ariaLabelSorting = this.localSortDesc ? this.labelSortAsc : this.labelSortDesc;
	        } else {
	          // Not currently sorted sortable column.
	          // Not using nested ternary's here for clarity/readability
	          // Default for ariaLabel
	          ariaLabelSorting = this.localSortDesc ? this.labelSortDesc : this.labelSortAsc; // Handle sortDirection setting

	          var sortDirection = this.sortDirection || field.sortDirection;

	          if (sortDirection === 'asc') {
	            ariaLabelSorting = this.labelSortAsc;
	          } else if (sortDirection === 'desc') {
	            ariaLabelSorting = this.labelSortDesc;
	          }
	        }
	      } else if (!this.noSortReset) {
	        // Non sortable column
	        ariaLabelSorting = this.localSortBy ? this.labelSortClear : '';
	      } // Assemble the aria-label attribute value


	      ariaLabel = [ariaLabel.trim(), ariaLabelSorting.trim()].filter(Boolean).join(': '); // Assemble the aria-sort attribute value

	      var ariaSort = sortable && this.localSortBy === key ? this.localSortDesc ? 'descending' : 'ascending' : sortable ? 'none' : null; // Return the attributes
	      // (All the above just to get these two values)

	      return {
	        'aria-label': ariaLabel || null,
	        'aria-sort': ariaSort
	      };
	    }
	  }
	};

	var paginationMixin$1 = {
	  props: {
	    perPage: {
	      type: [Number, String],
	      default: 0
	    },
	    currentPage: {
	      type: [Number, String],
	      default: 1
	    }
	  },
	  computed: {
	    localPaging: function localPaging() {
	      return this.hasProvider ? !!this.noProviderPaging : true;
	    },
	    paginatedItems: function paginatedItems() {
	      var items = this.sortedItems || this.filteredItems || this.localItems || [];
	      var currentPage = Math.max(parseInt(this.currentPage, 10) || 1, 1);
	      var perPage = Math.max(parseInt(this.perPage, 10) || 0, 0); // Apply local pagination

	      if (this.localPaging && !!perPage) {
	        // Grab the current page of data (which may be past filtered items limit)
	        items = items.slice((currentPage - 1) * perPage, currentPage * perPage);
	      } // Return the items to display in the table


	      return items;
	    }
	  }
	};

	var captionMixin = {
	  props: {
	    // `caption-top` is part of table-redere mixin (styling)
	    // captionTop: {
	    //   type: Boolean,
	    //   default: false
	    // },
	    caption: {
	      type: String,
	      default: null
	    },
	    captionHtml: {
	      type: String
	    }
	  },
	  computed: {
	    captionId: function captionId() {
	      // Even though `this.safeId` looks like a method, it is a computed prop
	      // that returns a new function if the underlying ID changes
	      return this.isStacked ? this.safeId('_caption_') : null;
	    }
	  },
	  methods: {
	    renderCaption: function renderCaption() {
	      var h = this.$createElement; // Build the caption

	      var $captionSlot = this.normalizeSlot('table-caption');
	      var $caption = h();

	      if ($captionSlot || this.caption || this.captionHtml) {
	        var data = {
	          key: 'caption',
	          attrs: {
	            id: this.captionId
	          }
	        };

	        if (!$captionSlot) {
	          data.domProps = htmlOrText(this.captionHtml, this.caption);
	        }

	        $caption = h('caption', data, [$captionSlot]);
	      }

	      return $caption;
	    }
	  }
	};

	var colgroupMixin = {
	  methods: {
	    renderColgroup: function renderColgroup() {
	      var h = this.$createElement;
	      var fields = this.computedFields;
	      var $colgroup = h();

	      if (this.hasNormalizedSlot('table-colgroup')) {
	        $colgroup = h('colgroup', {
	          key: 'colgroup'
	        }, [this.normalizeSlot('table-colgroup', {
	          columns: fields.length,
	          fields: fields
	        })]);
	      }

	      return $colgroup;
	    }
	  }
	};

	var TABLE_TAG_NAMES = ['TD', 'TH', 'TR']; // Returns `true` if we should ignore the click/double-click/keypress event
	// Avoids having the user need to use `@click.stop` on the form control

	var filterEvent = function filterEvent(evt) {
	  // Exit early when we don't have a target element
	  if (!evt || !evt.target) {
	    /* istanbul ignore next */
	    return false;
	  }

	  var el = evt.target; // Exit early when element is disabled or a table element

	  if (el.disabled || TABLE_TAG_NAMES.indexOf(el.tagName) !== -1) {
	    return false;
	  } // Ignore the click when it was inside a dropdown menu


	  if (closest('.dropdown-menu', el)) {
	    return true;
	  }

	  var label = el.tagName === 'LABEL' ? el : closest('label', el); // If the label's form control is not disabled then we don't propagate event
	  // Modern browsers have `label.control` that references the associated input, but IE11
	  // does not have this property on the label element, so we resort to DOM lookups

	  if (label) {
	    var labelFor = getAttr(label, 'for');
	    var input = labelFor ? getById(labelFor) : select('input, select, textarea', label);

	    if (input && !input.disabled) {
	      return true;
	    }
	  } // Otherwise check if the event target matches one of the selectors in the
	  // event filter (i.e. anchors, non disabled inputs, etc.)
	  // Return `true` if we should ignore the event


	  return matches(el, EVENT_FILTER);
	};

	// Used to filter out click events caused by the mouse up at end of selection
	//
	// Accepts an element as only argument to test to see if selection overlaps or is
	// contained within the element

	var textSelectionActive = function textSelectionActive() {
	  var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
	  var sel = getSel();
	  return sel && sel.toString().trim() !== '' && sel.containsNode && isElement(el) ? sel.containsNode(el, true) : false;
	};

	function ownKeys$I(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$I(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$I(source, true).forEach(function (key) { _defineProperty$$(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$I(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$$(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$T = {
	  headVariant: {
	    // Also sniffed by <b-tr> / <b-td> / <b-th>
	    type: String,
	    // supported values: 'lite', 'dark', or null
	    default: null
	  }
	}; // @vue/component

	var BThead =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BThead',
	  mixins: [normalizeSlotMixin],
	  inheritAttrs: false,
	  provide: function provide() {
	    return {
	      bvTableRowGroup: this
	    };
	  },
	  inject: {
	    bvTable: {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      default: function _default()
	      /* istanbul ignore next */
	      {
	        return {};
	      }
	    }
	  },
	  props: props$T,
	  computed: {
	    isThead: function isThead() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return true;
	    },
	    isDark: function isDark() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.dark;
	    },
	    isStacked: function isStacked() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.isStacked;
	    },
	    isResponsive: function isResponsive() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.isResponsive;
	    },
	    isStickyHeader: function isStickyHeader() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      // Needed to handle header background classes, due to lack of
	      // background color inheritance with Bootstrap v4 table CSS
	      // Sticky headers only apply to cells in table `thead`
	      return !this.isStacked && this.bvTable.stickyHeader;
	    },
	    hasStickyHeader: function hasStickyHeader() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      // Needed to handle header background classes, due to lack of
	      // background color inheritance with Bootstrap v4 table CSS
	      return !this.isStacked && this.bvTable.stickyHeader;
	    },
	    tableVariant: function tableVariant() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.tableVariant;
	    },
	    theadClasses: function theadClasses() {
	      return [this.headVariant ? "thead-".concat(this.headVariant) : null];
	    },
	    theadAttrs: function theadAttrs() {
	      return _objectSpread$I({
	        role: 'rowgroup'
	      }, this.$attrs);
	    }
	  },
	  render: function render(h) {
	    return h('thead', {
	      class: this.theadClasses,
	      attrs: this.theadAttrs,
	      // Pass down any native listeners
	      on: this.$listeners
	    }, this.normalizeSlot('default', {}));
	  }
	});

	function ownKeys$J(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$J(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$J(source, true).forEach(function (key) { _defineProperty$10(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$J(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$10(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$U = {
	  footVariant: {
	    type: String,
	    // supported values: 'lite', 'dark', or null
	    default: null
	  }
	}; // @vue/component

	var BTfoot =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTfoot',
	  mixins: [normalizeSlotMixin],
	  inheritAttrs: false,
	  provide: function provide() {
	    return {
	      bvTableRowGroup: this
	    };
	  },
	  inject: {
	    bvTable: {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      default: function _default()
	      /* istanbul ignore next */
	      {
	        return {};
	      }
	    }
	  },
	  props: props$U,
	  computed: {
	    isTfoot: function isTfoot() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return true;
	    },
	    isDark: function isDark()
	    /* istanbul ignore next: Not currently sniffed in tests */
	    {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.dark;
	    },
	    isStacked: function isStacked() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.isStacked;
	    },
	    isResponsive: function isResponsive() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.isResponsive;
	    },
	    isStickyHeader: function isStickyHeader() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      // Sticky headers are only supported in thead
	      return false;
	    },
	    hasStickyHeader: function hasStickyHeader() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      // Needed to handle header background classes, due to lack of
	      // background color inheritance with Bootstrap v4 table CSS
	      return !this.isStacked && this.bvTable.stickyHeader;
	    },
	    tableVariant: function tableVariant()
	    /* istanbul ignore next: Not currently sniffed in tests */
	    {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.tableVariant;
	    },
	    tfootClasses: function tfootClasses() {
	      return [this.footVariant ? "thead-".concat(this.footVariant) : null];
	    },
	    tfootAttrs: function tfootAttrs() {
	      return _objectSpread$J({
	        role: 'rowgroup'
	      }, this.$attrs);
	    }
	  },
	  render: function render(h) {
	    return h('tfoot', {
	      class: this.tfootClasses,
	      attrs: this.tfootAttrs,
	      // Pass down any native listeners
	      on: this.$listeners
	    }, this.normalizeSlot('default', {}));
	  }
	});

	function ownKeys$K(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$K(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$K(source, true).forEach(function (key) { _defineProperty$11(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$K(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$11(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$V = {
	  variant: {
	    type: String,
	    default: null
	  }
	};
	var LIGHT = 'light';
	var DARK = 'dark'; // @vue/component

	var BTr =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTr',
	  mixins: [normalizeSlotMixin],
	  inheritAttrs: false,
	  provide: function provide() {
	    return {
	      bvTableTr: this
	    };
	  },
	  inject: {
	    bvTableRowGroup: {
	      defaut: function defaut()
	      /* istanbul ignore next */
	      {
	        return {};
	      }
	    }
	  },
	  props: props$V,
	  computed: {
	    inTbody: function inTbody() {
	      // Sniffed by <b-td> / <b-th>
	      return this.bvTableRowGroup.isTbody;
	    },
	    inThead: function inThead() {
	      // Sniffed by <b-td> / <b-th>
	      return this.bvTableRowGroup.isThead;
	    },
	    inTfoot: function inTfoot() {
	      // Sniffed by <b-td> / <b-th>
	      return this.bvTableRowGroup.isTfoot;
	    },
	    isDark: function isDark() {
	      // Sniffed by <b-td> / <b-th>
	      return this.bvTableRowGroup.isDark;
	    },
	    isStacked: function isStacked() {
	      // Sniffed by <b-td> / <b-th>
	      return this.bvTableRowGroup.isStacked;
	    },
	    isResponsive: function isResponsive() {
	      // Sniffed by <b-td> / <b-th>
	      return this.bvTableRowGroup.isResponsive;
	    },
	    isStickyHeader: function isStickyHeader() {
	      // Sniffed by <b-td> / <b-th>
	      // Sticky headers are only supported in thead
	      return this.bvTableRowGroup.isStickyHeader;
	    },
	    hasStickyHeader: function hasStickyHeader() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      // Needed to handle header background classes, due to lack of
	      // background color inheritance with Bootstrap v4 table CSS
	      return !this.isStacked && this.bvTableRowGroup.hasStickyHeader;
	    },
	    tableVariant: function tableVariant() {
	      // Sniffed by <b-td> / <b-th>
	      return this.bvTableRowGroup.tableVariant;
	    },
	    headVariant: function headVariant() {
	      // Sniffed by <b-td> / <b-th>
	      return this.inThead ? this.bvTableRowGroup.headVariant : null;
	    },
	    footVariant: function footVariant() {
	      // Sniffed by <b-td> / <b-th>
	      return this.inTfoot ? this.bvTableRowGroup.footVariant : null;
	    },
	    isRowDark: function isRowDark() {
	      return this.headVariant === LIGHT || this.footVariant === LIGHT ? false : this.headVariant === DARK || this.footVariant === DARK ? true : this.isDark;
	    },
	    trClasses: function trClasses() {
	      return [this.variant ? "".concat(this.isRowDark ? 'bg' : 'table', "-").concat(this.variant) : null];
	    },
	    trAttrs: function trAttrs() {
	      return _objectSpread$K({
	        role: 'row'
	      }, this.$attrs);
	    }
	  },
	  render: function render(h) {
	    return h('tr', {
	      class: this.trClasses,
	      attrs: this.trAttrs,
	      // Pass native listeners to child
	      on: this.$listeners
	    }, this.normalizeSlot('default', {}));
	  }
	});

	function ownKeys$L(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$L(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$L(source, true).forEach(function (key) { _defineProperty$12(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$L(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$12(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var digitsRx = /^\d+$/; // Parse a rowspan or colspan into a digit (or null if < 1 or NaN)

	var parseSpan = function parseSpan(val) {
	  val = parseInt(val, 10);
	  return digitsRx.test(String(val)) && val > 0 ? val : null;
	};
	/* istanbul ignore next */


	var spanValidator = function spanValidator(val) {
	  return isUndefinedOrNull(val) || parseSpan(val) > 0;
	};

	var props$W = {
	  variant: {
	    type: String,
	    default: null
	  },
	  colspan: {
	    type: [Number, String],
	    default: null,
	    validator: spanValidator
	  },
	  rowspan: {
	    type: [Number, String],
	    default: null,
	    validator: spanValidator
	  },
	  stackedHeading: {
	    type: String,
	    default: null
	  },
	  stickyColumn: {
	    type: Boolean,
	    default: false
	  }
	}; // @vue/component

	var BTd =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTableCell',
	  mixins: [normalizeSlotMixin],
	  inheritAttrs: false,
	  inject: {
	    bvTableTr: {
	      default: function _default()
	      /* istanbul ignore next */
	      {
	        return {};
	      }
	    }
	  },
	  props: props$W,
	  computed: {
	    tag: function tag() {
	      // Overridden by <b-th>
	      return 'td';
	    },
	    inTbody: function inTbody() {
	      return this.bvTableTr.inTbody;
	    },
	    inThead: function inThead() {
	      return this.bvTableTr.inThead;
	    },
	    inTfoot: function inTfoot() {
	      return this.bvTableTr.inTfoot;
	    },
	    isDark: function isDark() {
	      return this.bvTableTr.isDark;
	    },
	    isStacked: function isStacked() {
	      return this.bvTableTr.isStacked;
	    },
	    isStackedCell: function isStackedCell() {
	      // We only support stacked-heading in tbody in stacked mode
	      return this.inTbody && this.isStacked;
	    },
	    isResponsive: function isResponsive() {
	      return this.bvTableTr.isResponsive;
	    },
	    isStickyHeader: function isStickyHeader() {
	      // Needed to handle header background classes, due to lack of
	      // background color inheritance with Bootstrap v4 table CSS
	      // Sticky headers only apply to cells in table `thead`
	      return this.bvTableTr.isStickyHeader;
	    },
	    hasStickyHeader: function hasStickyHeader() {
	      // Needed to handle header background classes, due to lack of
	      // background color inheritance with Bootstrap v4 table CSS
	      return this.bvTableTr.hasStickyHeader;
	    },
	    isStickyColumn: function isStickyColumn() {
	      // Needed to handle background classes, due to lack of
	      // background color inheritance with Bootstrap v4 table CSS
	      // Sticky column cells are only available in responsive
	      // mode (horizontal scrolling) or when sticky header mode
	      // Applies to cells in `thead`, `tbody` and `tfoot`
	      return !this.isStacked && (this.isResponsive || this.hasStickyHeader) && this.stickyColumn;
	    },
	    rowVariant: function rowVariant() {
	      return this.bvTableTr.variant;
	    },
	    headVariant: function headVariant() {
	      return this.bvTableTr.headVariant;
	    },
	    footVariant: function footVariant()
	    /* istanbul ignore next: need to add in tests for footer variant */
	    {
	      return this.bvTableTr.footVariant;
	    },
	    tableVariant: function tableVariant() {
	      return this.bvTableTr.tableVariant;
	    },
	    computedColspan: function computedColspan() {
	      return parseSpan(this.colspan);
	    },
	    computedRowspan: function computedRowspan() {
	      return parseSpan(this.rowspan);
	    },
	    cellClasses: function cellClasses() {
	      // We use computed props here for improved performance by caching
	      // the results of the string interpolation
	      // TODO: need to add handling for footVariant
	      var variant = this.variant;

	      if (!variant && this.isStickyHeader && !this.headVariant || !variant && this.isStickyColumn) {
	        // Needed for sticky-header mode as Bootstrap v4 table cells do
	        // not inherit parent's background-color. Boo!
	        variant = this.rowVariant || this.tableVariant || 'b-table-default';
	      }

	      return [variant ? "".concat(this.isDark ? 'bg' : 'table', "-").concat(variant) : null, this.isStickyColumn ? 'b-table-sticky-column' : null];
	    },
	    cellAttrs: function cellAttrs() {
	      // We use computed props here for improved performance by caching
	      // the results of the object spread (Object.assign)
	      var headOrFoot = this.inThead || this.inTfoot; // Make sure col/rowspan's are > 0 or null

	      var colspan = this.computedColspan;
	      var rowspan = this.computedRowspan; // Default role and scope

	      var role = 'cell';
	      var scope = null; // Compute role and scope
	      // We only add scopes with an explicit span of 1 or greater

	      if (headOrFoot) {
	        // Header or footer cells
	        role = 'columnheader';
	        scope = colspan > 0 ? 'colspan' : 'col';
	      } else if (this.tag === 'th') {
	        // th's in tbody
	        role = 'rowheader';
	        scope = rowspan > 0 ? 'rowgroup' : 'row';
	      }

	      return _objectSpread$L({
	        colspan: colspan,
	        rowspan: rowspan,
	        role: role,
	        scope: scope
	      }, this.$attrs, {
	        // Add in the stacked cell label data-attribute if in
	        // stacked mode (if a stacked heading label is provided)
	        'data-label': this.isStackedCell && !isUndefinedOrNull(this.stackedHeading) ? toString$3(this.stackedHeading) : null
	      });
	    }
	  },
	  render: function render(h) {
	    var content = [this.normalizeSlot('default')];
	    return h(this.tag, {
	      class: this.cellClasses,
	      attrs: this.cellAttrs,
	      // Transfer any native listeners
	      on: this.$listeners
	    }, [this.isStackedCell ? h('div', [content]) : content]);
	  }
	});

	var BTh =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTh',
	  extends: BTd,
	  computed: {
	    tag: function tag() {
	      return 'th';
	    }
	  }
	});

	function _toConsumableArray$6(arr) { return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _nonIterableSpread$6(); }

	function _nonIterableSpread$6() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray$6(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") { return Array.from(iter); } }

	function _arrayWithoutHoles$6(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function ownKeys$M(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$M(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$M(source, true).forEach(function (key) { _defineProperty$13(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$M(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$13(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var theadMixin = {
	  props: {
	    headVariant: {
	      type: String,
	      // 'light', 'dark' or `null` (or custom)
	      default: function _default() {
	        return getComponentConfig('BTable', 'headVariant');
	      }
	    },
	    headRowVariant: {
	      type: String,
	      // Any Bootstrap theme variant (or custom)
	      default: null
	    },
	    theadClass: {
	      type: [String, Array, Object] // default: undefined

	    },
	    theadTrClass: {
	      type: [String, Array, Object] // default: undefined

	    }
	  },
	  methods: {
	    fieldClasses: function fieldClasses(field) {
	      // Header field (<th>) classes
	      return [field.class ? field.class : '', field.thClass ? field.thClass : ''];
	    },
	    headClicked: function headClicked(evt, field, isFoot) {
	      if (this.stopIfBusy && this.stopIfBusy(evt)) {
	        // If table is busy (via provider) then don't propagate
	        return;
	      } else if (filterEvent(evt)) {
	        // Clicked on a non-disabled control so ignore
	        return;
	      } else if (textSelectionActive(this.$el)) {
	        // User is selecting text, so ignore

	        /* istanbul ignore next: JSDOM doesn't support getSelection() */
	        return;
	      }

	      evt.stopPropagation();
	      evt.preventDefault();
	      this.$emit('head-clicked', field.key, field, evt, isFoot);
	    },
	    renderThead: function renderThead() {
	      var _this = this;

	      var isFoot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      var h = this.$createElement;
	      var fields = this.computedFields || [];

	      if (this.isStackedAlways || fields.length === 0) {
	        // In always stacked mode, we don't bother rendering the head/foot
	        // Or if no field headings (empty table)
	        return h();
	      } // Reference to `selectAllRows` and `clearSelected()`, if table is selectable


	      var selectAllRows = this.isSelectable ? this.selectAllRows : function () {};
	      var clearSelected = this.isSelectable ? this.clearSelected : function () {}; // Helper function to generate a field <th> cell

	      var makeCell = function makeCell(field, colIndex) {
	        var ariaLabel = null;

	        if (!field.label.trim() && !field.headerTitle) {
	          // In case field's label and title are empty/blank
	          // We need to add a hint about what the column is about for non-sighted users

	          /* istanbul ignore next */
	          ariaLabel = startCase(field.key);
	        }

	        var hasHeadClickListener = _this.$listeners['head-clicked'] || _this.isSortable;
	        var handlers = {};

	        if (hasHeadClickListener) {
	          handlers.click = function (evt) {
	            _this.headClicked(evt, field, isFoot);
	          };

	          handlers.keydown = function (evt) {
	            var keyCode = evt.keyCode;

	            if (keyCode === KEY_CODES.ENTER || keyCode === KEY_CODES.SPACE) {
	              _this.headClicked(evt, field, isFoot);
	            }
	          };
	        }

	        var sortAttrs = _this.isSortable ? _this.sortTheadThAttrs(field.key, field, isFoot) : {};
	        var sortClass = _this.isSortable ? _this.sortTheadThClasses(field.key, field, isFoot) : null;
	        var data = {
	          key: field.key,
	          class: [_this.fieldClasses(field), sortClass],
	          props: {
	            variant: field.variant,
	            stickyColumn: field.stickyColumn
	          },
	          style: field.thStyle || {},
	          attrs: _objectSpread$M({
	            // We only add a tabindex of 0 if there is a head-clicked listener
	            tabindex: hasHeadClickListener ? '0' : null,
	            abbr: field.headerAbbr || null,
	            title: field.headerTitle || null,
	            'aria-colindex': String(colIndex + 1),
	            'aria-label': ariaLabel
	          }, _this.getThValues(null, field.key, field.thAttr, isFoot ? 'foot' : 'head', {}), {}, sortAttrs),
	          on: handlers
	        }; // Handle edge case where in-document templates are used with new
	        // `v-slot:name` syntax where the browser lower-cases the v-slot's
	        // name (attributes become lower cased when parsed by the browser)
	        // We have replaced the square bracket syntax with round brackets
	        // to prevent confusion with dynamic slot names

	        var slotNames = ["head(".concat(field.key, ")"), "head(".concat(field.key.toLowerCase(), ")"), 'head()'];

	        if (isFoot) {
	          // Footer will fallback to header slot names
	          slotNames = ["foot(".concat(field.key, ")"), "foot(".concat(field.key.toLowerCase(), ")"), 'foot()'].concat(_toConsumableArray$6(slotNames));
	        }

	        var hasSlot = _this.hasNormalizedSlot(slotNames);

	        var slot = field.label;

	        if (hasSlot) {
	          slot = _this.normalizeSlot(slotNames, {
	            label: field.label,
	            column: field.key,
	            field: field,
	            isFoot: isFoot,
	            // Add in row select methods
	            selectAllRows: selectAllRows,
	            clearSelected: clearSelected
	          });
	        } else {
	          data.domProps = htmlOrText(field.labelHtml);
	        }

	        return h(BTh, data, slot);
	      }; // Generate the array of <th> cells


	      var $cells = fields.map(makeCell).filter(function (th) {
	        return th;
	      }); // Genrate the row(s)

	      var $trs = [];

	      if (isFoot) {
	        var trProps = {
	          variant: isUndefinedOrNull(this.footRowVariant) ? this.headRowVariant : this.footRowVariant
	        };
	        $trs.push(h(BTr, {
	          class: this.tfootTrClass,
	          props: trProps
	        }, $cells));
	      } else {
	        var scope = {
	          columns: fields.length,
	          fields: fields,
	          // Add in row select methods
	          selectAllRows: selectAllRows,
	          clearSelected: clearSelected
	        };
	        $trs.push(this.normalizeSlot('thead-top', scope) || h());
	        $trs.push(h(BTr, {
	          class: this.theadTrClass,
	          props: {
	            variant: this.headRowVariant
	          }
	        }, $cells));
	      }

	      return h(isFoot ? BTfoot : BThead, {
	        key: isFoot ? 'bv-tfoot' : 'bv-thead',
	        class: (isFoot ? this.tfootClass : this.theadClass) || null,
	        props: isFoot ? {
	          footVariant: this.footVariant || this.headVariant || null
	        } : {
	          headVariant: this.headVariant || null
	        }
	      }, $trs);
	    }
	  }
	};

	var tfootMixin = {
	  props: {
	    footClone: {
	      type: Boolean,
	      default: false
	    },
	    footVariant: {
	      type: String,
	      // 'dark', 'light', or `null` (or custom)
	      default: function _default() {
	        return getComponentConfig('BTable', 'footVariant');
	      }
	    },
	    footRowVariant: {
	      type: String,
	      // Any Bootstrap theme variant (or custom). Falls back to `headRowVariant`
	      default: null
	    },
	    tfootClass: {
	      type: [String, Array, Object],
	      default: null
	    },
	    tfootTrClass: {
	      type: [String, Array, Object],
	      default: null
	    }
	  },
	  methods: {
	    renderTFootCustom: function renderTFootCustom() {
	      var h = this.$createElement;

	      if (this.hasNormalizedSlot('custom-foot')) {
	        return h(BTfoot, {
	          key: 'bv-tfoot-custom',
	          class: this.tfootClass || null,
	          props: {
	            footVariant: this.footVariant || this.headVariant || null
	          }
	        }, this.normalizeSlot('custom-foot', {
	          items: this.computedItems.slice(),
	          fields: this.computedFields.slice(),
	          columns: this.computedFields.length
	        }));
	      } else {
	        return h();
	      }
	    },
	    renderTfoot: function renderTfoot() {
	      // Passing true to renderThead will make it render a tfoot
	      return this.footClone ? this.renderThead(true) : this.renderTFootCustom();
	    }
	  }
	};

	function ownKeys$N(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$N(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$N(source, true).forEach(function (key) { _defineProperty$14(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$N(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$14(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var props$X = {
	  tbodyTransitionProps: {
	    type: Object // default: undefined

	  },
	  tbodyTransitionHandlers: {
	    type: Object // default: undefined

	  }
	}; // @vue/component

	var BTbody =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTbody',
	  mixins: [normalizeSlotMixin],
	  inheritAttrs: false,
	  provide: function provide() {
	    return {
	      bvTableRowGroup: this
	    };
	  },
	  inject: {
	    bvTable: {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      default: function _default()
	      /* istanbul ignore next */
	      {
	        return {};
	      }
	    }
	  },
	  props: props$X,
	  computed: {
	    isTbody: function isTbody() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return true;
	    },
	    isDark: function isDark() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.dark;
	    },
	    isStacked: function isStacked() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.isStacked;
	    },
	    isResponsive: function isResponsive() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.isResponsive;
	    },
	    isStickyHeader: function isStickyHeader() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      // Sticky headers are only supported in thead
	      return false;
	    },
	    hasStickyHeader: function hasStickyHeader() {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      // Needed to handle header background classes, due to lack of
	      // background color inheritance with Bootstrap v4 table CSS
	      return !this.isStacked && this.bvTable.stickyHeader;
	    },
	    tableVariant: function tableVariant()
	    /* istanbul ignore next: Not currently sniffed in tests */
	    {
	      // Sniffed by <b-tr> / <b-td> / <b-th>
	      return this.bvTable.tableVariant;
	    },
	    isTransitionGroup: function isTransitionGroup() {
	      return this.tbodyTransitionProps || this.tbodyTransitionHandlers;
	    },
	    tbodyAttrs: function tbodyAttrs() {
	      return _objectSpread$N({
	        role: 'rowgroup'
	      }, this.$attrs);
	    },
	    tbodyProps: function tbodyProps() {
	      return this.tbodyTransitionProps ? _objectSpread$N({}, this.tbodyTransitionProps, {
	        tag: 'tbody'
	      }) : {};
	    }
	  },
	  render: function render(h) {
	    var data = {
	      props: this.tbodyProps,
	      attrs: this.tbodyAttrs
	    };

	    if (this.isTransitionGroup) {
	      // We use native listeners if a transition group
	      // for any delegated events
	      data.on = this.tbodyTransitionHandlers || {};
	      data.nativeOn = this.$listeners || {};
	    } else {
	      // Otherwise we place any listeners on the tbody element
	      data.on = this.$listeners || {};
	    }

	    return h(this.isTransitionGroup ? 'transition-group' : 'tbody', data, this.normalizeSlot('default', {}));
	  }
	});

	function ownKeys$O(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$O(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$O(source, true).forEach(function (key) { _defineProperty$15(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$O(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$15(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var detailsSlotName = 'row-details';
	var tbodyRowMixin = {
	  props: {
	    tbodyTrClass: {
	      type: [String, Array, Object, Function],
	      default: null
	    },
	    detailsTdClass: {
	      type: [String, Array, Object],
	      default: null
	    }
	  },
	  methods: {
	    // Methods for computing classes, attributes and styles for table cells
	    getTdValues: function getTdValues(item, key, tdValue, defValue) {
	      var parent = this.$parent;

	      if (tdValue) {
	        var value = get$1(item, key, '');

	        if (isFunction(tdValue)) {
	          return tdValue(value, key, item);
	        } else if (isString(tdValue) && isFunction(parent[tdValue])) {
	          return parent[tdValue](value, key, item);
	        }

	        return tdValue;
	      }

	      return defValue;
	    },
	    getThValues: function getThValues(item, key, thValue, type, defValue) {
	      var parent = this.$parent;

	      if (thValue) {
	        var value = get$1(item, key, '');

	        if (isFunction(thValue)) {
	          return thValue(value, key, item, type);
	        } else if (isString(thValue) && isFunction(parent[thValue])) {
	          return parent[thValue](value, key, item, type);
	        }

	        return thValue;
	      }

	      return defValue;
	    },
	    // Method to get the value for a field
	    getFormattedValue: function getFormattedValue(item, field) {
	      var key = field.key;
	      var formatter = this.getFieldFormatter(key);
	      var value = get$1(item, key, null);

	      if (isFunction(formatter)) {
	        value = formatter(value, key, item);
	      }

	      return isUndefinedOrNull(value) ? '' : value;
	    },
	    // Factory function methods
	    toggleDetailsFactory: function toggleDetailsFactory(hasDetailsSlot, item) {
	      var _this = this;

	      // Returns a function to toggle a row's details slot
	      return function () {
	        if (hasDetailsSlot) {
	          _this.$set(item, '_showDetails', !item._showDetails);
	        }
	      };
	    },
	    // Row event handlers
	    rowHovered: function rowHovered(evt) {
	      // `mouseenter` handler (non-bubbling)
	      // `this.tbodyRowEvtStopped` from tbody mixin
	      if (!this.tbodyRowEvtStopped(evt)) {
	        // `this.emitTbodyRowEvent` from tbody mixin
	        this.emitTbodyRowEvent('row-hovered', evt);
	      }
	    },
	    rowUnhovered: function rowUnhovered(evt) {
	      // `mouseleave` handler (non-bubbling)
	      // `this.tbodyRowEvtStopped` from tbody mixin
	      if (!this.tbodyRowEvtStopped(evt)) {
	        // `this.emitTbodyRowEvent` from tbody mixin
	        this.emitTbodyRowEvent('row-unhovered', evt);
	      }
	    },
	    // Render helpers
	    renderTbodyRowCell: function renderTbodyRowCell(field, colIndex, item, rowIndex) {
	      var _this2 = this;

	      // Renders a TD or TH for a row's field
	      var h = this.$createElement;
	      var hasDetailsSlot = this.hasNormalizedSlot(detailsSlotName);
	      var formatted = this.getFormattedValue(item, field);
	      var key = field.key;
	      var stickyColumn = !this.isStacked && (this.isResponsive || this.stickyHeader) && field.stickyColumn; // We only uses the helper components for sticky columns to
	      // improve performance of BTable/BTableLite by reducing the
	      // total number of vue instances created during render

	      var cellTag = stickyColumn ? field.isRowHeader ? BTh : BTd : field.isRowHeader ? 'th' : 'td';
	      var cellVariant = item._cellVariants && item._cellVariants[key] ? item._cellVariants[key] : field.variant || null;
	      var data = {
	        // For the Vue key, we concatenate the column index and
	        // field key (as field keys could be duplicated)
	        // TODO: Although we do prevent duplicate field keys...
	        //   So we could change this to: `row-${rowIndex}-cell-${key}`
	        key: "row-".concat(rowIndex, "-cell-").concat(colIndex, "-").concat(key),
	        class: [field.class ? field.class : '', this.getTdValues(item, key, field.tdClass, '')],
	        props: {},
	        attrs: _objectSpread$O({
	          'aria-colindex': String(colIndex + 1)
	        }, field.isRowHeader ? this.getThValues(item, key, field.thAttr, 'row', {}) : this.getTdValues(item, key, field.tdAttr, {}))
	      };

	      if (stickyColumn) {
	        // We are using the helper BTd or BTh
	        data.props = {
	          stackedHeading: this.isStacked ? field.label : null,
	          stickyColumn: true,
	          variant: cellVariant
	        };
	      } else {
	        // Using native TD or TH element, so we need to
	        // add in the attributes and variant class
	        data.attrs['data-label'] = this.isStacked && !isUndefinedOrNull(field.label) ? toString$3(field.label) : null;
	        data.attrs.role = field.isRowHeader ? 'rowheader' : 'cell';
	        data.attrs.scope = field.isRowHeader ? 'row' : null; // Add in the variant class

	        if (cellVariant) {
	          data.class.push("".concat(this.dark ? 'bg' : 'table', "-").concat(cellVariant));
	        }
	      }

	      var slotScope = {
	        item: item,
	        index: rowIndex,
	        field: field,
	        unformatted: get$1(item, key, ''),
	        value: formatted,
	        toggleDetails: this.toggleDetailsFactory(hasDetailsSlot, item),
	        detailsShowing: Boolean(item._showDetails)
	      }; // If table supports selectable mode, then add in the following scope
	      // this.supportsSelectableRows will be undefined if mixin isn't loaded

	      if (this.supportsSelectableRows) {
	        slotScope.rowSelected = this.isRowSelected(rowIndex);

	        slotScope.selectRow = function () {
	          return _this2.selectRow(rowIndex);
	        };

	        slotScope.unselectRow = function () {
	          return _this2.unselectRow(rowIndex);
	        };
	      } // The new `v-slot` syntax doesn't like a slot name starting with
	      // a square bracket and if using in-document HTML templates, the
	      // v-slot attributes are lower-cased by the browser.
	      // Switched to round bracket syntax to prevent confusion with
	      // dynamic slot name syntax.
	      // We look for slots in this order: `cell(${key})`, `cell(${key.toLowerCase()})`, 'cell()'
	      // Slot names are now cached by mixin tbody in `this.$_bodyFieldSlotNameCache`
	      // Will be `null` if no slot (or fallback slot) exists


	      var slotName = this.$_bodyFieldSlotNameCache[key];
	      var $childNodes = slotName ? this.normalizeSlot(slotName, slotScope) : toString$3(formatted);

	      if (this.isStacked) {
	        // We wrap in a DIV to ensure rendered as a single cell when visually stacked!
	        $childNodes = [h('div', {}, [$childNodes])];
	      } // Render either a td or th cell


	      return h(cellTag, data, [$childNodes]);
	    },
	    renderTbodyRow: function renderTbodyRow(item, rowIndex) {
	      var _this3 = this;

	      // Renders an item's row (or rows if details supported)
	      var h = this.$createElement;
	      var fields = this.computedFields;
	      var tableStriped = this.striped;
	      var hasDetailsSlot = this.hasNormalizedSlot(detailsSlotName);
	      var rowShowDetails = Boolean(item._showDetails && hasDetailsSlot);
	      var hasRowClickHandler = this.$listeners['row-clicked'] || this.hasSelectableRowClick; // We can return more than one TR if rowDetails enabled

	      var $rows = []; // Details ID needed for `aria-details` when details showing
	      // We set it to `null` when not showing so that attribute
	      // does not appear on the element

	      var detailsId = rowShowDetails ? this.safeId("_details_".concat(rowIndex, "_")) : null; // For each item data field in row

	      var $tds = fields.map(function (field, colIndex) {
	        return _this3.renderTbodyRowCell(field, colIndex, item, rowIndex);
	      }); // Calculate the row number in the dataset (indexed from 1)

	      var ariaRowIndex = null;

	      if (this.currentPage && this.perPage && this.perPage > 0) {
	        ariaRowIndex = String((this.currentPage - 1) * this.perPage + rowIndex + 1);
	      } // Create a unique :key to help ensure that sub components are re-rendered rather than
	      // re-used, which can cause issues. If a primary key is not provided we use the rendered
	      // rows index within the tbody.
	      // See: https://github.com/bootstrap-vue/bootstrap-vue/issues/2410


	      var primaryKey = this.primaryKey;
	      var primaryKeyValue = toString$3(get$1(item, primaryKey)) || null;
	      var rowKey = primaryKeyValue || String(rowIndex); // If primary key is provided, use it to generate a unique ID on each tbody > tr
	      // In the format of '{tableId}__row_{primaryKeyValue}'

	      var rowId = primaryKeyValue ? this.safeId("_row_".concat(primaryKeyValue)) : null; // Selectable classes and attributes

	      var selectableClasses = this.selectableRowClasses ? this.selectableRowClasses(rowIndex) : {};
	      var selectableAttrs = this.selectableRowAttrs ? this.selectableRowAttrs(rowIndex) : {}; // Add the item row

	      $rows.push(h(BTr, {
	        key: "__b-table-row-".concat(rowKey, "__"),
	        ref: 'itemRows',
	        refInFor: true,
	        class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(item, 'row') : this.tbodyTrClass, selectableClasses, rowShowDetails ? 'b-table-has-details' : ''],
	        props: {
	          variant: item._rowVariant || null
	        },
	        attrs: _objectSpread$O({
	          id: rowId,
	          tabindex: hasRowClickHandler ? '0' : null,
	          'data-pk': primaryKeyValue || null,
	          'aria-details': detailsId,
	          'aria-owns': detailsId,
	          'aria-rowindex': ariaRowIndex
	        }, selectableAttrs),
	        on: {
	          // Note: These events are not A11Y friendly!
	          mouseenter: this.rowHovered,
	          mouseleave: this.rowUnhovered
	        }
	      }, $tds)); // Row Details slot

	      if (rowShowDetails) {
	        var detailsScope = {
	          item: item,
	          index: rowIndex,
	          fields: fields,
	          toggleDetails: this.toggleDetailsFactory(hasDetailsSlot, item)
	        }; // If table supports selectable mode, then add in the following scope
	        // this.supportsSelectableRows will be undefined if mixin isn't loaded

	        if (this.supportsSelectableRows) {
	          detailsScope.rowSelected = this.isRowSelected(rowIndex);

	          detailsScope.selectRow = function () {
	            return _this3.selectRow(rowIndex);
	          };

	          detailsScope.unselectRow = function () {
	            return _this3.unselectRow(rowIndex);
	          };
	        } // Render the details slot in a TD


	        var $details = h(BTd, {
	          props: {
	            colspan: fields.length
	          },
	          class: this.detailsTdClass
	        }, [this.normalizeSlot(detailsSlotName, detailsScope)]); // Add a hidden row to keep table row striping consistent when details showing
	        // Only added if the table is striped

	        if (tableStriped) {
	          $rows.push( // We don't use `BTr` here as we don't need the extra functionality
	          h('tr', {
	            key: "__b-table-details-stripe__".concat(rowKey),
	            staticClass: 'd-none',
	            attrs: {
	              'aria-hidden': 'true',
	              role: 'presentation'
	            }
	          }));
	        } // Add the actual details row


	        $rows.push(h(BTr, {
	          key: "__b-table-details__".concat(rowKey),
	          staticClass: 'b-table-details',
	          class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(item, detailsSlotName) : this.tbodyTrClass],
	          props: {
	            variant: item._rowVariant || null
	          },
	          attrs: {
	            id: detailsId,
	            tabindex: '-1'
	          }
	        }, [$details]));
	      } else if (hasDetailsSlot) {
	        // Only add the placeholder if a the table has a row-details slot defined (but not shown)
	        $rows.push(h());

	        if (tableStriped) {
	          // Add extra placeholder if table is striped
	          $rows.push(h());
	        }
	      } // Return the row(s)


	      return $rows;
	    }
	  }
	};

	function ownKeys$P(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$P(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$P(source, true).forEach(function (key) { _defineProperty$16(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$P(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$16(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var props$Y = _objectSpread$P({}, props$X, {
	  tbodyClass: {
	    type: [String, Array, Object] // default: undefined

	  }
	});

	var tbodyMixin = {
	  mixins: [tbodyRowMixin],
	  props: props$Y,
	  methods: {
	    // Helper methods
	    getTbodyTrs: function getTbodyTrs() {
	      // Returns all the item TR elements (excludes detail and spacer rows)
	      // `this.$refs.itemRows` is an array of item TR components/elements
	      // Rows should all be B-TR components, but we map to TR elements
	      // Also note that `this.$refs.itemRows` may not always be in document order
	      var tbody = this.$refs.tbody.$el || this.$refs.tbody;
	      var trs = (this.$refs.itemRows || []).map(function (tr) {
	        return tr.$el || tr;
	      }); // TODO: This may take time for tables many rows, so we may want to cache
	      //       the result of this during each render cycle on a non-reactive
	      //       property. We clear out the cache as each render starts, and
	      //       populate it on first access of this method if null

	      return from(tbody.children).filter(function (tr) {
	        return arrayIncludes(trs, tr);
	      });
	    },
	    getTbodyTrIndex: function getTbodyTrIndex(el) {
	      // Returns index of a particular TBODY item TR
	      // We set `true` on closest to include self in result

	      /* istanbul ignore next: should not normally happen */
	      if (!isElement(el)) {
	        return -1;
	      }

	      var tr = el.tagName === 'TR' ? el : closest('tr', el, true);
	      return tr ? this.getTbodyTrs().indexOf(tr) : -1;
	    },
	    emitTbodyRowEvent: function emitTbodyRowEvent(type, evt) {
	      // Emits a row event, with the item object, row index and original event
	      if (type && evt && evt.target) {
	        var rowIndex = this.getTbodyTrIndex(evt.target);

	        if (rowIndex > -1) {
	          // The array of TRs correlate to the `computedItems` array
	          var item = this.computedItems[rowIndex];
	          this.$emit(type, item, rowIndex, evt);
	        }
	      }
	    },
	    tbodyRowEvtStopped: function tbodyRowEvtStopped(evt) {
	      return this.stopIfBusy && this.stopIfBusy(evt);
	    },
	    // Delegated row event handlers
	    onTbodyRowKeydown: function onTbodyRowKeydown(evt) {
	      // Keyboard navigation and row click emulation
	      var target = evt.target;

	      if (this.tbodyRowEvtStopped(evt) || target.tagName !== 'TR' || target !== document.activeElement || target.tabIndex !== 0) {
	        // Early exit if not an item row TR
	        return;
	      }

	      var keyCode = evt.keyCode;

	      if (arrayIncludes([KEY_CODES.ENTER, KEY_CODES.SPACE], keyCode)) {
	        // Emulated click for keyboard users, transfer to click handler
	        evt.stopPropagation();
	        evt.preventDefault();
	        this.onTBodyRowClicked(evt);
	      } else if (arrayIncludes([KEY_CODES.UP, KEY_CODES.DOWN, KEY_CODES.HOME, KEY_CODES.END], keyCode)) {
	        // Keyboard navigation
	        var rowIndex = this.getTbodyTrIndex(target);

	        if (rowIndex > -1) {
	          evt.stopPropagation();
	          evt.preventDefault();
	          var trs = this.getTbodyTrs();
	          var shift = evt.shiftKey;

	          if (keyCode === KEY_CODES.HOME || shift && keyCode === KEY_CODES.UP) {
	            // Focus first row
	            trs[0].focus();
	          } else if (keyCode === KEY_CODES.END || shift && keyCode === KEY_CODES.DOWN) {
	            // Focus last row
	            trs[trs.length - 1].focus();
	          } else if (keyCode === KEY_CODES.UP && rowIndex > 0) {
	            // Focus previous row
	            trs[rowIndex - 1].focus();
	          } else if (keyCode === KEY_CODES.DOWN && rowIndex < trs.length - 1) {
	            // Focus next row
	            trs[rowIndex + 1].focus();
	          }
	        }
	      }
	    },
	    onTBodyRowClicked: function onTBodyRowClicked(evt) {
	      if (this.tbodyRowEvtStopped(evt)) {
	        // If table is busy, then don't propagate
	        return;
	      } else if (filterEvent(evt) || textSelectionActive(this.$el)) {
	        // Clicked on a non-disabled control so ignore
	        // Or user is selecting text, so ignore
	        return;
	      }

	      this.emitTbodyRowEvent('row-clicked', evt);
	    },
	    onTbodyRowMiddleMouseRowClicked: function onTbodyRowMiddleMouseRowClicked(evt) {
	      if (!this.tbodyRowEvtStopped(evt) && evt.which === 2) {
	        this.emitTbodyRowEvent('row-middle-clicked', evt);
	      }
	    },
	    onTbodyRowContextmenu: function onTbodyRowContextmenu(evt) {
	      if (!this.tbodyRowEvtStopped(evt)) {
	        this.emitTbodyRowEvent('row-contextmenu', evt);
	      }
	    },
	    onTbodyRowDblClicked: function onTbodyRowDblClicked(evt) {
	      if (!this.tbodyRowEvtStopped(evt) && !filterEvent(evt)) {
	        this.emitTbodyRowEvent('row-dblclicked', evt);
	      }
	    },
	    // Note: Row hover handlers are handled by the tbody-row mixin
	    // As mouseenter/mouseleave events do not bubble
	    //
	    // Render Helper
	    renderTbody: function renderTbody() {
	      var _this = this;

	      // Render the tbody element and children
	      var items = this.computedItems; // Shortcut to `createElement` (could use `this._c()` instead)

	      var h = this.$createElement;
	      var hasRowClickHandler = this.$listeners['row-clicked'] || this.hasSelectableRowClick; // Prepare the tbody rows

	      var $rows = []; // Add the item data rows or the busy slot

	      var $busy = this.renderBusy ? this.renderBusy() : null;

	      if ($busy) {
	        // If table is busy and a busy slot, then return only the busy "row" indicator
	        $rows.push($busy);
	      } else {
	        // Table isn't busy, or we don't have a busy slot
	        // Create a slot cache for improved performance when looking up cell slot names
	        // Values will be keyed by the field's `key` and will store the slot's name
	        // Slots could be dynamic (i.e. `v-if`), so we must compute on each render
	        // Used by tbody-row mixin render helper
	        var cache = {};
	        var defaultSlotName = this.hasNormalizedSlot('cell()') ? 'cell()' : null;
	        this.computedFields.forEach(function (field) {
	          var key = field.key;
	          var fullName = "cell(".concat(key, ")");
	          var lowerName = "cell(".concat(key.toLowerCase(), ")");
	          cache[key] = _this.hasNormalizedSlot(fullName) ? fullName : _this.hasNormalizedSlot(lowerName) ? lowerName : defaultSlotName;
	        }); // Created as a non-reactive property so to not trigger component updates
	        // Must be a fresh object each render

	        this.$_bodyFieldSlotNameCache = cache; // Add static top row slot (hidden in visibly stacked mode
	        // as we can't control `data-label` attr)

	        $rows.push(this.renderTopRow ? this.renderTopRow() : h()); // Render the rows

	        items.forEach(function (item, rowIndex) {
	          // Render the individual item row (rows if details slot)
	          $rows.push(_this.renderTbodyRow(item, rowIndex));
	        }); // Empty items / empty filtered row slot (only shows if `items.length < 1`)

	        $rows.push(this.renderEmpty ? this.renderEmpty() : h()); // Static bottom row slot (hidden in visibly stacked mode
	        // as we can't control `data-label` attr)

	        $rows.push(this.renderBottomRow ? this.renderBottomRow() : h());
	      }

	      var handlers = {
	        // TODO: We may want to to only instantiate these handlers
	        //       if there is an event listener registered
	        auxclick: this.onTbodyRowMiddleMouseRowClicked,
	        // TODO: Perhaps we do want to automatically prevent the
	        //       default context menu from showing if there is
	        //       a `row-contextmenu` listener registered.
	        contextmenu: this.onTbodyRowContextmenu,
	        // The following event(s) is not considered A11Y friendly
	        dblclick: this.onTbodyRowDblClicked // hover events (mouseenter/mouseleave) ad handled by tbody-row mixin

	      };

	      if (hasRowClickHandler) {
	        handlers.click = this.onTBodyRowClicked;
	        handlers.keydown = this.onTbodyRowKeydown;
	      } // Assemble rows into the tbody


	      var $tbody = h(BTbody, {
	        ref: 'tbody',
	        class: this.tbodyClass || null,
	        props: {
	          tbodyTransitionProps: this.tbodyTransitionProps,
	          tbodyTransitionHandlers: this.tbodyTransitionHandlers
	        },
	        // BTbody transfers all native event listeners to the root element
	        // TODO: Only set the handlers if the table is not busy
	        on: handlers
	      }, $rows); // Return the assembled tbody

	      return $tbody;
	    }
	  }
	};

	var emptyMixin = {
	  props: {
	    showEmpty: {
	      type: Boolean,
	      default: false
	    },
	    emptyText: {
	      type: String,
	      default: 'There are no records to show'
	    },
	    emptyHtml: {
	      type: String
	    },
	    emptyFilteredText: {
	      type: String,
	      default: 'There are no records matching your request'
	    },
	    emptyFilteredHtml: {
	      type: String
	    }
	  },
	  methods: {
	    renderEmpty: function renderEmpty() {
	      var h = this.$createElement;
	      var items = this.computedItems;
	      var $empty;

	      if (this.showEmpty && (!items || items.length === 0) && !(this.computedBusy && this.hasNormalizedSlot('table-busy'))) {
	        $empty = this.normalizeSlot(this.isFiltered ? 'emptyfiltered' : 'empty', {
	          emptyFilteredHtml: this.emptyFilteredHtml,
	          emptyFilteredText: this.emptyFilteredText,
	          emptyHtml: this.emptyHtml,
	          emptyText: this.emptyText,
	          fields: this.computedFields,
	          // Not sure why this is included, as it will always be an empty array
	          items: this.computedItems
	        });

	        if (!$empty) {
	          $empty = h('div', {
	            class: ['text-center', 'my-2'],
	            domProps: this.isFiltered ? htmlOrText(this.emptyFilteredHtml, this.emptyFilteredText) : htmlOrText(this.emptyHtml, this.emptyText)
	          });
	        }

	        $empty = h(BTd, {
	          props: {
	            colspan: this.computedFields.length || null
	          }
	        }, [h('div', {
	          attrs: {
	            role: 'alert',
	            'aria-live': 'polite'
	          }
	        }, [$empty])]);
	        $empty = h(BTr, {
	          key: this.isFiltered ? 'b-empty-filtered-row' : 'b-empty-row',
	          staticClass: 'b-table-empty-row',
	          class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, 'row-empty') : this.tbodyTrClass]
	        }, [$empty]);
	      }

	      return $empty || h();
	    }
	  }
	};

	var slotName = 'top-row';
	var topRowMixin = {
	  methods: {
	    renderTopRow: function renderTopRow() {
	      var h = this.$createElement; // Add static Top Row slot (hidden in visibly stacked mode as we can't control the data-label)
	      // If in *always* stacked mode, we don't bother rendering the row

	      if (!this.hasNormalizedSlot(slotName) || this.stacked === true || this.stacked === '') {
	        return h();
	      }

	      var fields = this.computedFields;
	      return h(BTr, {
	        key: 'b-top-row',
	        staticClass: 'b-table-top-row',
	        class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, 'row-top') : this.tbodyTrClass]
	      }, [this.normalizeSlot(slotName, {
	        columns: fields.length,
	        fields: fields
	      })]);
	    }
	  }
	};

	var slotName$1 = 'bottom-row';
	var bottomRowMixin = {
	  methods: {
	    renderBottomRow: function renderBottomRow() {
	      var h = this.$createElement; // Static bottom row slot (hidden in visibly stacked mode as we can't control the data-label)
	      // If in *always* stacked mode, we don't bother rendering the row

	      if (!this.hasNormalizedSlot(slotName$1) || this.stacked === true || this.stacked === '') {
	        return h();
	      }

	      var fields = this.computedFields;
	      return h(BTr, {
	        key: 'b-bottom-row',
	        staticClass: 'b-table-bottom-row',
	        class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, 'row-bottom') : this.tbodyTrClass]
	      }, this.normalizeSlot(slotName$1, {
	        columns: fields.length,
	        fields: fields
	      }));
	    }
	  }
	};

	var busySlotName = 'table-busy';
	var busyMixin = {
	  props: {
	    busy: {
	      type: Boolean,
	      default: false
	    }
	  },
	  data: function data() {
	    return {
	      localBusy: false
	    };
	  },
	  computed: {
	    computedBusy: function computedBusy() {
	      return this.busy || this.localBusy;
	    }
	  },
	  watch: {
	    localBusy: function localBusy(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        this.$emit('update:busy', newVal);
	      }
	    }
	  },
	  methods: {
	    // Event handler helper
	    stopIfBusy: function stopIfBusy(evt) {
	      if (this.computedBusy) {
	        // If table is busy (via provider) then don't propagate
	        evt.preventDefault();
	        evt.stopPropagation();
	        return true;
	      }

	      return false;
	    },
	    // Render the busy indicator or return `null` if not busy
	    renderBusy: function renderBusy() {
	      var h = this.$createElement; // Return a busy indicator row, or `null` if not busy

	      if (this.computedBusy && this.hasNormalizedSlot(busySlotName)) {
	        // Show the busy slot
	        return h(BTr, {
	          key: 'table-busy-slot',
	          staticClass: 'b-table-busy-slot',
	          class: [isFunction(this.tbodyTrClass) ? this.tbodyTrClass(null, busySlotName) : this.tbodyTrClass]
	        }, [h(BTd, {
	          props: {
	            colspan: this.computedFields.length || null
	          }
	        }, [this.normalizeSlot(busySlotName)])]);
	      } else {
	        // We return `null` here so that we can determine if we need to
	        // render the table items rows or not
	        return null;
	      }
	    }
	  }
	};

	function _defineProperty$17(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	var selectableMixin = {
	  props: {
	    selectable: {
	      type: Boolean,
	      default: false
	    },
	    selectMode: {
	      type: String,
	      default: 'multi',
	      validator: function validator(val) {
	        return arrayIncludes(['range', 'multi', 'single'], val);
	      }
	    },
	    selectedVariant: {
	      type: String,
	      default: function _default() {
	        return getComponentConfig('BTable', 'selectedVariant');
	      }
	    },
	    noSelectOnClick: {
	      // Disable use of click handlers for row selection
	      type: Boolean,
	      default: false
	    }
	  },
	  data: function data() {
	    return {
	      selectedRows: [],
	      selectedLastRow: -1
	    };
	  },
	  computed: {
	    isSelectable: function isSelectable() {
	      return this.selectable && this.selectMode;
	    },
	    hasSelectableRowClick: function hasSelectableRowClick() {
	      return this.isSelectable && !this.noSelectOnClick;
	    },
	    supportsSelectableRows: function supportsSelectableRows() {
	      return true;
	    },
	    selectableHasSelection: function selectableHasSelection() {
	      return this.isSelectable && this.selectedRows && this.selectedRows.length > 0 && this.selectedRows.some(Boolean);
	    },
	    selectableIsMultiSelect: function selectableIsMultiSelect() {
	      return this.isSelectable && arrayIncludes(['range', 'multi'], this.selectMode);
	    },
	    selectableTableClasses: function selectableTableClasses() {
	      var _ref;

	      return _ref = {
	        'b-table-selectable': this.isSelectable
	      }, _defineProperty$17(_ref, "b-table-select-".concat(this.selectMode), this.isSelectable), _defineProperty$17(_ref, 'b-table-selecting', this.selectableHasSelection), _defineProperty$17(_ref, 'b-table-selectable-no-click', this.isSelectable && !this.hasSelectableRowClick), _ref;
	    },
	    selectableTableAttrs: function selectableTableAttrs() {
	      return {
	        // TODO:
	        //   Should this attribute not be included when no-select-on-click is set
	        //   since this attribute implies keyboard navigation?
	        'aria-multiselectable': !this.isSelectable ? null : this.selectableIsMultiSelect ? 'true' : 'false'
	      };
	    }
	  },
	  watch: {
	    computedItems: function computedItems(newVal, oldVal) {
	      // Reset for selectable
	      var equal = false;

	      if (this.isSelectable && this.selectedRows.length > 0) {
	        // Quick check against array length
	        equal = isArray(newVal) && isArray(oldVal) && newVal.length === oldVal.length;

	        for (var i = 0; equal && i < newVal.length; i++) {
	          // Look for the first non-loosely equal row, after ignoring reserved fields
	          equal = looseEqual(sanitizeRow(newVal[i]), sanitizeRow(oldVal[i]));
	        }
	      }

	      if (!equal) {
	        this.clearSelected();
	      }
	    },
	    selectable: function selectable(newVal, oldVal) {
	      this.clearSelected();
	      this.setSelectionHandlers(newVal);
	    },
	    selectMode: function selectMode(newVal, oldVal) {
	      this.clearSelected();
	    },
	    hasSelectableRowClick: function hasSelectableRowClick(newVal, oldVal) {
	      this.clearSelected();
	      this.setSelectionHandlers(!newVal);
	    },
	    selectedRows: function selectedRows(_selectedRows, oldVal) {
	      var _this = this;

	      if (this.isSelectable && !looseEqual(_selectedRows, oldVal)) {
	        var items = []; // `.forEach()` skips over non-existent indices (on sparse arrays)

	        _selectedRows.forEach(function (v, idx) {
	          if (v) {
	            items.push(_this.computedItems[idx]);
	          }
	        });

	        this.$emit('row-selected', items);
	      }
	    }
	  },
	  beforeMount: function beforeMount() {
	    // Set up handlers if needed
	    if (this.isSelectable) {
	      this.setSelectionHandlers(true);
	    }
	  },
	  methods: {
	    // Public methods
	    selectRow: function selectRow(index) {
	      // Select a particular row (indexed based on computedItems)
	      if (this.isSelectable && isNumber(index) && index >= 0 && index < this.computedItems.length && !this.isRowSelected(index)) {
	        var selectedRows = this.selectableIsMultiSelect ? this.selectedRows.slice() : [];
	        selectedRows[index] = true;
	        this.selectedLastClicked = -1;
	        this.selectedRows = selectedRows;
	      }
	    },
	    unselectRow: function unselectRow(index) {
	      // Un-select a particular row (indexed based on `computedItems`)
	      if (this.isSelectable && isNumber(index) && this.isRowSelected(index)) {
	        var selectedRows = this.selectedRows.slice();
	        selectedRows[index] = false;
	        this.selectedLastClicked = -1;
	        this.selectedRows = selectedRows;
	      }
	    },
	    selectAllRows: function selectAllRows() {
	      var length = this.computedItems.length;

	      if (this.isSelectable && length > 0) {
	        this.selectedLastClicked = -1;
	        this.selectedRows = this.selectableIsMultiSelect ? range(length).map(function (i) {
	          return true;
	        }) : [true];
	      }
	    },
	    isRowSelected: function isRowSelected(index) {
	      // Determine if a row is selected (indexed based on `computedItems`)
	      return Boolean(isNumber(index) && this.selectedRows[index]);
	    },
	    clearSelected: function clearSelected() {
	      // Clear any active selected row(s)
	      this.selectedLastClicked = -1;
	      this.selectedRows = [];
	    },
	    // Internal private methods
	    selectableRowClasses: function selectableRowClasses(index) {
	      if (this.isSelectable && this.isRowSelected(index)) {
	        var variant = this.selectedVariant;
	        return _defineProperty$17({
	          'b-table-row-selected': true
	        }, "".concat(this.dark ? 'bg' : 'table', "-").concat(variant), variant);
	      } else {
	        return {};
	      }
	    },
	    selectableRowAttrs: function selectableRowAttrs(index) {
	      return {
	        'aria-selected': !this.isSelectable ? null : this.isRowSelected(index) ? 'true' : 'false'
	      };
	    },
	    setSelectionHandlers: function setSelectionHandlers(on) {
	      var method = on && !this.noSelectOnClick ? '$on' : '$off'; // Handle row-clicked event

	      this[method]('row-clicked', this.selectionHandler); // Clear selection on filter, pagination, and sort changes

	      this[method]('filtered', this.clearSelected);
	      this[method]('context-changed', this.clearSelected);
	    },
	    selectionHandler: function selectionHandler(item, index, evt) {
	      /* istanbul ignore if: should never happen */
	      if (!this.isSelectable || this.noSelectOnClick) {
	        // Don't do anything if table is not in selectable mode
	        this.clearSelected();
	        return;
	      }

	      var selectMode = this.selectMode;
	      var selectedRows = this.selectedRows.slice();
	      var selected = !selectedRows[index]; // Note 'multi' mode needs no special event handling

	      if (selectMode === 'single') {
	        selectedRows = [];
	      } else if (selectMode === 'range') {
	        if (this.selectedLastRow > -1 && evt.shiftKey) {
	          // range
	          for (var idx = Math.min(this.selectedLastRow, index); idx <= Math.max(this.selectedLastRow, index); idx++) {
	            selectedRows[idx] = true;
	          }

	          selected = true;
	        } else {
	          if (!(evt.ctrlKey || evt.metaKey)) {
	            // Clear range selection if any
	            selectedRows = [];
	            selected = true;
	          }

	          this.selectedLastRow = selected ? index : -1;
	        }
	      }

	      selectedRows[index] = selected;
	      this.selectedRows = selectedRows;
	    }
	  }
	};

	var providerMixin = {
	  mixins: [listenOnRootMixin],
	  props: {
	    // Prop override(s)
	    items: {
	      // Adds in 'Function' support
	      type: [Array, Function],
	      default: function _default()
	      /* istanbul ignore next */
	      {
	        return [];
	      }
	    },
	    // Additional props
	    noProviderPaging: {
	      type: Boolean,
	      default: false
	    },
	    noProviderSorting: {
	      type: Boolean,
	      default: false
	    },
	    noProviderFiltering: {
	      type: Boolean,
	      default: false
	    },
	    apiUrl: {
	      // Passthrough prop. Passed to the context object. Not used by b-table directly
	      type: String,
	      default: ''
	    }
	  },
	  computed: {
	    hasProvider: function hasProvider() {
	      return isFunction(this.items);
	    },
	    providerTriggerContext: function providerTriggerContext() {
	      // Used to trigger the provider function via a watcher. Only the fields that
	      // are needed for triggering a provider update are included. Note that the
	      // regular this.context is sent to the provider during fetches though, as they
	      // may need all the prop info.
	      var ctx = {
	        apiUrl: this.apiUrl,
	        filter: null,
	        sortBy: null,
	        sortDesc: null,
	        perPage: null,
	        currentPage: null
	      };

	      if (!this.noProviderFiltering) {
	        // Either a string, or could be an object or array.
	        ctx.filter = this.localFilter;
	      }

	      if (!this.noProviderSorting) {
	        ctx.sortBy = this.localSortBy;
	        ctx.sortDesc = this.localSortDesc;
	      }

	      if (!this.noProviderPaging) {
	        ctx.perPage = this.perPage;
	        ctx.currentPage = this.currentPage;
	      }

	      return clone(ctx);
	    }
	  },
	  watch: {
	    // Provider update triggering
	    items: function items(newVal, oldVal) {
	      // If a new provider has been specified, trigger an update
	      if (this.hasProvider || isFunction(newVal)) {
	        this.$nextTick(this._providerUpdate);
	      }
	    },
	    providerTriggerContext: function providerTriggerContext(newVal, oldVal) {
	      // Trigger the provider to update as the relevant context values have changed.
	      if (!looseEqual(newVal, oldVal)) {
	        this.$nextTick(this._providerUpdate);
	      }
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    // Call the items provider if necessary
	    if (this.hasProvider && (!this.localItems || this.localItems.length === 0)) {
	      // Fetch on mount if localItems is empty
	      this._providerUpdate();
	    } // Listen for global messages to tell us to force refresh the table


	    this.listenOnRoot('bv::refresh::table', function (id) {
	      if (id === _this.id || id === _this) {
	        _this.refresh();
	      }
	    });
	  },
	  methods: {
	    refresh: function refresh() {
	      // Public Method: Force a refresh of the provider function
	      this.$off('refreshed', this.refresh);

	      if (this.computedBusy) {
	        // Can't force an update when forced busy by user (busy prop === true)
	        if (this.localBusy && this.hasProvider) {
	          // But if provider running (localBusy), re-schedule refresh once `refreshed` emitted
	          this.$on('refreshed', this.refresh);
	        }
	      } else {
	        this.clearSelected();

	        if (this.hasProvider) {
	          this.$nextTick(this._providerUpdate);
	        } else {
	          /* istanbul ignore next */
	          this.localItems = isArray(this.items) ? this.items.slice() : [];
	        }
	      }
	    },
	    // Provider related methods
	    _providerSetLocal: function _providerSetLocal(items) {
	      this.localItems = isArray(items) ? items.slice() : [];
	      this.localBusy = false;
	      this.$emit('refreshed'); // New root emit

	      if (this.id) {
	        this.emitOnRoot('bv::table::refreshed', this.id);
	      }
	    },
	    _providerUpdate: function _providerUpdate() {
	      var _this2 = this;

	      // Refresh the provider function items.
	      if (!this.hasProvider) {
	        // Do nothing if no provider
	        return;
	      } // If table is busy, wait until refreshed before calling again


	      if (this.computedBusy) {
	        // Schedule a new refresh once `refreshed` is emitted
	        this.$nextTick(this.refresh);
	        return;
	      } // Set internal busy state


	      this.localBusy = true; // Call provider function with context and optional callback after DOM is fully updated

	      this.$nextTick(function () {
	        try {
	          // Call provider function passing it the context and optional callback
	          var data = _this2.items(_this2.context, _this2._providerSetLocal);

	          if (isPromise(data)) {
	            // Provider returned Promise
	            data.then(function (items) {
	              // Provider resolved with items
	              _this2._providerSetLocal(items);
	            });
	          } else if (isArray(data)) {
	            // Provider returned Array data
	            _this2._providerSetLocal(data);
	          } else {
	            /* istanbul ignore if */
	            if (_this2.items.length !== 2) {
	              // Check number of arguments provider function requested
	              // Provider not using callback (didn't request second argument), so we clear
	              // busy state as most likely there was an error in the provider function

	              /* istanbul ignore next */
	              warn("b-table provider function didn't request callback and did not return a promise or data");
	              _this2.localBusy = false;
	            }
	          }
	        } catch (e)
	        /* istanbul ignore next */
	        {
	          // Provider function borked on us, so we spew out a warning
	          // and clear the busy state
	          warn("b-table provider function error [".concat(e.name, "] ").concat(e.message));
	          _this2.localBusy = false;

	          _this2.$off('refreshed', _this2.refresh);
	        }
	      });
	    }
	  }
	};

	function ownKeys$Q(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$Q(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$Q(source, true).forEach(function (key) { _defineProperty$18(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$Q(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$18(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	// Includes all main table styling options

	var tableRendererMixin = {
	  // Don't place attributes on root element automatically,
	  // as table could be wrapped in responsive `<div>`
	  inheritAttrs: false,
	  provide: function provide() {
	    return {
	      bvTable: this
	    };
	  },
	  props: {
	    striped: {
	      type: Boolean,
	      default: false
	    },
	    bordered: {
	      type: Boolean,
	      default: false
	    },
	    borderless: {
	      type: Boolean,
	      default: false
	    },
	    outlined: {
	      type: Boolean,
	      default: false
	    },
	    dark: {
	      type: Boolean,
	      default: false
	    },
	    hover: {
	      type: Boolean,
	      default: false
	    },
	    small: {
	      type: Boolean,
	      default: false
	    },
	    fixed: {
	      type: Boolean,
	      default: false
	    },
	    responsive: {
	      type: [Boolean, String],
	      default: false
	    },
	    stickyHeader: {
	      // If a string, it is assumed to be the table `max-height` value
	      type: [Boolean, String],
	      default: false
	    },
	    noBorderCollapse: {
	      type: Boolean,
	      default: false
	    },
	    captionTop: {
	      type: Boolean,
	      default: false
	    },
	    tableVariant: {
	      type: String,
	      default: null
	    },
	    tableClass: {
	      type: [String, Array, Object],
	      default: null
	    }
	  },
	  computed: {
	    // Layout related computed props
	    isResponsive: function isResponsive() {
	      var responsive = this.responsive === '' ? true : this.responsive;
	      return this.isStacked ? false : responsive;
	    },
	    isStickyHeader: function isStickyHeader() {
	      var stickyHeader = this.stickyHeader === '' ? true : this.stickyHeader;
	      return this.isStacked ? false : stickyHeader;
	    },
	    wrapperClasses: function wrapperClasses() {
	      return [this.isStickyHeader ? 'b-table-sticky-header' : '', this.isResponsive === true ? 'table-responsive' : this.isResponsive ? "table-responsive-".concat(this.responsive) : ''].filter(Boolean);
	    },
	    wrapperStyles: function wrapperStyles() {
	      return this.isStickyHeader && !isBoolean(this.isStickyHeader) ? {
	        maxHeight: this.isStickyHeader
	      } : {};
	    },
	    tableClasses: function tableClasses() {
	      var hover = this.isTableSimple ? this.hover : this.hover && this.computedItems.length > 0 && !this.computedBusy;
	      return [// User supplied classes
	      this.tableClass, // Styling classes
	      {
	        'table-striped': this.striped,
	        'table-hover': hover,
	        'table-dark': this.dark,
	        'table-bordered': this.bordered,
	        'table-borderless': this.borderless,
	        'table-sm': this.small,
	        // The following are b-table custom styles
	        border: this.outlined,
	        'b-table-fixed': this.fixed,
	        'b-table-caption-top': this.captionTop,
	        'b-table-no-border-collapse': this.noBorderCollapse
	      }, this.tableVariant ? "".concat(this.dark ? 'bg' : 'table', "-").concat(this.tableVariant) : '', // Stacked table classes
	      this.stackedTableClasses, // Selectable classes
	      this.selectableTableClasses];
	    },
	    tableAttrs: function tableAttrs() {
	      // Preserve user supplied aria-describedby, if provided in `$attrs`
	      var adb = [(this.$attrs || {})['aria-describedby'], this.captionId].filter(Boolean).join(' ') || null;
	      var items = this.computedItems;
	      var filteredItems = this.filteredItems;
	      var fields = this.computedFields;
	      var selectableAttrs = this.selectableTableAttrs || {};
	      var ariaAttrs = this.isTableSimple ? {} : {
	        'aria-busy': this.computedBusy ? 'true' : 'false',
	        'aria-colcount': String(fields.length),
	        'aria-describedby': adb
	      };
	      var rowCount = items && filteredItems && filteredItems.length > items.length ? String(filteredItems.length) : null;
	      return _objectSpread$Q({
	        // We set `aria-rowcount` before merging in `$attrs`,
	        // in case user has supplied their own
	        'aria-rowcount': rowCount
	      }, this.$attrs, {
	        // Now we can override any `$attrs` here
	        id: this.safeId(),
	        role: 'table'
	      }, ariaAttrs, {}, selectableAttrs);
	    }
	  },
	  render: function render(h) {
	    var $content = [];

	    if (this.isTableSimple) {
	      $content.push(this.normalizeSlot('default', {}));
	    } else {
	      // Build the `<caption>` (from caption mixin)
	      $content.push(this.renderCaption ? this.renderCaption() : null); // Build the `<colgroup>`

	      $content.push(this.renderColgroup ? this.renderColgroup() : null); // Build the `<thead>`

	      $content.push(this.renderThead ? this.renderThead() : null); // Build the `<tbody>`

	      $content.push(this.renderTbody ? this.renderTbody() : null); // Build the `<tfoot>`

	      $content.push(this.renderTfoot ? this.renderTfoot() : null);
	    } // Assemble `<table>`


	    var $table = h('table', {
	      key: 'b-table',
	      staticClass: 'table b-table',
	      class: this.tableClasses,
	      attrs: this.tableAttrs
	    }, $content.filter(Boolean)); // Add responsive/sticky wrapper if needed and return table

	    return this.wrapperClasses.length > 0 ? h('div', {
	      key: 'wrap',
	      class: this.wrapperClasses,
	      style: this.wrapperStyles
	    }, [$table]) : $table;
	  }
	};

	// @vue/component

	var BTable =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTable',
	  // Order of mixins is important!
	  // They are merged from first to last, followed by this component.
	  mixins: [// Required Mixins
	  idMixin, normalizeSlotMixin, itemsMixin, tableRendererMixin, stackedMixin, theadMixin, tfootMixin, tbodyMixin, // Features Mixins
	  stackedMixin, filteringMixin, sortingMixin, paginationMixin$1, captionMixin, colgroupMixin, selectableMixin, emptyMixin, topRowMixin, bottomRowMixin, busyMixin, providerMixin] // render function provided by table-renderer mixin

	});

	// @vue/component

	var BTableLite =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTableLite',
	  // Order of mixins is important!
	  // They are merged from first to last, followed by this component.
	  mixins: [// Required mixins
	  idMixin, normalizeSlotMixin, itemsMixin, tableRendererMixin, stackedMixin, theadMixin, tfootMixin, tbodyMixin, // Features Mixins
	  // These are pretty lightweight, and are useful for lightweight tables
	  captionMixin, colgroupMixin] // render function provided by table-renderer mixin

	});

	// @vue/component

	var BTableSimple =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTableSimple',
	  // Order of mixins is important!
	  // They are merged from first to last, followed by this component.
	  mixins: [// Required mixins
	  idMixin, normalizeSlotMixin, tableRendererMixin, // feature mixin
	  // Stacked requires extra handling by users via
	  // the table cell `stacked-heading` prop
	  stackedMixin],
	  computed: {
	    isTableSimple: function isTableSimple() {
	      return true;
	    }
	  } // render function provided by table-renderer mixin

	});

	var TableLitePlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BTableLite: BTableLite
	  }
	});
	var TableSimplePlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BTableSimple: BTableSimple,
	    BTbody: BTbody,
	    BThead: BThead,
	    BTfoot: BTfoot,
	    BTr: BTr,
	    BTd: BTd,
	    BTh: BTh
	  }
	});
	var TablePlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BTable: BTable
	  },
	  plugins: {
	    TableLitePlugin: TableLitePlugin,
	    TableSimplePlugin: TableSimplePlugin
	  }
	});

	function ownKeys$R(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$R(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$R(source, true).forEach(function (key) { _defineProperty$19(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$R(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$19(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var navProps = omit(props$I, ['tabs', 'isNavBar', 'cardHeader']); // -- Utils --
	// Filter function to filter out disabled tabs

	var notDisabled = function notDisabled(tab) {
	  return !tab.disabled;
	}; // --- Helper components ---
	// @vue/component


	var BTabButtonHelper =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTabButtonHelper',
	  inject: {
	    bvTabs: {
	      default: function _default()
	      /* istanbul ignore next */
	      {
	        return {};
	      }
	    }
	  },
	  props: {
	    // Reference to the child <b-tab> instance
	    tab: {
	      default: null
	    },
	    tabs: {
	      type: Array,
	      default: function _default()
	      /* istanbul ignore next */
	      {
	        return [];
	      }
	    },
	    id: {
	      type: String,
	      default: null
	    },
	    controls: {
	      type: String,
	      default: null
	    },
	    tabIndex: {
	      type: Number,
	      default: null
	    },
	    posInSet: {
	      type: Number,
	      default: null
	    },
	    setSize: {
	      type: Number,
	      default: null
	    },
	    noKeyNav: {
	      type: Boolean,
	      default: false
	    }
	  },
	  methods: {
	    focus: function focus() {
	      if (this.$refs && this.$refs.link && this.$refs.link.focus) {
	        this.$refs.link.focus();
	      }
	    },
	    handleEvt: function handleEvt(evt) {
	      var stop = function stop() {
	        evt.preventDefault();
	        evt.stopPropagation();
	      };

	      if (this.tab.disabled) {
	        /* istanbul ignore next */
	        return;
	      }

	      var type = evt.type;
	      var key = evt.keyCode;
	      var shift = evt.shiftKey;

	      if (type === 'click') {
	        stop();
	        this.$emit('click', evt);
	      } else if (type === 'keydown' && key === KEY_CODES.SPACE) {
	        // For ARIA tabs the SPACE key will also trigger a click/select
	        // Even with keyboard navigation disabled, SPACE should "click" the button
	        // See: https://github.com/bootstrap-vue/bootstrap-vue/issues/4323
	        stop();
	        this.$emit('click', evt);
	      } else if (type === 'keydown' && !this.noKeyNav) {
	        // For keyboard navigation
	        if (key === KEY_CODES.UP || key === KEY_CODES.LEFT || key === KEY_CODES.HOME) {
	          stop();

	          if (shift || key === KEY_CODES.HOME) {
	            this.$emit('first', evt);
	          } else {
	            this.$emit('prev', evt);
	          }
	        } else if (key === KEY_CODES.DOWN || key === KEY_CODES.RIGHT || key === KEY_CODES.END) {
	          stop();

	          if (shift || key === KEY_CODES.END) {
	            this.$emit('last', evt);
	          } else {
	            this.$emit('next', evt);
	          }
	        }
	      }
	    }
	  },
	  render: function render(h) {
	    var link = h(BLink, {
	      ref: 'link',
	      staticClass: 'nav-link',
	      class: [{
	        active: this.tab.localActive && !this.tab.disabled,
	        disabled: this.tab.disabled
	      }, this.tab.titleLinkClass, // Apply <b-tabs> `activeNavItemClass` styles when the tab is active
	      this.tab.localActive ? this.bvTabs.activeNavItemClass : null],
	      props: {
	        disabled: this.tab.disabled
	      },
	      attrs: {
	        role: 'tab',
	        id: this.id,
	        // Roving tab index when keynav enabled
	        tabindex: this.tabIndex,
	        'aria-selected': this.tab.localActive && !this.tab.disabled ? 'true' : 'false',
	        'aria-setsize': this.setSize,
	        'aria-posinset': this.posInSet,
	        'aria-controls': this.controls
	      },
	      on: {
	        click: this.handleEvt,
	        keydown: this.handleEvt
	      }
	    }, [this.tab.normalizeSlot('title') || this.tab.title]);
	    return h('li', {
	      staticClass: 'nav-item',
	      class: [this.tab.titleItemClass],
	      attrs: {
	        role: 'presentation'
	      }
	    }, [link]);
	  }
	}); // @vue/component

	var BTabs =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTabs',
	  mixins: [idMixin, normalizeSlotMixin],
	  provide: function provide() {
	    return {
	      bvTabs: this
	    };
	  },
	  model: {
	    prop: 'value',
	    event: 'input'
	  },
	  props: _objectSpread$R({}, navProps, {
	    tag: {
	      type: String,
	      default: 'div'
	    },
	    card: {
	      type: Boolean,
	      default: false
	    },
	    end: {
	      // Synonym for 'bottom'
	      type: Boolean,
	      default: false
	    },
	    noFade: {
	      type: Boolean,
	      default: false
	    },
	    noNavStyle: {
	      type: Boolean,
	      default: false
	    },
	    noKeyNav: {
	      type: Boolean,
	      default: false
	    },
	    lazy: {
	      // This prop is sniffed by the <b-tab> child
	      type: Boolean,
	      default: false
	    },
	    contentClass: {
	      type: [String, Array, Object],
	      default: null
	    },
	    navClass: {
	      type: [String, Array, Object],
	      default: null
	    },
	    navWrapperClass: {
	      type: [String, Array, Object],
	      default: null
	    },
	    activeNavItemClass: {
	      // Only applied to the currently active <b-nav-item>
	      type: [String, Array, Object],
	      default: null
	    },
	    activeTabClass: {
	      // Only applied to the currently active <b-tab>
	      // This prop is sniffed by the <b-tab> child
	      type: [String, Array, Object],
	      default: null
	    },
	    value: {
	      // v-model
	      type: Number,
	      default: null
	    }
	  }),
	  data: function data() {
	    var tabIdx = parseInt(this.value, 10);
	    tabIdx = isNaN(tabIdx) ? -1 : tabIdx;
	    return {
	      // Index of current tab
	      currentTab: tabIdx,
	      // Array of direct child <b-tab> instances, in DOM order
	      tabs: [],
	      // Array of child instances registered (for triggering reactive updates)
	      registeredTabs: [],
	      // Flag to know if we are mounted or not
	      isMounted: false
	    };
	  },
	  computed: {
	    fade: function fade() {
	      // This computed prop is sniffed by the tab child
	      return !this.noFade;
	    },
	    localNavClass: function localNavClass() {
	      var classes = [];

	      if (this.card && this.vertical) {
	        classes.push('card-header', 'h-100', 'border-bottom-0', 'rounded-0');
	      }

	      return [].concat(classes, [this.navClass]);
	    }
	  },
	  watch: {
	    currentTab: function currentTab(val, old) {
	      var index = -1; // Ensure only one tab is active at most

	      this.tabs.forEach(function (tab, idx) {
	        if (val === idx && !tab.disabled) {
	          tab.localActive = true;
	          index = idx;
	        } else {
	          tab.localActive = false;
	        }
	      }); // Update the v-model

	      this.$emit('input', index);
	    },
	    value: function value(val, old) {
	      if (val !== old) {
	        val = parseInt(val, 10);
	        val = isNaN(val) ? -1 : val;
	        old = parseInt(old, 10) || 0;
	        var tabs = this.tabs;

	        if (tabs[val] && !tabs[val].disabled) {
	          this.activateTab(tabs[val]);
	        } else {
	          // Try next or prev tabs
	          if (val < old) {
	            this.previousTab();
	          } else {
	            this.nextTab();
	          }
	        }
	      }
	    },
	    registeredTabs: function registeredTabs(newVal, oldVal) {
	      var _this = this;

	      // Each b-tab will register/unregister itself.
	      // We use this to detect when tabs are added/removed
	      // to trigger the update of the tabs.
	      this.$nextTick(function () {
	        requestAF(function () {
	          _this.updateTabs();
	        });
	      });
	    },
	    tabs: function tabs(newVal, oldVal) {
	      var _this2 = this;

	      // If tabs added, removed, or re-ordered, we emit a `changed` event.
	      // We use `tab._uid` instead of `tab.safeId()`, as the later is changed
	      // in a nextTick if no explicit ID is provided, causing duplicate emits.
	      if (!looseEqual(newVal.map(function (t) {
	        return t._uid;
	      }), oldVal.map(function (t) {
	        return t._uid;
	      }))) {
	        // In a nextTick to ensure currentTab has been set first.
	        this.$nextTick(function () {
	          // We emit shallow copies of the new and old arrays of tabs, to
	          // prevent users from potentially mutating the internal arrays.
	          _this2.$emit('changed', newVal.slice(), oldVal.slice());
	        });
	      }
	    },
	    isMounted: function isMounted(newVal, oldVal) {
	      var _this3 = this;

	      // Trigger an update after mounted.  Needed for tabs inside lazy modals.
	      if (newVal) {
	        requestAF(function () {
	          _this3.updateTabs();
	        });
	      } // Enable or disable the observer


	      this.setObserver(newVal);
	    }
	  },
	  created: function created() {
	    var _this4 = this;

	    var tabIdx = parseInt(this.value, 10);
	    this.currentTab = isNaN(tabIdx) ? -1 : tabIdx;
	    this._bvObserver = null; // For SSR and to make sure only a single tab is shown on mount
	    // We wrap this in a `$nextTick()` to ensure the child tabs have been created

	    this.$nextTick(function () {
	      _this4.updateTabs();
	    });
	  },
	  mounted: function mounted() {
	    var _this5 = this;

	    // Call `updateTabs()` just in case...
	    this.updateTabs();
	    this.$nextTick(function () {
	      // Flag we are now mounted and to switch to DOM for tab probing.
	      // As this.$slots.default appears to lie about component instances
	      // after b-tabs is destroyed and re-instantiated.
	      // And this.$children does not respect DOM order.
	      _this5.isMounted = true;
	    });
	  },
	  deactivated: function deactivated()
	  /* istanbul ignore next */
	  {
	    this.isMounted = false;
	  },
	  activated: function activated()
	  /* istanbul ignore next */
	  {
	    var _this6 = this;

	    var tabIdx = parseInt(this.value, 10);
	    this.currentTab = isNaN(tabIdx) ? -1 : tabIdx;
	    this.$nextTick(function () {
	      _this6.updateTabs();

	      _this6.isMounted = true;
	    });
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.isMounted = false;
	  },
	  destroyed: function destroyed() {
	    // Ensure no references to child instances exist
	    this.tabs = [];
	  },
	  methods: {
	    registerTab: function registerTab(tab) {
	      var _this7 = this;

	      if (!arrayIncludes(this.registeredTabs, tab)) {
	        this.registeredTabs.push(tab);
	        tab.$once('hook:destroyed', function () {
	          _this7.unregisterTab(tab);
	        });
	      }
	    },
	    unregisterTab: function unregisterTab(tab) {
	      this.registeredTabs = this.registeredTabs.slice().filter(function (t) {
	        return t !== tab;
	      });
	    },
	    setObserver: function setObserver(on) {
	      // DOM observer is needed to detect changes in order of tabs
	      if (on) {
	        // Make sure no existing observer running
	        this.setObserver(false);
	        var self = this;
	        /* istanbul ignore next: difficult to test mutation observer in JSDOM */

	        var handler = function handler() {
	          // We delay the update to ensure that `tab.safeId()` has
	          // updated with the final ID value.
	          self.$nextTick(function () {
	            requestAF(function () {
	              self.updateTabs();
	            });
	          });
	        }; // Watch for changes to <b-tab> sub components


	        this._bvObserver = observeDom(this.$refs.tabsContainer, handler, {
	          childList: true,
	          subtree: false,
	          attributes: true,
	          attributeFilter: ['id']
	        });
	      } else {
	        if (this._bvObserver && this._bvObserver.disconnect) {
	          this._bvObserver.disconnect();
	        }

	        this._bvObserver = null;
	      }
	    },
	    getTabs: function getTabs() {
	      // We use registeredTabs as the source of truth for child tab components. And we
	      // filter out any BTab components that are extended BTab with a root child BTab.
	      // https://github.com/bootstrap-vue/bootstrap-vue/issues/3260
	      var tabs = this.registeredTabs.filter(function (tab) {
	        return tab.$children.filter(function (t) {
	          return t._isTab;
	        }).length === 0;
	      }); // DOM Order of Tabs

	      var order = [];

	      if (this.isMounted && tabs.length > 0) {
	        // We rely on the DOM when mounted to get the 'true' order of the b-tab children.
	        // querySelectorAll(...) always returns elements in document order, regardless of
	        // order specified in the selector.
	        var selector = tabs.map(function (tab) {
	          return "#".concat(tab.safeId());
	        }).join(', ');
	        order = selectAll(selector, this.$el).map(function (el) {
	          return el.id;
	        }).filter(Boolean);
	      } // Stable sort keeps the original order if not found in the
	      // `order` array, which will be an empty array before mount.


	      return stableSort(tabs, function (a, b) {
	        return order.indexOf(a.safeId()) - order.indexOf(b.safeId());
	      });
	    },
	    // Update list of <b-tab> children
	    updateTabs: function updateTabs() {
	      // Probe tabs
	      var tabs = this.getTabs(); // Find *last* active non-disabled tab in current tabs
	      // We trust tab state over currentTab, in case tabs were added/removed/re-ordered

	      var tabIndex = tabs.indexOf(tabs.slice().reverse().find(function (tab) {
	        return tab.localActive && !tab.disabled;
	      })); // Else try setting to currentTab

	      if (tabIndex < 0) {
	        var currentTab = this.currentTab;

	        if (currentTab >= tabs.length) {
	          // Handle last tab being removed, so find the last non-disabled tab
	          tabIndex = tabs.indexOf(tabs.slice().reverse().find(notDisabled));
	        } else if (tabs[currentTab] && !tabs[currentTab].disabled) {
	          // Current tab is not disabled
	          tabIndex = currentTab;
	        }
	      } // Else find *first* non-disabled tab in current tabs


	      if (tabIndex < 0) {
	        tabIndex = tabs.indexOf(tabs.find(notDisabled));
	      } // Set the current tab state to active


	      tabs.forEach(function (tab, idx) {
	        // tab.localActive = idx === tabIndex && !tab.disabled
	        tab.localActive = false;
	      });

	      if (tabs[tabIndex]) {
	        tabs[tabIndex].localActive = true;
	      } // Update the array of tab children


	      this.tabs = tabs; // Set the currentTab index (can be -1 if no non-disabled tabs)

	      this.currentTab = tabIndex;
	    },
	    // Find a button that controls a tab, given the tab reference
	    // Returns the button vm instance
	    getButtonForTab: function getButtonForTab(tab) {
	      return (this.$refs.buttons || []).find(function (btn) {
	        return btn.tab === tab;
	      });
	    },
	    // Force a button to re-render it's content, given a <b-tab> instance
	    // Called by <b-tab> on `update()`
	    updateButton: function updateButton(tab) {
	      var button = this.getButtonForTab(tab);

	      if (button && button.$forceUpdate) {
	        button.$forceUpdate();
	      }
	    },
	    // Activate a tab given a <b-tab> instance
	    // Also accessed by <b-tab>
	    activateTab: function activateTab(tab) {
	      var result = false;

	      if (tab) {
	        var index = this.tabs.indexOf(tab);

	        if (!tab.disabled && index > -1 && index !== this.currentTab) {
	          var tabEvt = new BvEvent('activate-tab', {
	            cancelable: true,
	            vueTarget: this,
	            componentId: this.safeId()
	          });
	          this.$emit(tabEvt.type, index, this.currentTab, tabEvt);

	          if (!tabEvt.defaultPrevented) {
	            result = true;
	            this.currentTab = index;
	          }
	        }
	      } // Couldn't set tab, so ensure v-model is set to `this.currentTab`

	      /* istanbul ignore next: should rarely happen */


	      if (!result && this.currentTab !== this.value) {
	        this.$emit('input', this.currentTab);
	      }

	      return result;
	    },
	    // Deactivate a tab given a <b-tab> instance
	    // Accessed by <b-tab>
	    deactivateTab: function deactivateTab(tab) {
	      if (tab) {
	        // Find first non-disabled tab that isn't the one being deactivated
	        // If no tabs are available, then don't deactivate current tab
	        return this.activateTab(this.tabs.filter(function (t) {
	          return t !== tab;
	        }).find(notDisabled));
	      }
	      /* istanbul ignore next: should never/rarely happen */


	      return false;
	    },
	    // Focus a tab button given it's <b-tab> instance
	    focusButton: function focusButton(tab) {
	      var _this8 = this;

	      // Wrap in `$nextTick()` to ensure DOM has completed rendering/updating before focusing
	      this.$nextTick(function () {
	        var button = _this8.getButtonForTab(tab);

	        if (button && button.focus) {
	          button.focus();
	        }
	      });
	    },
	    // Emit a click event on a specified <b-tab> component instance
	    emitTabClick: function emitTabClick(tab, evt) {
	      if (isEvent(evt) && tab && tab.$emit && !tab.disabled) {
	        tab.$emit('click', evt);
	      }
	    },
	    // Click handler
	    clickTab: function clickTab(tab, evt) {
	      this.activateTab(tab);
	      this.emitTabClick(tab, evt);
	    },
	    // Move to first non-disabled tab
	    firstTab: function firstTab(focus) {
	      var tab = this.tabs.find(notDisabled);

	      if (this.activateTab(tab) && focus) {
	        this.focusButton(tab);
	        this.emitTabClick(tab, focus);
	      }
	    },
	    // Move to previous non-disabled tab
	    previousTab: function previousTab(focus) {
	      var currentIndex = Math.max(this.currentTab, 0);
	      var tab = this.tabs.slice(0, currentIndex).reverse().find(notDisabled);

	      if (this.activateTab(tab) && focus) {
	        this.focusButton(tab);
	        this.emitTabClick(tab, focus);
	      }
	    },
	    // Move to next non-disabled tab
	    nextTab: function nextTab(focus) {
	      var currentIndex = Math.max(this.currentTab, -1);
	      var tab = this.tabs.slice(currentIndex + 1).find(notDisabled);

	      if (this.activateTab(tab) && focus) {
	        this.focusButton(tab);
	        this.emitTabClick(tab, focus);
	      }
	    },
	    // Move to last non-disabled tab
	    lastTab: function lastTab(focus) {
	      var tab = this.tabs.slice().reverse().find(notDisabled);

	      if (this.activateTab(tab) && focus) {
	        this.focusButton(tab);
	        this.emitTabClick(tab, focus);
	      }
	    }
	  },
	  render: function render(h) {
	    var _this9 = this;

	    var tabs = this.tabs; // Currently active tab

	    var activeTab = tabs.find(function (tab) {
	      return tab.localActive && !tab.disabled;
	    }); // Tab button to allow focusing when no active tab found (keynav only)

	    var fallbackTab = tabs.find(function (tab) {
	      return !tab.disabled;
	    }); // For each <b-tab> found create the tab buttons

	    var buttons = tabs.map(function (tab, index) {
	      var tabIndex = null; // Ensure at least one tab button is focusable when keynav enabled (if possible)

	      if (!_this9.noKeyNav) {
	        // Buttons are not in tab index unless active, or a fallback tab
	        tabIndex = -1;

	        if (activeTab === tab || !activeTab && fallbackTab === tab) {
	          // Place tab button in tab sequence
	          tabIndex = null;
	        }
	      }

	      return h(BTabButtonHelper, {
	        key: tab._uid || index,
	        ref: 'buttons',
	        // Needed to make `this.$refs.buttons` an array
	        refInFor: true,
	        props: {
	          tab: tab,
	          tabs: tabs,
	          id: tab.controlledBy || (tab.safeId ? tab.safeId("_BV_tab_button_") : null),
	          controls: tab.safeId ? tab.safeId() : null,
	          tabIndex: tabIndex,
	          setSize: tabs.length,
	          posInSet: index + 1,
	          noKeyNav: _this9.noKeyNav
	        },
	        on: {
	          click: function click(evt) {
	            _this9.clickTab(tab, evt);
	          },
	          first: _this9.firstTab,
	          prev: _this9.previousTab,
	          next: _this9.nextTab,
	          last: _this9.lastTab
	        }
	      });
	    }); // Nav

	    var nav = h(BNav, {
	      ref: 'nav',
	      class: this.localNavClass,
	      attrs: {
	        role: 'tablist',
	        id: this.safeId('_BV_tab_controls_')
	      },
	      props: {
	        fill: this.fill,
	        justified: this.justified,
	        align: this.align,
	        tabs: !this.noNavStyle && !this.pills,
	        pills: !this.noNavStyle && this.pills,
	        vertical: this.vertical,
	        small: this.small,
	        cardHeader: this.card && !this.vertical
	      }
	    }, [this.normalizeSlot('tabs-start') || h(), buttons, this.normalizeSlot('tabs-end') || h()]);
	    nav = h('div', {
	      key: 'bv-tabs-nav',
	      class: [{
	        'card-header': this.card && !this.vertical && !this.end,
	        'card-footer': this.card && !this.vertical && this.end,
	        'col-auto': this.vertical
	      }, this.navWrapperClass]
	    }, [nav]);
	    var empty = h();

	    if (!tabs || tabs.length === 0) {
	      empty = h('div', {
	        key: 'bv-empty-tab',
	        class: ['tab-pane', 'active', {
	          'card-body': this.card
	        }]
	      }, this.normalizeSlot('empty'));
	    } // Main content section


	    var content = h('div', {
	      ref: 'tabsContainer',
	      key: 'bv-tabs-container',
	      staticClass: 'tab-content',
	      class: [{
	        col: this.vertical
	      }, this.contentClass],
	      attrs: {
	        id: this.safeId('_BV_tab_container_')
	      }
	    }, concat(this.normalizeSlot('default'), empty)); // Render final output

	    return h(this.tag, {
	      staticClass: 'tabs',
	      class: {
	        row: this.vertical,
	        'no-gutters': this.vertical && this.card
	      },
	      attrs: {
	        id: this.safeId()
	      }
	    }, [this.end ? content : h(), [nav], this.end ? h() : content]);
	  }
	});

	var BTab =
	/*#__PURE__*/
	Vue.extend({
	  name: 'BTab',
	  mixins: [idMixin, normalizeSlotMixin],
	  inject: {
	    bvTabs: {
	      default: function _default() {
	        return {
	          // Don't set a tab index if not rendered inside <b-tabs>
	          noKeyNav: true
	        };
	      }
	    }
	  },
	  props: {
	    active: {
	      type: Boolean,
	      default: false
	    },
	    tag: {
	      type: String,
	      default: 'div'
	    },
	    buttonId: {
	      type: String,
	      default: ''
	    },
	    title: {
	      type: String,
	      default: ''
	    },
	    titleItemClass: {
	      // Sniffed by tabs.js and added to nav 'li.nav-item'
	      type: [String, Array, Object],
	      default: null
	    },
	    titleLinkClass: {
	      // Sniffed by tabs.js and added to nav 'a.nav-link'
	      type: [String, Array, Object],
	      default: null
	    },
	    disabled: {
	      type: Boolean,
	      default: false
	    },
	    noBody: {
	      type: Boolean,
	      default: false
	    },
	    lazy: {
	      type: Boolean,
	      default: false
	    }
	  },
	  data: function data() {
	    return {
	      localActive: this.active && !this.disabled,
	      show: false
	    };
	  },
	  computed: {
	    tabClasses: function tabClasses() {
	      return [{
	        active: this.localActive,
	        disabled: this.disabled,
	        'card-body': this.bvTabs.card && !this.noBody
	      }, // Apply <b-tabs> `activeTabClass` styles when this tab is active
	      this.localActive ? this.bvTabs.activeTabClass : null];
	    },
	    controlledBy: function controlledBy() {
	      return this.buttonId || this.safeId('__BV_tab_button__');
	    },
	    computedNoFade: function computedNoFade() {
	      return !(this.bvTabs.fade || false);
	    },
	    computedLazy: function computedLazy() {
	      return this.bvTabs.lazy || this.lazy;
	    },
	    _isTab: function _isTab() {
	      // For parent sniffing of child
	      return true;
	    }
	  },
	  watch: {
	    localActive: function localActive(newVal, oldVal) {
	      // Make 'active' prop work with `.sync` modifier
	      this.$emit('update:active', newVal);
	    },
	    active: function active(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        if (newVal) {
	          // If activated post mount
	          this.activate();
	        } else {
	          /* istanbul ignore next */
	          if (!this.deactivate()) {
	            // Tab couldn't be deactivated, so we reset the synced active prop
	            // Deactivation will fail if no other tabs to activate
	            this.$emit('update:active', this.localActive);
	          }
	        }
	      }
	    },
	    disabled: function disabled(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        if (newVal && this.localActive && this.bvTabs.firstTab) {
	          this.localActive = false;
	          this.bvTabs.firstTab();
	        }
	      }
	    }
	  },
	  mounted: function mounted() {
	    // Inform b-tabs of our presence
	    this.registerTab(); // Initially show on mount if active and not disabled

	    this.show = this.localActive;
	  },
	  updated: function updated() {
	    // Force the tab button content to update (since slots are not reactive)
	    // Only done if we have a title slot, as the title prop is reactive
	    if (this.hasNormalizedSlot('title') && this.bvTabs.updateButton) {
	      this.bvTabs.updateButton(this);
	    }
	  },
	  destroyed: function destroyed() {
	    // inform b-tabs of our departure
	    this.unregisterTab();
	  },
	  methods: {
	    // Private methods
	    registerTab: function registerTab() {
	      // Inform `b-tabs` of our presence
	      this.bvTabs.registerTab && this.bvTabs.registerTab(this);
	    },
	    unregisterTab: function unregisterTab() {
	      // Inform `b-tabs` of our departure
	      this.bvTabs.unregisterTab && this.bvTabs.unregisterTab(this);
	    },
	    // Public methods
	    activate: function activate() {
	      if (this.bvTabs.activateTab && !this.disabled) {
	        return this.bvTabs.activateTab(this);
	      } else {
	        // Not inside a <b-tabs> component or tab is disabled
	        return false;
	      }
	    },
	    deactivate: function deactivate() {
	      if (this.bvTabs.deactivateTab && this.localActive) {
	        return this.bvTabs.deactivateTab(this);
	      } else {
	        // Not inside a <b-tabs> component or not active to begin with
	        return false;
	      }
	    }
	  },
	  render: function render(h) {
	    var content = h(this.tag, {
	      ref: 'panel',
	      staticClass: 'tab-pane',
	      class: this.tabClasses,
	      directives: [{
	        name: 'show',
	        rawName: 'v-show',
	        value: this.localActive,
	        expression: 'localActive'
	      }],
	      attrs: {
	        role: 'tabpanel',
	        id: this.safeId(),
	        tabindex: this.localActive && !this.bvTabs.noKeyNav ? '-1' : null,
	        'aria-hidden': this.localActive ? 'false' : 'true',
	        'aria-labelledby': this.controlledBy || null
	      }
	    }, // Render content lazily if requested
	    [this.localActive || !this.computedLazy ? this.normalizeSlot('default') : h()]);
	    return h(BVTransition, {
	      props: {
	        mode: 'out-in',
	        noFade: this.computedNoFade
	      }
	    }, [content]);
	  }
	});

	var TabsPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BTabs: BTabs,
	    BTab: BTab
	  }
	});

	function _typeof$4(obj) {
	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof$4 = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof$4 = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof$4(obj);
	}

	function _toConsumableArray$7(arr) {
	  return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _nonIterableSpread$7();
	}

	function _arrayWithoutHoles$7(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; }

	    return arr2;
	  }
	}

	function _iterableToArray$7(iter) {
	  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") { return Array.from(iter); }
	}

	function _nonIterableSpread$7() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance");
	}

	var inBrowser = typeof window !== 'undefined';
	function freeze$1(item) {
	  if (Array.isArray(item) || _typeof$4(item) === 'object') {
	    return Object.freeze(item);
	  }

	  return item;
	}
	function combinePassengers(transports) {
	  var slotProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  return transports.reduce(function (passengers, transport) {
	    var temp = transport.passengers[0];
	    var newPassengers = typeof temp === 'function' ? temp(slotProps) : transport.passengers;
	    return passengers.concat(newPassengers);
	  }, []);
	}
	function stableSort$1(array, compareFn) {
	  return array.map(function (v, idx) {
	    return [idx, v];
	  }).sort(function (a, b) {
	    return compareFn(a[1], b[1]) || a[0] - b[0];
	  }).map(function (c) {
	    return c[1];
	  });
	}
	function pick(obj, keys) {
	  return keys.reduce(function (acc, key) {
	    if (obj.hasOwnProperty(key)) {
	      acc[key] = obj[key];
	    }

	    return acc;
	  }, {});
	}

	var transports = {};
	var targets = {};
	var sources = {};
	var Wormhole = Vue.extend({
	  data: function data() {
	    return {
	      transports: transports,
	      targets: targets,
	      sources: sources,
	      trackInstances: inBrowser
	    };
	  },
	  methods: {
	    open: function open(transport) {
	      if (!inBrowser) { return; }
	      var to = transport.to,
	          from = transport.from,
	          passengers = transport.passengers,
	          _transport$order = transport.order,
	          order = _transport$order === void 0 ? Infinity : _transport$order;
	      if (!to || !from || !passengers) { return; }
	      var newTransport = {
	        to: to,
	        from: from,
	        passengers: freeze$1(passengers),
	        order: order
	      };
	      var keys = Object.keys(this.transports);

	      if (keys.indexOf(to) === -1) {
	        Vue.set(this.transports, to, []);
	      }

	      var currentIndex = this.$_getTransportIndex(newTransport); // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays

	      var newTransports = this.transports[to].slice(0);

	      if (currentIndex === -1) {
	        newTransports.push(newTransport);
	      } else {
	        newTransports[currentIndex] = newTransport;
	      }

	      this.transports[to] = stableSort$1(newTransports, function (a, b) {
	        return a.order - b.order;
	      });
	    },
	    close: function close(transport) {
	      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var to = transport.to,
	          from = transport.from;
	      if (!to || !from && force === false) { return; }

	      if (!this.transports[to]) {
	        return;
	      }

	      if (force) {
	        this.transports[to] = [];
	      } else {
	        var index = this.$_getTransportIndex(transport);

	        if (index >= 0) {
	          // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays
	          var newTransports = this.transports[to].slice(0);
	          newTransports.splice(index, 1);
	          this.transports[to] = newTransports;
	        }
	      }
	    },
	    registerTarget: function registerTarget(target, vm, force) {
	      if (!inBrowser) { return; }

	      if (this.trackInstances && !force && this.targets[target]) {
	        console.warn("[portal-vue]: Target ".concat(target, " already exists"));
	      }

	      this.$set(this.targets, target, Object.freeze([vm]));
	    },
	    unregisterTarget: function unregisterTarget(target) {
	      this.$delete(this.targets, target);
	    },
	    registerSource: function registerSource(source, vm, force) {
	      if (!inBrowser) { return; }

	      if (this.trackInstances && !force && this.sources[source]) {
	        console.warn("[portal-vue]: source ".concat(source, " already exists"));
	      }

	      this.$set(this.sources, source, Object.freeze([vm]));
	    },
	    unregisterSource: function unregisterSource(source) {
	      this.$delete(this.sources, source);
	    },
	    hasTarget: function hasTarget(to) {
	      return !!(this.targets[to] && this.targets[to][0]);
	    },
	    hasSource: function hasSource(to) {
	      return !!(this.sources[to] && this.sources[to][0]);
	    },
	    hasContentFor: function hasContentFor(to) {
	      return !!this.transports[to] && !!this.transports[to].length;
	    },
	    // Internal
	    $_getTransportIndex: function $_getTransportIndex(_ref) {
	      var to = _ref.to,
	          from = _ref.from;

	      for (var i in this.transports[to]) {
	        if (this.transports[to][i].from === from) {
	          return +i;
	        }
	      }

	      return -1;
	    }
	  }
	});
	var wormhole = new Wormhole(transports);

	var _id = 1;
	var Portal = Vue.extend({
	  name: 'portal',
	  props: {
	    disabled: {
	      type: Boolean
	    },
	    name: {
	      type: String,
	      default: function _default() {
	        return String(_id++);
	      }
	    },
	    order: {
	      type: Number,
	      default: 0
	    },
	    slim: {
	      type: Boolean
	    },
	    slotProps: {
	      type: Object,
	      default: function _default() {
	        return {};
	      }
	    },
	    tag: {
	      type: String,
	      default: 'DIV'
	    },
	    to: {
	      type: String,
	      default: function _default() {
	        return String(Math.round(Math.random() * 10000000));
	      }
	    }
	  },
	  created: function created() {
	    var _this = this;

	    this.$nextTick(function () {
	      wormhole.registerSource(_this.name, _this);
	    });
	  },
	  mounted: function mounted() {
	    if (!this.disabled) {
	      this.sendUpdate();
	    }
	  },
	  updated: function updated() {
	    if (this.disabled) {
	      this.clear();
	    } else {
	      this.sendUpdate();
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    wormhole.unregisterSource(this.name);
	    this.clear();
	  },
	  watch: {
	    to: function to(newValue, oldValue) {
	      oldValue && oldValue !== newValue && this.clear(oldValue);
	      this.sendUpdate();
	    }
	  },
	  methods: {
	    clear: function clear(target) {
	      var closer = {
	        from: this.name,
	        to: target || this.to
	      };
	      wormhole.close(closer);
	    },
	    normalizeSlots: function normalizeSlots() {
	      return this.$scopedSlots.default ? [this.$scopedSlots.default] : this.$slots.default;
	    },
	    normalizeOwnChildren: function normalizeOwnChildren(children) {
	      return typeof children === 'function' ? children(this.slotProps) : children;
	    },
	    sendUpdate: function sendUpdate() {
	      var slotContent = this.normalizeSlots();

	      if (slotContent) {
	        var transport = {
	          from: this.name,
	          to: this.to,
	          passengers: _toConsumableArray$7(slotContent),
	          order: this.order
	        };
	        wormhole.open(transport);
	      } else {
	        this.clear();
	      }
	    }
	  },
	  render: function render(h) {
	    var children = this.$slots.default || this.$scopedSlots.default || [];
	    var Tag = this.tag;

	    if (children && this.disabled) {
	      return children.length <= 1 && this.slim ? this.normalizeOwnChildren(children)[0] : h(Tag, [this.normalizeOwnChildren(children)]);
	    } else {
	      return this.slim ? h() : h(Tag, {
	        class: {
	          'v-portal': true
	        },
	        style: {
	          display: 'none'
	        },
	        key: 'v-portal-placeholder'
	      });
	    }
	  }
	});

	var PortalTarget = Vue.extend({
	  name: 'portalTarget',
	  props: {
	    multiple: {
	      type: Boolean,
	      default: false
	    },
	    name: {
	      type: String,
	      required: true
	    },
	    slim: {
	      type: Boolean,
	      default: false
	    },
	    slotProps: {
	      type: Object,
	      default: function _default() {
	        return {};
	      }
	    },
	    tag: {
	      type: String,
	      default: 'div'
	    },
	    transition: {
	      type: [String, Object, Function]
	    }
	  },
	  data: function data() {
	    return {
	      transports: wormhole.transports,
	      firstRender: true
	    };
	  },
	  created: function created() {
	    var _this = this;

	    this.$nextTick(function () {
	      wormhole.registerTarget(_this.name, _this);
	    });
	  },
	  watch: {
	    ownTransports: function ownTransports() {
	      this.$emit('change', this.children().length > 0);
	    },
	    name: function name(newVal, oldVal) {
	      /**
	       * TODO
	       * This should warn as well ...
	       */
	      wormhole.unregisterTarget(oldVal);
	      wormhole.registerTarget(newVal, this);
	    }
	  },
	  mounted: function mounted() {
	    var _this2 = this;

	    if (this.transition) {
	      this.$nextTick(function () {
	        // only when we have a transition, because it causes a re-render
	        _this2.firstRender = false;
	      });
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    wormhole.unregisterTarget(this.name);
	  },
	  computed: {
	    ownTransports: function ownTransports() {
	      var transports = this.transports[this.name] || [];

	      if (this.multiple) {
	        return transports;
	      }

	      return transports.length === 0 ? [] : [transports[transports.length - 1]];
	    },
	    passengers: function passengers() {
	      return combinePassengers(this.ownTransports, this.slotProps);
	    }
	  },
	  methods: {
	    // can't be a computed prop because it has to "react" to $slot changes.
	    children: function children() {
	      return this.passengers.length !== 0 ? this.passengers : this.$scopedSlots.default ? this.$scopedSlots.default(this.slotProps) : this.$slots.default || [];
	    },
	    // can't be a computed prop because it has to "react" to this.children().
	    noWrapper: function noWrapper() {
	      var noWrapper = this.slim && !this.transition;

	      if (noWrapper && this.children().length > 1) {
	        console.warn('[portal-vue]: PortalTarget with `slim` option received more than one child element.');
	      }

	      return noWrapper;
	    }
	  },
	  render: function render(h) {
	    var noWrapper = this.noWrapper();
	    var children = this.children();
	    var Tag = this.transition || this.tag;
	    return noWrapper ? children[0] : this.slim && !Tag ? h() : h(Tag, {
	      props: {
	        // if we have a transition component, pass the tag if it exists
	        tag: this.transition && this.tag ? this.tag : undefined
	      },
	      class: {
	        'vue-portal-target': true
	      }
	    }, children);
	  }
	});

	var _id$1 = 0;
	var portalProps = ['disabled', 'name', 'order', 'slim', 'slotProps', 'tag', 'to'];
	var targetProps = ['multiple', 'transition'];
	var MountingPortal = Vue.extend({
	  name: 'MountingPortal',
	  inheritAttrs: false,
	  props: {
	    append: {
	      type: [Boolean, String]
	    },
	    bail: {
	      type: Boolean
	    },
	    mountTo: {
	      type: String,
	      required: true
	    },
	    // Portal
	    disabled: {
	      type: Boolean
	    },
	    // name for the portal
	    name: {
	      type: String,
	      default: function _default() {
	        return 'mounted_' + String(_id$1++);
	      }
	    },
	    order: {
	      type: Number,
	      default: 0
	    },
	    slim: {
	      type: Boolean
	    },
	    slotProps: {
	      type: Object,
	      default: function _default() {
	        return {};
	      }
	    },
	    tag: {
	      type: String,
	      default: 'DIV'
	    },
	    // name for the target
	    to: {
	      type: String,
	      default: function _default() {
	        return String(Math.round(Math.random() * 10000000));
	      }
	    },
	    // Target
	    multiple: {
	      type: Boolean,
	      default: false
	    },
	    targetSlim: {
	      type: Boolean
	    },
	    targetSlotProps: {
	      type: Object,
	      default: function _default() {
	        return {};
	      }
	    },
	    targetTag: {
	      type: String,
	      default: 'div'
	    },
	    transition: {
	      type: [String, Object, Function]
	    }
	  },
	  created: function created() {
	    if (typeof document === 'undefined') { return; }
	    var el = document.querySelector(this.mountTo);

	    if (!el) {
	      console.error("[portal-vue]: Mount Point '".concat(this.mountTo, "' not found in document"));
	      return;
	    }

	    var props = this.$props; // Target already exists

	    if (wormhole.targets[props.name]) {
	      if (props.bail) {
	        console.warn("[portal-vue]: Target ".concat(props.name, " is already mounted.\n        Aborting because 'bail: true' is set"));
	      } else {
	        this.portalTarget = wormhole.targets[props.name];
	      }

	      return;
	    }

	    var append = props.append;

	    if (append) {
	      var type = typeof append === 'string' ? append : 'DIV';
	      var mountEl = document.createElement(type);
	      el.appendChild(mountEl);
	      el = mountEl;
	    } // get props for target from $props
	    // we have to rename a few of them


	    var _props = pick(this.$props, targetProps);

	    _props.slim = this.targetSlim;
	    _props.tag = this.targetTag;
	    _props.slotProps = this.targetSlotProps;
	    _props.name = this.to;
	    this.portalTarget = new PortalTarget({
	      el: el,
	      parent: this.$parent || this,
	      propsData: _props
	    });
	  },
	  beforeDestroy: function beforeDestroy() {
	    var target = this.portalTarget;

	    if (this.append) {
	      var el = target.$el;
	      el.parentNode.removeChild(el);
	    }

	    target.$destroy();
	  },
	  render: function render(h) {
	    if (!this.portalTarget) {
	      console.warn("[portal-vue] Target wasn't mounted");
	      return h();
	    } // if there's no "manual" scoped slot, so we create a <Portal> ourselves


	    if (!this.$scopedSlots.manual) {
	      var props = pick(this.$props, portalProps);
	      return h(Portal, {
	        props: props,
	        attrs: this.$attrs,
	        on: this.$listeners,
	        scopedSlots: this.$scopedSlots
	      }, this.$slots.default);
	    } // else, we render the scoped slot


	    var content = this.$scopedSlots.manual({
	      to: this.to
	    }); // if user used <template> for the scoped slot
	    // content will be an array

	    if (Array.isArray(content)) {
	      content = content[0];
	    }

	    if (!content) { return h(); }
	    return content;
	  }
	});

	var NAME$x = 'BToaster';
	var props$Z = {
	  name: {
	    type: String,
	    required: true
	  },
	  ariaLive: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$x, 'ariaLive');
	    }
	  },
	  ariaAtomic: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$x, 'ariaAtomic');
	    } // Allowed: 'true' or 'false' or null

	  },
	  role: {
	    // Aria role
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$x, 'role');
	    }
	  }
	  /*
	  transition: {
	    type: [Boolean, String, Object],
	    default: false
	  }
	  */

	}; // @vue/component

	var DefaultTransition =
	/*#__PURE__*/
	Vue.extend({
	  data: function data() {
	    return {
	      // Transition classes base name
	      name: 'b-toaster'
	    };
	  },
	  methods: {
	    onAfterEnter: function onAfterEnter(el) {
	      var _this = this;

	      // Handle bug where enter-to class is not removed.
	      // Bug is related to portal-vue and transition-groups.
	      requestAF(function () {
	        removeClass(el, "".concat(_this.name, "-enter-to")); // The *-move class is also stuck on elements that moved,
	        // but there are no javascript hooks to handle after move.
	      });
	    }
	  },
	  render: function render(h) {
	    return h('transition-group', {
	      props: {
	        tag: 'div',
	        name: this.name
	      },
	      on: {
	        afterEnter: this.onAfterEnter
	      }
	    }, this.$slots.default);
	  }
	}); // @vue/component

	var BToaster =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$x,
	  props: props$Z,
	  data: function data() {
	    return {
	      // We don't render on SSR or if a an existing target found
	      doRender: false,
	      dead: false,
	      // Toaster names cannot change once created
	      staticName: this.name
	    };
	  },
	  beforeMount: function beforeMount() {
	    var _this2 = this;

	    this.staticName = this.name;
	    /* istanbul ignore if */

	    if (wormhole.hasTarget(this.staticName)) {
	      warn("b-toaster: A <portal-target> with name '".concat(this.name, "' already exists in the document."));
	      this.dead = true;
	    } else {
	      this.doRender = true;
	      this.$once('hook:beforeDestroy', function () {
	        // Let toasts made with `this.$bvToast.toast()` know that this toaster
	        // is being destroyed and should should also destroy/hide themselves
	        _this2.$root.$emit('bv::toaster::destroyed', _this2.staticName);
	      });
	    }
	  },
	  destroyed: function destroyed() {
	    // Remove from DOM if needed

	    /* istanbul ignore next: difficult to test */
	    if (this.$el && this.$el.parentNode) {
	      this.$el.parentNode.removeChild(this.$el);
	    }
	  },
	  render: function render(h) {
	    var $toaster = h('div', {
	      class: ['d-none', {
	        'b-dead-toaster': this.dead
	      }]
	    });

	    if (this.doRender) {
	      var $target = h(PortalTarget, {
	        staticClass: 'b-toaster-slot',
	        props: {
	          name: this.staticName,
	          multiple: true,
	          tag: 'div',
	          slim: false,
	          // transition: this.transition || DefaultTransition
	          transition: DefaultTransition
	        }
	      });
	      $toaster = h('div', {
	        staticClass: 'b-toaster',
	        class: [this.staticName],
	        attrs: {
	          id: this.staticName,
	          role: this.role || null,
	          // Fallback to null to make sure attribute doesn't exist
	          'aria-live': this.ariaLive,
	          'aria-atomic': this.ariaAtomic
	        }
	      }, [$target]);
	    }

	    return $toaster;
	  }
	});

	function ownKeys$S(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$S(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$S(source, true).forEach(function (key) { _defineProperty$1a(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$S(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$1a(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var NAME$y = 'BToast';
	var MIN_DURATION = 1000;
	var EVENT_OPTIONS = {
	  passive: true,
	  capture: false
	}; // --- Props ---

	var props$_ = {
	  id: {
	    // Even though the ID prop is provided by idMixin, we
	    // add it here for $bvToast props filtering
	    type: String,
	    default: null
	  },
	  title: {
	    type: String,
	    default: null
	  },
	  toaster: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$y, 'toaster');
	    }
	  },
	  visible: {
	    type: Boolean,
	    default: false
	  },
	  variant: {
	    type: String,
	    default: function _default() {
	      return getComponentConfig(NAME$y, 'variant');
	    }
	  },
	  isStatus: {
	    // Switches role to 'status' and aria-live to 'polite'
	    type: Boolean,
	    default: false
	  },
	  appendToast: {
	    type: Boolean,
	    default: false
	  },
	  noAutoHide: {
	    type: Boolean,
	    default: false
	  },
	  autoHideDelay: {
	    type: [Number, String],
	    default: function _default() {
	      return getComponentConfig(NAME$y, 'autoHideDelay');
	    }
	  },
	  noCloseButton: {
	    type: Boolean,
	    default: false
	  },
	  noFade: {
	    type: Boolean,
	    default: false
	  },
	  noHoverPause: {
	    type: Boolean,
	    default: false
	  },
	  solid: {
	    type: Boolean,
	    default: false
	  },
	  toastClass: {
	    type: [String, Object, Array],
	    default: function _default() {
	      return getComponentConfig(NAME$y, 'toastClass');
	    }
	  },
	  headerClass: {
	    type: [String, Object, Array],
	    default: function _default() {
	      return getComponentConfig(NAME$y, 'headerClass');
	    }
	  },
	  bodyClass: {
	    type: [String, Object, Array],
	    default: function _default() {
	      return getComponentConfig(NAME$y, 'bodyClass');
	    }
	  },
	  href: {
	    type: String,
	    default: null
	  },
	  to: {
	    type: [String, Object],
	    default: null
	  },
	  static: {
	    // Render the toast in place, rather than in a portal-target
	    type: Boolean,
	    default: false
	  }
	}; // @vue/component

	var BToast =
	/*#__PURE__*/
	Vue.extend({
	  name: NAME$y,
	  mixins: [idMixin, listenOnRootMixin, normalizeSlotMixin, scopedStyleAttrsMixin],
	  inheritAttrs: false,
	  model: {
	    prop: 'visible',
	    event: 'change'
	  },
	  props: props$_,
	  data: function data() {
	    return {
	      isMounted: false,
	      doRender: false,
	      localShow: false,
	      isTransitioning: false,
	      isHiding: false,
	      order: 0,
	      timer: null,
	      dismissStarted: 0,
	      resumeDismiss: 0
	    };
	  },
	  computed: {
	    bToastClasses: function bToastClasses() {
	      return _defineProperty$1a({
	        'b-toast-solid': this.solid,
	        'b-toast-append': this.appendToast,
	        'b-toast-prepend': !this.appendToast
	      }, "b-toast-".concat(this.variant), this.variant);
	    },
	    slotScope: function slotScope() {
	      return {
	        hide: this.hide
	      };
	    },
	    computedDuration: function computedDuration() {
	      // Minimum supported duration is 1 second
	      return Math.max(parseInt(this.autoHideDelay, 10) || 0, MIN_DURATION);
	    },
	    computedToaster: function computedToaster() {
	      return String(this.toaster);
	    },
	    transitionHandlers: function transitionHandlers() {
	      return {
	        beforeEnter: this.onBeforeEnter,
	        afterEnter: this.onAfterEnter,
	        beforeLeave: this.onBeforeLeave,
	        afterLeave: this.onAfterLeave
	      };
	    }
	  },
	  watch: {
	    visible: function visible(newVal) {
	      newVal ? this.show() : this.hide();
	    },
	    localShow: function localShow(newVal) {
	      if (newVal !== this.visible) {
	        this.$emit('change', newVal);
	      }
	    },
	    toaster: function toaster(newVal)
	    /* istanbul ignore next */
	    {
	      var _this = this;

	      // If toaster target changed, make sure toaster exists
	      this.$nextTick(function () {
	        return _this.ensureToaster;
	      });
	    },
	    static: function _static(newVal)
	    /* istanbul ignore next */
	    {
	      // If static changes to true, and the toast is showing,
	      // ensure the toaster target exists
	      if (newVal && this.localShow) {
	        this.ensureToaster();
	      }
	    }
	  },
	  mounted: function mounted() {
	    var _this2 = this;

	    this.isMounted = true;
	    this.$nextTick(function () {
	      if (_this2.visible) {
	        requestAF(function () {
	          _this2.show();
	        });
	      }
	    }); // Listen for global $root show events

	    this.listenOnRoot('bv::show::toast', function (id) {
	      if (id === _this2.safeId()) {
	        _this2.show();
	      }
	    }); // Listen for global $root hide events

	    this.listenOnRoot('bv::hide::toast', function (id) {
	      if (!id || id === _this2.safeId()) {
	        _this2.hide();
	      }
	    }); // Make sure we hide when toaster is destroyed

	    /* istanbul ignore next: difficult to test */

	    this.listenOnRoot('bv::toaster::destroyed', function (toaster) {
	      /* istanbul ignore next */
	      if (toaster === _this2.computedToaster) {
	        /* istanbul ignore next */
	        _this2.hide();
	      }
	    });
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.clearDismissTimer();
	  },
	  methods: {
	    show: function show() {
	      var _this3 = this;

	      if (!this.localShow) {
	        this.ensureToaster();
	        var showEvt = this.buildEvent('show');
	        this.emitEvent(showEvt);
	        this.dismissStarted = this.resumeDismiss = 0;
	        this.order = Date.now() * (this.appendToast ? 1 : -1);
	        this.isHiding = false;
	        this.doRender = true;
	        this.$nextTick(function () {
	          // We show the toast after we have rendered the portal and b-toast wrapper
	          // so that screen readers will properly announce the toast
	          requestAF(function () {
	            _this3.localShow = true;
	          });
	        });
	      }
	    },
	    hide: function hide() {
	      var _this4 = this;

	      if (this.localShow) {
	        var hideEvt = this.buildEvent('hide');
	        this.emitEvent(hideEvt);
	        this.setHoverHandler(false);
	        this.dismissStarted = this.resumeDismiss = 0;
	        this.clearDismissTimer();
	        this.isHiding = true;
	        requestAF(function () {
	          _this4.localShow = false;
	        });
	      }
	    },
	    buildEvent: function buildEvent(type) {
	      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return new BvEvent(type, _objectSpread$S({
	        cancelable: false,
	        target: this.$el || null,
	        relatedTarget: null
	      }, opts, {
	        vueTarget: this,
	        componentId: this.safeId()
	      }));
	    },
	    emitEvent: function emitEvent(bvEvt) {
	      var type = bvEvt.type;
	      this.$root.$emit("bv::toast:".concat(type), bvEvt);
	      this.$emit(type, bvEvt);
	    },
	    ensureToaster: function ensureToaster() {
	      if (this.static) {
	        return;
	      }

	      if (!wormhole.hasTarget(this.computedToaster)) {
	        var div = document.createElement('div');
	        document.body.appendChild(div);
	        var toaster = new BToaster({
	          parent: this.$root,
	          propsData: {
	            name: this.computedToaster
	          }
	        });
	        toaster.$mount(div);
	      }
	    },
	    startDismissTimer: function startDismissTimer() {
	      this.clearDismissTimer();

	      if (!this.noAutoHide) {
	        this.timer = setTimeout(this.hide, this.resumeDismiss || this.computedDuration);
	        this.dismissStarted = Date.now();
	        this.resumeDismiss = 0;
	      }
	    },
	    clearDismissTimer: function clearDismissTimer() {
	      clearTimeout(this.timer);
	      this.timer = null;
	    },
	    setHoverHandler: function setHoverHandler(on) {
	      var method = on ? eventOn : eventOff;
	      var el = this.$refs['b-toast'];
	      method(el, 'mouseenter', this.onPause, EVENT_OPTIONS);
	      method(el, 'mouseleave', this.onUnPause, EVENT_OPTIONS);
	    },
	    onPause: function onPause(evt) {
	      // Determine time remaining, and then pause timer
	      if (this.noAutoHide || this.noHoverPause || !this.timer || this.resumeDismiss) {
	        return;
	      }

	      var passed = Date.now() - this.dismissStarted;

	      if (passed > 0) {
	        this.clearDismissTimer();
	        this.resumeDismiss = Math.max(this.computedDuration - passed, MIN_DURATION);
	      }
	    },
	    onUnPause: function onUnPause(evt) {
	      // Restart timer with max of time remaining or 1 second
	      if (this.noAutoHide || this.noHoverPause || !this.resumeDismiss) {
	        this.resumeDismiss = this.dismissStarted = 0;
	        return;
	      }

	      this.startDismissTimer();
	    },
	    onLinkClick: function onLinkClick() {
	      var _this5 = this;

	      // We delay the close to allow time for the
	      // browser to process the link click
	      this.$nextTick(function () {
	        requestAF(function () {
	          _this5.hide();
	        });
	      });
	    },
	    onBeforeEnter: function onBeforeEnter() {
	      this.isTransitioning = true;
	    },
	    onAfterEnter: function onAfterEnter() {
	      this.isTransitioning = false;
	      var hiddenEvt = this.buildEvent('shown');
	      this.emitEvent(hiddenEvt);
	      this.startDismissTimer();
	      this.setHoverHandler(true);
	    },
	    onBeforeLeave: function onBeforeLeave() {
	      this.isTransitioning = true;
	    },
	    onAfterLeave: function onAfterLeave() {
	      this.isTransitioning = false;
	      this.order = 0;
	      this.resumeDismiss = this.dismissStarted = 0;
	      var hiddenEvt = this.buildEvent('hidden');
	      this.emitEvent(hiddenEvt);
	      this.doRender = false;
	    },
	    makeToast: function makeToast(h) {
	      var _this6 = this;

	      // Render helper for generating the toast
	      // Assemble the header content
	      var $headerContent = [];
	      var $title = this.normalizeSlot('toast-title', this.slotScope);

	      if ($title) {
	        $headerContent.push($title);
	      } else if (this.title) {
	        $headerContent.push(h('strong', {
	          staticClass: 'mr-2'
	        }, this.title));
	      }

	      if (!this.noCloseButton) {
	        $headerContent.push(h(BButtonClose, {
	          staticClass: 'ml-auto mb-1',
	          on: {
	            click: function click(evt) {
	              _this6.hide();
	            }
	          }
	        }));
	      } // Assemble the header (if needed)


	      var $header = h();

	      if ($headerContent.length > 0) {
	        $header = h('header', {
	          staticClass: 'toast-header',
	          class: this.headerClass
	        }, $headerContent);
	      } // Toast body


	      var isLink = this.href || this.to;
	      var $body = h(isLink ? BLink : 'div', {
	        staticClass: 'toast-body',
	        class: this.bodyClass,
	        props: isLink ? {
	          to: this.to,
	          href: this.href
	        } : {},
	        on: isLink ? {
	          click: this.onLinkClick
	        } : {}
	      }, [this.normalizeSlot('default', this.slotScope) || h()]); // Build the toast

	      var $toast = h('div', {
	        key: "toast-".concat(this._uid),
	        ref: 'toast',
	        staticClass: 'toast',
	        class: this.toastClass,
	        attrs: _objectSpread$S({}, this.$attrs, {
	          tabindex: '0',
	          id: this.safeId()
	        })
	      }, [$header, $body]);
	      return $toast;
	    }
	  },
	  render: function render(h) {
	    if (!this.doRender || !this.isMounted) {
	      return h();
	    }

	    var name = "b-toast-".concat(this._uid); // If scoped styles are applied and the toast is not static,
	    // make sure the scoped style data attribute is applied

	    var scopedStyleAttrs = !this.static ? this.scopedStyleAttrs : {};
	    return h(Portal, {
	      props: {
	        name: name,
	        to: this.computedToaster,
	        order: this.order,
	        slim: true,
	        disabled: this.static
	      }
	    }, [h('div', {
	      key: name,
	      ref: 'b-toast',
	      staticClass: 'b-toast',
	      class: this.bToastClasses,
	      attrs: _objectSpread$S({}, scopedStyleAttrs, {
	        id: this.safeId('_toast_outer'),
	        role: this.isHiding ? null : this.isStatus ? 'status' : 'alert',
	        'aria-live': this.isHiding ? null : this.isStatus ? 'polite' : 'assertive',
	        'aria-atomic': this.isHiding ? null : 'true'
	      })
	    }, [h(BVTransition, {
	      props: {
	        noFade: this.noFade
	      },
	      on: this.transitionHandlers
	    }, [this.localShow ? this.makeToast(h) : h()])])]);
	  }
	});

	function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) { _defineProperties$5(Constructor.prototype, protoProps); } if (staticProps) { _defineProperties$5(Constructor, staticProps); } return Constructor; }

	function ownKeys$T(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$T(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$T(source, true).forEach(function (key) { _defineProperty$1b(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$T(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$1b(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _toConsumableArray$8(arr) { return _arrayWithoutHoles$8(arr) || _iterableToArray$8(arr) || _nonIterableSpread$8(); }

	function _nonIterableSpread$8() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray$8(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") { return Array.from(iter); } }

	function _arrayWithoutHoles$8(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	var PROP_NAME$3 = '$bvToast';
	var PROP_NAME_PRIV$1 = '_bv__toast'; // Base toast props that are allowed
	// Some may be ignored or overridden on some message boxes
	// Prop ID is allowed, but really only should be used for testing
	// We need to add it in explicitly as it comes from the `idMixin`

	var BASE_PROPS$1 = ['id'].concat(_toConsumableArray$8(keys$2(omit(props$_, ['static', 'visible'])))); // Map prop names to toast slot names

	var propsToSlots$1 = {
	  toastContent: 'default',
	  title: 'toast-title'
	}; // --- Utility methods ---
	// Method to filter only recognized props that are not undefined

	var filterOptions$1 = function filterOptions(options) {
	  return BASE_PROPS$1.reduce(function (memo, key) {
	    if (!isUndefined(options[key])) {
	      memo[key] = options[key];
	    }

	    return memo;
	  }, {});
	}; // Method to install `$bvToast` VM injection


	var plugin$1 = function plugin(Vue) {
	  // Create a private sub-component constructor that
	  // extends BToast and self-destructs after hidden
	  // @vue/component
	  var BToastPop = Vue.extend({
	    name: 'BToastPop',
	    extends: BToast,
	    destroyed: function destroyed() {
	      // Make sure we not in document any more
	      if (this.$el && this.$el.parentNode) {
	        this.$el.parentNode.removeChild(this.$el);
	      }
	    },
	    mounted: function mounted() {
	      var self = this; // Self destruct handler

	      var handleDestroy = function handleDestroy() {
	        // Ensure the toast has been force hidden
	        self.localShow = false;
	        self.doRender = false;
	        self.$nextTick(function () {
	          self.$nextTick(function () {
	            // In a `requestAF()` to release control back to application
	            // and to allow the portal-target time to remove the content
	            requestAF(function () {
	              self.$destroy();
	            });
	          });
	        });
	      }; // Self destruct if parent destroyed


	      this.$parent.$once('hook:destroyed', handleDestroy); // Self destruct after hidden

	      this.$once('hidden', handleDestroy); // Self destruct when toaster is destroyed

	      this.listenOnRoot('bv::toaster::destroyed', function (toaster) {
	        /* istanbul ignore next: hard to test */
	        if (toaster === self.toaster) {
	          handleDestroy();
	        }
	      });
	    }
	  }); // Private method to generate the on-demand toast

	  var makeToast = function makeToast(props, $parent) {
	    if (warnNotClient(PROP_NAME$3)) {
	      /* istanbul ignore next */
	      return;
	    } // Create an instance of `BToastPop` component


	    var toast = new BToastPop({
	      // We set parent as the local VM so these toasts can emit events on the
	      // app `$root`, and it ensures `BToast` is destroyed when parent is destroyed
	      parent: $parent,
	      propsData: _objectSpread$T({}, filterOptions$1(getComponentConfig('BToast') || {}), {}, omit(props, keys$2(propsToSlots$1)), {
	        // Props that can't be overridden
	        static: false,
	        visible: true
	      })
	    }); // Convert certain props to slots

	    keys$2(propsToSlots$1).forEach(function (prop) {
	      var value = props[prop];

	      if (!isUndefined(value)) {
	        // Can be a string, or array of VNodes
	        if (prop === 'title' && isString(value)) {
	          // Special case for title if it is a string, we wrap in a <strong>
	          value = [$parent.$createElement('strong', {
	            class: 'mr-2'
	          }, value)];
	        }

	        toast.$slots[propsToSlots$1[prop]] = concat(value);
	      }
	    }); // Create a mount point (a DIV) and mount it (which triggers the show)

	    var div = document.createElement('div');
	    document.body.appendChild(div);
	    toast.$mount(div);
	  }; // Declare BvToast instance property class


	  var BvToast =
	  /*#__PURE__*/
	  function () {
	    function BvToast(vm) {
	      _classCallCheck$6(this, BvToast);

	      // Assign the new properties to this instance
	      assign(this, {
	        _vm: vm,
	        _root: vm.$root
	      }); // Set these properties as read-only and non-enumerable

	      defineProperties(this, {
	        _vm: readonlyDescriptor(),
	        _root: readonlyDescriptor()
	      });
	    } // --- Public Instance methods ---
	    // Opens a user defined toast and returns immediately


	    _createClass$5(BvToast, [{
	      key: "toast",
	      value: function toast(content) {
	        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	        if (!content || warnNotClient(PROP_NAME$3)) {
	          /* istanbul ignore next */
	          return;
	        }

	        makeToast(_objectSpread$T({}, filterOptions$1(options), {
	          toastContent: content
	        }), this._vm);
	      } // shows a `<b-toast>` component with the specified ID

	    }, {
	      key: "show",
	      value: function show(id) {
	        if (id) {
	          this._root.$emit('bv::show::toast', id);
	        }
	      } // Hide a toast with specified ID, or if not ID all toasts

	    }, {
	      key: "hide",
	      value: function hide() {
	        var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	        this._root.$emit('bv::hide::toast', id);
	      }
	    }]);

	    return BvToast;
	  }(); // Add our instance mixin


	  Vue.mixin({
	    beforeCreate: function beforeCreate() {
	      // Because we need access to `$root` for `$emits`, and VM for parenting,
	      // we have to create a fresh instance of `BvToast` for each VM
	      this[PROP_NAME_PRIV$1] = new BvToast(this);
	    }
	  }); // Define our read-only `$bvToast` instance property
	  // Placed in an if just in case in HMR mode
	  // eslint-disable-next-line no-prototype-builtins

	  if (!Vue.prototype.hasOwnProperty(PROP_NAME$3)) {
	    defineProperty$1(Vue.prototype, PROP_NAME$3, {
	      get: function get() {
	        /* istanbul ignore next */
	        if (!this || !this[PROP_NAME_PRIV$1]) {
	          warn("'".concat(PROP_NAME$3, "' must be accessed from a Vue instance 'this' context"));
	        }

	        return this[PROP_NAME_PRIV$1];
	      }
	    });
	  }
	};

	var BVToastPlugin =
	/*#__PURE__*/
	pluginFactory({
	  plugins: {
	    plugin: plugin$1
	  }
	});

	var ToastPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BToast: BToast,
	    BToaster: BToaster
	  },
	  // $bvToast injection
	  plugins: {
	    BVToastPlugin: BVToastPlugin
	  }
	});

	function ownKeys$U(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$U(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$U(source, true).forEach(function (key) { _defineProperty$1c(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$U(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$1c(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var BV_TOOLTIP = '__BV_Tooltip__'; // Default trigger

	var DefaultTrigger$1 = 'hover focus'; // Valid event triggers

	var validTriggers$1 = {
	  focus: true,
	  hover: true,
	  click: true,
	  blur: true,
	  manual: true
	}; // Directive modifier test regular expressions. Pre-compile for performance

	var htmlRE$1 = /^html$/i;
	var noFadeRE$1 = /^nofade$/i;
	var placementRE$1 = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;
	var boundaryRE$1 = /^(window|viewport|scrollParent)$/i;
	var delayRE$1 = /^d\d+$/i;
	var delayShowRE$1 = /^ds\d+$/i;
	var delayHideRE$1 = /^dh\d+$/i;
	var offsetRE$1 = /^o-?\d+$/i;
	var variantRE$1 = /^v-.+$/i; // Build a Tooltip config based on bindings (if any)
	// Arguments and modifiers take precedence over passed value config object

	var parseBindings$1 = function parseBindings(bindings, vnode)
	/* istanbul ignore next: not easy to test */
	{
	  // We start out with a basic config
	  var NAME = 'BTooltip'; // Default config

	  var config = {
	    title: undefined,
	    trigger: '',
	    // Default set below if needed
	    placement: 'top',
	    fallbackPlacement: 'flip',
	    container: false,
	    // Default of body
	    animation: true,
	    offset: 0,
	    id: null,
	    html: false,
	    disabled: false,
	    delay: getComponentConfig(NAME, 'delay'),
	    boundary: String(getComponentConfig(NAME, 'boundary')),
	    boundaryPadding: parseInt(getComponentConfig(NAME, 'boundaryPadding'), 10) || 0,
	    variant: getComponentConfig(NAME, 'variant'),
	    customClass: getComponentConfig(NAME, 'customClass')
	  }; // Process `bindings.value`

	  if (isString(bindings.value) || isNumber(bindings.value)) {
	    // Value is tooltip content (HTML optionally supported)
	    config.title = bindings.value;
	  } else if (isFunction(bindings.value)) {
	    // Title generator function
	    config.title = bindings.value;
	  } else if (isPlainObject(bindings.value)) {
	    // Value is config object, so merge
	    config = _objectSpread$U({}, config, {}, bindings.value);
	  } // If title is not provided, try title attribute


	  if (isUndefined(config.title)) {
	    // Try attribute
	    var data = vnode.data || {};
	    config.title = data.attrs && !isUndefinedOrNull(data.attrs.title) ? data.attrs.title : undefined;
	  } // Normalize delay


	  if (!isPlainObject(config.delay)) {
	    config.delay = {
	      show: parseInt(config.delay, 10) || 0,
	      hide: parseInt(config.delay, 10) || 0
	    };
	  } // If argument, assume element ID of container element


	  if (bindings.arg) {
	    // Element ID specified as arg
	    // We must prepend '#' to become a CSS selector
	    config.container = "#".concat(bindings.arg);
	  } // Process modifiers


	  keys$2(bindings.modifiers).forEach(function (mod) {
	    if (htmlRE$1.test(mod)) {
	      // Title allows HTML
	      config.html = true;
	    } else if (noFadeRE$1.test(mod)) {
	      // No animation
	      config.animation = false;
	    } else if (placementRE$1.test(mod)) {
	      // Placement of tooltip
	      config.placement = mod;
	    } else if (boundaryRE$1.test(mod)) {
	      // Boundary of tooltip
	      mod = mod === 'scrollparent' ? 'scrollParent' : mod;
	      config.boundary = mod;
	    } else if (delayRE$1.test(mod)) {
	      // Delay value
	      var delay = parseInt(mod.slice(1), 10) || 0;
	      config.delay.show = delay;
	      config.delay.hide = delay;
	    } else if (delayShowRE$1.test(mod)) {
	      // Delay show value
	      config.delay.show = parseInt(mod.slice(2), 10) || 0;
	    } else if (delayHideRE$1.test(mod)) {
	      // Delay hide value
	      config.delay.hide = parseInt(mod.slice(2), 10) || 0;
	    } else if (offsetRE$1.test(mod)) {
	      // Offset value, negative allowed
	      config.offset = parseInt(mod.slice(1), 10) || 0;
	    } else if (variantRE$1.test(mod)) {
	      // Variant
	      config.variant = mod.slice(2) || null;
	    }
	  }); // Special handling of event trigger modifiers trigger is
	  // a space separated list

	  var selectedTriggers = {}; // Parse current config object trigger

	  concat(config.trigger || '').filter(Boolean).join(' ').trim().toLowerCase().split(/\s+/).forEach(function (trigger) {
	    if (validTriggers$1[trigger]) {
	      selectedTriggers[trigger] = true;
	    }
	  }); // Parse modifiers for triggers

	  keys$2(bindings.modifiers).forEach(function (mod) {
	    mod = mod.toLowerCase();

	    if (validTriggers$1[mod]) {
	      // If modifier is a valid trigger
	      selectedTriggers[mod] = true;
	    }
	  }); // Sanitize triggers

	  config.trigger = keys$2(selectedTriggers).join(' ');

	  if (config.trigger === 'blur') {
	    // Blur by itself is useless, so convert it to 'focus'
	    config.trigger = 'focus';
	  }

	  if (!config.trigger) {
	    // Use default trigger
	    config.trigger = DefaultTrigger$1;
	  } // Return the config


	  return config;
	}; // Add/update Tooltip on our element


	var applyTooltip = function applyTooltip(el, bindings, vnode) {
	  if (!isBrowser) {
	    /* istanbul ignore next */
	    return;
	  }

	  var config = parseBindings$1(bindings, vnode);

	  if (!el[BV_TOOLTIP]) {
	    var $parent = vnode.context;
	    el[BV_TOOLTIP] = new BVTooltip({
	      parent: $parent,
	      // Add the parent's scoped style attribute data
	      _scopeId: getScopeId($parent, undefined)
	    });
	    el[BV_TOOLTIP].__bv_prev_data__ = {};
	    el[BV_TOOLTIP].$on('show', function ()
	    /* istanbul ignore next: for now */
	    {
	      // Before showing the tooltip, we update the title if it is a function
	      if (isFunction(config.title)) {
	        el[BV_TOOLTIP].updateData({
	          title: config.title(el)
	        });
	      }
	    });
	  }

	  var data = {
	    title: config.title,
	    triggers: config.trigger,
	    placement: config.placement,
	    fallbackPlacement: config.fallbackPlacement,
	    variant: config.variant,
	    customClass: config.customClass,
	    container: config.container,
	    boundary: config.boundary,
	    delay: config.delay,
	    offset: config.offset,
	    noFade: !config.animation,
	    id: config.id,
	    disabled: config.disabled,
	    html: config.html
	  };
	  var oldData = el[BV_TOOLTIP].__bv_prev_data__;
	  el[BV_TOOLTIP].__bv_prev_data__ = data;

	  if (!looseEqual(data, oldData)) {
	    // We only update the instance if data has changed
	    var newData = {
	      target: el
	    };
	    keys$2(data).forEach(function (prop) {
	      // We only pass data properties that have changed
	      if (data[prop] !== oldData[prop]) {
	        // if title is a function, we execute it here
	        newData[prop] = prop === 'title' && isFunction(data[prop]) ? data[prop](el) : data[prop];
	      }
	    });
	    el[BV_TOOLTIP].updateData(newData);
	  }
	}; // Remove Tooltip on our element


	var removeTooltip = function removeTooltip(el) {
	  if (el[BV_TOOLTIP]) {
	    el[BV_TOOLTIP].$destroy();
	    el[BV_TOOLTIP] = null;
	  }

	  delete el[BV_TOOLTIP];
	}; // Export our directive


	var VBTooltip = {
	  bind: function bind(el, bindings, vnode) {
	    applyTooltip(el, bindings, vnode);
	  },
	  // We use `componentUpdated` here instead of `update`, as the former
	  // waits until the containing component and children have finished updating
	  componentUpdated: function componentUpdated(el, bindings, vnode) {
	    // Performed in a `$nextTick()` to prevent render update loops
	    vnode.context.$nextTick(function () {
	      applyTooltip(el, bindings, vnode);
	    });
	  },
	  unbind: function unbind(el) {
	    removeTooltip(el);
	  }
	};

	var VBTooltipPlugin =
	/*#__PURE__*/
	pluginFactory({
	  directives: {
	    VBTooltip: VBTooltip
	  }
	});

	var TooltipPlugin =
	/*#__PURE__*/
	pluginFactory({
	  components: {
	    BTooltip: BTooltip
	  },
	  plugins: {
	    VBTooltipPlugin: VBTooltipPlugin
	  }
	});

	var componentsPlugin =
	/*#__PURE__*/
	pluginFactory({
	  plugins: {
	    AlertPlugin: AlertPlugin,
	    BadgePlugin: BadgePlugin,
	    BreadcrumbPlugin: BreadcrumbPlugin,
	    ButtonPlugin: ButtonPlugin,
	    ButtonGroupPlugin: ButtonGroupPlugin,
	    ButtonToolbarPlugin: ButtonToolbarPlugin,
	    CardPlugin: CardPlugin,
	    CarouselPlugin: CarouselPlugin,
	    CollapsePlugin: CollapsePlugin,
	    DropdownPlugin: DropdownPlugin,
	    EmbedPlugin: EmbedPlugin,
	    FormPlugin: FormPlugin,
	    FormGroupPlugin: FormGroupPlugin,
	    FormCheckboxPlugin: FormCheckboxPlugin,
	    FormRadioPlugin: FormRadioPlugin,
	    FormInputPlugin: FormInputPlugin,
	    FormTextareaPlugin: FormTextareaPlugin,
	    FormFilePlugin: FormFilePlugin,
	    FormSelectPlugin: FormSelectPlugin,
	    ImagePlugin: ImagePlugin,
	    InputGroupPlugin: InputGroupPlugin,
	    JumbotronPlugin: JumbotronPlugin,
	    LayoutPlugin: LayoutPlugin,
	    LinkPlugin: LinkPlugin,
	    ListGroupPlugin: ListGroupPlugin,
	    MediaPlugin: MediaPlugin,
	    ModalPlugin: ModalPlugin,
	    NavPlugin: NavPlugin,
	    NavbarPlugin: NavbarPlugin,
	    PaginationPlugin: PaginationPlugin,
	    PaginationNavPlugin: PaginationNavPlugin,
	    PopoverPlugin: PopoverPlugin,
	    ProgressPlugin: ProgressPlugin,
	    SpinnerPlugin: SpinnerPlugin,
	    TablePlugin: TablePlugin,
	    TabsPlugin: TabsPlugin,
	    ToastPlugin: ToastPlugin,
	    TooltipPlugin: TooltipPlugin
	  }
	});

	var VBModalPlugin =
	/*#__PURE__*/
	pluginFactory({
	  directives: {
	    VBModal: VBModal
	  }
	});

	function ownKeys$V(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$V(target) {
	var arguments$1 = arguments;
	 for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i] != null ? arguments$1[i] : {}; if (i % 2) { ownKeys$V(source, true).forEach(function (key) { _defineProperty$1d(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$V(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

	function _defineProperty$1d(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) { _defineProperties$6(Constructor.prototype, protoProps); } if (staticProps) { _defineProperties$6(Constructor, staticProps); } return Constructor; }
	/*
	 * Constants / Defaults
	 */

	var NAME$z = 'v-b-scrollspy';
	var ACTIVATE_EVENT = 'bv::scrollspy::activate';
	var Default = {
	  element: 'body',
	  offset: 10,
	  method: 'auto',
	  throttle: 75
	};
	var DefaultType = {
	  element: '(string|element|component)',
	  offset: 'number',
	  method: 'string',
	  throttle: 'number'
	};
	var ClassName = {
	  DROPDOWN_ITEM: 'dropdown-item',
	  ACTIVE: 'active'
	};
	var Selector$2 = {
	  ACTIVE: '.active',
	  NAV_LIST_GROUP: '.nav, .list-group',
	  NAV_LINKS: '.nav-link',
	  NAV_ITEMS: '.nav-item',
	  LIST_ITEMS: '.list-group-item',
	  DROPDOWN: '.dropdown, .dropup',
	  DROPDOWN_ITEMS: '.dropdown-item',
	  DROPDOWN_TOGGLE: '.dropdown-toggle'
	};
	var OffsetMethod = {
	  OFFSET: 'offset',
	  POSITION: 'position'
	}; // HREFs must end with a hash followed by at least one non-hash character.
	// HREFs in the links are assumed to point to non-external links.
	// Comparison to the current page base URL is not performed!

	var HREF_REGEX = /^.*(#[^#]+)$/; // Transition Events

	var TransitionEndEvents$1 = ['webkitTransitionEnd', 'transitionend', 'otransitionend', 'oTransitionEnd']; // Options for events

	var EventOptions$2 = {
	  passive: true,
	  capture: false
	};
	/*
	 * Utility Methods
	 */
	// Better var type detection

	var toType$1 = function toType(obj)
	/* istanbul ignore next: not easy to test */
	{
	  return toString$2(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
	}; // Check config properties for expected types


	var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes)
	/* istanbul ignore next: not easy to test */
	{
	  for (var property in configTypes) {
	    if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
	      var expectedTypes = configTypes[property];
	      var value = config[property];
	      var valueType = value && isElement(value) ? 'element' : toType$1(value); // handle Vue instances

	      valueType = value && value._isVue ? 'component' : valueType;

	      if (!new RegExp(expectedTypes).test(valueType)) {
	        /* istanbul ignore next */
	        warn("".concat(componentName, ": Option \"").concat(property, "\" provided type \"").concat(valueType, "\" but expected type \"").concat(expectedTypes, "\""));
	      }
	    }
	  }
	};
	/*
	 * ------------------------------------------------------------------------
	 * Class Definition
	 * ------------------------------------------------------------------------
	 */

	/* istanbul ignore next: not easy to test */


	var ScrollSpy
	/* istanbul ignore next: not easy to test */
	=
	/*#__PURE__*/
	function () {
	  function ScrollSpy(element, config, $root) {
	    _classCallCheck$7(this, ScrollSpy);

	    // The element we activate links in
	    this.$el = element;
	    this.$scroller = null;
	    this.$selector = [Selector$2.NAV_LINKS, Selector$2.LIST_ITEMS, Selector$2.DROPDOWN_ITEMS].join(',');
	    this.$offsets = [];
	    this.$targets = [];
	    this.$activeTarget = null;
	    this.$scrollHeight = 0;
	    this.$resizeTimeout = null;
	    this.$obs_scroller = null;
	    this.$obs_targets = null;
	    this.$root = $root || null;
	    this.$config = null;
	    this.updateConfig(config);
	  }

	  _createClass$6(ScrollSpy, [{
	    key: "updateConfig",
	    value: function updateConfig(config, $root) {
	      if (this.$scroller) {
	        // Just in case out scroll element has changed
	        this.unlisten();
	        this.$scroller = null;
	      }

	      var cfg = _objectSpread$V({}, this.constructor.Default, {}, config);

	      if ($root) {
	        this.$root = $root;
	      }

	      typeCheckConfig(this.constructor.Name, cfg, this.constructor.DefaultType);
	      this.$config = cfg;

	      if (this.$root) {
	        var self = this;
	        this.$root.$nextTick(function () {
	          self.listen();
	        });
	      } else {
	        this.listen();
	      }
	    }
	  }, {
	    key: "dispose",
	    value: function dispose() {
	      this.unlisten();
	      clearTimeout(this.$resizeTimeout);
	      this.$resizeTimeout = null;
	      this.$el = null;
	      this.$config = null;
	      this.$scroller = null;
	      this.$selector = null;
	      this.$offsets = null;
	      this.$targets = null;
	      this.$activeTarget = null;
	      this.$scrollHeight = null;
	    }
	  }, {
	    key: "listen",
	    value: function listen() {
	      var _this = this;

	      var scroller = this.getScroller();

	      if (scroller && scroller.tagName !== 'BODY') {
	        eventOn(scroller, 'scroll', this, EventOptions$2);
	      }

	      eventOn(window, 'scroll', this, EventOptions$2);
	      eventOn(window, 'resize', this, EventOptions$2);
	      eventOn(window, 'orientationchange', this, EventOptions$2);
	      TransitionEndEvents$1.forEach(function (evtName) {
	        eventOn(window, evtName, _this, EventOptions$2);
	      });
	      this.setObservers(true); // Schedule a refresh

	      this.handleEvent('refresh');
	    }
	  }, {
	    key: "unlisten",
	    value: function unlisten() {
	      var _this2 = this;

	      var scroller = this.getScroller();
	      this.setObservers(false);

	      if (scroller && scroller.tagName !== 'BODY') {
	        eventOff(scroller, 'scroll', this, EventOptions$2);
	      }

	      eventOff(window, 'scroll', this, EventOptions$2);
	      eventOff(window, 'resize', this, EventOptions$2);
	      eventOff(window, 'orientationchange', this, EventOptions$2);
	      TransitionEndEvents$1.forEach(function (evtName) {
	        eventOff(window, evtName, _this2, EventOptions$2);
	      });
	    }
	  }, {
	    key: "setObservers",
	    value: function setObservers(on) {
	      var _this3 = this;

	      // We observe both the scroller for content changes, and the target links
	      if (this.$obs_scroller) {
	        this.$obs_scroller.disconnect();
	        this.$obs_scroller = null;
	      }

	      if (this.$obs_targets) {
	        this.$obs_targets.disconnect();
	        this.$obs_targets = null;
	      }

	      if (on) {
	        this.$obs_targets = observeDom(this.$el, function () {
	          _this3.handleEvent('mutation');
	        }, {
	          subtree: true,
	          childList: true,
	          attributes: true,
	          attributeFilter: ['href']
	        });
	        this.$obs_scroller = observeDom(this.getScroller(), function () {
	          _this3.handleEvent('mutation');
	        }, {
	          subtree: true,
	          childList: true,
	          characterData: true,
	          attributes: true,
	          attributeFilter: ['id', 'style', 'class']
	        });
	      }
	    } // General event handler

	  }, {
	    key: "handleEvent",
	    value: function handleEvent(evt) {
	      var type = isString(evt) ? evt : evt.type;
	      var self = this;

	      var resizeThrottle = function resizeThrottle() {
	        if (!self.$resizeTimeout) {
	          self.$resizeTimeout = setTimeout(function () {
	            self.refresh();
	            self.process();
	            self.$resizeTimeout = null;
	          }, self.$config.throttle);
	        }
	      };

	      if (type === 'scroll') {
	        if (!this.$obs_scroller) {
	          // Just in case we are added to the DOM before the scroll target is
	          // We re-instantiate our listeners, just in case
	          this.listen();
	        }

	        this.process();
	      } else if (/(resize|orientationchange|mutation|refresh)/.test(type)) {
	        // Postpone these events by throttle time
	        resizeThrottle();
	      }
	    } // Refresh the list of target links on the element we are applied to

	  }, {
	    key: "refresh",
	    value: function refresh() {
	      var _this4 = this;

	      var scroller = this.getScroller();

	      if (!scroller) {
	        return;
	      }

	      var autoMethod = scroller !== scroller.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;
	      var method = this.$config.method === 'auto' ? autoMethod : this.$config.method;
	      var methodFn = method === OffsetMethod.POSITION ? position : offset;
	      var offsetBase = method === OffsetMethod.POSITION ? this.getScrollTop() : 0;
	      this.$offsets = [];
	      this.$targets = [];
	      this.$scrollHeight = this.getScrollHeight(); // Find all the unique link HREFs that we will control

	      selectAll(this.$selector, this.$el) // Get HREF value
	      .map(function (link) {
	        return getAttr(link, 'href');
	      }) // Filter out HREFs that do not match our RegExp
	      .filter(function (href) {
	        return href && HREF_REGEX.test(href || '');
	      }) // Find all elements with ID that match HREF hash
	      .map(function (href) {
	        // Convert HREF into an ID (including # at beginning)
	        var id = href.replace(HREF_REGEX, '$1').trim();

	        if (!id) {
	          return null;
	        } // Find the element with the ID specified by id


	        var el = select(id, scroller);

	        if (el && isVisible(el)) {
	          return {
	            offset: parseInt(methodFn(el).top, 10) + offsetBase,
	            target: id
	          };
	        }

	        return null;
	      }).filter(Boolean) // Sort them by their offsets (smallest first)
	      .sort(function (a, b) {
	        return a.offset - b.offset;
	      }) // record only unique targets/offsets
	      .reduce(function (memo, item) {
	        if (!memo[item.target]) {
	          _this4.$offsets.push(item.offset);

	          _this4.$targets.push(item.target);

	          memo[item.target] = true;
	        }

	        return memo;
	      }, {}); // Return this for easy chaining

	      return this;
	    } // Handle activating/clearing

	  }, {
	    key: "process",
	    value: function process() {
	      var scrollTop = this.getScrollTop() + this.$config.offset;
	      var scrollHeight = this.getScrollHeight();
	      var maxScroll = this.$config.offset + scrollHeight - this.getOffsetHeight();

	      if (this.$scrollHeight !== scrollHeight) {
	        this.refresh();
	      }

	      if (scrollTop >= maxScroll) {
	        var target = this.$targets[this.$targets.length - 1];

	        if (this.$activeTarget !== target) {
	          this.activate(target);
	        }

	        return;
	      }

	      if (this.$activeTarget && scrollTop < this.$offsets[0] && this.$offsets[0] > 0) {
	        this.$activeTarget = null;
	        this.clear();
	        return;
	      }

	      for (var i = this.$offsets.length; i--;) {
	        var isActiveTarget = this.$activeTarget !== this.$targets[i] && scrollTop >= this.$offsets[i] && (isUndefined(this.$offsets[i + 1]) || scrollTop < this.$offsets[i + 1]);

	        if (isActiveTarget) {
	          this.activate(this.$targets[i]);
	        }
	      }
	    }
	  }, {
	    key: "getScroller",
	    value: function getScroller() {
	      if (this.$scroller) {
	        return this.$scroller;
	      }

	      var scroller = this.$config.element;

	      if (!scroller) {
	        return null;
	      } else if (isElement(scroller.$el)) {
	        scroller = scroller.$el;
	      } else if (isString(scroller)) {
	        scroller = select(scroller);
	      }

	      if (!scroller) {
	        return null;
	      }

	      this.$scroller = scroller.tagName === 'BODY' ? window : scroller;
	      return this.$scroller;
	    }
	  }, {
	    key: "getScrollTop",
	    value: function getScrollTop() {
	      var scroller = this.getScroller();
	      return scroller === window ? scroller.pageYOffset : scroller.scrollTop;
	    }
	  }, {
	    key: "getScrollHeight",
	    value: function getScrollHeight() {
	      return this.getScroller().scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
	    }
	  }, {
	    key: "getOffsetHeight",
	    value: function getOffsetHeight() {
	      var scroller = this.getScroller();
	      return scroller === window ? window.innerHeight : getBCR(scroller).height;
	    }
	  }, {
	    key: "activate",
	    value: function activate(target) {
	      var _this5 = this;

	      this.$activeTarget = target;
	      this.clear(); // Grab the list of target links (<a href="{$target}">)

	      var links = selectAll(this.$selector // Split out the base selectors
	      .split(',') // Map to a selector that matches links with HREF ending in the ID (including '#')
	      .map(function (selector) {
	        return "".concat(selector, "[href$=\"").concat(target, "\"]");
	      }) // Join back into a single selector string
	      .join(','), this.$el);
	      links.forEach(function (link) {
	        if (hasClass(link, ClassName.DROPDOWN_ITEM)) {
	          // This is a dropdown item, so find the .dropdown-toggle and set it's state
	          var dropdown = closest(Selector$2.DROPDOWN, link);

	          if (dropdown) {
	            _this5.setActiveState(select(Selector$2.DROPDOWN_TOGGLE, dropdown), true);
	          } // Also set this link's state


	          _this5.setActiveState(link, true);
	        } else {
	          // Set triggered link as active
	          _this5.setActiveState(link, true);

	          if (matches(link.parentElement, Selector$2.NAV_ITEMS)) {
	            // Handle nav-link inside nav-item, and set nav-item active
	            _this5.setActiveState(link.parentElement, true);
	          } // Set triggered links parents as active
	          // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor


	          var el = link;

	          while (el) {
	            el = closest(Selector$2.NAV_LIST_GROUP, el);
	            var sibling = el ? el.previousElementSibling : null;

	            if (sibling && matches(sibling, "".concat(Selector$2.NAV_LINKS, ", ").concat(Selector$2.LIST_ITEMS))) {
	              _this5.setActiveState(sibling, true);
	            } // Handle special case where nav-link is inside a nav-item


	            if (sibling && matches(sibling, Selector$2.NAV_ITEMS)) {
	              _this5.setActiveState(select(Selector$2.NAV_LINKS, sibling), true); // Add active state to nav-item as well


	              _this5.setActiveState(sibling, true);
	            }
	          }
	        }
	      }); // Signal event to via $root, passing ID of activated target and reference to array of links

	      if (links && links.length > 0 && this.$root) {
	        this.$root.$emit(ACTIVATE_EVENT, target, links);
	      }
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      var _this6 = this;

	      selectAll("".concat(this.$selector, ", ").concat(Selector$2.NAV_ITEMS), this.$el).filter(function (el) {
	        return hasClass(el, ClassName.ACTIVE);
	      }).forEach(function (el) {
	        return _this6.setActiveState(el, false);
	      });
	    }
	  }, {
	    key: "setActiveState",
	    value: function setActiveState(el, active) {
	      if (!el) {
	        return;
	      }

	      if (active) {
	        addClass(el, ClassName.ACTIVE);
	      } else {
	        removeClass(el, ClassName.ACTIVE);
	      }
	    }
	  }], [{
	    key: "Name",
	    get: function get() {
	      return NAME$z;
	    }
	  }, {
	    key: "Default",
	    get: function get() {
	      return Default;
	    }
	  }, {
	    key: "DefaultType",
	    get: function get() {
	      return DefaultType;
	    }
	  }]);

	  return ScrollSpy;
	}();

	var BV_SCROLLSPY = '__BV_ScrollSpy__'; // Build a ScrollSpy config based on bindings (if any)
	// Arguments and modifiers take precedence over passed value config object

	/* istanbul ignore next: not easy to test */

	var parseBindings$2 = function parseBindings(bindings)
	/* istanbul ignore next: not easy to test */
	{
	  var config = {}; // If argument, assume element ID

	  if (bindings.arg) {
	    // Element ID specified as arg
	    // We must prepend '#' to become a CSS selector
	    config.element = "#".concat(bindings.arg);
	  } // Process modifiers


	  keys$2(bindings.modifiers).forEach(function (mod) {
	    if (/^\d+$/.test(mod)) {
	      // Offset value
	      config.offset = parseInt(mod, 10);
	    } else if (/^(auto|position|offset)$/.test(mod)) {
	      // Offset method
	      config.method = mod;
	    }
	  }); // Process value

	  if (isString(bindings.value)) {
	    // Value is a CSS ID or selector
	    config.element = bindings.value;
	  } else if (isNumber(bindings.value)) {
	    // Value is offset
	    config.offset = Math.round(bindings.value);
	  } else if (isObject(bindings.value)) {
	    // Value is config object
	    // Filter the object based on our supported config options
	    keys$2(bindings.value).filter(function (k) {
	      return Boolean(ScrollSpy.DefaultType[k]);
	    }).forEach(function (k) {
	      config[k] = bindings.value[k];
	    });
	  }

	  return config;
	}; // Add or update ScrollSpy on our element


	var applyScrollspy = function applyScrollspy(el, bindings, vnode)
	/* istanbul ignore next: not easy to test */
	{
	  if (!isBrowser) {
	    /* istanbul ignore next */
	    return;
	  }

	  var config = parseBindings$2(bindings);

	  if (el[BV_SCROLLSPY]) {
	    el[BV_SCROLLSPY].updateConfig(config, vnode.context.$root);
	  } else {
	    el[BV_SCROLLSPY] = new ScrollSpy(el, config, vnode.context.$root);
	  }
	}; // Remove ScrollSpy on our element

	/* istanbul ignore next: not easy to test */


	var removeScrollspy = function removeScrollspy(el)
	/* istanbul ignore next: not easy to test */
	{
	  if (el[BV_SCROLLSPY]) {
	    el[BV_SCROLLSPY].dispose();
	    el[BV_SCROLLSPY] = null;
	    delete el[BV_SCROLLSPY];
	  }
	};
	/*
	 * Export our directive
	 */


	var VBScrollspy = {
	  bind: function bind(el, bindings, vnode)
	  /* istanbul ignore next: not easy to test */
	  {
	    applyScrollspy(el, bindings, vnode);
	  },
	  inserted: function inserted(el, bindings, vnode)
	  /* istanbul ignore next: not easy to test */
	  {
	    applyScrollspy(el, bindings, vnode);
	  },
	  update: function update(el, bindings, vnode)
	  /* istanbul ignore next: not easy to test */
	  {
	    if (bindings.value !== bindings.oldValue) {
	      applyScrollspy(el, bindings, vnode);
	    }
	  },
	  componentUpdated: function componentUpdated(el, bindings, vnode)
	  /* istanbul ignore next: not easy to test */
	  {
	    if (bindings.value !== bindings.oldValue) {
	      applyScrollspy(el, bindings, vnode);
	    }
	  },
	  unbind: function unbind(el)
	  /* istanbul ignore next: not easy to test */
	  {
	    removeScrollspy(el);
	  }
	};

	var VBScrollspyPlugin =
	/*#__PURE__*/
	pluginFactory({
	  directives: {
	    VBScrollspy: VBScrollspy
	  }
	});

	var VBTogglePlugin =
	/*#__PURE__*/
	pluginFactory({
	  directives: {
	    VBToggle: VBToggle
	  }
	});

	var VBVisiblePlugin =
	/*#__PURE__*/
	pluginFactory({
	  directives: {
	    VBVisible: VBVisible
	  }
	});

	var directivesPlugin =
	/*#__PURE__*/
	pluginFactory({
	  plugins: {
	    VBModalPlugin: VBModalPlugin,
	    VBPopoverPlugin: VBPopoverPlugin,
	    VBScrollspyPlugin: VBScrollspyPlugin,
	    VBTogglePlugin: VBTogglePlugin,
	    VBTooltipPlugin: VBTooltipPlugin,
	    VBVisiblePlugin: VBVisiblePlugin
	  }
	});

	/*!
	 * BoostrapVue 2.1.0
	 *
	 * @link https://bootstrap-vue.js.org
	 * @source https://github.com/bootstrap-vue/bootstrap-vue
	 * @copyright (c) 2016-2019 BootstrapVue
	 * @license MIT
	 * https://github.com/bootstrap-vue/bootstrap-vue/blob/master/LICENSE
	 */
	var NAME$A = 'BootstrapVue'; //
	// BootstrapVue installer
	//

	var install =
	/*#__PURE__*/
	installFactory({
	  plugins: {
	    componentsPlugin: componentsPlugin,
	    directivesPlugin: directivesPlugin
	  }
	}); //
	// BootstrapVue plugin
	//

	var BootstrapVue =
	/*#__PURE__*/
	{
	  install: install,
	  NAME: NAME$A
	}; //

	var vue2Filters = createCommonjsModule(function (module, exports) {
	(function webpackUniversalModuleDefinition(root, factory) {
		{ module.exports = factory(); }
	})(typeof self !== 'undefined' ? self : commonjsGlobal, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId]) {
	/******/ 			return installedModules[moduleId].exports;
	/******/ 		}
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			i: moduleId,
	/******/ 			l: false,
	/******/ 			exports: {}
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.l = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// define getter function for harmony exports
	/******/ 	__webpack_require__.d = function(exports, name, getter) {
	/******/ 		if(!__webpack_require__.o(exports, name)) {
	/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
	/******/ 		}
	/******/ 	};
	/******/
	/******/ 	// define __esModule on exports
	/******/ 	__webpack_require__.r = function(exports) {
	/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
	/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
	/******/ 		}
	/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
	/******/ 	};
	/******/
	/******/ 	// create a fake namespace object
	/******/ 	// mode & 1: value is a module id, require it
	/******/ 	// mode & 2: merge all properties of value into the ns
	/******/ 	// mode & 4: return value when already ns object
	/******/ 	// mode & 8|1: behave like require
	/******/ 	__webpack_require__.t = function(value, mode) {
	/******/ 		if(mode & 1) { value = __webpack_require__(value); }
	/******/ 		if(mode & 8) { return value; }
	/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) { return value; }
	/******/ 		var ns = Object.create(null);
	/******/ 		__webpack_require__.r(ns);
	/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
	/******/ 		if(mode & 2 && typeof value != 'string') { for(var key in value) { __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key)); } }
	/******/ 		return ns;
	/******/ 	};
	/******/
	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
	/******/ 	__webpack_require__.n = function(module) {
	/******/ 		var getter = module && module.__esModule ?
	/******/ 			function getDefault() { return module['default']; } :
	/******/ 			function getModuleExports() { return module; };
	/******/ 		__webpack_require__.d(getter, 'a', getter);
	/******/ 		return getter;
	/******/ 	};
	/******/
	/******/ 	// Object.prototype.hasOwnProperty.call
	/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(__webpack_require__.s = 0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
	__webpack_require__.r(__webpack_exports__);
	var string_namespaceObject = {};
	__webpack_require__.r(string_namespaceObject);
	__webpack_require__.d(string_namespaceObject, "capitalize", function() { return string_capitalize; });
	__webpack_require__.d(string_namespaceObject, "uppercase", function() { return string_uppercase; });
	__webpack_require__.d(string_namespaceObject, "lowercase", function() { return string_lowercase; });
	__webpack_require__.d(string_namespaceObject, "placeholder", function() { return string_placeholder; });
	__webpack_require__.d(string_namespaceObject, "truncate", function() { return string_truncate; });
	var other_namespaceObject = {};
	__webpack_require__.r(other_namespaceObject);
	__webpack_require__.d(other_namespaceObject, "currency", function() { return other_currency; });
	__webpack_require__.d(other_namespaceObject, "bytes", function() { return other_bytes; });
	__webpack_require__.d(other_namespaceObject, "pluralize", function() { return other_pluralize; });
	__webpack_require__.d(other_namespaceObject, "ordinal", function() { return other_ordinal; });
	__webpack_require__.d(other_namespaceObject, "number", function() { return other_number; });

	// CONCATENATED MODULE: ./src/util/index.js
	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") { return Array.from(iter); } }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	var ObjProto = Object.prototype;
	var util_toString = ObjProto.toString;
	var util = {};

	util.isArray = function (obj) {
	  return Array.isArray(obj);
	};

	var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

	util.isArrayLike = function (obj) {
	  if (_typeof(obj) !== 'object' || !obj) {
	    return false;
	  }

	  var length = obj.length;
	  return typeof length === 'number' && length % 1 === 0 && length >= 0 && length <= MAX_ARRAY_INDEX;
	};

	util.isObject = function (obj) {
	  var type = _typeof(obj);

	  return type === 'function' || type === 'object' && !!obj;
	};

	util.each = function (obj, callback) {
	  var i, len;

	  if (util.isArray(obj)) {
	    for (i = 0, len = obj.length; i < len; i++) {
	      if (callback(obj[i], i, obj) === false) {
	        break;
	      }
	    }
	  } else {
	    for (i in obj) {
	      if (callback(obj[i], i, obj) === false) {
	        break;
	      }
	    }
	  }

	  return obj;
	};

	util.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function (name) {
	  util['is' + name] = function (obj) {
	    return util_toString.call(obj) === '[object ' + name + ']';
	  };
	});

	util.toArray = function (list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);

	  while (i--) {
	    ret[i] = list[i + start];
	  }

	  return ret;
	};

	util.toNumber = function (value) {
	  if (typeof value !== 'string') {
	    return value;
	  } else {
	    var parsed = Number(value);
	    return isNaN(parsed) ? value : parsed;
	  }
	};

	util.convertRangeToArray = function (range) {
	  return _toConsumableArray(Array(range + 1).keys()).slice(1);
	};

	util.convertArray = function (value) {
	  if (util.isArray(value)) {
	    return value;
	  } else if (util.isPlainObject(value)) {
	    // convert plain object to array.
	    var keys = Object.keys(value);
	    var i = keys.length;
	    var res = new Array(i);
	    var key;

	    while (i--) {
	      key = keys[i];
	      res[i] = {
	        $key: key,
	        $value: value[key]
	      };
	    }

	    return res;
	  } else {
	    return value || [];
	  }
	};

	function multiIndex(obj, is) {
	  // obj,['1','2','3'] -> ((obj['1'])['2'])['3']
	  return is.length ? multiIndex(obj[is[0]], is.slice(1)) : obj;
	}

	util.getPath = function (obj, is) {
	  // obj,'1.2.3' -> multiIndex(obj,['1','2','3'])
	  return multiIndex(obj, is.split('.'));
	};
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */


	var util_toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';

	util.isPlainObject = function (obj) {
	  return util_toString.call(obj) === OBJECT_STRING;
	};

	util.exist = function (value) {
	  return value !== null && typeof value !== 'undefined';
	};

	/* harmony default export */ var src_util = (util);
	// CONCATENATED MODULE: ./src/string/capitalize.js
	/**
	 *  Converts a string into Capitalize
	 * 
	 * 'abc' => 'Abc'
	 * 
	 * @param {Object} options
	 */
	function capitalize(value, options) {
	  var globalOptions = this && this.capitalize ? this.capitalize : {};
	  options = options || globalOptions;
	  var onlyFirstLetter = options.onlyFirstLetter != null ? options.onlyFirstLetter : false;
	  if (!value && value !== 0) { return ''; }

	  if (onlyFirstLetter === true) {
	    return value.toString().charAt(0).toUpperCase() + value.toString().slice(1);
	  } else {
	    value = value.toString().toLowerCase().split(' ');
	    return value.map(function (item) {
	      return item.charAt(0).toUpperCase() + item.slice(1);
	    }).join(' ');
	  }
	}

	/* harmony default export */ var string_capitalize = (capitalize);
	// CONCATENATED MODULE: ./src/string/uppercase.js
	/**
	 * Converts a string to UPPERCASE
	 * 
	 * 'abc' => 'ABC'
	 */
	function uppercase(value) {
	  return value || value === 0 ? value.toString().toUpperCase() : '';
	}

	/* harmony default export */ var string_uppercase = (uppercase);
	// CONCATENATED MODULE: ./src/string/lowercase.js
	/**
	 * Converts a string to lowercase
	 * 
	 * 'AbC' => 'abc'
	 */
	function lowercase(value) {
	  return value || value === 0 ? value.toString().toLowerCase() : '';
	}

	/* harmony default export */ var string_lowercase = (lowercase);
	// CONCATENATED MODULE: ./src/string/placeholder.js
	/**
	 *  If the value is missing outputs the placeholder text
	 * 
	 * '' => {placeholder}
	 * 'foo' => 'foo'
	 */
	function placeholder(input, property) {
	  return input === undefined || input === '' || input === null ? property : input;
	}

	/* harmony default export */ var string_placeholder = (placeholder);
	// CONCATENATED MODULE: ./src/string/truncate.js
	/**
	 *  Truncate at the given || default length
	 *
	 * 'lorem ipsum dolor' => 'lorem ipsum dol...'
	 */
	function truncate(value, length) {
	  length = length || 15;
	  if (!value || typeof value !== 'string') { return ''; }
	  if (value.length <= length) { return value; }
	  return value.substring(0, length) + '...';
	}

	/* harmony default export */ var string_truncate = (truncate);
	// CONCATENATED MODULE: ./src/string/index.js






	// CONCATENATED MODULE: ./src/array/limitBy.js

	/**
	 * Limit filter for arrays
	 *
	 * @param {Number|Array} arr (If Number, decimal expected)
	 * @param {Number} n
	 * @param {Number} offset (Decimal expected)
	 */

	function limitBy(arr, n, offset) {
	  arr = src_util.isArray(arr) ? arr : src_util.convertRangeToArray(arr);
	  offset = offset ? parseInt(offset, 10) : 0;
	  n = src_util.toNumber(n);
	  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
	}

	/* harmony default export */ var array_limitBy = (limitBy);
	// CONCATENATED MODULE: ./src/array/filterBy.js

	/**
	 * Filter filter for arrays
	 *
	 * @param {Array} arr
	 * @param {String} prop
	 * @param {String|Number} search
	 */

	function filterBy(arr, search) {
	  var arr = src_util.convertArray(arr);

	  if (search == null) {
	    return arr;
	  }

	  if (typeof search === 'function') {
	    return arr.filter(search);
	  } // cast to lowercase string


	  search = ('' + search).toLowerCase();
	  var n = 2; // extract and flatten keys

	  var keys = Array.prototype.concat.apply([], src_util.toArray(arguments, n));
	  var res = [];
	  var item, key, val, j;

	  for (var i = 0, l = arr.length; i < l; i++) {
	    item = arr[i];
	    val = item && item.$value || item;
	    j = keys.length;

	    if (j) {
	      while (j--) {
	        key = keys[j];

	        if (key === '$key' && contains(item.$key, search) || contains(src_util.getPath(val, key), search)) {
	          res.push(item);
	          break;
	        }
	      }
	    } else if (contains(item, search)) {
	      res.push(item);
	    }
	  }

	  return res;
	}

	function contains(val, search) {
	  var i;

	  if (src_util.isPlainObject(val)) {
	    var keys = Object.keys(val);
	    i = keys.length;

	    while (i--) {
	      if (contains(val[keys[i]], search)) {
	        return true;
	      }
	    }
	  } else if (src_util.isArray(val)) {
	    i = val.length;

	    while (i--) {
	      if (contains(val[i], search)) {
	        return true;
	      }
	    }
	  } else if (val != null) {
	    return val.toString().toLowerCase().indexOf(search) > -1;
	  }
	}

	/* harmony default export */ var array_filterBy = (filterBy);
	// CONCATENATED MODULE: ./src/array/orderBy.js

	/**
	 * Filter filter for arrays
	 *
	 * @param {String|Array<String>|Function} ...sortKeys
	 * @param {Number} [order]
	 */

	function orderBy(arr) {
	  var _comparator = null;
	  var sortKeys;
	  arr = src_util.convertArray(arr); // determine order (last argument)

	  var args = src_util.toArray(arguments, 1);
	  var order = args[args.length - 1];

	  if (typeof order === 'number') {
	    order = order < 0 ? -1 : 1;
	    args = args.length > 1 ? args.slice(0, -1) : args;
	  } else {
	    order = 1;
	  } // determine sortKeys & comparator


	  var firstArg = args[0];

	  if (!firstArg) {
	    return arr;
	  } else if (typeof firstArg === 'function') {
	    // custom comparator
	    _comparator = function comparator(a, b) {
	      return firstArg(a, b) * order;
	    };
	  } else {
	    // string keys. flatten first
	    sortKeys = Array.prototype.concat.apply([], args);

	    _comparator = function comparator(a, b, i) {
	      i = i || 0;
	      return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || _comparator(a, b, i + 1);
	    };
	  }

	  function baseCompare(a, b, sortKeyIndex) {
	    var sortKey = sortKeys[sortKeyIndex];

	    if (sortKey) {
	      if (sortKey !== '$key') {
	        if (src_util.isObject(a) && '$value' in a) { a = a.$value; }
	        if (src_util.isObject(b) && '$value' in b) { b = b.$value; }
	      }

	      a = src_util.isObject(a) ? src_util.getPath(a, sortKey) : a;
	      b = src_util.isObject(b) ? src_util.getPath(b, sortKey) : b;
	      a = typeof a === 'string' ? a.toLowerCase() : a;
	      b = typeof b === 'string' ? b.toLowerCase() : b;
	    }

	    return a === b ? 0 : a > b ? order : -order;
	  } // sort on a copy to avoid mutating original array


	  return arr.slice().sort(_comparator);
	}

	/* harmony default export */ var array_orderBy = (orderBy);
	// CONCATENATED MODULE: ./src/array/find.js

	/**
	 * Get first matching element from a filtered array
	 *
	 * @param {Array} arr
	 * @param {String|Number} search
	 * @returns {mixed}
	 */

	function find(arr, search) {
	  var array = array_filterBy.apply(this, arguments);
	  array.splice(1);
	  return array;
	}

	/* harmony default export */ var array_find = (find);
	// CONCATENATED MODULE: ./src/array/index.js





	// CONCATENATED MODULE: ./src/other/currency.js

	/**
	 * 
	 * 12345 => $12,345.00
	 *
	 * @param {String} symbol
	 * @param {Number} decimals Decimal places
	 * @param {Object} options
	 */

	function currency(value, symbol, decimals, options) {
	  var globalOptions = this && this.currency ? this.currency : {};
	  symbol = src_util.exist(symbol) ? symbol : globalOptions.symbol;
	  decimals = src_util.exist(decimals) ? decimals : globalOptions.decimalDigits;
	  options = options || globalOptions;
	  var thousandsSeparator, symbolOnLeft, spaceBetweenAmountAndSymbol, showPlusSign;
	  var digitsRE = /(\d{3})(?=\d)/g;
	  value = parseFloat(value);
	  if (!isFinite(value) || !value && value !== 0) { return ''; }
	  symbol = typeof symbol !== 'undefined' ? symbol : '$';
	  decimals = typeof decimals !== 'undefined' ? decimals : 2;
	  thousandsSeparator = options.thousandsSeparator != null ? options.thousandsSeparator : ',';
	  symbolOnLeft = options.symbolOnLeft != null ? options.symbolOnLeft : true;
	  spaceBetweenAmountAndSymbol = options.spaceBetweenAmountAndSymbol != null ? options.spaceBetweenAmountAndSymbol : false;
	  showPlusSign = options.showPlusSign != null ? options.showPlusSign : false;
	  var number = Math.abs(value);
	  var stringified = toFixed(number, decimals);
	  stringified = options.decimalSeparator ? stringified.replace('.', options.decimalSeparator) : stringified;

	  var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;

	  var i = _int.length % 3;
	  var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? thousandsSeparator : '') : '';

	  var _float = decimals ? stringified.slice(-1 - decimals) : '';

	  symbol = spaceBetweenAmountAndSymbol ? symbolOnLeft ? symbol + ' ' : ' ' + symbol : symbol;
	  symbol = symbolOnLeft ? symbol + head + _int.slice(i).replace(digitsRE, '$1' + thousandsSeparator) + _float : head + _int.slice(i).replace(digitsRE, '$1' + thousandsSeparator) + _float + symbol;
	  var sign = value < 0 ? '-' : '';
	  var plusSign = value > 0 && showPlusSign ? '+' : '';
	  return plusSign + sign + symbol;
	}

	function toFixed(num, precision) {
	  return (+(Math.round(+(num + 'e' + precision)) + 'e' + -precision)).toFixed(precision);
	}

	/* harmony default export */ var other_currency = (currency);
	// CONCATENATED MODULE: ./src/other/bytes.js

	/**
	 * 8                => '8 byte'
	 * 1024             => '1.00 kb'
	 * 2000000          => '1.90 MB'
	 * 2000000000       => '1.86 GB'
	 * 2000000000000    => '1.82 TB'
	 *
	 * @param {Number} value
	 * @param {Number} decimals Decimal places (default: 2)
	 */

	function bytes(value, decimals) {
	  var globalOptions = this && this.bytes ? this.bytes : {};
	  decimals = src_util.exist(decimals) ? decimals : globalOptions.decimalDigits;
	  decimals = typeof decimals !== 'undefined' ? decimals : 2;
	  value = value === null || isNaN(value) ? 0 : value;

	  if (value >= Math.pow(1024, 4)) {
	    // TB
	    return "".concat((value / Math.pow(1024, 4)).toFixed(decimals), " TB");
	  } else if (value >= Math.pow(1024, 3)) {
	    // GB
	    return "".concat((value / Math.pow(1024, 3)).toFixed(decimals), " GB");
	  } else if (value >= Math.pow(1024, 2)) {
	    // MB
	    return "".concat((value / Math.pow(1024, 2)).toFixed(decimals), " MB");
	  } else if (value >= 1024) {
	    // kb
	    return "".concat((value / 1024).toFixed(decimals), " kb");
	  } // byte


	  return "".concat(value, " byte");
	}

	/* harmony default export */ var other_bytes = (bytes);
	// CONCATENATED MODULE: ./src/other/pluralize.js

	/**
	 * 'item' => 'items'
	 *
	 * @param {String|Array} word
	 * @param {Object} options
	 *
	 */

	function pluralize(value, word, options) {
	  var globalOptions = this && this.pluralize ? this.pluralize : {};
	  options = options || globalOptions;
	  var output = '';
	  var includeNumber = options.includeNumber != null ? options.includeNumber : false;
	  if (includeNumber === true) { output += value + ' '; }
	  if (!value && value !== 0 || !word) { return output; }

	  if (Array.isArray(word)) {
	    output += word[value - 1] || word[word.length - 1];
	  } else {
	    output += word + (value === 1 ? '' : 's');
	  }

	  return output;
	}

	/* harmony default export */ var other_pluralize = (pluralize);
	// CONCATENATED MODULE: ./src/other/ordinal.js

	/**
	 * 42 => 'nd'
	 *
	 * @params {Object} options
	 * 
	 */

	function ordinal(value, options) {
	  var globalOptions = this && this.ordinal ? this.ordinal : {};
	  options = options || globalOptions;
	  var output = '';
	  var includeNumber = options.includeNumber != null ? options.includeNumber : false;
	  if (includeNumber === true) { output += value; }
	  var j = value % 10,
	      k = value % 100;
	  if (j == 1 && k != 11) { output += 'st'; }else if (j == 2 && k != 12) { output += 'nd'; }else if (j == 3 && k != 13) { output += 'rd'; }else { output += 'th'; }
	  return output;
	}

	/* harmony default export */ var other_ordinal = (ordinal);
	// CONCATENATED MODULE: ./src/other/number.js

	/**
	 * 123456 => '123,456'
	 *
	 * @params {Object} options
	 * 
	 */

	function number_number(value, format, options) {
	  var globalOptions = this && this.number ? this.number : {};
	  format = src_util.exist(format) ? format : globalOptions.format;
	  options = options || globalOptions;
	  var config = parseFormat(format);
	  var number = parseNumber(value);
	  var thousandsSeparator = options.thousandsSeparator != null ? options.thousandsSeparator : ',';
	  var decimalSeparator = options.decimalSeparator != null ? options.decimalSeparator : '.';
	  config.sign = config.sign || number.sign;

	  if (config.unit) {
	    var numberWithUnit = addUnit(number.float, config);
	    return config.sign + numberWithUnit;
	  }

	  var int = config.decimals === 0 ? number_toFixed(number.float, 0) : number.int;

	  switch (config.base) {
	    case '':
	      int = '';
	      break;

	    case '0,0':
	      int = addSeparator(int, thousandsSeparator);
	      break;
	  }

	  var fraction = getFraction(number.float, config.decimals, decimalSeparator);
	  return config.sign + int + fraction;
	}

	Math.sign = function (x) {
	  x = +x;

	  if (x === 0 || isNaN(x)) {
	    return x;
	  }

	  return x > 0 ? 1 : -1;
	};

	function parseNumber(num) {
	  return {
	    float: Math.abs(parseFloat(num)),
	    int: Math.abs(parseInt(num)),
	    sign: Math.sign(num) < 0 ? '-' : ''
	  };
	}

	function parseFormat() {
	  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0';
	  var regex = /([\+\-])?([0-9\,]+)?([\.0-9]+)?([a\s]+)?/;
	  var matches = string ? string.match(regex) : ['', '', '', '', ''];
	  var float = matches[3];
	  var decimals = float ? float.match(/0/g).length : 0;
	  return {
	    sign: matches[1] || '',
	    base: matches[2] || '',
	    decimals: decimals,
	    unit: matches[4] || ''
	  };
	}

	function addUnit(num, config) {
	  var rx = /\.0+$|(\.[0-9]*[1-9])0+$/;
	  var si = [{
	    value: 1,
	    symbol: ""
	  }, {
	    value: 1E3,
	    symbol: "K"
	  }, {
	    value: 1E6,
	    symbol: "M"
	  }];
	  var i;

	  for (i = si.length - 1; i > 0; i--) {
	    if (num >= si[i].value) {
	      break;
	    }
	  }

	  num = (num / si[i].value).toFixed(config.decimals).replace(rx, "$1");
	  return num + config.unit.replace('a', si[i].symbol);
	}

	function addSeparator(num, separator) {
	  var regex = /(\d+)(\d{3})/;
	  var string = num.toString();
	  var x = string.split('.');
	  var x1 = x[0];
	  var x2 = x.length > 1 ? '.' + x[1] : '';

	  while (regex.test(x1)) {
	    x1 = x1.replace(regex, '$1' + separator + '$2');
	  }

	  return x1 + x2;
	}

	function getFraction(num, decimals, separator) {
	  var fraction = number_toFixed(num, decimals).toString().split('.')[1];
	  return fraction ? separator + fraction : '';
	}

	function number_toFixed(num, precision) {
	  return (+(Math.round(+(num + 'e' + precision)) + 'e' + -precision)).toFixed(precision);
	}

	/* harmony default export */ var other_number = (number_number);
	// CONCATENATED MODULE: ./src/other/index.js






	// CONCATENATED MODULE: ./src/index.js




	var Vue2Filters = {
	  install: function install(Vue, options) {
	    src_util.each(string_namespaceObject, function (value, key) {
	      Vue.filter(key, value.bind(options));
	    });
	    src_util.each(other_namespaceObject, function (value, key) {
	      Vue.filter(key, value.bind(options));
	    });
	  },
	  mixin: {
	    methods: {
	      limitBy: array_limitBy,
	      filterBy: array_filterBy,
	      orderBy: array_orderBy,
	      find: array_find
	    }
	  }
	};
	/* harmony default export */ var src = __webpack_exports__["default"] = (Vue2Filters);

	if (typeof window !== 'undefined' && window.Vue) {
	  window.Vue.use(Vue2Filters);
	  window.Vue2Filters = Vue2Filters;
	}

	/***/ })
	/******/ ]);
	});
	});

	var Vue2Filters = unwrapExports(vue2Filters);

	/*!
	 * vue-resource v1.5.1
	 * https://github.com/pagekit/vue-resource
	 * Released under the MIT License.
	 */

	/**
	 * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
	 */

	var RESOLVED = 0;
	var REJECTED = 1;
	var PENDING = 2;

	function Promise$1$1(executor) {

	    this.state = PENDING;
	    this.value = undefined;
	    this.deferred = [];

	    var promise = this;

	    try {
	        executor(function (x) {
	            promise.resolve(x);
	        }, function (r) {
	            promise.reject(r);
	        });
	    } catch (e) {
	        promise.reject(e);
	    }
	}

	Promise$1$1.reject = function (r) {
	    return new Promise$1$1(function (resolve, reject) {
	        reject(r);
	    });
	};

	Promise$1$1.resolve = function (x) {
	    return new Promise$1$1(function (resolve, reject) {
	        resolve(x);
	    });
	};

	Promise$1$1.all = function all(iterable) {
	    return new Promise$1$1(function (resolve, reject) {
	        var count = 0, result = [];

	        if (iterable.length === 0) {
	            resolve(result);
	        }

	        function resolver(i) {
	            return function (x) {
	                result[i] = x;
	                count += 1;

	                if (count === iterable.length) {
	                    resolve(result);
	                }
	            };
	        }

	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise$1$1.resolve(iterable[i]).then(resolver(i), reject);
	        }
	    });
	};

	Promise$1$1.race = function race(iterable) {
	    return new Promise$1$1(function (resolve, reject) {
	        for (var i = 0; i < iterable.length; i += 1) {
	            Promise$1$1.resolve(iterable[i]).then(resolve, reject);
	        }
	    });
	};

	var p = Promise$1$1.prototype;

	p.resolve = function resolve(x) {
	    var promise = this;

	    if (promise.state === PENDING) {
	        if (x === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }

	        var called = false;

	        try {
	            var then = x && x['then'];

	            if (x !== null && typeof x === 'object' && typeof then === 'function') {
	                then.call(x, function (x) {
	                    if (!called) {
	                        promise.resolve(x);
	                    }
	                    called = true;

	                }, function (r) {
	                    if (!called) {
	                        promise.reject(r);
	                    }
	                    called = true;
	                });
	                return;
	            }
	        } catch (e) {
	            if (!called) {
	                promise.reject(e);
	            }
	            return;
	        }

	        promise.state = RESOLVED;
	        promise.value = x;
	        promise.notify();
	    }
	};

	p.reject = function reject(reason) {
	    var promise = this;

	    if (promise.state === PENDING) {
	        if (reason === promise) {
	            throw new TypeError('Promise settled with itself.');
	        }

	        promise.state = REJECTED;
	        promise.value = reason;
	        promise.notify();
	    }
	};

	p.notify = function notify() {
	    var promise = this;

	    nextTick(function () {
	        if (promise.state !== PENDING) {
	            while (promise.deferred.length) {
	                var deferred = promise.deferred.shift(),
	                    onResolved = deferred[0],
	                    onRejected = deferred[1],
	                    resolve = deferred[2],
	                    reject = deferred[3];

	                try {
	                    if (promise.state === RESOLVED) {
	                        if (typeof onResolved === 'function') {
	                            resolve(onResolved.call(undefined, promise.value));
	                        } else {
	                            resolve(promise.value);
	                        }
	                    } else if (promise.state === REJECTED) {
	                        if (typeof onRejected === 'function') {
	                            resolve(onRejected.call(undefined, promise.value));
	                        } else {
	                            reject(promise.value);
	                        }
	                    }
	                } catch (e) {
	                    reject(e);
	                }
	            }
	        }
	    });
	};

	p.then = function then(onResolved, onRejected) {
	    var promise = this;

	    return new Promise$1$1(function (resolve, reject) {
	        promise.deferred.push([onResolved, onRejected, resolve, reject]);
	        promise.notify();
	    });
	};

	p.catch = function (onRejected) {
	    return this.then(undefined, onRejected);
	};

	/**
	 * Promise adapter.
	 */

	if (typeof Promise === 'undefined') {
	    window.Promise = Promise$1$1;
	}

	function PromiseObj(executor, context) {

	    if (executor instanceof Promise) {
	        this.promise = executor;
	    } else {
	        this.promise = new Promise(executor.bind(context));
	    }

	    this.context = context;
	}

	PromiseObj.all = function (iterable, context) {
	    return new PromiseObj(Promise.all(iterable), context);
	};

	PromiseObj.resolve = function (value, context) {
	    return new PromiseObj(Promise.resolve(value), context);
	};

	PromiseObj.reject = function (reason, context) {
	    return new PromiseObj(Promise.reject(reason), context);
	};

	PromiseObj.race = function (iterable, context) {
	    return new PromiseObj(Promise.race(iterable), context);
	};

	var p$1 = PromiseObj.prototype;

	p$1.bind = function (context) {
	    this.context = context;
	    return this;
	};

	p$1.then = function (fulfilled, rejected) {

	    if (fulfilled && fulfilled.bind && this.context) {
	        fulfilled = fulfilled.bind(this.context);
	    }

	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }

	    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);
	};

	p$1.catch = function (rejected) {

	    if (rejected && rejected.bind && this.context) {
	        rejected = rejected.bind(this.context);
	    }

	    return new PromiseObj(this.promise.catch(rejected), this.context);
	};

	p$1.finally = function (callback) {

	    return this.then(function (value) {
	        callback.call(this);
	        return value;
	    }, function (reason) {
	        callback.call(this);
	        return Promise.reject(reason);
	    }
	    );
	};

	/**
	 * Utility functions.
	 */

	var ref = {};
	var hasOwnProperty$3 = ref.hasOwnProperty;
	var ref$1 = [];
	var slice$1 = ref$1.slice;
	var debug = false, ntick;

	var inBrowser$1 = typeof window !== 'undefined';

	function Util (ref) {
	    var config = ref.config;
	    var nextTick = ref.nextTick;

	    ntick = nextTick;
	    debug = config.debug || !config.silent;
	}

	function warn$1(msg) {
	    if (typeof console !== 'undefined' && debug) {
	        console.warn('[VueResource warn]: ' + msg);
	    }
	}

	function error(msg) {
	    if (typeof console !== 'undefined') {
	        console.error(msg);
	    }
	}

	function nextTick(cb, ctx) {
	    return ntick(cb, ctx);
	}

	function trim$1(str) {
	    return str ? str.replace(/^\s*|\s*$/g, '') : '';
	}

	function trimEnd$1(str, chars) {

	    if (str && chars === undefined) {
	        return str.replace(/\s+$/, '');
	    }

	    if (!str || !chars) {
	        return str;
	    }

	    return str.replace(new RegExp(("[" + chars + "]+$")), '');
	}

	function toLower(str) {
	    return str ? str.toLowerCase() : '';
	}

	function toUpper(str) {
	    return str ? str.toUpperCase() : '';
	}

	var isArray$1 = Array.isArray;

	function isString$1(val) {
	    return typeof val === 'string';
	}

	function isFunction$2(val) {
	    return typeof val === 'function';
	}

	function isObject$1(obj) {
	    return obj !== null && typeof obj === 'object';
	}

	function isPlainObject$1(obj) {
	    return isObject$1(obj) && Object.getPrototypeOf(obj) == Object.prototype;
	}

	function isBlob(obj) {
	    return typeof Blob !== 'undefined' && obj instanceof Blob;
	}

	function isFormData(obj) {
	    return typeof FormData !== 'undefined' && obj instanceof FormData;
	}

	function when(value, fulfilled, rejected) {

	    var promise = PromiseObj.resolve(value);

	    if (arguments.length < 2) {
	        return promise;
	    }

	    return promise.then(fulfilled, rejected);
	}

	function options(fn, obj, opts) {

	    opts = opts || {};

	    if (isFunction$2(opts)) {
	        opts = opts.call(obj);
	    }

	    return merge(fn.bind({$vm: obj, $options: opts}), fn, {$options: opts});
	}

	function each(obj, iterator) {

	    var i, key;

	    if (isArray$1(obj)) {
	        for (i = 0; i < obj.length; i++) {
	            iterator.call(obj[i], obj[i], i);
	        }
	    } else if (isObject$1(obj)) {
	        for (key in obj) {
	            if (hasOwnProperty$3.call(obj, key)) {
	                iterator.call(obj[key], obj[key], key);
	            }
	        }
	    }

	    return obj;
	}

	var assign$1 = Object.assign || _assign;

	function merge(target) {

	    var args = slice$1.call(arguments, 1);

	    args.forEach(function (source) {
	        _merge(target, source, true);
	    });

	    return target;
	}

	function defaults(target) {

	    var args = slice$1.call(arguments, 1);

	    args.forEach(function (source) {

	        for (var key in source) {
	            if (target[key] === undefined) {
	                target[key] = source[key];
	            }
	        }

	    });

	    return target;
	}

	function _assign(target) {

	    var args = slice$1.call(arguments, 1);

	    args.forEach(function (source) {
	        _merge(target, source);
	    });

	    return target;
	}

	function _merge(target, source, deep) {
	    for (var key in source) {
	        if (deep && (isPlainObject$1(source[key]) || isArray$1(source[key]))) {
	            if (isPlainObject$1(source[key]) && !isPlainObject$1(target[key])) {
	                target[key] = {};
	            }
	            if (isArray$1(source[key]) && !isArray$1(target[key])) {
	                target[key] = [];
	            }
	            _merge(target[key], source[key], deep);
	        } else if (source[key] !== undefined) {
	            target[key] = source[key];
	        }
	    }
	}

	/**
	 * Root Prefix Transform.
	 */

	function root (options$$1, next) {

	    var url = next(options$$1);

	    if (isString$1(options$$1.root) && !/^(https?:)?\//.test(url)) {
	        url = trimEnd$1(options$$1.root, '/') + '/' + url;
	    }

	    return url;
	}

	/**
	 * Query Parameter Transform.
	 */

	function query (options$$1, next) {

	    var urlParams = Object.keys(Url.options.params), query = {}, url = next(options$$1);

	    each(options$$1.params, function (value, key) {
	        if (urlParams.indexOf(key) === -1) {
	            query[key] = value;
	        }
	    });

	    query = Url.params(query);

	    if (query) {
	        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
	    }

	    return url;
	}

	/**
	 * URL Template v2.0.6 (https://github.com/bramstein/url-template)
	 */

	function expand(url, params, variables) {

	    var tmpl = parse(url), expanded = tmpl.expand(params);

	    if (variables) {
	        variables.push.apply(variables, tmpl.vars);
	    }

	    return expanded;
	}

	function parse(template) {

	    var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];

	    return {
	        vars: variables,
	        expand: function expand(context) {
	            return template.replace(/\{([^{}]+)\}|([^{}]+)/g, function (_, expression, literal) {
	                if (expression) {

	                    var operator = null, values = [];

	                    if (operators.indexOf(expression.charAt(0)) !== -1) {
	                        operator = expression.charAt(0);
	                        expression = expression.substr(1);
	                    }

	                    expression.split(/,/g).forEach(function (variable) {
	                        var tmp = /([^:*]*)(?::(\d+)|(\*))?/.exec(variable);
	                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
	                        variables.push(tmp[1]);
	                    });

	                    if (operator && operator !== '+') {

	                        var separator = ',';

	                        if (operator === '?') {
	                            separator = '&';
	                        } else if (operator !== '#') {
	                            separator = operator;
	                        }

	                        return (values.length !== 0 ? operator : '') + values.join(separator);
	                    } else {
	                        return values.join(',');
	                    }

	                } else {
	                    return encodeReserved(literal);
	                }
	            });
	        }
	    };
	}

	function getValues(context, operator, key, modifier) {

	    var value = context[key], result = [];

	    if (isDefined(value) && value !== '') {
	        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
	            value = value.toString();

	            if (modifier && modifier !== '*') {
	                value = value.substring(0, parseInt(modifier, 10));
	            }

	            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
	        } else {
	            if (modifier === '*') {
	                if (Array.isArray(value)) {
	                    value.filter(isDefined).forEach(function (value) {
	                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
	                    });
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (isDefined(value[k])) {
	                            result.push(encodeValue(operator, value[k], k));
	                        }
	                    });
	                }
	            } else {
	                var tmp = [];

	                if (Array.isArray(value)) {
	                    value.filter(isDefined).forEach(function (value) {
	                        tmp.push(encodeValue(operator, value));
	                    });
	                } else {
	                    Object.keys(value).forEach(function (k) {
	                        if (isDefined(value[k])) {
	                            tmp.push(encodeURIComponent(k));
	                            tmp.push(encodeValue(operator, value[k].toString()));
	                        }
	                    });
	                }

	                if (isKeyOperator(operator)) {
	                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
	                } else if (tmp.length !== 0) {
	                    result.push(tmp.join(','));
	                }
	            }
	        }
	    } else {
	        if (operator === ';') {
	            result.push(encodeURIComponent(key));
	        } else if (value === '' && (operator === '&' || operator === '?')) {
	            result.push(encodeURIComponent(key) + '=');
	        } else if (value === '') {
	            result.push('');
	        }
	    }

	    return result;
	}

	function isDefined(value) {
	    return value !== undefined && value !== null;
	}

	function isKeyOperator(operator) {
	    return operator === ';' || operator === '&' || operator === '?';
	}

	function encodeValue(operator, value, key) {

	    value = (operator === '+' || operator === '#') ? encodeReserved(value) : encodeURIComponent(value);

	    if (key) {
	        return encodeURIComponent(key) + '=' + value;
	    } else {
	        return value;
	    }
	}

	function encodeReserved(str) {
	    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
	        if (!/%[0-9A-Fa-f]/.test(part)) {
	            part = encodeURI(part);
	        }
	        return part;
	    }).join('');
	}

	/**
	 * URL Template (RFC 6570) Transform.
	 */

	function template (options) {

	    var variables = [], url = expand(options.url, options.params, variables);

	    variables.forEach(function (key) {
	        delete options.params[key];
	    });

	    return url;
	}

	/**
	 * Service for URL templating.
	 */

	function Url(url, params) {

	    var self = this || {}, options$$1 = url, transform;

	    if (isString$1(url)) {
	        options$$1 = {url: url, params: params};
	    }

	    options$$1 = merge({}, Url.options, self.$options, options$$1);

	    Url.transforms.forEach(function (handler) {

	        if (isString$1(handler)) {
	            handler = Url.transform[handler];
	        }

	        if (isFunction$2(handler)) {
	            transform = factory(handler, transform, self.$vm);
	        }

	    });

	    return transform(options$$1);
	}

	/**
	 * Url options.
	 */

	Url.options = {
	    url: '',
	    root: null,
	    params: {}
	};

	/**
	 * Url transforms.
	 */

	Url.transform = {template: template, query: query, root: root};
	Url.transforms = ['template', 'query', 'root'];

	/**
	 * Encodes a Url parameter string.
	 *
	 * @param {Object} obj
	 */

	Url.params = function (obj) {

	    var params = [], escape = encodeURIComponent;

	    params.add = function (key, value) {

	        if (isFunction$2(value)) {
	            value = value();
	        }

	        if (value === null) {
	            value = '';
	        }

	        this.push(escape(key) + '=' + escape(value));
	    };

	    serialize(params, obj);

	    return params.join('&').replace(/%20/g, '+');
	};

	/**
	 * Parse a URL and return its components.
	 *
	 * @param {String} url
	 */

	Url.parse = function (url) {

	    var el = document.createElement('a');

	    if (document.documentMode) {
	        el.href = url;
	        url = el.href;
	    }

	    el.href = url;

	    return {
	        href: el.href,
	        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
	        port: el.port,
	        host: el.host,
	        hostname: el.hostname,
	        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
	        search: el.search ? el.search.replace(/^\?/, '') : '',
	        hash: el.hash ? el.hash.replace(/^#/, '') : ''
	    };
	};

	function factory(handler, next, vm) {
	    return function (options$$1) {
	        return handler.call(vm, options$$1, next);
	    };
	}

	function serialize(params, obj, scope) {

	    var array = isArray$1(obj), plain = isPlainObject$1(obj), hash;

	    each(obj, function (value, key) {

	        hash = isObject$1(value) || isArray$1(value);

	        if (scope) {
	            key = scope + '[' + (plain || hash ? key : '') + ']';
	        }

	        if (!scope && array) {
	            params.add(value.name, value.value);
	        } else if (hash) {
	            serialize(params, value, key);
	        } else {
	            params.add(key, value);
	        }
	    });
	}

	/**
	 * XDomain client (Internet Explorer).
	 */

	function xdrClient (request) {
	    return new PromiseObj(function (resolve) {

	        var xdr = new XDomainRequest(), handler = function (ref) {
	                var type = ref.type;


	                var status = 0;

	                if (type === 'load') {
	                    status = 200;
	                } else if (type === 'error') {
	                    status = 500;
	                }

	                resolve(request.respondWith(xdr.responseText, {status: status}));
	            };

	        request.abort = function () { return xdr.abort(); };

	        xdr.open(request.method, request.getUrl());

	        if (request.timeout) {
	            xdr.timeout = request.timeout;
	        }

	        xdr.onload = handler;
	        xdr.onabort = handler;
	        xdr.onerror = handler;
	        xdr.ontimeout = handler;
	        xdr.onprogress = function () {};
	        xdr.send(request.getBody());
	    });
	}

	/**
	 * CORS Interceptor.
	 */

	var SUPPORTS_CORS = inBrowser$1 && 'withCredentials' in new XMLHttpRequest();

	function cors (request) {

	    if (inBrowser$1) {

	        var orgUrl = Url.parse(location.href);
	        var reqUrl = Url.parse(request.getUrl());

	        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {

	            request.crossOrigin = true;
	            request.emulateHTTP = false;

	            if (!SUPPORTS_CORS) {
	                request.client = xdrClient;
	            }
	        }
	    }

	}

	/**
	 * Form data Interceptor.
	 */

	function form (request) {

	    if (isFormData(request.body)) {
	        request.headers.delete('Content-Type');
	    } else if (isObject$1(request.body) && request.emulateJSON) {
	        request.body = Url.params(request.body);
	        request.headers.set('Content-Type', 'application/x-www-form-urlencoded');
	    }

	}

	/**
	 * JSON Interceptor.
	 */

	function json (request) {

	    var type = request.headers.get('Content-Type') || '';

	    if (isObject$1(request.body) && type.indexOf('application/json') === 0) {
	        request.body = JSON.stringify(request.body);
	    }

	    return function (response) {

	        return response.bodyText ? when(response.text(), function (text) {

	            var type = response.headers.get('Content-Type') || '';

	            if (type.indexOf('application/json') === 0 || isJson(text)) {

	                try {
	                    response.body = JSON.parse(text);
	                } catch (e) {
	                    response.body = null;
	                }

	            } else {
	                response.body = text;
	            }

	            return response;

	        }) : response;

	    };
	}

	function isJson(str) {

	    var start = str.match(/^\s*(\[|\{)/);
	    var end = {'[': /]\s*$/, '{': /}\s*$/};

	    return start && end[start[1]].test(str);
	}

	/**
	 * JSONP client (Browser).
	 */

	function jsonpClient (request) {
	    return new PromiseObj(function (resolve) {

	        var name = request.jsonp || 'callback', callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2), body = null, handler, script;

	        handler = function (ref) {
	            var type = ref.type;


	            var status = 0;

	            if (type === 'load' && body !== null) {
	                status = 200;
	            } else if (type === 'error') {
	                status = 500;
	            }

	            if (status && window[callback]) {
	                delete window[callback];
	                document.body.removeChild(script);
	            }

	            resolve(request.respondWith(body, {status: status}));
	        };

	        window[callback] = function (result) {
	            body = JSON.stringify(result);
	        };

	        request.abort = function () {
	            handler({type: 'abort'});
	        };

	        request.params[name] = callback;

	        if (request.timeout) {
	            setTimeout(request.abort, request.timeout);
	        }

	        script = document.createElement('script');
	        script.src = request.getUrl();
	        script.type = 'text/javascript';
	        script.async = true;
	        script.onload = handler;
	        script.onerror = handler;

	        document.body.appendChild(script);
	    });
	}

	/**
	 * JSONP Interceptor.
	 */

	function jsonp (request) {

	    if (request.method == 'JSONP') {
	        request.client = jsonpClient;
	    }

	}

	/**
	 * Before Interceptor.
	 */

	function before (request) {

	    if (isFunction$2(request.before)) {
	        request.before.call(this, request);
	    }

	}

	/**
	 * HTTP method override Interceptor.
	 */

	function method (request) {

	    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
	        request.headers.set('X-HTTP-Method-Override', request.method);
	        request.method = 'POST';
	    }

	}

	/**
	 * Header Interceptor.
	 */

	function header (request) {

	    var headers = assign$1({}, Http.headers.common,
	        !request.crossOrigin ? Http.headers.custom : {},
	        Http.headers[toLower(request.method)]
	    );

	    each(headers, function (value, name) {
	        if (!request.headers.has(name)) {
	            request.headers.set(name, value);
	        }
	    });

	}

	/**
	 * XMLHttp client (Browser).
	 */

	function xhrClient (request) {
	    return new PromiseObj(function (resolve) {

	        var xhr = new XMLHttpRequest(), handler = function (event) {

	                var response = request.respondWith(
	                'response' in xhr ? xhr.response : xhr.responseText, {
	                    status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
	                    statusText: xhr.status === 1223 ? 'No Content' : trim$1(xhr.statusText)
	                });

	                each(trim$1(xhr.getAllResponseHeaders()).split('\n'), function (row) {
	                    response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));
	                });

	                resolve(response);
	            };

	        request.abort = function () { return xhr.abort(); };

	        xhr.open(request.method, request.getUrl(), true);

	        if (request.timeout) {
	            xhr.timeout = request.timeout;
	        }

	        if (request.responseType && 'responseType' in xhr) {
	            xhr.responseType = request.responseType;
	        }

	        if (request.withCredentials || request.credentials) {
	            xhr.withCredentials = true;
	        }

	        if (!request.crossOrigin) {
	            request.headers.set('X-Requested-With', 'XMLHttpRequest');
	        }

	        // deprecated use downloadProgress
	        if (isFunction$2(request.progress) && request.method === 'GET') {
	            xhr.addEventListener('progress', request.progress);
	        }

	        if (isFunction$2(request.downloadProgress)) {
	            xhr.addEventListener('progress', request.downloadProgress);
	        }

	        // deprecated use uploadProgress
	        if (isFunction$2(request.progress) && /^(POST|PUT)$/i.test(request.method)) {
	            xhr.upload.addEventListener('progress', request.progress);
	        }

	        if (isFunction$2(request.uploadProgress) && xhr.upload) {
	            xhr.upload.addEventListener('progress', request.uploadProgress);
	        }

	        request.headers.forEach(function (value, name) {
	            xhr.setRequestHeader(name, value);
	        });

	        xhr.onload = handler;
	        xhr.onabort = handler;
	        xhr.onerror = handler;
	        xhr.ontimeout = handler;
	        xhr.send(request.getBody());
	    });
	}

	/**
	 * Http client (Node).
	 */

	function nodeClient (request) {

	    var client = require('got');

	    return new PromiseObj(function (resolve) {

	        var url = request.getUrl();
	        var body = request.getBody();
	        var method = request.method;
	        var headers = {}, handler;

	        request.headers.forEach(function (value, name) {
	            headers[name] = value;
	        });

	        client(url, {body: body, method: method, headers: headers}).then(handler = function (resp) {

	            var response = request.respondWith(resp.body, {
	                status: resp.statusCode,
	                statusText: trim$1(resp.statusMessage)
	            });

	            each(resp.headers, function (value, name) {
	                response.headers.set(name, value);
	            });

	            resolve(response);

	        }, function (error$$1) { return handler(error$$1.response); });
	    });
	}

	/**
	 * Base client.
	 */

	function Client (context) {

	    var reqHandlers = [sendRequest], resHandlers = [];

	    if (!isObject$1(context)) {
	        context = null;
	    }

	    function Client(request) {
	        while (reqHandlers.length) {

	            var handler = reqHandlers.pop();

	            if (isFunction$2(handler)) {

	                var response = (void 0), next = (void 0);

	                response = handler.call(context, request, function (val) { return next = val; }) || next;

	                if (isObject$1(response)) {
	                    return new PromiseObj(function (resolve, reject) {

	                        resHandlers.forEach(function (handler) {
	                            response = when(response, function (response) {
	                                return handler.call(context, response) || response;
	                            }, reject);
	                        });

	                        when(response, resolve, reject);

	                    }, context);
	                }

	                if (isFunction$2(response)) {
	                    resHandlers.unshift(response);
	                }

	            } else {
	                warn$1(("Invalid interceptor of type " + (typeof handler) + ", must be a function"));
	            }
	        }
	    }

	    Client.use = function (handler) {
	        reqHandlers.push(handler);
	    };

	    return Client;
	}

	function sendRequest(request) {

	    var client = request.client || (inBrowser$1 ? xhrClient : nodeClient);

	    return client(request);
	}

	/**
	 * HTTP Headers.
	 */

	var Headers = function Headers(headers) {
	    var this$1 = this;


	    this.map = {};

	    each(headers, function (value, name) { return this$1.append(name, value); });
	};

	Headers.prototype.has = function has (name) {
	    return getName(this.map, name) !== null;
	};

	Headers.prototype.get = function get (name) {

	    var list = this.map[getName(this.map, name)];

	    return list ? list.join() : null;
	};

	Headers.prototype.getAll = function getAll (name) {
	    return this.map[getName(this.map, name)] || [];
	};

	Headers.prototype.set = function set (name, value) {
	    this.map[normalizeName(getName(this.map, name) || name)] = [trim$1(value)];
	};

	Headers.prototype.append = function append (name, value) {

	    var list = this.map[getName(this.map, name)];

	    if (list) {
	        list.push(trim$1(value));
	    } else {
	        this.set(name, value);
	    }
	};

	Headers.prototype.delete = function delete$1 (name) {
	    delete this.map[getName(this.map, name)];
	};

	Headers.prototype.deleteAll = function deleteAll () {
	    this.map = {};
	};

	Headers.prototype.forEach = function forEach (callback, thisArg) {
	        var this$1 = this;

	    each(this.map, function (list, name) {
	        each(list, function (value) { return callback.call(thisArg, value, name, this$1); });
	    });
	};

	function getName(map, name) {
	    return Object.keys(map).reduce(function (prev, curr) {
	        return toLower(name) === toLower(curr) ? curr : prev;
	    }, null);
	}

	function normalizeName(name) {

	    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
	        throw new TypeError('Invalid character in header field name');
	    }

	    return trim$1(name);
	}

	/**
	 * HTTP Response.
	 */

	var Response = function Response(body, ref) {
	    var url = ref.url;
	    var headers = ref.headers;
	    var status = ref.status;
	    var statusText = ref.statusText;


	    this.url = url;
	    this.ok = status >= 200 && status < 300;
	    this.status = status || 0;
	    this.statusText = statusText || '';
	    this.headers = new Headers(headers);
	    this.body = body;

	    if (isString$1(body)) {

	        this.bodyText = body;

	    } else if (isBlob(body)) {

	        this.bodyBlob = body;

	        if (isBlobText(body)) {
	            this.bodyText = blobText(body);
	        }
	    }
	};

	Response.prototype.blob = function blob () {
	    return when(this.bodyBlob);
	};

	Response.prototype.text = function text () {
	    return when(this.bodyText);
	};

	Response.prototype.json = function json () {
	    return when(this.text(), function (text) { return JSON.parse(text); });
	};

	Object.defineProperty(Response.prototype, 'data', {

	    get: function get() {
	        return this.body;
	    },

	    set: function set(body) {
	        this.body = body;
	    }

	});

	function blobText(body) {
	    return new PromiseObj(function (resolve) {

	        var reader = new FileReader();

	        reader.readAsText(body);
	        reader.onload = function () {
	            resolve(reader.result);
	        };

	    });
	}

	function isBlobText(body) {
	    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;
	}

	/**
	 * HTTP Request.
	 */

	var Request = function Request(options$$1) {

	    this.body = null;
	    this.params = {};

	    assign$1(this, options$$1, {
	        method: toUpper(options$$1.method || 'GET')
	    });

	    if (!(this.headers instanceof Headers)) {
	        this.headers = new Headers(this.headers);
	    }
	};

	Request.prototype.getUrl = function getUrl () {
	    return Url(this);
	};

	Request.prototype.getBody = function getBody () {
	    return this.body;
	};

	Request.prototype.respondWith = function respondWith (body, options$$1) {
	    return new Response(body, assign$1(options$$1 || {}, {url: this.getUrl()}));
	};

	/**
	 * Service for sending network requests.
	 */

	var COMMON_HEADERS = {'Accept': 'application/json, text/plain, */*'};
	var JSON_CONTENT_TYPE = {'Content-Type': 'application/json;charset=utf-8'};

	function Http(options$$1) {

	    var self = this || {}, client = Client(self.$vm);

	    defaults(options$$1 || {}, self.$options, Http.options);

	    Http.interceptors.forEach(function (handler) {

	        if (isString$1(handler)) {
	            handler = Http.interceptor[handler];
	        }

	        if (isFunction$2(handler)) {
	            client.use(handler);
	        }

	    });

	    return client(new Request(options$$1)).then(function (response) {

	        return response.ok ? response : PromiseObj.reject(response);

	    }, function (response) {

	        if (response instanceof Error) {
	            error(response);
	        }

	        return PromiseObj.reject(response);
	    });
	}

	Http.options = {};

	Http.headers = {
	    put: JSON_CONTENT_TYPE,
	    post: JSON_CONTENT_TYPE,
	    patch: JSON_CONTENT_TYPE,
	    delete: JSON_CONTENT_TYPE,
	    common: COMMON_HEADERS,
	    custom: {}
	};

	Http.interceptor = {before: before, method: method, jsonp: jsonp, json: json, form: form, header: header, cors: cors};
	Http.interceptors = ['before', 'method', 'jsonp', 'json', 'form', 'header', 'cors'];

	['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {

	    Http[method$$1] = function (url, options$$1) {
	        return this(assign$1(options$$1 || {}, {url: url, method: method$$1}));
	    };

	});

	['post', 'put', 'patch'].forEach(function (method$$1) {

	    Http[method$$1] = function (url, body, options$$1) {
	        return this(assign$1(options$$1 || {}, {url: url, method: method$$1, body: body}));
	    };

	});

	/**
	 * Service for interacting with RESTful services.
	 */

	function Resource(url, params, actions, options$$1) {

	    var self = this || {}, resource = {};

	    actions = assign$1({},
	        Resource.actions,
	        actions
	    );

	    each(actions, function (action, name) {

	        action = merge({url: url, params: assign$1({}, params)}, options$$1, action);

	        resource[name] = function () {
	            return (self.$http || Http)(opts(action, arguments));
	        };
	    });

	    return resource;
	}

	function opts(action, args) {

	    var options$$1 = assign$1({}, action), params = {}, body;

	    switch (args.length) {

	        case 2:

	            params = args[0];
	            body = args[1];

	            break;

	        case 1:

	            if (/^(POST|PUT|PATCH)$/i.test(options$$1.method)) {
	                body = args[0];
	            } else {
	                params = args[0];
	            }

	            break;

	        case 0:

	            break;

	        default:

	            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';
	    }

	    options$$1.body = body;
	    options$$1.params = assign$1({}, options$$1.params, params);

	    return options$$1;
	}

	Resource.actions = {

	    get: {method: 'GET'},
	    save: {method: 'POST'},
	    query: {method: 'GET'},
	    update: {method: 'PUT'},
	    remove: {method: 'DELETE'},
	    delete: {method: 'DELETE'}

	};

	/**
	 * Install plugin.
	 */

	function plugin$2(Vue) {

	    if (plugin$2.installed) {
	        return;
	    }

	    Util(Vue);

	    Vue.url = Url;
	    Vue.http = Http;
	    Vue.resource = Resource;
	    Vue.Promise = PromiseObj;

	    Object.defineProperties(Vue.prototype, {

	        $url: {
	            get: function get() {
	                return options(Vue.url, this, this.$options.url);
	            }
	        },

	        $http: {
	            get: function get() {
	                return options(Vue.http, this, this.$options.http);
	            }
	        },

	        $resource: {
	            get: function get() {
	                return Vue.resource.bind(this);
	            }
	        },

	        $promise: {
	            get: function get() {
	                var this$1 = this;

	                return function (executor) { return new Vue.Promise(executor, this$1); };
	            }
	        }

	    });
	}

	if (typeof window !== 'undefined' && window.Vue) {
	    window.Vue.use(plugin$2);
	}

	var vueLadda = createCommonjsModule(function (module, exports) {
	!function(n,t){module.exports=t();}(commonjsGlobal,function(){return function(n){function t(e){if(a[e]){ return a[e].exports; }var d=a[e]={i:e,l:!1,exports:{}};return n[e].call(d.exports,d,d.exports,t),d.l=!0,d.exports}var a={};return t.m=n,t.c=a,t.i=function(n){return n},t.d=function(n,a,e){t.o(n,a)||Object.defineProperty(n,a,{configurable:!1,enumerable:!0,get:e});},t.n=function(n){var a=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(a,"a",a),a},t.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},t.p="",t(t.s=2)}([function(n,t,a){a(9);var e=a(7)(a(1),a(8),null,null);e.options.__file="/Users/zhangchaofan/Dev/Temp/vue-ladda/src/vue-ladda.vue",e.esModule&&Object.keys(e.esModule).some(function(n){return "default"!==n&&"__esModule"!==n})&&console.error("named exports are not supported in *.vue files."),e.options.functional&&console.error("[vue-loader] vue-ladda.vue: functional components are not supported with templates, they should use render functions."),n.exports=e.exports;},function(n,t,a){Object.defineProperty(t,"__esModule",{value:!0});var e=a(5),d=function(n){return n&&n.__esModule?n:{default:n}}(e);t.default={name:"VueLadda",props:{buttonClass:{type:String,default:"ladda-button"},dataStyle:{type:String,default:"expand-left"},loading:{type:Boolean,required:!0},progress:{validator:function(n){return n>=0&&n<=1},default:0}},watch:{loading:function(n){n?this.ladda.start():this.ladda.stop();},progress:function(n){this.ladda.setProgress(n);}},methods:{handleClick:function(n){this.$emit("click",n);}},mounted:function(){this.ladda=d.default.create(this.$refs.ladda),this.loading?this.ladda.start():this.ladda.stop();},beforeDestroy:function(){this.ladda.remove(),delete this.ladda;}};},function(n,t,a){Object.defineProperty(t,"__esModule",{value:!0});var e=a(0),d=function(n){return n&&n.__esModule?n:{default:n}}(e),o={install:function(n,t){n.component("vue-ladda",d.default);}};"undefined"!=typeof window&&window.Vue&&window.Vue.use(o),t.default=d.default;},function(n,t,a){t=n.exports=a(4)(!1),t.push([n.i,'/*!\r\n * Ladda including the default theme.\r\n */\n/*!\r\n * Ladda\r\n * http://lab.hakim.se/ladda\r\n * MIT licensed\r\n *\r\n * Copyright (C) 2016 Hakim El Hattab, http://hakim.se\r\n */\n/*************************************\r\n * CONFIG\r\n */\n/*************************************\r\n * MIXINS\r\n */\n/*************************************\r\n * BUTTON BASE\r\n */\n.ladda-button {\n  position: relative;\n}\n\n/* Spinner animation */\n.ladda-button .ladda-spinner {\n  position: absolute;\n  z-index: 2;\n  display: inline-block;\n  width: 32px;\n  top: 50%;\n  margin-top: 0;\n  opacity: 0;\n  pointer-events: none;\n}\n\n/* Button label */\n.ladda-button .ladda-label {\n  position: relative;\n  z-index: 3;\n}\n\n/* Progress bar */\n.ladda-button .ladda-progress {\n  position: absolute;\n  width: 0;\n  height: 100%;\n  left: 0;\n  top: 0;\n  background: rgba(0, 0, 0, 0.2);\n  display: none;\n  -webkit-transition: 0.1s linear all !important;\n  -moz-transition: 0.1s linear all !important;\n  -ms-transition: 0.1s linear all !important;\n  -o-transition: 0.1s linear all !important;\n  transition: 0.1s linear all !important;\n}\n.ladda-button[data-loading] .ladda-progress {\n  display: block;\n}\n\n/*************************************\r\n * EASING\r\n */\n.ladda-button,\n.ladda-button .ladda-spinner,\n.ladda-button .ladda-label {\n  -webkit-transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) all !important;\n  -moz-transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) all !important;\n  -ms-transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) all !important;\n  -o-transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) all !important;\n  transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) all !important;\n}\n.ladda-button[data-style=zoom-in],\n.ladda-button[data-style=zoom-in] .ladda-spinner,\n.ladda-button[data-style=zoom-in] .ladda-label,\n.ladda-button[data-style=zoom-out],\n.ladda-button[data-style=zoom-out] .ladda-spinner,\n.ladda-button[data-style=zoom-out] .ladda-label {\n  -webkit-transition: 0.3s ease all !important;\n  -moz-transition: 0.3s ease all !important;\n  -ms-transition: 0.3s ease all !important;\n  -o-transition: 0.3s ease all !important;\n  transition: 0.3s ease all !important;\n}\n\n/*************************************\r\n * EXPAND RIGHT\r\n */\n.ladda-button[data-style=expand-right] .ladda-spinner {\n  right: -6px;\n}\n.ladda-button[data-style=expand-right][data-size="s"] .ladda-spinner,\n.ladda-button[data-style=expand-right][data-size="xs"] .ladda-spinner {\n  right: -12px;\n}\n.ladda-button[data-style=expand-right][data-loading] {\n  padding-right: 56px;\n}\n.ladda-button[data-style=expand-right][data-loading] .ladda-spinner {\n    opacity: 1;\n}\n.ladda-button[data-style=expand-right][data-loading][data-size="s"], .ladda-button[data-style=expand-right][data-loading][data-size="xs"] {\n    padding-right: 40px;\n}\n\n/*************************************\r\n * EXPAND LEFT\r\n */\n.ladda-button[data-style=expand-left] .ladda-spinner {\n  left: 26px;\n}\n.ladda-button[data-style=expand-left][data-size="s"] .ladda-spinner,\n.ladda-button[data-style=expand-left][data-size="xs"] .ladda-spinner {\n  left: 4px;\n}\n.ladda-button[data-style=expand-left][data-loading] {\n  padding-left: 56px;\n}\n.ladda-button[data-style=expand-left][data-loading] .ladda-spinner {\n    opacity: 1;\n}\n.ladda-button[data-style=expand-left][data-loading][data-size="s"], .ladda-button[data-style=expand-left][data-loading][data-size="xs"] {\n    padding-left: 40px;\n}\n\n/*************************************\r\n * EXPAND UP\r\n */\n.ladda-button[data-style=expand-up] {\n  overflow: hidden;\n}\n.ladda-button[data-style=expand-up] .ladda-spinner {\n    top: -32px;\n    left: 50%;\n    margin-left: 0;\n}\n.ladda-button[data-style=expand-up][data-loading] {\n    padding-top: 54px;\n}\n.ladda-button[data-style=expand-up][data-loading] .ladda-spinner {\n      opacity: 1;\n      top: 26px;\n      margin-top: 0;\n}\n.ladda-button[data-style=expand-up][data-loading][data-size="s"], .ladda-button[data-style=expand-up][data-loading][data-size="xs"] {\n      padding-top: 32px;\n}\n.ladda-button[data-style=expand-up][data-loading][data-size="s"] .ladda-spinner, .ladda-button[data-style=expand-up][data-loading][data-size="xs"] .ladda-spinner {\n        top: 4px;\n}\n\n/*************************************\r\n * EXPAND DOWN\r\n */\n.ladda-button[data-style=expand-down] {\n  overflow: hidden;\n}\n.ladda-button[data-style=expand-down] .ladda-spinner {\n    top: 62px;\n    left: 50%;\n    margin-left: 0;\n}\n.ladda-button[data-style=expand-down][data-size="s"] .ladda-spinner,\n  .ladda-button[data-style=expand-down][data-size="xs"] .ladda-spinner {\n    top: 40px;\n}\n.ladda-button[data-style=expand-down][data-loading] {\n    padding-bottom: 54px;\n}\n.ladda-button[data-style=expand-down][data-loading] .ladda-spinner {\n      opacity: 1;\n}\n.ladda-button[data-style=expand-down][data-loading][data-size="s"], .ladda-button[data-style=expand-down][data-loading][data-size="xs"] {\n      padding-bottom: 32px;\n}\n\n/*************************************\r\n * SLIDE LEFT\r\n */\n.ladda-button[data-style=slide-left] {\n  overflow: hidden;\n}\n.ladda-button[data-style=slide-left] .ladda-label {\n    position: relative;\n}\n.ladda-button[data-style=slide-left] .ladda-spinner {\n    left: 100%;\n    margin-left: 0;\n}\n.ladda-button[data-style=slide-left][data-loading] .ladda-label {\n    opacity: 0;\n    left: -100%;\n}\n.ladda-button[data-style=slide-left][data-loading] .ladda-spinner {\n    opacity: 1;\n    left: 50%;\n}\n\n/*************************************\r\n * SLIDE RIGHT\r\n */\n.ladda-button[data-style=slide-right] {\n  overflow: hidden;\n}\n.ladda-button[data-style=slide-right] .ladda-label {\n    position: relative;\n}\n.ladda-button[data-style=slide-right] .ladda-spinner {\n    right: 100%;\n    margin-left: 0;\n    left: 16px;\n}\n[dir="rtl"] .ladda-button[data-style=slide-right] .ladda-spinner {\n      right: auto;\n}\n.ladda-button[data-style=slide-right][data-loading] .ladda-label {\n    opacity: 0;\n    left: 100%;\n}\n.ladda-button[data-style=slide-right][data-loading] .ladda-spinner {\n    opacity: 1;\n    left: 50%;\n}\n\n/*************************************\r\n * SLIDE UP\r\n */\n.ladda-button[data-style=slide-up] {\n  overflow: hidden;\n}\n.ladda-button[data-style=slide-up] .ladda-label {\n    position: relative;\n}\n.ladda-button[data-style=slide-up] .ladda-spinner {\n    left: 50%;\n    margin-left: 0;\n    margin-top: 1em;\n}\n.ladda-button[data-style=slide-up][data-loading] .ladda-label {\n    opacity: 0;\n    top: -1em;\n}\n.ladda-button[data-style=slide-up][data-loading] .ladda-spinner {\n    opacity: 1;\n    margin-top: 0;\n}\n\n/*************************************\r\n * SLIDE DOWN\r\n */\n.ladda-button[data-style=slide-down] {\n  overflow: hidden;\n}\n.ladda-button[data-style=slide-down] .ladda-label {\n    position: relative;\n}\n.ladda-button[data-style=slide-down] .ladda-spinner {\n    left: 50%;\n    margin-left: 0;\n    margin-top: -2em;\n}\n.ladda-button[data-style=slide-down][data-loading] .ladda-label {\n    opacity: 0;\n    top: 1em;\n}\n.ladda-button[data-style=slide-down][data-loading] .ladda-spinner {\n    opacity: 1;\n    margin-top: 0;\n}\n\n/*************************************\r\n * ZOOM-OUT\r\n */\n.ladda-button[data-style=zoom-out] {\n  overflow: hidden;\n}\n.ladda-button[data-style=zoom-out] .ladda-spinner {\n  left: 50%;\n  margin-left: 32px;\n  -webkit-transform: scale(2.5);\n  -moz-transform: scale(2.5);\n  -ms-transform: scale(2.5);\n  -o-transform: scale(2.5);\n  transform: scale(2.5);\n}\n.ladda-button[data-style=zoom-out] .ladda-label {\n  position: relative;\n  display: inline-block;\n}\n.ladda-button[data-style=zoom-out][data-loading] .ladda-label {\n  opacity: 0;\n  -webkit-transform: scale(0.5);\n  -moz-transform: scale(0.5);\n  -ms-transform: scale(0.5);\n  -o-transform: scale(0.5);\n  transform: scale(0.5);\n}\n.ladda-button[data-style=zoom-out][data-loading] .ladda-spinner {\n  opacity: 1;\n  margin-left: 0;\n  -webkit-transform: none;\n  -moz-transform: none;\n  -ms-transform: none;\n  -o-transform: none;\n  transform: none;\n}\n\n/*************************************\r\n * ZOOM-IN\r\n */\n.ladda-button[data-style=zoom-in] {\n  overflow: hidden;\n}\n.ladda-button[data-style=zoom-in] .ladda-spinner {\n  left: 50%;\n  margin-left: -16px;\n  -webkit-transform: scale(0.2);\n  -moz-transform: scale(0.2);\n  -ms-transform: scale(0.2);\n  -o-transform: scale(0.2);\n  transform: scale(0.2);\n}\n.ladda-button[data-style=zoom-in] .ladda-label {\n  position: relative;\n  display: inline-block;\n}\n.ladda-button[data-style=zoom-in][data-loading] .ladda-label {\n  opacity: 0;\n  -webkit-transform: scale(2.2);\n  -moz-transform: scale(2.2);\n  -ms-transform: scale(2.2);\n  -o-transform: scale(2.2);\n  transform: scale(2.2);\n}\n.ladda-button[data-style=zoom-in][data-loading] .ladda-spinner {\n  opacity: 1;\n  margin-left: 0;\n  -webkit-transform: none;\n  -moz-transform: none;\n  -ms-transform: none;\n  -o-transform: none;\n  transform: none;\n}\n\n/*************************************\r\n * CONTRACT\r\n */\n.ladda-button[data-style=contract] {\n  overflow: hidden;\n  width: 100px;\n}\n.ladda-button[data-style=contract] .ladda-spinner {\n  left: 50%;\n  margin-left: 0;\n}\n.ladda-button[data-style=contract][data-loading] {\n  border-radius: 50%;\n  width: 52px;\n}\n.ladda-button[data-style=contract][data-loading] .ladda-label {\n  opacity: 0;\n}\n.ladda-button[data-style=contract][data-loading] .ladda-spinner {\n  opacity: 1;\n}\n\n/*************************************\r\n * OVERLAY\r\n */\n.ladda-button[data-style=contract-overlay] {\n  overflow: hidden;\n  width: 100px;\n  box-shadow: 0px 0px 0px 2000px rgba(0, 0, 0, 0);\n}\n.ladda-button[data-style=contract-overlay] .ladda-spinner {\n  left: 50%;\n  margin-left: 0;\n}\n.ladda-button[data-style=contract-overlay][data-loading] {\n  border-radius: 50%;\n  width: 52px;\n  /*outline: 10000px solid rgba( 0, 0, 0, 0.5 );*/\n  box-shadow: 0px 0px 0px 2000px rgba(0, 0, 0, 0.8);\n}\n.ladda-button[data-style=contract-overlay][data-loading] .ladda-label {\n  opacity: 0;\n}\n.ladda-button[data-style=contract-overlay][data-loading] .ladda-spinner {\n  opacity: 1;\n}\n[dir="rtl"] .ladda-spinner > div {\n  left: 25% !important;\n}\n\n/*************************************\r\n * CONFIG\r\n */\n/*************************************\r\n * BUTTON THEME\r\n */\n.ladda-button {\n  background: #666;\n  border: 0;\n  padding: 14px 18px;\n  font-size: 18px;\n  cursor: pointer;\n  color: #fff;\n  border-radius: 2px;\n  border: 1px solid transparent;\n  -webkit-appearance: none;\n  -webkit-font-smoothing: antialiased;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n.ladda-button:hover {\n    border-color: rgba(0, 0, 0, 0.07);\n    background-color: #888;\n}\n.ladda-button[data-color=green] {\n    background: #2aca76;\n}\n.ladda-button[data-color=green]:hover {\n      background-color: #38d683;\n}\n.ladda-button[data-color=blue] {\n    background: #53b5e6;\n}\n.ladda-button[data-color=blue]:hover {\n      background-color: #69bfe9;\n}\n.ladda-button[data-color=red] {\n    background: #ea8557;\n}\n.ladda-button[data-color=red]:hover {\n      background-color: #ed956e;\n}\n.ladda-button[data-color=purple] {\n    background: #9973C2;\n}\n.ladda-button[data-color=purple]:hover {\n      background-color: #a685ca;\n}\n.ladda-button[data-color=mint] {\n    background: #16a085;\n}\n.ladda-button[data-color=mint]:hover {\n      background-color: #19b698;\n}\n.ladda-button[disabled], .ladda-button[data-loading] {\n    border-color: rgba(0, 0, 0, 0.07);\n}\n.ladda-button[disabled], .ladda-button[disabled]:hover, .ladda-button[data-loading], .ladda-button[data-loading]:hover {\n      cursor: default;\n      background-color: #999;\n}\n.ladda-button[data-size=xs] {\n    padding: 4px 8px;\n}\n.ladda-button[data-size=xs] .ladda-label {\n      font-size: 0.7em;\n}\n.ladda-button[data-size=s] {\n    padding: 6px 10px;\n}\n.ladda-button[data-size=s] .ladda-label {\n      font-size: 0.9em;\n}\n.ladda-button[data-size=l] .ladda-label {\n    font-size: 1.2em;\n}\n.ladda-button[data-size=xl] .ladda-label {\n    font-size: 1.5em;\n}\n',""]);},function(n,t){function a(n,t){var a=n[1]||"",d=n[3];if(!d){ return a; }if(t&&"function"==typeof btoa){var o=e(d);return [a].concat(d.sources.map(function(n){return "/*# sourceURL="+d.sourceRoot+n+" */"})).concat([o]).join("\n")}return [a].join("\n")}function e(n){return "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(n))))+" */"}n.exports=function(n){var t=[];return t.toString=function(){return this.map(function(t){var e=a(t,n);return t[2]?"@media "+t[2]+"{"+e+"}":e}).join("")},t.i=function(n,a){"string"==typeof n&&(n=[[null,n,""]]);for(var e={},d=0;d<this.length;d++){var o=this[d][0];"number"==typeof o&&(e[o]=!0);}for(d=0;d<n.length;d++){var r=n[d];"number"==typeof r[0]&&e[r[0]]||(a&&!r[2]?r[2]=a:a&&(r[2]="("+r[2]+") and ("+a+")"),t.push(r));}},t};},function(n,t,a){/*!
	 * Ladda
	 * http://lab.hakim.se/ladda
	 * MIT licensed
	 *
	 * Copyright (C) 2016 Hakim El Hattab, http://hakim.se
	 */
	!function(t,e){n.exports=e(a(6));}(0,function(n){function t(n){if(void 0===n){ return void console.warn("Ladda button target must be defined."); }if(/ladda-button/i.test(n.className)||(n.className+=" ladda-button"),n.hasAttribute("data-style")||n.setAttribute("data-style","expand-right"),!n.querySelector(".ladda-label")){var t=document.createElement("span");t.className="ladda-label",i(n,t);}var a,e=n.querySelector(".ladda-spinner");e||(e=document.createElement("span"),e.className="ladda-spinner"),n.appendChild(e);var d,o={start:function(){return a||(a=r(n)),n.disabled=!0,n.setAttribute("data-loading",""),clearTimeout(d),a.spin(e),this.setProgress(0),this},startAfter:function(n){return clearTimeout(d),d=setTimeout(function(){o.start();},n),this},stop:function(){return o.isLoading()&&(n.disabled=!1,n.removeAttribute("data-loading")),clearTimeout(d),a&&(d=setTimeout(function(){a.stop();},1e3)),this},toggle:function(){return this.isLoading()?this.stop():this.start()},setProgress:function(t){t=Math.max(Math.min(t,1),0);var a=n.querySelector(".ladda-progress");0===t&&a&&a.parentNode?a.parentNode.removeChild(a):(a||(a=document.createElement("div"),a.className="ladda-progress",n.appendChild(a)),a.style.width=(t||0)*n.offsetWidth+"px");},enable:function(){return this.stop()},disable:function(){return this.stop(),n.disabled=!0,this},isLoading:function(){return n.hasAttribute("data-loading")},remove:function(){clearTimeout(d),n.disabled=!1,n.removeAttribute("data-loading"),a&&(a.stop(),a=null),s.splice(s.indexOf(o),1);}};return s.push(o),o}function a(n,t){for(;n.parentNode&&n.tagName!==t;){ n=n.parentNode; }return t===n.tagName?n:void 0}function e(n){var t=["input","textarea","select"],a=[];return t.forEach(function(t){for(var e=n.getElementsByTagName(t),d=0;d<e.length;d++){ e[d].hasAttribute("required")&&a.push(e[d]); }}),a}function d(n,t){var a;if("string"==typeof n){ a=document.querySelectorAll(n); }else{if("object"!=typeof n){ throw new Error("target must be string or object"); }a=[n];}t=t||{};for(var e=0;e<a.length;e++){ l(a[e],t); }}function o(){for(var n=0,t=s.length;n<t;n++){ s[n].stop(); }}function r(t){var a,e,d=t.offsetHeight;0===d&&(d=parseFloat(window.getComputedStyle(t).height)),d>32&&(d*=.8),t.hasAttribute("data-spinner-size")&&(d=parseInt(t.getAttribute("data-spinner-size"),10)),t.hasAttribute("data-spinner-color")&&(a=t.getAttribute("data-spinner-color")),t.hasAttribute("data-spinner-lines")&&(e=parseInt(t.getAttribute("data-spinner-lines"),10));var o=.2*d,r=.6*o,i=o<7?2:3;return new n({color:a||"#fff",lines:e||12,radius:o,length:r,width:i,zIndex:"auto",top:"auto",left:"auto",className:""})}function i(n,t){var a=document.createRange();a.selectNodeContents(n),a.surroundContents(t),n.appendChild(t);}function l(n,d){if("function"==typeof n.addEventListener){var o=t(n),r=-1;n.addEventListener("click",function(){var t=!0,i=a(n,"FORM");if(void 0!==i&&!i.hasAttribute("novalidate")){ if("function"==typeof i.checkValidity){ t=i.checkValidity(); }else { for(var l=e(i),s=0;s<l.length;s++){var u=l[s],p=u.getAttribute("type");if(""===u.value.replace(/^\s+|\s+$/g,"")&&(t=!1),"checkbox"!==p&&"radio"!==p||u.checked||(t=!1),"email"===p&&(t=/^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9-]+(\.[a-z0-9-]+)*$/i.test(u.value)),"url"===p&&(t=/^([a-z]([a-z]|\d|\+|-|\.)*):(\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?((\[(|(v[\da-f]{1,}\.(([a-z]|\d|-|\.|_|~)|[!\$&'\(\)\*\+,;=]|:)+))\])|((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=])*)(:\d*)?)(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*|(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)|((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)|((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)){0})(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(u.value)),!t){ break }} } }t&&(o.startAfter(1),"number"==typeof d.timeout&&(clearTimeout(r),r=setTimeout(o.stop,d.timeout)),"function"==typeof d.callback&&d.callback.apply(null,[o]));},!1);}}var s=[];return {bind:d,create:t,stopAll:o}});},function(n,t,a){var e,d;!function(o,r){"object"==typeof n&&n.exports?n.exports=r():(e=r,void 0!==(d="function"==typeof e?e.call(t,a,t,n):e)&&(n.exports=d));}(0,function(){function n(n,t){var a,e=document.createElement(n||"div");for(a in t){ e[a]=t[a]; }return e}function t(n){
	var arguments$1 = arguments;
	for(var t=1,a=arguments.length;t<a;t++){ n.appendChild(arguments$1[t]); }return n}function a(n,t,a,e){var d=["opacity",t,~~(100*n),a,e].join("-"),o=.01+a/e*100,r=Math.max(1-(1-n)/t*(100-o),n),i=l.substring(0,l.indexOf("Animation")).toLowerCase(),u=i&&"-"+i+"-"||"";return p[d]||(s.insertRule("@"+u+"keyframes "+d+"{0%{opacity:"+r+"}"+o+"%{opacity:"+n+"}"+(o+.01)+"%{opacity:1}"+(o+t)%100+"%{opacity:"+n+"}100%{opacity:"+r+"}}",s.cssRules.length),p[d]=1),d}function e(n,t){var a,e,d=n.style;if(t=t.charAt(0).toUpperCase()+t.slice(1),void 0!==d[t]){ return t; }for(e=0;e<u.length;e++){ if(a=u[e]+t,void 0!==d[a]){ return a } }}function d(n,t){for(var a in t){ n.style[e(n,a)||a]=t[a]; }return n}function o(n){
	var arguments$1 = arguments;
	for(var t=1;t<arguments.length;t++){var a=arguments$1[t];for(var e in a){ void 0===n[e]&&(n[e]=a[e]); }}return n}function r(n,t){return "string"==typeof n?n:n[t%n.length]}function i(n){this.opts=o(n||{},i.defaults,c);}var l,s,u=["webkit","Moz","ms","O"],p={},c={lines:12,length:7,width:5,radius:10,scale:1,corners:1,color:"#000",opacity:.25,rotate:0,direction:1,speed:1,trail:100,fps:20,zIndex:2e9,className:"spinner",top:"50%",left:"50%",shadow:!1,hwaccel:!1,position:"absolute"};if(i.defaults={},o(i.prototype,{spin:function(t){this.stop();var a=this,e=a.opts,o=a.el=n(null,{className:e.className});if(d(o,{position:e.position,width:0,zIndex:e.zIndex,left:e.left,top:e.top}),t&&t.insertBefore(o,t.firstChild||null),o.setAttribute("role","progressbar"),a.lines(o,a.opts),!l){var r,i=0,s=(e.lines-1)*(1-e.direction)/2,u=e.fps,p=u/e.speed,c=(1-e.opacity)/(p*e.trail/100),f=p/e.lines;!function n(){i++;for(var t=0;t<e.lines;t++){ r=Math.max(1-(i+(e.lines-t)*f)%p*c,e.opacity),a.opacity(o,t*e.direction+s,r,e); }a.timeout=a.el&&setTimeout(n,~~(1e3/u));}();}return a},stop:function(){var n=this.el;return n&&(clearTimeout(this.timeout),n.parentNode&&n.parentNode.removeChild(n),this.el=void 0),this},lines:function(e,o){function i(t,a){return d(n(),{position:"absolute",width:o.scale*(o.length+o.width)+"px",height:o.scale*o.width+"px",background:t,boxShadow:a,transformOrigin:"left",transform:"rotate("+~~(360/o.lines*u+o.rotate)+"deg) translate("+o.scale*o.radius+"px,0)",borderRadius:(o.corners*o.scale*o.width>>1)+"px"})}for(var s,u=0,p=(o.lines-1)*(1-o.direction)/2;u<o.lines;u++){ s=d(n(),{position:"absolute",top:1+~(o.scale*o.width/2)+"px",transform:o.hwaccel?"translate3d(0,0,0)":"",opacity:o.opacity,animation:l&&a(o.opacity,o.trail,p+u*o.direction,o.lines)+" "+1/o.speed+"s linear infinite"}),o.shadow&&t(s,d(i("#000","0 0 4px #000"),{top:"2px"})),t(e,t(s,i(r(o.color,u),"0 0 1px rgba(0,0,0,.1)"))); }return e},opacity:function(n,t,a){t<n.childNodes.length&&(n.childNodes[t].style.opacity=a);}}),"undefined"!=typeof document){s=function(){var a=n("style",{type:"text/css"});return t(document.getElementsByTagName("head")[0],a),a.sheet||a.styleSheet}();var f=d(n("group"),{behavior:"url(#default#VML)"});!e(f,"transform")&&f.adj?function(){function a(t,a){return n("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">',a)}s.addRule(".spin-vml","behavior:url(#default#VML)"),i.prototype.lines=function(n,e){function o(){return d(a("group",{coordsize:u+" "+u,coordorigin:-s+" "+-s}),{width:u,height:u})}function i(n,i,l){t(c,t(d(o(),{rotation:360/e.lines*n+"deg",left:~~i}),t(d(a("roundrect",{arcsize:e.corners}),{width:s,height:e.scale*e.width,left:e.scale*e.radius,top:-e.scale*e.width>>1,filter:l}),a("fill",{color:r(e.color,n),opacity:e.opacity}),a("stroke",{opacity:0}))));}var l,s=e.scale*(e.length+e.width),u=2*e.scale*s,p=-(e.width+e.length)*e.scale*2+"px",c=d(o(),{position:"absolute",top:p,left:p});if(e.shadow){ for(l=1;l<=e.lines;l++){ i(l,-2,"progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)"); } }for(l=1;l<=e.lines;l++){ i(l); }return t(n,c)},i.prototype.opacity=function(n,t,a,e){var d=n.firstChild;e=e.shadow&&e.lines||0,d&&t+e<d.childNodes.length&&(d=d.childNodes[t+e],d=d&&d.firstChild,(d=d&&d.firstChild)&&(d.opacity=a));};}():l=e(f,"animation");}return i});},function(n,t){n.exports=function(n,t,a,e){var d,o=n=n||{},r=typeof n.default;"object"!==r&&"function"!==r||(d=n,o=n.default);var i="function"==typeof o?o.options:o;if(t&&(i.render=t.render,i.staticRenderFns=t.staticRenderFns),a&&(i._scopeId=a),e){var l=Object.create(i.computed||null);Object.keys(e).forEach(function(n){var t=e[n];l[n]=function(){return t};}),i.computed=l;}return {esModule:d,exports:o,options:i}};},function(n,t,a){n.exports={render:function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("button",{ref:"ladda",class:n.buttonClass,attrs:{"data-style":n.dataStyle},on:{click:n.handleClick}},[n._t("default",[a("span",{staticClass:"ladda-label"},[n._v("Submit")])])],2)},staticRenderFns:[]},n.exports.render._withStripped=!0;},function(n,t,a){var e=a(3);"string"==typeof e&&(e=[[n.i,e,""]]),e.locals&&(n.exports=e.locals);a(10)("e5cb09de",e,!1);},function(n,t,a){function e(n){for(var t=0;t<n.length;t++){var a=n[t],e=u[a.id];if(e){e.refs++;for(var d=0;d<e.parts.length;d++){ e.parts[d](a.parts[d]); }for(;d<a.parts.length;d++){ e.parts.push(o(a.parts[d])); }e.parts.length>a.parts.length&&(e.parts.length=a.parts.length);}else{for(var r=[],d=0;d<a.parts.length;d++){ r.push(o(a.parts[d])); }u[a.id]={id:a.id,refs:1,parts:r};}}}function d(){var n=document.createElement("style");return n.type="text/css",p.appendChild(n),n}function o(n){var t,a,e=document.querySelector('style[data-vue-ssr-id~="'+n.id+'"]');if(e){if(b){ return m; }e.parentNode.removeChild(e);}if(h){var o=f++;e=c||(c=d()),t=r.bind(null,e,o,!1),a=r.bind(null,e,o,!0);}else { e=d(),t=i.bind(null,e),a=function(){e.parentNode.removeChild(e);}; }return t(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap){ return; }t(n=e);}else { a(); }}}function r(n,t,a,e){var d=a?"":e.css;if(n.styleSheet){ n.styleSheet.cssText=g(t,d); }else{var o=document.createTextNode(d),r=n.childNodes;r[t]&&n.removeChild(r[t]),r.length?n.insertBefore(o,r[t]):n.appendChild(o);}}function i(n,t){var a=t.css,e=t.media,d=t.sourceMap;if(e&&n.setAttribute("media",e),d&&(a+="\n/*# sourceURL="+d.sources[0]+" */",a+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(d))))+" */"),n.styleSheet){ n.styleSheet.cssText=a; }else{for(;n.firstChild;){ n.removeChild(n.firstChild); }n.appendChild(document.createTextNode(a));}}var l="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!l){ throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."); }var s=a(11),u={},p=l&&(document.head||document.getElementsByTagName("head")[0]),c=null,f=0,b=!1,m=function(){},h="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());n.exports=function(n,t,a){b=a;var d=s(n,t);return e(d),function(t){for(var a=[],o=0;o<d.length;o++){var r=d[o],i=u[r.id];i.refs--,a.push(i);}t?(d=s(n,t),e(d)):d=[];for(var o=0;o<a.length;o++){var i=a[o];if(0===i.refs){for(var l=0;l<i.parts.length;l++){ i.parts[l](); }delete u[i.id];}}}};var g=function(){var n=[];return function(t,a){return n[t]=a,n.filter(Boolean).join("\n")}}();},function(n,t){n.exports=function(n,t){for(var a=[],e={},d=0;d<t.length;d++){var o=t[d],r=o[0],i=o[1],l=o[2],s=o[3],u={id:n+":"+d,css:i,media:l,sourceMap:s};e[r]?e[r].parts.push(u):a.push(e[r]={id:r,parts:[u]});}return a};}])});
	});

	var LaddaComponent = unwrapExports(vueLadda);
	var vueLadda_1 = vueLadda.VueLadda;

	/**!
	 * @fileOverview Kickass library to create and place poppers near their reference elements.
	 * @version 1.16.0
	 * @license
	 * Copyright (c) 2016 Federico Zivolo and contributors
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */
	var isBrowser$2 = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

	var timeoutDuration$1 = function () {
	  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
	  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
	    if (isBrowser$2 && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
	      return 1;
	    }
	  }
	  return 0;
	}();

	function microtaskDebounce$1(fn) {
	  var called = false;
	  return function () {
	    if (called) {
	      return;
	    }
	    called = true;
	    window.Promise.resolve().then(function () {
	      called = false;
	      fn();
	    });
	  };
	}

	function taskDebounce$1(fn) {
	  var scheduled = false;
	  return function () {
	    if (!scheduled) {
	      scheduled = true;
	      setTimeout(function () {
	        scheduled = false;
	        fn();
	      }, timeoutDuration$1);
	    }
	  };
	}

	var supportsMicroTasks$1 = isBrowser$2 && window.Promise;

	/**
	* Create a debounced version of a method, that's asynchronously deferred
	* but called in the minimum time possible.
	*
	* @method
	* @memberof Popper.Utils
	* @argument {Function} fn
	* @returns {Function}
	*/
	var debounce$1 = supportsMicroTasks$1 ? microtaskDebounce$1 : taskDebounce$1;

	/**
	 * Check if the given variable is a function
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Any} functionToCheck - variable to check
	 * @returns {Boolean} answer to: is a function?
	 */
	function isFunction$3(functionToCheck) {
	  var getType = {};
	  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
	}

	/**
	 * Get CSS computed property of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Eement} element
	 * @argument {String} property
	 */
	function getStyleComputedProperty$1(element, property) {
	  if (element.nodeType !== 1) {
	    return [];
	  }
	  // NOTE: 1 DOM access here
	  var window = element.ownerDocument.defaultView;
	  var css = window.getComputedStyle(element, null);
	  return property ? css[property] : css;
	}

	/**
	 * Returns the parentNode or the host of the element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} parent
	 */
	function getParentNode$1(element) {
	  if (element.nodeName === 'HTML') {
	    return element;
	  }
	  return element.parentNode || element.host;
	}

	/**
	 * Returns the scrolling parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} scroll parent
	 */
	function getScrollParent$1(element) {
	  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
	  if (!element) {
	    return document.body;
	  }

	  switch (element.nodeName) {
	    case 'HTML':
	    case 'BODY':
	      return element.ownerDocument.body;
	    case '#document':
	      return element.body;
	  }

	  // Firefox want us to check `-x` and `-y` variations as well

	  var _getStyleComputedProp = getStyleComputedProperty$1(element),
	      overflow = _getStyleComputedProp.overflow,
	      overflowX = _getStyleComputedProp.overflowX,
	      overflowY = _getStyleComputedProp.overflowY;

	  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
	    return element;
	  }

	  return getScrollParent$1(getParentNode$1(element));
	}

	/**
	 * Returns the reference node of the reference object, or the reference object itself.
	 * @method
	 * @memberof Popper.Utils
	 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
	 * @returns {Element} parent
	 */
	function getReferenceNode$1(reference) {
	  return reference && reference.referenceNode ? reference.referenceNode : reference;
	}

	var isIE11$1 = isBrowser$2 && !!(window.MSInputMethodContext && document.documentMode);
	var isIE10$1 = isBrowser$2 && /MSIE 10/.test(navigator.userAgent);

	/**
	 * Determines if the browser is Internet Explorer
	 * @method
	 * @memberof Popper.Utils
	 * @param {Number} version to check
	 * @returns {Boolean} isIE
	 */
	function isIE$2(version) {
	  if (version === 11) {
	    return isIE11$1;
	  }
	  if (version === 10) {
	    return isIE10$1;
	  }
	  return isIE11$1 || isIE10$1;
	}

	/**
	 * Returns the offset parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} offset parent
	 */
	function getOffsetParent$1(element) {
	  if (!element) {
	    return document.documentElement;
	  }

	  var noOffsetParent = isIE$2(10) ? document.body : null;

	  // NOTE: 1 DOM access here
	  var offsetParent = element.offsetParent || null;
	  // Skip hidden elements which don't have an offsetParent
	  while (offsetParent === noOffsetParent && element.nextElementSibling) {
	    offsetParent = (element = element.nextElementSibling).offsetParent;
	  }

	  var nodeName = offsetParent && offsetParent.nodeName;

	  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
	    return element ? element.ownerDocument.documentElement : document.documentElement;
	  }

	  // .offsetParent will return the closest TH, TD or TABLE in case
	  // no offsetParent is present, I hate this job...
	  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty$1(offsetParent, 'position') === 'static') {
	    return getOffsetParent$1(offsetParent);
	  }

	  return offsetParent;
	}

	function isOffsetContainer$1(element) {
	  var nodeName = element.nodeName;

	  if (nodeName === 'BODY') {
	    return false;
	  }
	  return nodeName === 'HTML' || getOffsetParent$1(element.firstElementChild) === element;
	}

	/**
	 * Finds the root node (document, shadowDOM root) of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} node
	 * @returns {Element} root node
	 */
	function getRoot$1(node) {
	  if (node.parentNode !== null) {
	    return getRoot$1(node.parentNode);
	  }

	  return node;
	}

	/**
	 * Finds the offset parent common to the two provided nodes
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element1
	 * @argument {Element} element2
	 * @returns {Element} common offset parent
	 */
	function findCommonOffsetParent$1(element1, element2) {
	  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
	  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
	    return document.documentElement;
	  }

	  // Here we make sure to give as "start" the element that comes first in the DOM
	  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
	  var start = order ? element1 : element2;
	  var end = order ? element2 : element1;

	  // Get common ancestor container
	  var range = document.createRange();
	  range.setStart(start, 0);
	  range.setEnd(end, 0);
	  var commonAncestorContainer = range.commonAncestorContainer;

	  // Both nodes are inside #document

	  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
	    if (isOffsetContainer$1(commonAncestorContainer)) {
	      return commonAncestorContainer;
	    }

	    return getOffsetParent$1(commonAncestorContainer);
	  }

	  // one of the nodes is inside shadowDOM, find which one
	  var element1root = getRoot$1(element1);
	  if (element1root.host) {
	    return findCommonOffsetParent$1(element1root.host, element2);
	  } else {
	    return findCommonOffsetParent$1(element1, getRoot$1(element2).host);
	  }
	}

	/**
	 * Gets the scroll value of the given element in the given side (top and left)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {String} side `top` or `left`
	 * @returns {number} amount of scrolled pixels
	 */
	function getScroll$1(element) {
	  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

	  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
	  var nodeName = element.nodeName;

	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    var html = element.ownerDocument.documentElement;
	    var scrollingElement = element.ownerDocument.scrollingElement || html;
	    return scrollingElement[upperSide];
	  }

	  return element[upperSide];
	}

	/*
	 * Sum or subtract the element scroll values (left and top) from a given rect object
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} rect - Rect object you want to change
	 * @param {HTMLElement} element - The element from the function reads the scroll values
	 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
	 * @return {Object} rect - The modifier rect object
	 */
	function includeScroll$1(rect, element) {
	  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  var scrollTop = getScroll$1(element, 'top');
	  var scrollLeft = getScroll$1(element, 'left');
	  var modifier = subtract ? -1 : 1;
	  rect.top += scrollTop * modifier;
	  rect.bottom += scrollTop * modifier;
	  rect.left += scrollLeft * modifier;
	  rect.right += scrollLeft * modifier;
	  return rect;
	}

	/*
	 * Helper to detect borders of a given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {CSSStyleDeclaration} styles
	 * Result of `getStyleComputedProperty` on the given element
	 * @param {String} axis - `x` or `y`
	 * @return {number} borders - The borders size of the given axis
	 */

	function getBordersSize$1(styles, axis) {
	  var sideA = axis === 'x' ? 'Left' : 'Top';
	  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

	  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
	}

	function getSize$1(axis, body, html, computedStyle) {
	  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE$2(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
	}

	function getWindowSizes$1(document) {
	  var body = document.body;
	  var html = document.documentElement;
	  var computedStyle = isIE$2(10) && getComputedStyle(html);

	  return {
	    height: getSize$1('Height', body, html, computedStyle),
	    width: getSize$1('Width', body, html, computedStyle)
	  };
	}

	var classCallCheck$1 = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass$1 = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) { descriptor.writable = true; }
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) { defineProperties(Constructor.prototype, protoProps); }
	    if (staticProps) { defineProperties(Constructor, staticProps); }
	    return Constructor;
	  };
	}();





	var defineProperty$3 = function (obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

	var _extends$1 = Object.assign || function (target) {
	  var arguments$1 = arguments;

	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments$1[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

	/**
	 * Given element offsets, generate an output similar to getBoundingClientRect
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} offsets
	 * @returns {Object} ClientRect like output
	 */
	function getClientRect$1(offsets) {
	  return _extends$1({}, offsets, {
	    right: offsets.left + offsets.width,
	    bottom: offsets.top + offsets.height
	  });
	}

	/**
	 * Get bounding client rect of given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} element
	 * @return {Object} client rect
	 */
	function getBoundingClientRect$1(element) {
	  var rect = {};

	  // IE10 10 FIX: Please, don't ask, the element isn't
	  // considered in DOM in some circumstances...
	  // This isn't reproducible in IE10 compatibility mode of IE11
	  try {
	    if (isIE$2(10)) {
	      rect = element.getBoundingClientRect();
	      var scrollTop = getScroll$1(element, 'top');
	      var scrollLeft = getScroll$1(element, 'left');
	      rect.top += scrollTop;
	      rect.left += scrollLeft;
	      rect.bottom += scrollTop;
	      rect.right += scrollLeft;
	    } else {
	      rect = element.getBoundingClientRect();
	    }
	  } catch (e) {}

	  var result = {
	    left: rect.left,
	    top: rect.top,
	    width: rect.right - rect.left,
	    height: rect.bottom - rect.top
	  };

	  // subtract scrollbar size from sizes
	  var sizes = element.nodeName === 'HTML' ? getWindowSizes$1(element.ownerDocument) : {};
	  var width = sizes.width || element.clientWidth || result.width;
	  var height = sizes.height || element.clientHeight || result.height;

	  var horizScrollbar = element.offsetWidth - width;
	  var vertScrollbar = element.offsetHeight - height;

	  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
	  // we make this check conditional for performance reasons
	  if (horizScrollbar || vertScrollbar) {
	    var styles = getStyleComputedProperty$1(element);
	    horizScrollbar -= getBordersSize$1(styles, 'x');
	    vertScrollbar -= getBordersSize$1(styles, 'y');

	    result.width -= horizScrollbar;
	    result.height -= vertScrollbar;
	  }

	  return getClientRect$1(result);
	}

	function getOffsetRectRelativeToArbitraryNode$1(children, parent) {
	  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  var isIE10 = isIE$2(10);
	  var isHTML = parent.nodeName === 'HTML';
	  var childrenRect = getBoundingClientRect$1(children);
	  var parentRect = getBoundingClientRect$1(parent);
	  var scrollParent = getScrollParent$1(children);

	  var styles = getStyleComputedProperty$1(parent);
	  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
	  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

	  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
	  if (fixedPosition && isHTML) {
	    parentRect.top = Math.max(parentRect.top, 0);
	    parentRect.left = Math.max(parentRect.left, 0);
	  }
	  var offsets = getClientRect$1({
	    top: childrenRect.top - parentRect.top - borderTopWidth,
	    left: childrenRect.left - parentRect.left - borderLeftWidth,
	    width: childrenRect.width,
	    height: childrenRect.height
	  });
	  offsets.marginTop = 0;
	  offsets.marginLeft = 0;

	  // Subtract margins of documentElement in case it's being used as parent
	  // we do this only on HTML because it's the only element that behaves
	  // differently when margins are applied to it. The margins are included in
	  // the box of the documentElement, in the other cases not.
	  if (!isIE10 && isHTML) {
	    var marginTop = parseFloat(styles.marginTop, 10);
	    var marginLeft = parseFloat(styles.marginLeft, 10);

	    offsets.top -= borderTopWidth - marginTop;
	    offsets.bottom -= borderTopWidth - marginTop;
	    offsets.left -= borderLeftWidth - marginLeft;
	    offsets.right -= borderLeftWidth - marginLeft;

	    // Attach marginTop and marginLeft because in some circumstances we may need them
	    offsets.marginTop = marginTop;
	    offsets.marginLeft = marginLeft;
	  }

	  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
	    offsets = includeScroll$1(offsets, parent);
	  }

	  return offsets;
	}

	function getViewportOffsetRectRelativeToArtbitraryNode$1(element) {
	  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  var html = element.ownerDocument.documentElement;
	  var relativeOffset = getOffsetRectRelativeToArbitraryNode$1(element, html);
	  var width = Math.max(html.clientWidth, window.innerWidth || 0);
	  var height = Math.max(html.clientHeight, window.innerHeight || 0);

	  var scrollTop = !excludeScroll ? getScroll$1(html) : 0;
	  var scrollLeft = !excludeScroll ? getScroll$1(html, 'left') : 0;

	  var offset = {
	    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
	    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
	    width: width,
	    height: height
	  };

	  return getClientRect$1(offset);
	}

	/**
	 * Check if the given element is fixed or is inside a fixed parent
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {Element} customContainer
	 * @returns {Boolean} answer to "isFixed?"
	 */
	function isFixed$1(element) {
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    return false;
	  }
	  if (getStyleComputedProperty$1(element, 'position') === 'fixed') {
	    return true;
	  }
	  var parentNode = getParentNode$1(element);
	  if (!parentNode) {
	    return false;
	  }
	  return isFixed$1(parentNode);
	}

	/**
	 * Finds the first parent of an element that has a transformed property defined
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} first transformed parent or documentElement
	 */

	function getFixedPositionOffsetParent$1(element) {
	  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
	  if (!element || !element.parentElement || isIE$2()) {
	    return document.documentElement;
	  }
	  var el = element.parentElement;
	  while (el && getStyleComputedProperty$1(el, 'transform') === 'none') {
	    el = el.parentElement;
	  }
	  return el || document.documentElement;
	}

	/**
	 * Computed the boundaries limits and return them
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} popper
	 * @param {HTMLElement} reference
	 * @param {number} padding
	 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
	 * @param {Boolean} fixedPosition - Is in fixed position mode
	 * @returns {Object} Coordinates of the boundaries
	 */
	function getBoundaries$1(popper, reference, padding, boundariesElement) {
	  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

	  // NOTE: 1 DOM access here

	  var boundaries = { top: 0, left: 0 };
	  var offsetParent = fixedPosition ? getFixedPositionOffsetParent$1(popper) : findCommonOffsetParent$1(popper, getReferenceNode$1(reference));

	  // Handle viewport case
	  if (boundariesElement === 'viewport') {
	    boundaries = getViewportOffsetRectRelativeToArtbitraryNode$1(offsetParent, fixedPosition);
	  } else {
	    // Handle other cases based on DOM element used as boundaries
	    var boundariesNode = void 0;
	    if (boundariesElement === 'scrollParent') {
	      boundariesNode = getScrollParent$1(getParentNode$1(reference));
	      if (boundariesNode.nodeName === 'BODY') {
	        boundariesNode = popper.ownerDocument.documentElement;
	      }
	    } else if (boundariesElement === 'window') {
	      boundariesNode = popper.ownerDocument.documentElement;
	    } else {
	      boundariesNode = boundariesElement;
	    }

	    var offsets = getOffsetRectRelativeToArbitraryNode$1(boundariesNode, offsetParent, fixedPosition);

	    // In case of HTML, we need a different computation
	    if (boundariesNode.nodeName === 'HTML' && !isFixed$1(offsetParent)) {
	      var _getWindowSizes = getWindowSizes$1(popper.ownerDocument),
	          height = _getWindowSizes.height,
	          width = _getWindowSizes.width;

	      boundaries.top += offsets.top - offsets.marginTop;
	      boundaries.bottom = height + offsets.top;
	      boundaries.left += offsets.left - offsets.marginLeft;
	      boundaries.right = width + offsets.left;
	    } else {
	      // for all the other DOM elements, this one is good
	      boundaries = offsets;
	    }
	  }

	  // Add paddings
	  padding = padding || 0;
	  var isPaddingNumber = typeof padding === 'number';
	  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
	  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
	  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
	  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

	  return boundaries;
	}

	function getArea$1(_ref) {
	  var width = _ref.width,
	      height = _ref.height;

	  return width * height;
	}

	/**
	 * Utility used to transform the `auto` placement to the placement with more
	 * available space.
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeAutoPlacement$1(placement, refRect, popper, reference, boundariesElement) {
	  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

	  if (placement.indexOf('auto') === -1) {
	    return placement;
	  }

	  var boundaries = getBoundaries$1(popper, reference, padding, boundariesElement);

	  var rects = {
	    top: {
	      width: boundaries.width,
	      height: refRect.top - boundaries.top
	    },
	    right: {
	      width: boundaries.right - refRect.right,
	      height: boundaries.height
	    },
	    bottom: {
	      width: boundaries.width,
	      height: boundaries.bottom - refRect.bottom
	    },
	    left: {
	      width: refRect.left - boundaries.left,
	      height: boundaries.height
	    }
	  };

	  var sortedAreas = Object.keys(rects).map(function (key) {
	    return _extends$1({
	      key: key
	    }, rects[key], {
	      area: getArea$1(rects[key])
	    });
	  }).sort(function (a, b) {
	    return b.area - a.area;
	  });

	  var filteredAreas = sortedAreas.filter(function (_ref2) {
	    var width = _ref2.width,
	        height = _ref2.height;
	    return width >= popper.clientWidth && height >= popper.clientHeight;
	  });

	  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

	  var variation = placement.split('-')[1];

	  return computedPlacement + (variation ? '-' + variation : '');
	}

	/**
	 * Get offsets to the reference element
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} state
	 * @param {Element} popper - the popper element
	 * @param {Element} reference - the reference element (the popper will be relative to this)
	 * @param {Element} fixedPosition - is in fixed position mode
	 * @returns {Object} An object containing the offsets which will be applied to the popper
	 */
	function getReferenceOffsets$1(state, popper, reference) {
	  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent$1(popper) : findCommonOffsetParent$1(popper, getReferenceNode$1(reference));
	  return getOffsetRectRelativeToArbitraryNode$1(reference, commonOffsetParent, fixedPosition);
	}

	/**
	 * Get the outer sizes of the given element (offset size + margins)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Object} object containing width and height properties
	 */
	function getOuterSizes$1(element) {
	  var window = element.ownerDocument.defaultView;
	  var styles = window.getComputedStyle(element);
	  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
	  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
	  var result = {
	    width: element.offsetWidth + y,
	    height: element.offsetHeight + x
	  };
	  return result;
	}

	/**
	 * Get the opposite placement of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement
	 * @returns {String} flipped placement
	 */
	function getOppositePlacement$1(placement) {
	  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
	  return placement.replace(/left|right|bottom|top/g, function (matched) {
	    return hash[matched];
	  });
	}

	/**
	 * Get offsets to the popper
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} position - CSS position the Popper will get applied
	 * @param {HTMLElement} popper - the popper element
	 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
	 * @param {String} placement - one of the valid placement options
	 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
	 */
	function getPopperOffsets$1(popper, referenceOffsets, placement) {
	  placement = placement.split('-')[0];

	  // Get popper node sizes
	  var popperRect = getOuterSizes$1(popper);

	  // Add position, width and height to our offsets object
	  var popperOffsets = {
	    width: popperRect.width,
	    height: popperRect.height
	  };

	  // depending by the popper placement we have to compute its offsets slightly differently
	  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
	  var mainSide = isHoriz ? 'top' : 'left';
	  var secondarySide = isHoriz ? 'left' : 'top';
	  var measurement = isHoriz ? 'height' : 'width';
	  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

	  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
	  if (placement === secondarySide) {
	    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
	  } else {
	    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement$1(secondarySide)];
	  }

	  return popperOffsets;
	}

	/**
	 * Mimics the `find` method of Array
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function find$1(arr, check) {
	  // use native find if supported
	  if (Array.prototype.find) {
	    return arr.find(check);
	  }

	  // use `filter` to obtain the same behavior of `find`
	  return arr.filter(check)[0];
	}

	/**
	 * Return the index of the matching object
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function findIndex$1(arr, prop, value) {
	  // use native findIndex if supported
	  if (Array.prototype.findIndex) {
	    return arr.findIndex(function (cur) {
	      return cur[prop] === value;
	    });
	  }

	  // use `find` + `indexOf` if `findIndex` isn't supported
	  var match = find$1(arr, function (obj) {
	    return obj[prop] === value;
	  });
	  return arr.indexOf(match);
	}

	/**
	 * Loop trough the list of modifiers and run them in order,
	 * each of them will then edit the data object.
	 * @method
	 * @memberof Popper.Utils
	 * @param {dataObject} data
	 * @param {Array} modifiers
	 * @param {String} ends - Optional modifier name used as stopper
	 * @returns {dataObject}
	 */
	function runModifiers$1(modifiers, data, ends) {
	  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex$1(modifiers, 'name', ends));

	  modifiersToRun.forEach(function (modifier) {
	    if (modifier['function']) {
	      // eslint-disable-line dot-notation
	      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
	    }
	    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
	    if (modifier.enabled && isFunction$3(fn)) {
	      // Add properties to offsets to make them a complete clientRect object
	      // we do this before each modifier to make sure the previous one doesn't
	      // mess with these values
	      data.offsets.popper = getClientRect$1(data.offsets.popper);
	      data.offsets.reference = getClientRect$1(data.offsets.reference);

	      data = fn(data, modifier);
	    }
	  });

	  return data;
	}

	/**
	 * Updates the position of the popper, computing the new offsets and applying
	 * the new style.<br />
	 * Prefer `scheduleUpdate` over `update` because of performance reasons.
	 * @method
	 * @memberof Popper
	 */
	function update$1() {
	  // if popper is destroyed, don't perform any further update
	  if (this.state.isDestroyed) {
	    return;
	  }

	  var data = {
	    instance: this,
	    styles: {},
	    arrowStyles: {},
	    attributes: {},
	    flipped: false,
	    offsets: {}
	  };

	  // compute reference element offsets
	  data.offsets.reference = getReferenceOffsets$1(this.state, this.popper, this.reference, this.options.positionFixed);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit `placement` if needed
	  // and refer to originalPlacement to know the original value
	  data.placement = computeAutoPlacement$1(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

	  // store the computed placement inside `originalPlacement`
	  data.originalPlacement = data.placement;

	  data.positionFixed = this.options.positionFixed;

	  // compute the popper offsets
	  data.offsets.popper = getPopperOffsets$1(this.popper, data.offsets.reference, data.placement);

	  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

	  // run the modifiers
	  data = runModifiers$1(this.modifiers, data);

	  // the first `update` will call `onCreate` callback
	  // the other ones will call `onUpdate` callback
	  if (!this.state.isCreated) {
	    this.state.isCreated = true;
	    this.options.onCreate(data);
	  } else {
	    this.options.onUpdate(data);
	  }
	}

	/**
	 * Helper used to know if the given modifier is enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @returns {Boolean}
	 */
	function isModifierEnabled$1(modifiers, modifierName) {
	  return modifiers.some(function (_ref) {
	    var name = _ref.name,
	        enabled = _ref.enabled;
	    return enabled && name === modifierName;
	  });
	}

	/**
	 * Get the prefixed supported property name
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} property (camelCase)
	 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
	 */
	function getSupportedPropertyName$1(property) {
	  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
	  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

	  for (var i = 0; i < prefixes.length; i++) {
	    var prefix = prefixes[i];
	    var toCheck = prefix ? '' + prefix + upperProp : property;
	    if (typeof document.body.style[toCheck] !== 'undefined') {
	      return toCheck;
	    }
	  }
	  return null;
	}

	/**
	 * Destroys the popper.
	 * @method
	 * @memberof Popper
	 */
	function destroy$2() {
	  this.state.isDestroyed = true;

	  // touch DOM only if `applyStyle` modifier is enabled
	  if (isModifierEnabled$1(this.modifiers, 'applyStyle')) {
	    this.popper.removeAttribute('x-placement');
	    this.popper.style.position = '';
	    this.popper.style.top = '';
	    this.popper.style.left = '';
	    this.popper.style.right = '';
	    this.popper.style.bottom = '';
	    this.popper.style.willChange = '';
	    this.popper.style[getSupportedPropertyName$1('transform')] = '';
	  }

	  this.disableEventListeners();

	  // remove the popper if user explicitly asked for the deletion on destroy
	  // do not use `remove` because IE11 doesn't support it
	  if (this.options.removeOnDestroy) {
	    this.popper.parentNode.removeChild(this.popper);
	  }
	  return this;
	}

	/**
	 * Get the window associated with the element
	 * @argument {Element} element
	 * @returns {Window}
	 */
	function getWindow$1(element) {
	  var ownerDocument = element.ownerDocument;
	  return ownerDocument ? ownerDocument.defaultView : window;
	}

	function attachToScrollParents$1(scrollParent, event, callback, scrollParents) {
	  var isBody = scrollParent.nodeName === 'BODY';
	  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
	  target.addEventListener(event, callback, { passive: true });

	  if (!isBody) {
	    attachToScrollParents$1(getScrollParent$1(target.parentNode), event, callback, scrollParents);
	  }
	  scrollParents.push(target);
	}

	/**
	 * Setup needed event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function setupEventListeners$1(reference, options, state, updateBound) {
	  // Resize event listener on window
	  state.updateBound = updateBound;
	  getWindow$1(reference).addEventListener('resize', state.updateBound, { passive: true });

	  // Scroll event listener on scroll parents
	  var scrollElement = getScrollParent$1(reference);
	  attachToScrollParents$1(scrollElement, 'scroll', state.updateBound, state.scrollParents);
	  state.scrollElement = scrollElement;
	  state.eventsEnabled = true;

	  return state;
	}

	/**
	 * It will add resize/scroll events and start recalculating
	 * position of the popper element when they are triggered.
	 * @method
	 * @memberof Popper
	 */
	function enableEventListeners$1() {
	  if (!this.state.eventsEnabled) {
	    this.state = setupEventListeners$1(this.reference, this.options, this.state, this.scheduleUpdate);
	  }
	}

	/**
	 * Remove event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function removeEventListeners$1(reference, state) {
	  // Remove resize event listener on window
	  getWindow$1(reference).removeEventListener('resize', state.updateBound);

	  // Remove scroll event listener on scroll parents
	  state.scrollParents.forEach(function (target) {
	    target.removeEventListener('scroll', state.updateBound);
	  });

	  // Reset state
	  state.updateBound = null;
	  state.scrollParents = [];
	  state.scrollElement = null;
	  state.eventsEnabled = false;
	  return state;
	}

	/**
	 * It will remove resize/scroll events and won't recalculate popper position
	 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
	 * unless you call `update` method manually.
	 * @method
	 * @memberof Popper
	 */
	function disableEventListeners$1() {
	  if (this.state.eventsEnabled) {
	    cancelAnimationFrame(this.scheduleUpdate);
	    this.state = removeEventListeners$1(this.reference, this.state);
	  }
	}

	/**
	 * Tells if a given input is a number
	 * @method
	 * @memberof Popper.Utils
	 * @param {*} input to check
	 * @return {Boolean}
	 */
	function isNumeric$1(n) {
	  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
	}

	/**
	 * Set the style to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the style to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setStyles$1(element, styles) {
	  Object.keys(styles).forEach(function (prop) {
	    var unit = '';
	    // add unit if the value is numeric and is one of the following
	    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric$1(styles[prop])) {
	      unit = 'px';
	    }
	    element.style[prop] = styles[prop] + unit;
	  });
	}

	/**
	 * Set the attributes to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the attributes to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setAttributes$1(element, attributes) {
	  Object.keys(attributes).forEach(function (prop) {
	    var value = attributes[prop];
	    if (value !== false) {
	      element.setAttribute(prop, attributes[prop]);
	    } else {
	      element.removeAttribute(prop);
	    }
	  });
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} data.styles - List of style properties - values to apply to popper element
	 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The same data object
	 */
	function applyStyle$1(data) {
	  // any property present in `data.styles` will be applied to the popper,
	  // in this way we can make the 3rd party modifiers add custom styles to it
	  // Be aware, modifiers could override the properties defined in the previous
	  // lines of this modifier!
	  setStyles$1(data.instance.popper, data.styles);

	  // any property present in `data.attributes` will be applied to the popper,
	  // they will be set as HTML attributes of the element
	  setAttributes$1(data.instance.popper, data.attributes);

	  // if arrowElement is defined and arrowStyles has some properties
	  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
	    setStyles$1(data.arrowElement, data.arrowStyles);
	  }

	  return data;
	}

	/**
	 * Set the x-placement attribute before everything else because it could be used
	 * to add margins to the popper margins needs to be calculated to get the
	 * correct popper offsets.
	 * @method
	 * @memberof Popper.modifiers
	 * @param {HTMLElement} reference - The reference element used to position the popper
	 * @param {HTMLElement} popper - The HTML element used as popper
	 * @param {Object} options - Popper.js options
	 */
	function applyStyleOnLoad$1(reference, popper, options, modifierOptions, state) {
	  // compute reference element offsets
	  var referenceOffsets = getReferenceOffsets$1(state, popper, reference, options.positionFixed);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit `placement` if needed
	  // and refer to originalPlacement to know the original value
	  var placement = computeAutoPlacement$1(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

	  popper.setAttribute('x-placement', placement);

	  // Apply `position` to popper before anything else because
	  // without the position applied we can't guarantee correct computations
	  setStyles$1(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

	  return options;
	}

	/**
	 * @function
	 * @memberof Popper.Utils
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
	 * @returns {Object} The popper's position offsets rounded
	 *
	 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
	 * good as it can be within reason.
	 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
	 *
	 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
	 * as well on High DPI screens).
	 *
	 * Firefox prefers no rounding for positioning and does not have blurriness on
	 * high DPI screens.
	 *
	 * Only horizontal placement and left/right values need to be considered.
	 */
	function getRoundedOffsets$1(data, shouldRound) {
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;
	  var round = Math.round,
	      floor = Math.floor;

	  var noRound = function noRound(v) {
	    return v;
	  };

	  var referenceWidth = round(reference.width);
	  var popperWidth = round(popper.width);

	  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
	  var isVariation = data.placement.indexOf('-') !== -1;
	  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
	  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

	  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
	  var verticalToInteger = !shouldRound ? noRound : round;

	  return {
	    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
	    top: verticalToInteger(popper.top),
	    bottom: verticalToInteger(popper.bottom),
	    right: horizontalToInteger(popper.right)
	  };
	}

	var isFirefox$1 = isBrowser$2 && /Firefox/i.test(navigator.userAgent);

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeStyle$1(data, options) {
	  var x = options.x,
	      y = options.y;
	  var popper = data.offsets.popper;

	  // Remove this legacy support in Popper.js v2

	  var legacyGpuAccelerationOption = find$1(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'applyStyle';
	  }).gpuAcceleration;
	  if (legacyGpuAccelerationOption !== undefined) {
	    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
	  }
	  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

	  var offsetParent = getOffsetParent$1(data.instance.popper);
	  var offsetParentRect = getBoundingClientRect$1(offsetParent);

	  // Styles
	  var styles = {
	    position: popper.position
	  };

	  var offsets = getRoundedOffsets$1(data, window.devicePixelRatio < 2 || !isFirefox$1);

	  var sideA = x === 'bottom' ? 'top' : 'bottom';
	  var sideB = y === 'right' ? 'left' : 'right';

	  // if gpuAcceleration is set to `true` and transform is supported,
	  //  we use `translate3d` to apply the position to the popper we
	  // automatically use the supported prefixed version if needed
	  var prefixedProperty = getSupportedPropertyName$1('transform');

	  // now, let's make a step back and look at this code closely (wtf?)
	  // If the content of the popper grows once it's been positioned, it
	  // may happen that the popper gets misplaced because of the new content
	  // overflowing its reference element
	  // To avoid this problem, we provide two options (x and y), which allow
	  // the consumer to define the offset origin.
	  // If we position a popper on top of a reference element, we can set
	  // `x` to `top` to make the popper grow towards its top instead of
	  // its bottom.
	  var left = void 0,
	      top = void 0;
	  if (sideA === 'bottom') {
	    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
	    // and not the bottom of the html element
	    if (offsetParent.nodeName === 'HTML') {
	      top = -offsetParent.clientHeight + offsets.bottom;
	    } else {
	      top = -offsetParentRect.height + offsets.bottom;
	    }
	  } else {
	    top = offsets.top;
	  }
	  if (sideB === 'right') {
	    if (offsetParent.nodeName === 'HTML') {
	      left = -offsetParent.clientWidth + offsets.right;
	    } else {
	      left = -offsetParentRect.width + offsets.right;
	    }
	  } else {
	    left = offsets.left;
	  }
	  if (gpuAcceleration && prefixedProperty) {
	    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
	    styles[sideA] = 0;
	    styles[sideB] = 0;
	    styles.willChange = 'transform';
	  } else {
	    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
	    var invertTop = sideA === 'bottom' ? -1 : 1;
	    var invertLeft = sideB === 'right' ? -1 : 1;
	    styles[sideA] = top * invertTop;
	    styles[sideB] = left * invertLeft;
	    styles.willChange = sideA + ', ' + sideB;
	  }

	  // Attributes
	  var attributes = {
	    'x-placement': data.placement
	  };

	  // Update `data` attributes, styles and arrowStyles
	  data.attributes = _extends$1({}, attributes, data.attributes);
	  data.styles = _extends$1({}, styles, data.styles);
	  data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);

	  return data;
	}

	/**
	 * Helper used to know if the given modifier depends from another one.<br />
	 * It checks if the needed modifier is listed and enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @param {Array} modifiers - list of modifiers
	 * @param {String} requestingName - name of requesting modifier
	 * @param {String} requestedName - name of requested modifier
	 * @returns {Boolean}
	 */
	function isModifierRequired$1(modifiers, requestingName, requestedName) {
	  var requesting = find$1(modifiers, function (_ref) {
	    var name = _ref.name;
	    return name === requestingName;
	  });

	  var isRequired = !!requesting && modifiers.some(function (modifier) {
	    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
	  });

	  if (!isRequired) {
	    var _requesting = '`' + requestingName + '`';
	    var requested = '`' + requestedName + '`';
	    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
	  }
	  return isRequired;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function arrow$1(data, options) {
	  var _data$offsets$arrow;

	  // arrow depends on keepTogether in order to work
	  if (!isModifierRequired$1(data.instance.modifiers, 'arrow', 'keepTogether')) {
	    return data;
	  }

	  var arrowElement = options.element;

	  // if arrowElement is a string, suppose it's a CSS selector
	  if (typeof arrowElement === 'string') {
	    arrowElement = data.instance.popper.querySelector(arrowElement);

	    // if arrowElement is not found, don't run the modifier
	    if (!arrowElement) {
	      return data;
	    }
	  } else {
	    // if the arrowElement isn't a query selector we must check that the
	    // provided DOM node is child of its popper node
	    if (!data.instance.popper.contains(arrowElement)) {
	      console.warn('WARNING: `arrow.element` must be child of its popper element!');
	      return data;
	    }
	  }

	  var placement = data.placement.split('-')[0];
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

	  var len = isVertical ? 'height' : 'width';
	  var sideCapitalized = isVertical ? 'Top' : 'Left';
	  var side = sideCapitalized.toLowerCase();
	  var altSide = isVertical ? 'left' : 'top';
	  var opSide = isVertical ? 'bottom' : 'right';
	  var arrowElementSize = getOuterSizes$1(arrowElement)[len];

	  //
	  // extends keepTogether behavior making sure the popper and its
	  // reference have enough pixels in conjunction
	  //

	  // top/left side
	  if (reference[opSide] - arrowElementSize < popper[side]) {
	    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
	  }
	  // bottom/right side
	  if (reference[side] + arrowElementSize > popper[opSide]) {
	    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
	  }
	  data.offsets.popper = getClientRect$1(data.offsets.popper);

	  // compute center of the popper
	  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

	  // Compute the sideValue using the updated popper offsets
	  // take popper margin in account because we don't have this info available
	  var css = getStyleComputedProperty$1(data.instance.popper);
	  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
	  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
	  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

	  // prevent arrowElement from being placed not contiguously to its popper
	  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

	  data.arrowElement = arrowElement;
	  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$3(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$3(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

	  return data;
	}

	/**
	 * Get the opposite placement variation of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement variation
	 * @returns {String} flipped placement variation
	 */
	function getOppositeVariation$1(variation) {
	  if (variation === 'end') {
	    return 'start';
	  } else if (variation === 'start') {
	    return 'end';
	  }
	  return variation;
	}

	/**
	 * List of accepted placements to use as values of the `placement` option.<br />
	 * Valid placements are:
	 * - `auto`
	 * - `top`
	 * - `right`
	 * - `bottom`
	 * - `left`
	 *
	 * Each placement can have a variation from this list:
	 * - `-start`
	 * - `-end`
	 *
	 * Variations are interpreted easily if you think of them as the left to right
	 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
	 * is right.<br />
	 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
	 *
	 * Some valid examples are:
	 * - `top-end` (on top of reference, right aligned)
	 * - `right-start` (on right of reference, top aligned)
	 * - `bottom` (on bottom, centered)
	 * - `auto-end` (on the side with more space available, alignment depends by placement)
	 *
	 * @static
	 * @type {Array}
	 * @enum {String}
	 * @readonly
	 * @method placements
	 * @memberof Popper
	 */
	var placements$1 = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

	// Get rid of `auto` `auto-start` and `auto-end`
	var validPlacements$1 = placements$1.slice(3);

	/**
	 * Given an initial placement, returns all the subsequent placements
	 * clockwise (or counter-clockwise).
	 *
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement - A valid placement (it accepts variations)
	 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
	 * @returns {Array} placements including their variations
	 */
	function clockwise$1(placement) {
	  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  var index = validPlacements$1.indexOf(placement);
	  var arr = validPlacements$1.slice(index + 1).concat(validPlacements$1.slice(0, index));
	  return counter ? arr.reverse() : arr;
	}

	var BEHAVIORS$1 = {
	  FLIP: 'flip',
	  CLOCKWISE: 'clockwise',
	  COUNTERCLOCKWISE: 'counterclockwise'
	};

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function flip$1(data, options) {
	  // if `inner` modifier is enabled, we can't use the `flip` modifier
	  if (isModifierEnabled$1(data.instance.modifiers, 'inner')) {
	    return data;
	  }

	  if (data.flipped && data.placement === data.originalPlacement) {
	    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
	    return data;
	  }

	  var boundaries = getBoundaries$1(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

	  var placement = data.placement.split('-')[0];
	  var placementOpposite = getOppositePlacement$1(placement);
	  var variation = data.placement.split('-')[1] || '';

	  var flipOrder = [];

	  switch (options.behavior) {
	    case BEHAVIORS$1.FLIP:
	      flipOrder = [placement, placementOpposite];
	      break;
	    case BEHAVIORS$1.CLOCKWISE:
	      flipOrder = clockwise$1(placement);
	      break;
	    case BEHAVIORS$1.COUNTERCLOCKWISE:
	      flipOrder = clockwise$1(placement, true);
	      break;
	    default:
	      flipOrder = options.behavior;
	  }

	  flipOrder.forEach(function (step, index) {
	    if (placement !== step || flipOrder.length === index + 1) {
	      return data;
	    }

	    placement = data.placement.split('-')[0];
	    placementOpposite = getOppositePlacement$1(placement);

	    var popperOffsets = data.offsets.popper;
	    var refOffsets = data.offsets.reference;

	    // using floor because the reference offsets may contain decimals we are not going to consider here
	    var floor = Math.floor;
	    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

	    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
	    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
	    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
	    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

	    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

	    // flip the variation if required
	    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

	    // flips variation if reference element overflows boundaries
	    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

	    // flips variation if popper content overflows boundaries
	    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

	    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

	    if (overlapsRef || overflowsBoundaries || flippedVariation) {
	      // this boolean to detect any flip loop
	      data.flipped = true;

	      if (overlapsRef || overflowsBoundaries) {
	        placement = flipOrder[index + 1];
	      }

	      if (flippedVariation) {
	        variation = getOppositeVariation$1(variation);
	      }

	      data.placement = placement + (variation ? '-' + variation : '');

	      // this object contains `position`, we want to preserve it along with
	      // any additional property we may add in the future
	      data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets$1(data.instance.popper, data.offsets.reference, data.placement));

	      data = runModifiers$1(data.instance.modifiers, data, 'flip');
	    }
	  });
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function keepTogether$1(data) {
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var placement = data.placement.split('-')[0];
	  var floor = Math.floor;
	  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	  var side = isVertical ? 'right' : 'bottom';
	  var opSide = isVertical ? 'left' : 'top';
	  var measurement = isVertical ? 'width' : 'height';

	  if (popper[side] < floor(reference[opSide])) {
	    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
	  }
	  if (popper[opSide] > floor(reference[side])) {
	    data.offsets.popper[opSide] = floor(reference[side]);
	  }

	  return data;
	}

	/**
	 * Converts a string containing value + unit into a px value number
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} str - Value + unit string
	 * @argument {String} measurement - `height` or `width`
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @returns {Number|String}
	 * Value in pixels, or original string if no values were extracted
	 */
	function toValue$1(str, measurement, popperOffsets, referenceOffsets) {
	  // separate value from unit
	  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
	  var value = +split[1];
	  var unit = split[2];

	  // If it's not a number it's an operator, I guess
	  if (!value) {
	    return str;
	  }

	  if (unit.indexOf('%') === 0) {
	    var element = void 0;
	    switch (unit) {
	      case '%p':
	        element = popperOffsets;
	        break;
	      case '%':
	      case '%r':
	      default:
	        element = referenceOffsets;
	    }

	    var rect = getClientRect$1(element);
	    return rect[measurement] / 100 * value;
	  } else if (unit === 'vh' || unit === 'vw') {
	    // if is a vh or vw, we calculate the size based on the viewport
	    var size = void 0;
	    if (unit === 'vh') {
	      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	    } else {
	      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	    }
	    return size / 100 * value;
	  } else {
	    // if is an explicit pixel unit, we get rid of the unit and keep the value
	    // if is an implicit unit, it's px, and we return just the value
	    return value;
	  }
	}

	/**
	 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} offset
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @argument {String} basePlacement
	 * @returns {Array} a two cells array with x and y offsets in numbers
	 */
	function parseOffset$1(offset, popperOffsets, referenceOffsets, basePlacement) {
	  var offsets = [0, 0];

	  // Use height if placement is left or right and index is 0 otherwise use width
	  // in this way the first offset will use an axis and the second one
	  // will use the other one
	  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

	  // Split the offset string to obtain a list of values and operands
	  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
	  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
	    return frag.trim();
	  });

	  // Detect if the offset string contains a pair of values or a single one
	  // they could be separated by comma or space
	  var divider = fragments.indexOf(find$1(fragments, function (frag) {
	    return frag.search(/,|\s/) !== -1;
	  }));

	  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
	    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
	  }

	  // If divider is found, we divide the list of values and operands to divide
	  // them by ofset X and Y.
	  var splitRegex = /\s*,\s*|\s+/;
	  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

	  // Convert the values with units to absolute pixels to allow our computations
	  ops = ops.map(function (op, index) {
	    // Most of the units rely on the orientation of the popper
	    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
	    var mergeWithPrevious = false;
	    return op
	    // This aggregates any `+` or `-` sign that aren't considered operators
	    // e.g.: 10 + +5 => [10, +, +5]
	    .reduce(function (a, b) {
	      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
	        a[a.length - 1] = b;
	        mergeWithPrevious = true;
	        return a;
	      } else if (mergeWithPrevious) {
	        a[a.length - 1] += b;
	        mergeWithPrevious = false;
	        return a;
	      } else {
	        return a.concat(b);
	      }
	    }, [])
	    // Here we convert the string values into number values (in px)
	    .map(function (str) {
	      return toValue$1(str, measurement, popperOffsets, referenceOffsets);
	    });
	  });

	  // Loop trough the offsets arrays and execute the operations
	  ops.forEach(function (op, index) {
	    op.forEach(function (frag, index2) {
	      if (isNumeric$1(frag)) {
	        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
	      }
	    });
	  });
	  return offsets;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @argument {Number|String} options.offset=0
	 * The offset value as described in the modifier description
	 * @returns {Object} The data object, properly modified
	 */
	function offset$2(data, _ref) {
	  var offset = _ref.offset;
	  var placement = data.placement,
	      _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var basePlacement = placement.split('-')[0];

	  var offsets = void 0;
	  if (isNumeric$1(+offset)) {
	    offsets = [+offset, 0];
	  } else {
	    offsets = parseOffset$1(offset, popper, reference, basePlacement);
	  }

	  if (basePlacement === 'left') {
	    popper.top += offsets[0];
	    popper.left -= offsets[1];
	  } else if (basePlacement === 'right') {
	    popper.top += offsets[0];
	    popper.left += offsets[1];
	  } else if (basePlacement === 'top') {
	    popper.left += offsets[0];
	    popper.top -= offsets[1];
	  } else if (basePlacement === 'bottom') {
	    popper.left += offsets[0];
	    popper.top += offsets[1];
	  }

	  data.popper = popper;
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function preventOverflow$1(data, options) {
	  var boundariesElement = options.boundariesElement || getOffsetParent$1(data.instance.popper);

	  // If offsetParent is the reference element, we really want to
	  // go one step up and use the next offsetParent as reference to
	  // avoid to make this modifier completely useless and look like broken
	  if (data.instance.reference === boundariesElement) {
	    boundariesElement = getOffsetParent$1(boundariesElement);
	  }

	  // NOTE: DOM access here
	  // resets the popper's position so that the document size can be calculated excluding
	  // the size of the popper element itself
	  var transformProp = getSupportedPropertyName$1('transform');
	  var popperStyles = data.instance.popper.style; // assignment to help minification
	  var top = popperStyles.top,
	      left = popperStyles.left,
	      transform = popperStyles[transformProp];

	  popperStyles.top = '';
	  popperStyles.left = '';
	  popperStyles[transformProp] = '';

	  var boundaries = getBoundaries$1(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

	  // NOTE: DOM access here
	  // restores the original style properties after the offsets have been computed
	  popperStyles.top = top;
	  popperStyles.left = left;
	  popperStyles[transformProp] = transform;

	  options.boundaries = boundaries;

	  var order = options.priority;
	  var popper = data.offsets.popper;

	  var check = {
	    primary: function primary(placement) {
	      var value = popper[placement];
	      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
	        value = Math.max(popper[placement], boundaries[placement]);
	      }
	      return defineProperty$3({}, placement, value);
	    },
	    secondary: function secondary(placement) {
	      var mainSide = placement === 'right' ? 'left' : 'top';
	      var value = popper[mainSide];
	      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
	        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
	      }
	      return defineProperty$3({}, mainSide, value);
	    }
	  };

	  order.forEach(function (placement) {
	    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
	    popper = _extends$1({}, popper, check[side](placement));
	  });

	  data.offsets.popper = popper;

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function shift$1(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var shiftvariation = placement.split('-')[1];

	  // if shift shiftvariation is specified, run the modifier
	  if (shiftvariation) {
	    var _data$offsets = data.offsets,
	        reference = _data$offsets.reference,
	        popper = _data$offsets.popper;

	    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
	    var side = isVertical ? 'left' : 'top';
	    var measurement = isVertical ? 'width' : 'height';

	    var shiftOffsets = {
	      start: defineProperty$3({}, side, reference[side]),
	      end: defineProperty$3({}, side, reference[side] + reference[measurement] - popper[measurement])
	    };

	    data.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function hide$1(data) {
	  if (!isModifierRequired$1(data.instance.modifiers, 'hide', 'preventOverflow')) {
	    return data;
	  }

	  var refRect = data.offsets.reference;
	  var bound = find$1(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'preventOverflow';
	  }).boundaries;

	  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
	    // Avoid unnecessary DOM access if visibility hasn't changed
	    if (data.hide === true) {
	      return data;
	    }

	    data.hide = true;
	    data.attributes['x-out-of-boundaries'] = '';
	  } else {
	    // Avoid unnecessary DOM access if visibility hasn't changed
	    if (data.hide === false) {
	      return data;
	    }

	    data.hide = false;
	    data.attributes['x-out-of-boundaries'] = false;
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function inner$1(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

	  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

	  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

	  data.placement = getOppositePlacement$1(placement);
	  data.offsets.popper = getClientRect$1(popper);

	  return data;
	}

	/**
	 * Modifier function, each modifier can have a function of this type assigned
	 * to its `fn` property.<br />
	 * These functions will be called on each update, this means that you must
	 * make sure they are performant enough to avoid performance bottlenecks.
	 *
	 * @function ModifierFn
	 * @argument {dataObject} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {dataObject} The data object, properly modified
	 */

	/**
	 * Modifiers are plugins used to alter the behavior of your poppers.<br />
	 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
	 * needed by the library.
	 *
	 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
	 * All the other properties are configurations that could be tweaked.
	 * @namespace modifiers
	 */
	var modifiers$1 = {
	  /**
	   * Modifier used to shift the popper on the start or end of its reference
	   * element.<br />
	   * It will read the variation of the `placement` property.<br />
	   * It can be one either `-end` or `-start`.
	   * @memberof modifiers
	   * @inner
	   */
	  shift: {
	    /** @prop {number} order=100 - Index used to define the order of execution */
	    order: 100,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: shift$1
	  },

	  /**
	   * The `offset` modifier can shift your popper on both its axis.
	   *
	   * It accepts the following units:
	   * - `px` or unit-less, interpreted as pixels
	   * - `%` or `%r`, percentage relative to the length of the reference element
	   * - `%p`, percentage relative to the length of the popper element
	   * - `vw`, CSS viewport width unit
	   * - `vh`, CSS viewport height unit
	   *
	   * For length is intended the main axis relative to the placement of the popper.<br />
	   * This means that if the placement is `top` or `bottom`, the length will be the
	   * `width`. In case of `left` or `right`, it will be the `height`.
	   *
	   * You can provide a single value (as `Number` or `String`), or a pair of values
	   * as `String` divided by a comma or one (or more) white spaces.<br />
	   * The latter is a deprecated method because it leads to confusion and will be
	   * removed in v2.<br />
	   * Additionally, it accepts additions and subtractions between different units.
	   * Note that multiplications and divisions aren't supported.
	   *
	   * Valid examples are:
	   * ```
	   * 10
	   * '10%'
	   * '10, 10'
	   * '10%, 10'
	   * '10 + 10%'
	   * '10 - 5vh + 3%'
	   * '-10px + 5vh, 5px - 6%'
	   * ```
	   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
	   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
	   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  offset: {
	    /** @prop {number} order=200 - Index used to define the order of execution */
	    order: 200,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: offset$2,
	    /** @prop {Number|String} offset=0
	     * The offset value as described in the modifier description
	     */
	    offset: 0
	  },

	  /**
	   * Modifier used to prevent the popper from being positioned outside the boundary.
	   *
	   * A scenario exists where the reference itself is not within the boundaries.<br />
	   * We can say it has "escaped the boundaries" — or just "escaped".<br />
	   * In this case we need to decide whether the popper should either:
	   *
	   * - detach from the reference and remain "trapped" in the boundaries, or
	   * - if it should ignore the boundary and "escape with its reference"
	   *
	   * When `escapeWithReference` is set to`true` and reference is completely
	   * outside its boundaries, the popper will overflow (or completely leave)
	   * the boundaries in order to remain attached to the edge of the reference.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  preventOverflow: {
	    /** @prop {number} order=300 - Index used to define the order of execution */
	    order: 300,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: preventOverflow$1,
	    /**
	     * @prop {Array} [priority=['left','right','top','bottom']]
	     * Popper will try to prevent overflow following these priorities by default,
	     * then, it could overflow on the left and on top of the `boundariesElement`
	     */
	    priority: ['left', 'right', 'top', 'bottom'],
	    /**
	     * @prop {number} padding=5
	     * Amount of pixel used to define a minimum distance between the boundaries
	     * and the popper. This makes sure the popper always has a little padding
	     * between the edges of its container
	     */
	    padding: 5,
	    /**
	     * @prop {String|HTMLElement} boundariesElement='scrollParent'
	     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
	     * `viewport` or any DOM element.
	     */
	    boundariesElement: 'scrollParent'
	  },

	  /**
	   * Modifier used to make sure the reference and its popper stay near each other
	   * without leaving any gap between the two. Especially useful when the arrow is
	   * enabled and you want to ensure that it points to its reference element.
	   * It cares only about the first axis. You can still have poppers with margin
	   * between the popper and its reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  keepTogether: {
	    /** @prop {number} order=400 - Index used to define the order of execution */
	    order: 400,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: keepTogether$1
	  },

	  /**
	   * This modifier is used to move the `arrowElement` of the popper to make
	   * sure it is positioned between the reference element and its popper element.
	   * It will read the outer size of the `arrowElement` node to detect how many
	   * pixels of conjunction are needed.
	   *
	   * It has no effect if no `arrowElement` is provided.
	   * @memberof modifiers
	   * @inner
	   */
	  arrow: {
	    /** @prop {number} order=500 - Index used to define the order of execution */
	    order: 500,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: arrow$1,
	    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
	    element: '[x-arrow]'
	  },

	  /**
	   * Modifier used to flip the popper's placement when it starts to overlap its
	   * reference element.
	   *
	   * Requires the `preventOverflow` modifier before it in order to work.
	   *
	   * **NOTE:** this modifier will interrupt the current update cycle and will
	   * restart it if it detects the need to flip the placement.
	   * @memberof modifiers
	   * @inner
	   */
	  flip: {
	    /** @prop {number} order=600 - Index used to define the order of execution */
	    order: 600,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: flip$1,
	    /**
	     * @prop {String|Array} behavior='flip'
	     * The behavior used to change the popper's placement. It can be one of
	     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
	     * placements (with optional variations)
	     */
	    behavior: 'flip',
	    /**
	     * @prop {number} padding=5
	     * The popper will flip if it hits the edges of the `boundariesElement`
	     */
	    padding: 5,
	    /**
	     * @prop {String|HTMLElement} boundariesElement='viewport'
	     * The element which will define the boundaries of the popper position.
	     * The popper will never be placed outside of the defined boundaries
	     * (except if `keepTogether` is enabled)
	     */
	    boundariesElement: 'viewport',
	    /**
	     * @prop {Boolean} flipVariations=false
	     * The popper will switch placement variation between `-start` and `-end` when
	     * the reference element overlaps its boundaries.
	     *
	     * The original placement should have a set variation.
	     */
	    flipVariations: false,
	    /**
	     * @prop {Boolean} flipVariationsByContent=false
	     * The popper will switch placement variation between `-start` and `-end` when
	     * the popper element overlaps its reference boundaries.
	     *
	     * The original placement should have a set variation.
	     */
	    flipVariationsByContent: false
	  },

	  /**
	   * Modifier used to make the popper flow toward the inner of the reference element.
	   * By default, when this modifier is disabled, the popper will be placed outside
	   * the reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  inner: {
	    /** @prop {number} order=700 - Index used to define the order of execution */
	    order: 700,
	    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
	    enabled: false,
	    /** @prop {ModifierFn} */
	    fn: inner$1
	  },

	  /**
	   * Modifier used to hide the popper when its reference element is outside of the
	   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
	   * be used to hide with a CSS selector the popper when its reference is
	   * out of boundaries.
	   *
	   * Requires the `preventOverflow` modifier before it in order to work.
	   * @memberof modifiers
	   * @inner
	   */
	  hide: {
	    /** @prop {number} order=800 - Index used to define the order of execution */
	    order: 800,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: hide$1
	  },

	  /**
	   * Computes the style that will be applied to the popper element to gets
	   * properly positioned.
	   *
	   * Note that this modifier will not touch the DOM, it just prepares the styles
	   * so that `applyStyle` modifier can apply it. This separation is useful
	   * in case you need to replace `applyStyle` with a custom implementation.
	   *
	   * This modifier has `850` as `order` value to maintain backward compatibility
	   * with previous versions of Popper.js. Expect the modifiers ordering method
	   * to change in future major versions of the library.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  computeStyle: {
	    /** @prop {number} order=850 - Index used to define the order of execution */
	    order: 850,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: computeStyle$1,
	    /**
	     * @prop {Boolean} gpuAcceleration=true
	     * If true, it uses the CSS 3D transformation to position the popper.
	     * Otherwise, it will use the `top` and `left` properties
	     */
	    gpuAcceleration: true,
	    /**
	     * @prop {string} [x='bottom']
	     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
	     * Change this if your popper should grow in a direction different from `bottom`
	     */
	    x: 'bottom',
	    /**
	     * @prop {string} [x='left']
	     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
	     * Change this if your popper should grow in a direction different from `right`
	     */
	    y: 'right'
	  },

	  /**
	   * Applies the computed styles to the popper element.
	   *
	   * All the DOM manipulations are limited to this modifier. This is useful in case
	   * you want to integrate Popper.js inside a framework or view library and you
	   * want to delegate all the DOM manipulations to it.
	   *
	   * Note that if you disable this modifier, you must make sure the popper element
	   * has its position set to `absolute` before Popper.js can do its work!
	   *
	   * Just disable this modifier and define your own to achieve the desired effect.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  applyStyle: {
	    /** @prop {number} order=900 - Index used to define the order of execution */
	    order: 900,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: applyStyle$1,
	    /** @prop {Function} */
	    onLoad: applyStyleOnLoad$1,
	    /**
	     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
	     * @prop {Boolean} gpuAcceleration=true
	     * If true, it uses the CSS 3D transformation to position the popper.
	     * Otherwise, it will use the `top` and `left` properties
	     */
	    gpuAcceleration: undefined
	  }
	};

	/**
	 * The `dataObject` is an object containing all the information used by Popper.js.
	 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
	 * @name dataObject
	 * @property {Object} data.instance The Popper.js instance
	 * @property {String} data.placement Placement applied to popper
	 * @property {String} data.originalPlacement Placement originally defined on init
	 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
	 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
	 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
	 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
	 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
	 * @property {Object} data.boundaries Offsets of the popper boundaries
	 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
	 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
	 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
	 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
	 */

	/**
	 * Default options provided to Popper.js constructor.<br />
	 * These can be overridden using the `options` argument of Popper.js.<br />
	 * To override an option, simply pass an object with the same
	 * structure of the `options` object, as the 3rd argument. For example:
	 * ```
	 * new Popper(ref, pop, {
	 *   modifiers: {
	 *     preventOverflow: { enabled: false }
	 *   }
	 * })
	 * ```
	 * @type {Object}
	 * @static
	 * @memberof Popper
	 */
	var Defaults$1 = {
	  /**
	   * Popper's placement.
	   * @prop {Popper.placements} placement='bottom'
	   */
	  placement: 'bottom',

	  /**
	   * Set this to true if you want popper to position it self in 'fixed' mode
	   * @prop {Boolean} positionFixed=false
	   */
	  positionFixed: false,

	  /**
	   * Whether events (resize, scroll) are initially enabled.
	   * @prop {Boolean} eventsEnabled=true
	   */
	  eventsEnabled: true,

	  /**
	   * Set to true if you want to automatically remove the popper when
	   * you call the `destroy` method.
	   * @prop {Boolean} removeOnDestroy=false
	   */
	  removeOnDestroy: false,

	  /**
	   * Callback called when the popper is created.<br />
	   * By default, it is set to no-op.<br />
	   * Access Popper.js instance with `data.instance`.
	   * @prop {onCreate}
	   */
	  onCreate: function onCreate() {},

	  /**
	   * Callback called when the popper is updated. This callback is not called
	   * on the initialization/creation of the popper, but only on subsequent
	   * updates.<br />
	   * By default, it is set to no-op.<br />
	   * Access Popper.js instance with `data.instance`.
	   * @prop {onUpdate}
	   */
	  onUpdate: function onUpdate() {},

	  /**
	   * List of modifiers used to modify the offsets before they are applied to the popper.
	   * They provide most of the functionalities of Popper.js.
	   * @prop {modifiers}
	   */
	  modifiers: modifiers$1
	};

	/**
	 * @callback onCreate
	 * @param {dataObject} data
	 */

	/**
	 * @callback onUpdate
	 * @param {dataObject} data
	 */

	// Utils
	// Methods
	var Popper$1 = function () {
	  /**
	   * Creates a new Popper.js instance.
	   * @class Popper
	   * @param {Element|referenceObject} reference - The reference element used to position the popper
	   * @param {Element} popper - The HTML / XML element used as the popper
	   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
	   * @return {Object} instance - The generated Popper.js instance
	   */
	  function Popper(reference, popper) {
	    var _this = this;

	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    classCallCheck$1(this, Popper);

	    this.scheduleUpdate = function () {
	      return requestAnimationFrame(_this.update);
	    };

	    // make update() debounced, so that it only runs at most once-per-tick
	    this.update = debounce$1(this.update.bind(this));

	    // with {} we create a new object with the options inside it
	    this.options = _extends$1({}, Popper.Defaults, options);

	    // init state
	    this.state = {
	      isDestroyed: false,
	      isCreated: false,
	      scrollParents: []
	    };

	    // get reference and popper elements (allow jQuery wrappers)
	    this.reference = reference && reference.jquery ? reference[0] : reference;
	    this.popper = popper && popper.jquery ? popper[0] : popper;

	    // Deep merge modifiers options
	    this.options.modifiers = {};
	    Object.keys(_extends$1({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
	      _this.options.modifiers[name] = _extends$1({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
	    });

	    // Refactoring modifiers' list (Object => Array)
	    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
	      return _extends$1({
	        name: name
	      }, _this.options.modifiers[name]);
	    })
	    // sort the modifiers by order
	    .sort(function (a, b) {
	      return a.order - b.order;
	    });

	    // modifiers have the ability to execute arbitrary code when Popper.js get inited
	    // such code is executed in the same order of its modifier
	    // they could add new properties to their options configuration
	    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
	    this.modifiers.forEach(function (modifierOptions) {
	      if (modifierOptions.enabled && isFunction$3(modifierOptions.onLoad)) {
	        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
	      }
	    });

	    // fire the first update to position the popper in the right place
	    this.update();

	    var eventsEnabled = this.options.eventsEnabled;
	    if (eventsEnabled) {
	      // setup event listeners, they will take care of update the position in specific situations
	      this.enableEventListeners();
	    }

	    this.state.eventsEnabled = eventsEnabled;
	  }

	  // We can't use class properties because they don't get listed in the
	  // class prototype and break stuff like Sinon stubs


	  createClass$1(Popper, [{
	    key: 'update',
	    value: function update$$1() {
	      return update$1.call(this);
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy$$1() {
	      return destroy$2.call(this);
	    }
	  }, {
	    key: 'enableEventListeners',
	    value: function enableEventListeners$$1() {
	      return enableEventListeners$1.call(this);
	    }
	  }, {
	    key: 'disableEventListeners',
	    value: function disableEventListeners$$1() {
	      return disableEventListeners$1.call(this);
	    }

	    /**
	     * Schedules an update. It will run on the next UI update available.
	     * @method scheduleUpdate
	     * @memberof Popper
	     */


	    /**
	     * Collection of utilities useful when writing custom modifiers.
	     * Starting from version 1.7, this method is available only if you
	     * include `popper-utils.js` before `popper.js`.
	     *
	     * **DEPRECATION**: This way to access PopperUtils is deprecated
	     * and will be removed in v2! Use the PopperUtils module directly instead.
	     * Due to the high instability of the methods contained in Utils, we can't
	     * guarantee them to follow semver. Use them at your own risk!
	     * @static
	     * @private
	     * @type {Object}
	     * @deprecated since version 1.8
	     * @member Utils
	     * @memberof Popper
	     */

	  }]);
	  return Popper;
	}();

	/**
	 * The `referenceObject` is an object that provides an interface compatible with Popper.js
	 * and lets you use it as replacement of a real DOM node.<br />
	 * You can use this method to position a popper relatively to a set of coordinates
	 * in case you don't have a DOM node to use as reference.
	 *
	 * ```
	 * new Popper(referenceObject, popperNode);
	 * ```
	 *
	 * NB: This feature isn't supported in Internet Explorer 10.
	 * @name referenceObject
	 * @property {Function} data.getBoundingClientRect
	 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
	 * @property {number} data.clientWidth
	 * An ES6 getter that will return the width of the virtual reference element.
	 * @property {number} data.clientHeight
	 * An ES6 getter that will return the height of the virtual reference element.
	 */


	Popper$1.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
	Popper$1.placements = placements$1;
	Popper$1.Defaults = Defaults$1;

	/**!
	* tippy.js v4.3.5
	* (c) 2017-2019 atomiks
	* MIT License
	*/

	var css = ".tippy-iOS{cursor:pointer!important;-webkit-tap-highlight-color:transparent}.tippy-popper{transition-timing-function:cubic-bezier(.165,.84,.44,1);max-width:calc(100% - 8px);pointer-events:none;outline:0}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-7px;bottom:-6.5px;-webkit-transform-origin:50% 0;transform-origin:50% 0;margin:0 3px}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;bottom:-7px;margin:0 3px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 25%;transform-origin:0 25%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-55%);transform:scale(1) translate(-50%,-55%)}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%,-45%);transform:scale(.2) translate(-50%,-45%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(-10px);transform:perspective(700px) translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(60deg);transform:perspective(700px) rotateX(60deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=top] [data-animation=scale]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px) scale(.5);transform:translateY(-10px) scale(.5)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-7px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;margin:0 3px}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;top:-7px;margin:0 3px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -50%;transform-origin:0 -50%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-45%);transform:scale(1) translate(-50%,-45%)}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%);transform:scale(.2) translate(-50%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(10px);transform:perspective(700px) translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateX(-60deg);transform:perspective(700px) rotateX(-60deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=scale]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px) scale(.5);transform:translateY(10px) scale(.5)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:50% 0 0 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-12px;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%;margin:3px 0}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;right:-7px;margin:3px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-75%,-50%);transform:scale(.2) translate(-75%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(-10px);transform:perspective(700px) translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(-60deg);transform:perspective(700px) rotateY(-60deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=left] [data-animation=scale]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px) scale(.5);transform:translateX(-10px) scale(.5)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 50% 50% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-12px;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%;margin:3px 0}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;left:-7px;margin:3px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-25%,-50%);transform:scale(.2) translate(-25%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(10px);transform:perspective(700px) translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) rotateY(60deg);transform:perspective(700px) rotateY(60deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-popper[x-placement^=right] [data-animation=scale]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px) scale(.5);transform:translateX(10px) scale(.5)}.tippy-tooltip{position:relative;color:#fff;border-radius:.25rem;font-size:.875rem;padding:.3125rem .5625rem;line-height:1.4;text-align:center;background-color:#333}.tippy-tooltip[data-size=small]{padding:.1875rem .375rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.375rem .75rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:initial}.tippy-tooltip[data-interactive],.tippy-tooltip[data-interactive] .tippy-roundarrow path{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:18px;height:7px;fill:#333;pointer-events:none}.tippy-backdrop{position:absolute;background-color:#333;border-radius:50%;width:calc(110% + 2rem);left:50%;top:50%;z-index:-1;transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:\"\";float:left;padding-top:100%}.tippy-backdrop+.tippy-content{transition-property:opacity;will-change:opacity}.tippy-backdrop+.tippy-content[data-state=hidden]{opacity:0}";

	function _extends$1$1() {
	  _extends$1$1 = Object.assign || function (target) {
	    var arguments$1 = arguments;

	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments$1[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends$1$1.apply(this, arguments);
	}

	var version = "4.3.5";

	var isBrowser$1$1 = typeof window !== 'undefined' && typeof document !== 'undefined';
	var ua = isBrowser$1$1 ? navigator.userAgent : '';
	var isIE$1$1 = /MSIE |Trident\//.test(ua);
	var isUCBrowser = /UCBrowser\//.test(ua);
	var isIOS = isBrowser$1$1 && /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream;

	var defaultProps = {
	  a11y: true,
	  allowHTML: true,
	  animateFill: true,
	  animation: 'shift-away',
	  appendTo: function appendTo() {
	    return document.body;
	  },
	  aria: 'describedby',
	  arrow: false,
	  arrowType: 'sharp',
	  boundary: 'scrollParent',
	  content: '',
	  delay: 0,
	  distance: 10,
	  duration: [325, 275],
	  flip: true,
	  flipBehavior: 'flip',
	  flipOnUpdate: false,
	  followCursor: false,
	  hideOnClick: true,
	  ignoreAttributes: false,
	  inertia: false,
	  interactive: false,
	  interactiveBorder: 2,
	  interactiveDebounce: 0,
	  lazy: true,
	  maxWidth: 350,
	  multiple: false,
	  offset: 0,
	  onHidden: function onHidden() {},
	  onHide: function onHide() {},
	  onMount: function onMount() {},
	  onShow: function onShow() {},
	  onShown: function onShown() {},
	  onTrigger: function onTrigger() {},
	  placement: 'top',
	  popperOptions: {},
	  role: 'tooltip',
	  showOnInit: false,
	  size: 'regular',
	  sticky: false,
	  target: '',
	  theme: 'dark',
	  touch: true,
	  touchHold: false,
	  trigger: 'mouseenter focus',
	  triggerTarget: null,
	  updateDuration: 0,
	  wait: null,
	  zIndex: 9999
	  /**
	   * If the set() method encounters one of these, the popperInstance must be
	   * recreated
	   */

	};
	var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'arrowType', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions'];

	var elementProto = isBrowser$1$1 ? Element.prototype : {};
	var matches$1 = elementProto.matches || elementProto.matchesSelector || elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector;
	/**
	 * Ponyfill for Array.from - converts iterable values to an array
	 */

	function arrayFrom(value) {
	  return [].slice.call(value);
	}
	/**
	 * Ponyfill for Element.prototype.closest
	 */

	function closest$1(element, selector) {
	  return closestCallback(element, function (el) {
	    return matches$1.call(el, selector);
	  });
	}
	/**
	 * Works like Element.prototype.closest, but uses a callback instead
	 */

	function closestCallback(element, callback) {
	  while (element) {
	    if (callback(element)) {
	      return element;
	    }

	    element = element.parentElement;
	  }

	  return null;
	}

	// Passive event listener config
	var PASSIVE = {
	  passive: true // Popper `preventOverflow` padding

	};
	var PADDING = 4; // Popper attributes
	// In Popper v2 these will be `data-*` instead of `x-*` to adhere to HTML5 spec

	var PLACEMENT_ATTRIBUTE = 'x-placement';
	var OUT_OF_BOUNDARIES_ATTRIBUTE = 'x-out-of-boundaries'; // Classes

	var IOS_CLASS = "tippy-iOS";
	var ACTIVE_CLASS = "tippy-active";
	var POPPER_CLASS = "tippy-popper";
	var TOOLTIP_CLASS = "tippy-tooltip";
	var CONTENT_CLASS = "tippy-content";
	var BACKDROP_CLASS = "tippy-backdrop";
	var ARROW_CLASS = "tippy-arrow";
	var ROUND_ARROW_CLASS = "tippy-roundarrow"; // Selectors

	var POPPER_SELECTOR = ".".concat(POPPER_CLASS);
	var TOOLTIP_SELECTOR = ".".concat(TOOLTIP_CLASS);
	var CONTENT_SELECTOR = ".".concat(CONTENT_CLASS);
	var BACKDROP_SELECTOR = ".".concat(BACKDROP_CLASS);
	var ARROW_SELECTOR = ".".concat(ARROW_CLASS);
	var ROUND_ARROW_SELECTOR = ".".concat(ROUND_ARROW_CLASS);

	var isUsingTouch = false;
	function onDocumentTouch() {
	  if (isUsingTouch) {
	    return;
	  }

	  isUsingTouch = true;

	  if (isIOS) {
	    document.body.classList.add(IOS_CLASS);
	  }

	  if (window.performance) {
	    document.addEventListener('mousemove', onDocumentMouseMove);
	  }
	}
	var lastMouseMoveTime = 0;
	function onDocumentMouseMove() {
	  var now = performance.now(); // Chrome 60+ is 1 mousemove per animation frame, use 20ms time difference

	  if (now - lastMouseMoveTime < 20) {
	    isUsingTouch = false;
	    document.removeEventListener('mousemove', onDocumentMouseMove);

	    if (!isIOS) {
	      document.body.classList.remove(IOS_CLASS);
	    }
	  }

	  lastMouseMoveTime = now;
	}
	function onWindowBlur() {
	  var _document = document,
	      activeElement = _document.activeElement;

	  if (activeElement && activeElement.blur && activeElement._tippy) {
	    activeElement.blur();
	  }
	}
	/**
	 * Adds the needed global event listeners
	 */

	function bindGlobalEventListeners() {
	  document.addEventListener('touchstart', onDocumentTouch, PASSIVE);
	  window.addEventListener('blur', onWindowBlur);
	}

	var keys$3 = Object.keys(defaultProps);
	/**
	 * Returns an object of optional props from data-tippy-* attributes
	 */

	function getDataAttributeOptions(reference) {
	  return keys$3.reduce(function (acc, key) {
	    var valueAsString = (reference.getAttribute("data-tippy-".concat(key)) || '').trim();

	    if (!valueAsString) {
	      return acc;
	    }

	    if (key === 'content') {
	      acc[key] = valueAsString;
	    } else {
	      try {
	        acc[key] = JSON.parse(valueAsString);
	      } catch (e) {
	        acc[key] = valueAsString;
	      }
	    }

	    return acc;
	  }, {});
	}
	/**
	 * Polyfills the virtual reference (plain object) with Element.prototype props
	 * Mutating because DOM elements are mutated, adds `_tippy` property
	 */

	function polyfillElementPrototypeProperties(virtualReference) {
	  var polyfills = {
	    isVirtual: true,
	    attributes: virtualReference.attributes || {},
	    contains: function contains() {},
	    setAttribute: function setAttribute(key, value) {
	      virtualReference.attributes[key] = value;
	    },
	    getAttribute: function getAttribute(key) {
	      return virtualReference.attributes[key];
	    },
	    removeAttribute: function removeAttribute(key) {
	      delete virtualReference.attributes[key];
	    },
	    hasAttribute: function hasAttribute(key) {
	      return key in virtualReference.attributes;
	    },
	    addEventListener: function addEventListener() {},
	    removeEventListener: function removeEventListener() {},
	    classList: {
	      classNames: {},
	      add: function add(key) {
	        virtualReference.classList.classNames[key] = true;
	      },
	      remove: function remove(key) {
	        delete virtualReference.classList.classNames[key];
	      },
	      contains: function contains(key) {
	        return key in virtualReference.classList.classNames;
	      }
	    }
	  };

	  for (var key in polyfills) {
	    virtualReference[key] = polyfills[key];
	  }
	}

	/**
	 * Determines if a value is a "bare" virtual element (before mutations done
	 * by `polyfillElementPrototypeProperties()`). JSDOM elements show up as
	 * [object Object], we can check if the value is "element-like" if it has
	 * `addEventListener`
	 */

	function isBareVirtualElement(value) {
	  return {}.toString.call(value) === '[object Object]' && !value.addEventListener;
	}
	/**
	 * Determines if the value is a reference element
	 */

	function isReferenceElement(value) {
	  return !!value._tippy && !matches$1.call(value, POPPER_SELECTOR);
	}
	/**
	 * Safe .hasOwnProperty check, for prototype-less objects
	 */

	function hasOwnProperty$4(obj, key) {
	  return {}.hasOwnProperty.call(obj, key);
	}
	/**
	 * Returns an array of elements based on the value
	 */

	function getArrayOfElements(value) {
	  if (isSingular(value)) {
	    // TODO: VirtualReference is not compatible to type Element
	    return [value];
	  }

	  if (value instanceof NodeList) {
	    return arrayFrom(value);
	  }

	  if (Array.isArray(value)) {
	    return value;
	  }

	  try {
	    return arrayFrom(document.querySelectorAll(value));
	  } catch (e) {
	    return [];
	  }
	}
	/**
	 * Returns a value at a given index depending on if it's an array or number
	 */

	function getValue(value, index, defaultValue) {
	  if (Array.isArray(value)) {
	    var v = value[index];
	    return v == null ? defaultValue : v;
	  }

	  return value;
	}
	/**
	 * Debounce utility. To avoid bloating bundle size, we're only passing 1
	 * argument here, a more generic function would pass all arguments. Only
	 * `onMouseMove` uses this which takes the event object for now.
	 */

	function debounce$1$1(fn, ms) {
	  // Avoid wrapping in `setTimeout` if ms is 0 anyway
	  if (ms === 0) {
	    return fn;
	  }

	  var timeout;
	  return function (arg) {
	    clearTimeout(timeout);
	    timeout = setTimeout(function () {
	      fn(arg);
	    }, ms);
	  };
	}
	/**
	 * Prevents errors from being thrown while accessing nested modifier objects
	 * in `popperOptions`
	 */

	function getModifier(obj, key) {
	  return obj && obj.modifiers && obj.modifiers[key];
	}
	/**
	 * Determines if an array or string includes a value
	 */

	function includes$1(a, b) {
	  return a.indexOf(b) > -1;
	}
	/**
	 * Determines if the value is a real element
	 */

	function isRealElement(value) {
	  return value instanceof Element;
	}
	/**
	 * Determines if the value is singular-like
	 */

	function isSingular(value) {
	  return !!(value && hasOwnProperty$4(value, 'isVirtual')) || isRealElement(value);
	}
	/**
	 * Firefox extensions don't allow setting .innerHTML directly, this will trick it
	 */

	function innerHTML() {
	  return 'innerHTML';
	}
	/**
	 * Evaluates a function if one, or returns the value
	 */

	function invokeWithArgsOrReturn(value, args) {
	  return typeof value === 'function' ? value.apply(null, args) : value;
	}
	/**
	 * Sets a popperInstance `flip` modifier's enabled state
	 */

	function setFlipModifierEnabled(modifiers, value) {
	  modifiers.filter(function (m) {
	    return m.name === 'flip';
	  })[0].enabled = value;
	}
	/**
	 * Determines if an element can receive focus
	 * Always returns true for virtual objects
	 */

	function canReceiveFocus(element) {
	  return isRealElement(element) ? matches$1.call(element, 'a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]') && !element.hasAttribute('disabled') : true;
	}
	/**
	 * Returns a new `div` element
	 */

	function div() {
	  return document.createElement('div');
	}
	/**
	 * Applies a transition duration to a list of elements
	 */

	function setTransitionDuration(els, value) {
	  els.forEach(function (el) {
	    if (el) {
	      el.style.transitionDuration = "".concat(value, "ms");
	    }
	  });
	}
	/**
	 * Sets the visibility state to elements so they can begin to transition
	 */

	function setVisibilityState(els, state) {
	  els.forEach(function (el) {
	    if (el) {
	      el.setAttribute('data-state', state);
	    }
	  });
	}
	/**
	 * Evaluates the props object by merging data attributes and
	 * disabling conflicting options where necessary
	 */

	function evaluateProps(reference, props) {
	  var out = _extends$1$1({}, props, {
	    content: invokeWithArgsOrReturn(props.content, [reference])
	  }, props.ignoreAttributes ? {} : getDataAttributeOptions(reference));

	  if (out.arrow || isUCBrowser) {
	    out.animateFill = false;
	  }

	  return out;
	}
	/**
	 * Validates an object of options with the valid default props object
	 */

	function validateOptions(options, defaultProps) {
	  Object.keys(options).forEach(function (option) {
	    if (!hasOwnProperty$4(defaultProps, option)) {
	      throw new Error("[tippy]: `".concat(option, "` is not a valid option"));
	    }
	  });
	}

	/**
	 * Sets the innerHTML of an element
	 */

	function setInnerHTML(element, html) {
	  element[innerHTML()] = isRealElement(html) ? html[innerHTML()] : html;
	}
	/**
	 * Sets the content of a tooltip
	 */

	function setContent(contentEl, props) {
	  if (isRealElement(props.content)) {
	    setInnerHTML(contentEl, '');
	    contentEl.appendChild(props.content);
	  } else if (typeof props.content !== 'function') {
	    var key = props.allowHTML ? 'innerHTML' : 'textContent';
	    contentEl[key] = props.content;
	  }
	}
	/**
	 * Returns the child elements of a popper element
	 */

	function getChildren(popper) {
	  return {
	    tooltip: popper.querySelector(TOOLTIP_SELECTOR),
	    backdrop: popper.querySelector(BACKDROP_SELECTOR),
	    content: popper.querySelector(CONTENT_SELECTOR),
	    arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(ROUND_ARROW_SELECTOR)
	  };
	}
	/**
	 * Adds `data-inertia` attribute
	 */

	function addInertia(tooltip) {
	  tooltip.setAttribute('data-inertia', '');
	}
	/**
	 * Removes `data-inertia` attribute
	 */

	function removeInertia(tooltip) {
	  tooltip.removeAttribute('data-inertia');
	}
	/**
	 * Creates an arrow element and returns it
	 */

	function createArrowElement(arrowType) {
	  var arrow = div();

	  if (arrowType === 'round') {
	    arrow.className = ROUND_ARROW_CLASS;
	    setInnerHTML(arrow, '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>');
	  } else {
	    arrow.className = ARROW_CLASS;
	  }

	  return arrow;
	}
	/**
	 * Creates a backdrop element and returns it
	 */

	function createBackdropElement() {
	  var backdrop = div();
	  backdrop.className = BACKDROP_CLASS;
	  backdrop.setAttribute('data-state', 'hidden');
	  return backdrop;
	}
	/**
	 * Adds interactive-related attributes
	 */

	function addInteractive(popper, tooltip) {
	  popper.setAttribute('tabindex', '-1');
	  tooltip.setAttribute('data-interactive', '');
	}
	/**
	 * Removes interactive-related attributes
	 */

	function removeInteractive(popper, tooltip) {
	  popper.removeAttribute('tabindex');
	  tooltip.removeAttribute('data-interactive');
	}
	/**
	 * Add/remove transitionend listener from tooltip
	 */

	function updateTransitionEndListener(tooltip, action, listener) {
	  // UC Browser hasn't adopted the `transitionend` event despite supporting
	  // unprefixed transitions...
	  var eventName = isUCBrowser && document.body.style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
	  tooltip[action + 'EventListener'](eventName, listener);
	}
	/**
	 * Returns the popper's placement, ignoring shifting (top-start, etc)
	 */

	function getBasicPlacement(popper) {
	  var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
	  return fullPlacement ? fullPlacement.split('-')[0] : '';
	}
	/**
	 * Triggers reflow
	 */

	function reflow$1(popper) {
	  void popper.offsetHeight;
	}
	/**
	 * Adds/removes theme from tooltip's classList
	 */

	function updateTheme(tooltip, action, theme) {
	  theme.split(' ').forEach(function (themeName) {
	    tooltip.classList[action](themeName + '-theme');
	  });
	}
	/**
	 * Constructs the popper element and returns it
	 */

	function createPopperElement(id, props) {
	  var popper = div();
	  popper.className = POPPER_CLASS;
	  popper.id = "tippy-".concat(id);
	  popper.style.zIndex = '' + props.zIndex;
	  popper.style.position = 'absolute';
	  popper.style.top = '0';
	  popper.style.left = '0';

	  if (props.role) {
	    popper.setAttribute('role', props.role);
	  }

	  var tooltip = div();
	  tooltip.className = TOOLTIP_CLASS;
	  tooltip.style.maxWidth = props.maxWidth + (typeof props.maxWidth === 'number' ? 'px' : '');
	  tooltip.setAttribute('data-size', props.size);
	  tooltip.setAttribute('data-animation', props.animation);
	  tooltip.setAttribute('data-state', 'hidden');
	  updateTheme(tooltip, 'add', props.theme);
	  var content = div();
	  content.className = CONTENT_CLASS;
	  content.setAttribute('data-state', 'hidden');

	  if (props.interactive) {
	    addInteractive(popper, tooltip);
	  }

	  if (props.arrow) {
	    tooltip.appendChild(createArrowElement(props.arrowType));
	  }

	  if (props.animateFill) {
	    tooltip.appendChild(createBackdropElement());
	    tooltip.setAttribute('data-animatefill', '');
	  }

	  if (props.inertia) {
	    addInertia(tooltip);
	  }

	  setContent(content, props);
	  tooltip.appendChild(content);
	  popper.appendChild(tooltip);
	  return popper;
	}
	/**
	 * Updates the popper element based on the new props
	 */

	function updatePopperElement(popper, prevProps, nextProps) {
	  var _getChildren = getChildren(popper),
	      tooltip = _getChildren.tooltip,
	      content = _getChildren.content,
	      backdrop = _getChildren.backdrop,
	      arrow = _getChildren.arrow;

	  popper.style.zIndex = '' + nextProps.zIndex;
	  tooltip.setAttribute('data-size', nextProps.size);
	  tooltip.setAttribute('data-animation', nextProps.animation);
	  tooltip.style.maxWidth = nextProps.maxWidth + (typeof nextProps.maxWidth === 'number' ? 'px' : '');

	  if (nextProps.role) {
	    popper.setAttribute('role', nextProps.role);
	  } else {
	    popper.removeAttribute('role');
	  }

	  if (prevProps.content !== nextProps.content) {
	    setContent(content, nextProps);
	  } // animateFill


	  if (!prevProps.animateFill && nextProps.animateFill) {
	    tooltip.appendChild(createBackdropElement());
	    tooltip.setAttribute('data-animatefill', '');
	  } else if (prevProps.animateFill && !nextProps.animateFill) {
	    tooltip.removeChild(backdrop);
	    tooltip.removeAttribute('data-animatefill');
	  } // arrow


	  if (!prevProps.arrow && nextProps.arrow) {
	    tooltip.appendChild(createArrowElement(nextProps.arrowType));
	  } else if (prevProps.arrow && !nextProps.arrow) {
	    tooltip.removeChild(arrow);
	  } // arrowType


	  if (prevProps.arrow && nextProps.arrow && prevProps.arrowType !== nextProps.arrowType) {
	    tooltip.replaceChild(createArrowElement(nextProps.arrowType), arrow);
	  } // interactive


	  if (!prevProps.interactive && nextProps.interactive) {
	    addInteractive(popper, tooltip);
	  } else if (prevProps.interactive && !nextProps.interactive) {
	    removeInteractive(popper, tooltip);
	  } // inertia


	  if (!prevProps.inertia && nextProps.inertia) {
	    addInertia(tooltip);
	  } else if (prevProps.inertia && !nextProps.inertia) {
	    removeInertia(tooltip);
	  } // theme


	  if (prevProps.theme !== nextProps.theme) {
	    updateTheme(tooltip, 'remove', prevProps.theme);
	    updateTheme(tooltip, 'add', nextProps.theme);
	  }
	}
	/**
	 * Hides all visible poppers on the document
	 */

	function hideAll() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      excludedReferenceOrInstance = _ref.exclude,
	      duration = _ref.duration;

	  arrayFrom(document.querySelectorAll(POPPER_SELECTOR)).forEach(function (popper) {
	    var instance = popper._tippy;

	    if (instance) {
	      var isExcluded = false;

	      if (excludedReferenceOrInstance) {
	        isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : popper === excludedReferenceOrInstance.popper;
	      }

	      if (!isExcluded) {
	        instance.hide(duration);
	      }
	    }
	  });
	}
	/**
	 * Determines if the mouse cursor is outside of the popper's interactive border
	 * region
	 */

	function isCursorOutsideInteractiveBorder(popperPlacement, popperRect, event, props) {
	  if (!popperPlacement) {
	    return true;
	  }

	  var x = event.clientX,
	      y = event.clientY;
	  var interactiveBorder = props.interactiveBorder,
	      distance = props.distance;
	  var exceedsTop = popperRect.top - y > (popperPlacement === 'top' ? interactiveBorder + distance : interactiveBorder);
	  var exceedsBottom = y - popperRect.bottom > (popperPlacement === 'bottom' ? interactiveBorder + distance : interactiveBorder);
	  var exceedsLeft = popperRect.left - x > (popperPlacement === 'left' ? interactiveBorder + distance : interactiveBorder);
	  var exceedsRight = x - popperRect.right > (popperPlacement === 'right' ? interactiveBorder + distance : interactiveBorder);
	  return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
	}
	/**
	 * Returns the distance offset, taking into account the default offset due to
	 * the transform: translate() rule (10px) in CSS
	 */

	function getOffsetDistanceInPx(distance) {
	  return -(distance - 10) + 'px';
	}

	var idCounter = 1; // Workaround for IE11's lack of new MouseEvent constructor

	var mouseMoveListeners = [];
	/**
	 * Creates and returns a Tippy object. We're using a closure pattern instead of
	 * a class so that the exposed object API is clean without private members
	 * prefixed with `_`.
	 */

	function createTippy(reference, collectionProps) {
	  var props = evaluateProps(reference, collectionProps); // If the reference shouldn't have multiple tippys, return null early

	  if (!props.multiple && reference._tippy) {
	    return null;
	  }
	  /* ======================= 🔒 Private members 🔒 ======================= */


	  var lastTriggerEventType;
	  var lastMouseMoveEvent;
	  var showTimeoutId;
	  var hideTimeoutId;
	  var scheduleHideAnimationFrameId;
	  var isScheduledToShow = false;
	  var isBeingDestroyed = false;
	  var previousPlacement;
	  var wasVisibleDuringPreviousUpdate = false;
	  var hasMountCallbackRun = false;
	  var currentMountCallback;
	  var currentTransitionEndListener;
	  var listeners = [];
	  var currentComputedPadding;
	  var debouncedOnMouseMove = debounce$1$1(onMouseMove, props.interactiveDebounce);
	  /* ======================= 🔑 Public members 🔑 ======================= */

	  var id = idCounter++;
	  var popper = createPopperElement(id, props);
	  var popperChildren = getChildren(popper);
	  var popperInstance = null;
	  var state = {
	    // Is the instance currently enabled?
	    isEnabled: true,
	    // Is the tippy currently showing and not transitioning out?
	    isVisible: false,
	    // Has the instance been destroyed?
	    isDestroyed: false,
	    // Is the tippy currently mounted to the DOM?
	    isMounted: false,
	    // Has the tippy finished transitioning in?
	    isShown: false
	  };
	  var instance = {
	    // properties
	    id: id,
	    reference: reference,
	    popper: popper,
	    popperChildren: popperChildren,
	    popperInstance: popperInstance,
	    props: props,
	    state: state,
	    // methods
	    clearDelayTimeouts: clearDelayTimeouts,
	    set: set,
	    setContent: setContent,
	    show: show,
	    hide: hide,
	    enable: enable,
	    disable: disable,
	    destroy: destroy
	    /* ==================== Initial instance mutations =================== */

	  };
	  reference._tippy = instance;
	  popper._tippy = instance;
	  addTriggersToReference();

	  if (!props.lazy) {
	    createPopperInstance();
	  }

	  if (props.showOnInit) {
	    scheduleShow();
	  } // Ensure the event listeners target can receive focus


	  if (props.a11y && !props.target && !canReceiveFocus(getEventListenersTarget())) {
	    getEventListenersTarget().setAttribute('tabindex', '0');
	  } // Prevent a tippy with a delay from hiding if the cursor left then returned
	  // before it started hiding


	  popper.addEventListener('mouseenter', function (event) {
	    if (instance.props.interactive && instance.state.isVisible && lastTriggerEventType === 'mouseenter') {
	      // We don't want props.onTrigger() to be called here, since the `event`
	      // object is not related to the reference element
	      scheduleShow(event, true);
	    }
	  });
	  popper.addEventListener('mouseleave', function () {
	    if (instance.props.interactive && lastTriggerEventType === 'mouseenter') {
	      document.addEventListener('mousemove', debouncedOnMouseMove);
	    }
	  });
	  return instance;
	  /* ======================= 🔒 Private methods 🔒 ======================= */

	  /**
	   * Removes the follow cursor listener
	   */

	  function removeFollowCursorListener() {
	    document.removeEventListener('mousemove', positionVirtualReferenceNearCursor);
	  }
	  /**
	   * Cleans up interactive mouse listeners
	   */


	  function cleanupInteractiveMouseListeners() {
	    document.body.removeEventListener('mouseleave', scheduleHide);
	    document.removeEventListener('mousemove', debouncedOnMouseMove);
	    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
	      return listener !== debouncedOnMouseMove;
	    });
	  }
	  /**
	   * Returns correct target used for event listeners
	   */


	  function getEventListenersTarget() {
	    return instance.props.triggerTarget || reference;
	  }
	  /**
	   * Adds the document click event listener for the instance
	   */


	  function addDocumentClickListener() {
	    document.addEventListener('click', onDocumentClick, true);
	  }
	  /**
	   * Removes the document click event listener for the instance
	   */


	  function removeDocumentClickListener() {
	    document.removeEventListener('click', onDocumentClick, true);
	  }
	  /**
	   * Returns transitionable inner elements used in show/hide methods
	   */


	  function getTransitionableElements() {
	    return [instance.popperChildren.tooltip, instance.popperChildren.backdrop, instance.popperChildren.content];
	  }
	  /**
	   * Determines if the instance is in `followCursor` mode.
	   * NOTE: in v5, touch devices will use `initial` behavior no matter the value.
	   */


	  function getIsInLooseFollowCursorMode() {
	    var followCursor = instance.props.followCursor;
	    return followCursor && lastTriggerEventType !== 'focus' || isUsingTouch && followCursor === 'initial';
	  }
	  /**
	   * Updates the tooltip's position on each animation frame
	   */


	  function makeSticky() {
	    setTransitionDuration([popper], isIE$1$1 ? 0 : instance.props.updateDuration);
	    var prevRefRect = reference.getBoundingClientRect();

	    function updatePosition() {
	      var currentRefRect = reference.getBoundingClientRect(); // Only schedule an update if the reference rect has changed

	      if (prevRefRect.top !== currentRefRect.top || prevRefRect.right !== currentRefRect.right || prevRefRect.bottom !== currentRefRect.bottom || prevRefRect.left !== currentRefRect.left) {
	        instance.popperInstance.scheduleUpdate();
	      }

	      prevRefRect = currentRefRect;

	      if (instance.state.isMounted) {
	        requestAnimationFrame(updatePosition);
	      }
	    }

	    updatePosition();
	  }
	  /**
	   * Invokes a callback once the tooltip has fully transitioned out
	   */


	  function onTransitionedOut(duration, callback) {
	    onTransitionEnd(duration, function () {
	      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
	        callback();
	      }
	    });
	  }
	  /**
	   * Invokes a callback once the tooltip has fully transitioned in
	   */


	  function onTransitionedIn(duration, callback) {
	    onTransitionEnd(duration, callback);
	  }
	  /**
	   * Invokes a callback once the tooltip's CSS transition ends
	   */


	  function onTransitionEnd(duration, callback) {
	    var tooltip = instance.popperChildren.tooltip;
	    /**
	     * Listener added as the `transitionend` handler
	     */

	    function listener(event) {
	      if (event.target === tooltip) {
	        updateTransitionEndListener(tooltip, 'remove', listener);
	        callback();
	      }
	    } // Make callback synchronous if duration is 0
	    // `transitionend` won't fire otherwise


	    if (duration === 0) {
	      return callback();
	    }

	    updateTransitionEndListener(tooltip, 'remove', currentTransitionEndListener);
	    updateTransitionEndListener(tooltip, 'add', listener);
	    currentTransitionEndListener = listener;
	  }
	  /**
	   * Adds an event listener to the reference and stores it in `listeners`
	   */


	  function on(eventType, handler) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    getEventListenersTarget().addEventListener(eventType, handler, options);
	    listeners.push({
	      eventType: eventType,
	      handler: handler,
	      options: options
	    });
	  }
	  /**
	   * Adds event listeners to the reference based on the `trigger` prop
	   */


	  function addTriggersToReference() {
	    if (instance.props.touchHold && !instance.props.target) {
	      on('touchstart', onTrigger, PASSIVE);
	      on('touchend', onMouseLeave, PASSIVE);
	    }

	    instance.props.trigger.trim().split(' ').forEach(function (eventType) {
	      if (eventType === 'manual') {
	        return;
	      } // Non-delegates


	      if (!instance.props.target) {
	        on(eventType, onTrigger);

	        switch (eventType) {
	          case 'mouseenter':
	            on('mouseleave', onMouseLeave);
	            break;

	          case 'focus':
	            on(isIE$1$1 ? 'focusout' : 'blur', onBlur);
	            break;
	        }
	      } else {
	        // Delegates
	        switch (eventType) {
	          case 'mouseenter':
	            on('mouseover', onDelegateShow);
	            on('mouseout', onDelegateHide);
	            break;

	          case 'focus':
	            on('focusin', onDelegateShow);
	            on('focusout', onDelegateHide);
	            break;

	          case 'click':
	            on(eventType, onDelegateShow);
	            break;
	        }
	      }
	    });
	  }
	  /**
	   * Removes event listeners from the reference
	   */


	  function removeTriggersFromReference() {
	    listeners.forEach(function (_ref) {
	      var eventType = _ref.eventType,
	          handler = _ref.handler,
	          options = _ref.options;
	      getEventListenersTarget().removeEventListener(eventType, handler, options);
	    });
	    listeners = [];
	  }
	  /**
	   * Positions the virtual reference near the cursor
	   */


	  function positionVirtualReferenceNearCursor(event) {
	    var _lastMouseMoveEvent = lastMouseMoveEvent = event,
	        x = _lastMouseMoveEvent.clientX,
	        y = _lastMouseMoveEvent.clientY; // Gets set once popperInstance `onCreate` has been called


	    if (!currentComputedPadding) {
	      return;
	    } // If the instance is interactive, avoid updating the position unless it's
	    // over the reference element


	    var isCursorOverReference = closestCallback(event.target, function (el) {
	      return el === reference;
	    });
	    var rect = reference.getBoundingClientRect();
	    var followCursor = instance.props.followCursor;
	    var isHorizontal = followCursor === 'horizontal';
	    var isVertical = followCursor === 'vertical'; // The virtual reference needs some size to prevent itself from overflowing

	    var isVerticalPlacement = includes$1(['top', 'bottom'], getBasicPlacement(popper));
	    var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
	    var isVariation = fullPlacement ? !!fullPlacement.split('-')[1] : false;
	    var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;
	    var halfSize = size / 2;
	    var verticalIncrease = isVerticalPlacement ? 0 : isVariation ? size : halfSize;
	    var horizontalIncrease = isVerticalPlacement ? isVariation ? size : halfSize : 0;

	    if (isCursorOverReference || !instance.props.interactive) {
	      instance.popperInstance.reference = _extends$1$1({}, instance.popperInstance.reference, {
	        // This will exist in next Popper.js feature release to fix #532
	        // @ts-ignore
	        referenceNode: reference,
	        // These `client` values don't get used by Popper.js if they are 0
	        clientWidth: 0,
	        clientHeight: 0,
	        getBoundingClientRect: function getBoundingClientRect() {
	          return {
	            width: isVerticalPlacement ? size : 0,
	            height: isVerticalPlacement ? 0 : size,
	            top: (isHorizontal ? rect.top : y) - verticalIncrease,
	            bottom: (isHorizontal ? rect.bottom : y) + verticalIncrease,
	            left: (isVertical ? rect.left : x) - horizontalIncrease,
	            right: (isVertical ? rect.right : x) + horizontalIncrease
	          };
	        }
	      });
	      instance.popperInstance.update();
	    }

	    if (followCursor === 'initial' && instance.state.isVisible) {
	      removeFollowCursorListener();
	    }
	  }
	  /**
	   * Creates the tippy instance for a delegate when it's been triggered
	   */


	  function createDelegateChildTippy(event) {
	    if (event) {
	      var targetEl = closest$1(event.target, instance.props.target);

	      if (targetEl && !targetEl._tippy) {
	        createTippy(targetEl, _extends$1$1({}, instance.props, {
	          content: invokeWithArgsOrReturn(collectionProps.content, [targetEl]),
	          appendTo: collectionProps.appendTo,
	          target: '',
	          showOnInit: true
	        }));
	      }
	    }
	  }
	  /**
	   * Event listener invoked upon trigger
	   */


	  function onTrigger(event) {
	    if (!instance.state.isEnabled || isEventListenerStopped(event)) {
	      return;
	    }

	    if (!instance.state.isVisible) {
	      lastTriggerEventType = event.type;

	      if (event instanceof MouseEvent) {
	        lastMouseMoveEvent = event; // If scrolling, `mouseenter` events can be fired if the cursor lands
	        // over a new target, but `mousemove` events don't get fired. This
	        // causes interactive tooltips to get stuck open until the cursor is
	        // moved

	        mouseMoveListeners.forEach(function (listener) {
	          return listener(event);
	        });
	      }
	    } // Toggle show/hide when clicking click-triggered tooltips


	    if (event.type === 'click' && instance.props.hideOnClick !== false && instance.state.isVisible) {
	      scheduleHide();
	    } else {
	      scheduleShow(event);
	    }
	  }
	  /**
	   * Event listener used for interactive tooltips to detect when they should
	   * hide
	   */


	  function onMouseMove(event) {
	    var isCursorOverPopper = closest$1(event.target, POPPER_SELECTOR) === popper;
	    var isCursorOverReference = closestCallback(event.target, function (el) {
	      return el === reference;
	    });

	    if (isCursorOverPopper || isCursorOverReference) {
	      return;
	    }

	    if (isCursorOutsideInteractiveBorder(getBasicPlacement(popper), popper.getBoundingClientRect(), event, instance.props)) {
	      cleanupInteractiveMouseListeners();
	      scheduleHide();
	    }
	  }
	  /**
	   * Event listener invoked upon mouseleave
	   */


	  function onMouseLeave(event) {
	    if (isEventListenerStopped(event)) {
	      return;
	    }

	    if (instance.props.interactive) {
	      document.body.addEventListener('mouseleave', scheduleHide);
	      document.addEventListener('mousemove', debouncedOnMouseMove);
	      mouseMoveListeners.push(debouncedOnMouseMove);
	      return;
	    }

	    scheduleHide();
	  }
	  /**
	   * Event listener invoked upon blur
	   */


	  function onBlur(event) {
	    if (event.target !== getEventListenersTarget()) {
	      return;
	    }

	    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
	      return;
	    }

	    scheduleHide();
	  }
	  /**
	   * Event listener invoked when a child target is triggered
	   */


	  function onDelegateShow(event) {
	    if (closest$1(event.target, instance.props.target)) {
	      scheduleShow(event);
	    }
	  }
	  /**
	   * Event listener invoked when a child target should hide
	   */


	  function onDelegateHide(event) {
	    if (closest$1(event.target, instance.props.target)) {
	      scheduleHide();
	    }
	  }
	  /**
	   * Determines if an event listener should stop further execution due to the
	   * `touchHold` option
	   */


	  function isEventListenerStopped(event) {
	    var supportsTouch = 'ontouchstart' in window;
	    var isTouchEvent = includes$1(event.type, 'touch');
	    var touchHold = instance.props.touchHold;
	    return supportsTouch && isUsingTouch && touchHold && !isTouchEvent || isUsingTouch && !touchHold && isTouchEvent;
	  }
	  /**
	   * Runs the mount callback
	   */


	  function runMountCallback() {
	    if (!hasMountCallbackRun && currentMountCallback) {
	      hasMountCallbackRun = true;
	      reflow$1(popper);
	      currentMountCallback();
	    }
	  }
	  /**
	   * Creates the popper instance for the instance
	   */


	  function createPopperInstance() {
	    var popperOptions = instance.props.popperOptions;
	    var _instance$popperChild = instance.popperChildren,
	        tooltip = _instance$popperChild.tooltip,
	        arrow = _instance$popperChild.arrow;
	    var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow');

	    function applyMutations(data) {
	      if (instance.props.flip && !instance.props.flipOnUpdate) {
	        if (data.flipped) {
	          instance.popperInstance.options.placement = data.placement;
	        }

	        setFlipModifierEnabled(instance.popperInstance.modifiers, false);
	      } // Apply all of the popper's attributes to the tootip node as well.
	      // Allows users to avoid using the .tippy-popper selector for themes.


	      tooltip.setAttribute(PLACEMENT_ATTRIBUTE, data.placement);

	      if (data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE] !== false) {
	        tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE, '');
	      } else {
	        tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE);
	      } // Prevents a transition when changing placements (while tippy is visible)
	      // for scroll/resize updates


	      if (previousPlacement && previousPlacement !== data.placement && wasVisibleDuringPreviousUpdate) {
	        tooltip.style.transition = 'none';
	        requestAnimationFrame(function () {
	          tooltip.style.transition = '';
	        });
	      }

	      previousPlacement = data.placement;
	      wasVisibleDuringPreviousUpdate = instance.state.isVisible;
	      var basicPlacement = getBasicPlacement(popper);
	      var styles = tooltip.style; // Account for the `distance` offset

	      styles.top = styles.bottom = styles.left = styles.right = '';
	      styles[basicPlacement] = getOffsetDistanceInPx(instance.props.distance);
	      var padding = preventOverflowModifier && preventOverflowModifier.padding !== undefined ? preventOverflowModifier.padding : PADDING;
	      var isPaddingNumber = typeof padding === 'number';

	      var computedPadding = _extends$1$1({
	        top: isPaddingNumber ? padding : padding.top,
	        bottom: isPaddingNumber ? padding : padding.bottom,
	        left: isPaddingNumber ? padding : padding.left,
	        right: isPaddingNumber ? padding : padding.right
	      }, !isPaddingNumber && padding);

	      computedPadding[basicPlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basicPlacement] || 0) + instance.props.distance;
	      instance.popperInstance.modifiers.filter(function (m) {
	        return m.name === 'preventOverflow';
	      })[0].padding = computedPadding;
	      currentComputedPadding = computedPadding;
	    }

	    var config = _extends$1$1({
	      eventsEnabled: false,
	      placement: instance.props.placement
	    }, popperOptions, {
	      modifiers: _extends$1$1({}, popperOptions ? popperOptions.modifiers : {}, {
	        preventOverflow: _extends$1$1({
	          boundariesElement: instance.props.boundary,
	          padding: PADDING
	        }, preventOverflowModifier),
	        arrow: _extends$1$1({
	          element: arrow,
	          enabled: !!arrow
	        }, getModifier(popperOptions, 'arrow')),
	        flip: _extends$1$1({
	          enabled: instance.props.flip,
	          // The tooltip is offset by 10px from the popper in CSS,
	          // we need to account for its distance
	          padding: instance.props.distance + PADDING,
	          behavior: instance.props.flipBehavior
	        }, getModifier(popperOptions, 'flip')),
	        offset: _extends$1$1({
	          offset: instance.props.offset
	        }, getModifier(popperOptions, 'offset'))
	      }),
	      onCreate: function onCreate(data) {
	        applyMutations(data);
	        runMountCallback();

	        if (popperOptions && popperOptions.onCreate) {
	          popperOptions.onCreate(data);
	        }
	      },
	      onUpdate: function onUpdate(data) {
	        applyMutations(data);
	        runMountCallback();

	        if (popperOptions && popperOptions.onUpdate) {
	          popperOptions.onUpdate(data);
	        }
	      }
	    });

	    instance.popperInstance = new Popper$1(reference, popper, config);
	  }
	  /**
	   * Mounts the tooltip to the DOM
	   */


	  function mount() {
	    hasMountCallbackRun = false;
	    var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();

	    if (instance.popperInstance) {
	      setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip);

	      if (!isInLooseFollowCursorMode) {
	        instance.popperInstance.reference = reference;
	        instance.popperInstance.enableEventListeners();
	      }

	      instance.popperInstance.scheduleUpdate();
	    } else {
	      createPopperInstance();

	      if (!isInLooseFollowCursorMode) {
	        instance.popperInstance.enableEventListeners();
	      }
	    }

	    var appendTo = instance.props.appendTo;
	    var parentNode = appendTo === 'parent' ? reference.parentNode : invokeWithArgsOrReturn(appendTo, [reference]);

	    if (!parentNode.contains(popper)) {
	      parentNode.appendChild(popper);
	      instance.props.onMount(instance);
	      instance.state.isMounted = true;
	    }
	  }
	  /**
	   * Setup before show() is invoked (delays, etc.)
	   */


	  function scheduleShow(event, shouldAvoidCallingOnTrigger) {
	    clearDelayTimeouts();

	    if (instance.state.isVisible) {
	      return;
	    } // Is a delegate, create an instance for the child target


	    if (instance.props.target) {
	      return createDelegateChildTippy(event);
	    }

	    isScheduledToShow = true;

	    if (event && !shouldAvoidCallingOnTrigger) {
	      instance.props.onTrigger(instance, event);
	    }

	    if (instance.props.wait) {
	      return instance.props.wait(instance, event);
	    } // If the tooltip has a delay, we need to be listening to the mousemove as
	    // soon as the trigger event is fired, so that it's in the correct position
	    // upon mount.
	    // Edge case: if the tooltip is still mounted, but then scheduleShow() is
	    // called, it causes a jump.


	    if (getIsInLooseFollowCursorMode() && !instance.state.isMounted) {
	      if (!instance.popperInstance) {
	        createPopperInstance();
	      }

	      document.addEventListener('mousemove', positionVirtualReferenceNearCursor);
	    }

	    addDocumentClickListener();
	    var delay = getValue(instance.props.delay, 0, defaultProps.delay);

	    if (delay) {
	      showTimeoutId = setTimeout(function () {
	        show();
	      }, delay);
	    } else {
	      show();
	    }
	  }
	  /**
	   * Setup before hide() is invoked (delays, etc.)
	   */


	  function scheduleHide() {
	    clearDelayTimeouts();

	    if (!instance.state.isVisible) {
	      removeFollowCursorListener();
	      removeDocumentClickListener();
	      return;
	    }

	    isScheduledToShow = false;
	    var delay = getValue(instance.props.delay, 1, defaultProps.delay);

	    if (delay) {
	      hideTimeoutId = setTimeout(function () {
	        if (instance.state.isVisible) {
	          hide();
	        }
	      }, delay);
	    } else {
	      // Fixes a `transitionend` problem when it fires 1 frame too
	      // late sometimes, we don't want hide() to be called.
	      scheduleHideAnimationFrameId = requestAnimationFrame(function () {
	        hide();
	      });
	    }
	  }
	  /**
	   * Listener to handle clicks on the document to determine if the
	   * instance should hide
	   */


	  function onDocumentClick(event) {
	    // Clicked on interactive popper
	    if (instance.props.interactive && popper.contains(event.target)) {
	      return;
	    } // Clicked on the event listeners target


	    if (getEventListenersTarget().contains(event.target)) {
	      if (isUsingTouch) {
	        return;
	      }

	      if (instance.state.isVisible && includes$1(instance.props.trigger, 'click')) {
	        return;
	      }
	    }

	    if (instance.props.hideOnClick === true) {
	      clearDelayTimeouts();
	      hide();
	    }
	  }
	  /* ======================= 🔑 Public methods 🔑 ======================= */

	  /**
	   * Enables the instance to allow it to show or hide
	   */


	  function enable() {
	    instance.state.isEnabled = true;
	  }
	  /**
	   * Disables the instance to disallow it to show or hide
	   */


	  function disable() {
	    instance.state.isEnabled = false;
	  }
	  /**
	   * Clears pending timeouts related to the `delay` prop if any
	   */


	  function clearDelayTimeouts() {
	    clearTimeout(showTimeoutId);
	    clearTimeout(hideTimeoutId);
	    cancelAnimationFrame(scheduleHideAnimationFrameId);
	  }
	  /**
	   * Sets new props for the instance and redraws the tooltip
	   */


	  function set(options) {
	    // Backwards-compatible after TypeScript change
	    options = options || {};
	    validateOptions(options, defaultProps);
	    removeTriggersFromReference();
	    var prevProps = instance.props;
	    var nextProps = evaluateProps(reference, _extends$1$1({}, instance.props, {}, options, {
	      ignoreAttributes: true
	    }));
	    nextProps.ignoreAttributes = hasOwnProperty$4(options, 'ignoreAttributes') ? options.ignoreAttributes || false : prevProps.ignoreAttributes;
	    instance.props = nextProps;
	    addTriggersToReference();
	    cleanupInteractiveMouseListeners();
	    debouncedOnMouseMove = debounce$1$1(onMouseMove, nextProps.interactiveDebounce);
	    updatePopperElement(popper, prevProps, nextProps);
	    instance.popperChildren = getChildren(popper);

	    if (instance.popperInstance) {
	      if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
	        return hasOwnProperty$4(options, prop) && options[prop] !== prevProps[prop];
	      })) {
	        instance.popperInstance.destroy();
	        createPopperInstance();

	        if (instance.state.isVisible) {
	          instance.popperInstance.enableEventListeners();
	        }

	        if (instance.props.followCursor && lastMouseMoveEvent) {
	          positionVirtualReferenceNearCursor(lastMouseMoveEvent);
	        }
	      } else {
	        instance.popperInstance.update();
	      }
	    }
	  }
	  /**
	   * Shortcut for .set({ content: newContent })
	   */


	  function setContent(content) {
	    set({
	      content: content
	    });
	  }
	  /**
	   * Shows the tooltip
	   */


	  function show() {
	    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 0, defaultProps.duration[1]);

	    if (instance.state.isDestroyed || !instance.state.isEnabled || isUsingTouch && !instance.props.touch) {
	      return;
	    } // Standardize `disabled` behavior across browsers.
	    // Firefox allows events on disabled elements, but Chrome doesn't.
	    // Using a wrapper element (i.e. <span>) is recommended.


	    if (getEventListenersTarget().hasAttribute('disabled')) {
	      return;
	    }

	    if (instance.props.onShow(instance) === false) {
	      return;
	    }

	    addDocumentClickListener();
	    popper.style.visibility = 'visible';
	    instance.state.isVisible = true;

	    if (instance.props.interactive) {
	      getEventListenersTarget().classList.add(ACTIVE_CLASS);
	    } // Prevent a transition if the popper is at the opposite placement


	    var transitionableElements = getTransitionableElements();
	    setTransitionDuration(transitionableElements.concat(popper), 0);

	    currentMountCallback = function currentMountCallback() {
	      if (!instance.state.isVisible) {
	        return;
	      }

	      var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();

	      if (isInLooseFollowCursorMode && lastMouseMoveEvent) {
	        positionVirtualReferenceNearCursor(lastMouseMoveEvent);
	      } else if (!isInLooseFollowCursorMode) {
	        // Double update will apply correct mutations
	        instance.popperInstance.update();
	      }

	      if (instance.popperChildren.backdrop) {
	        instance.popperChildren.content.style.transitionDelay = Math.round(duration / 12) + 'ms';
	      }

	      if (instance.props.sticky) {
	        makeSticky();
	      }

	      setTransitionDuration([popper], instance.props.updateDuration);
	      setTransitionDuration(transitionableElements, duration);
	      setVisibilityState(transitionableElements, 'visible');
	      onTransitionedIn(duration, function () {
	        if (instance.props.aria) {
	          getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria), popper.id);
	        }

	        instance.props.onShown(instance);
	        instance.state.isShown = true;
	      });
	    };

	    mount();
	  }
	  /**
	   * Hides the tooltip
	   */


	  function hide() {
	    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 1, defaultProps.duration[1]);

	    if (instance.state.isDestroyed || !instance.state.isEnabled && !isBeingDestroyed) {
	      return;
	    }

	    if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
	      return;
	    }

	    removeDocumentClickListener();
	    popper.style.visibility = 'hidden';
	    instance.state.isVisible = false;
	    instance.state.isShown = false;
	    wasVisibleDuringPreviousUpdate = false;

	    if (instance.props.interactive) {
	      getEventListenersTarget().classList.remove(ACTIVE_CLASS);
	    }

	    var transitionableElements = getTransitionableElements();
	    setTransitionDuration(transitionableElements, duration);
	    setVisibilityState(transitionableElements, 'hidden');
	    onTransitionedOut(duration, function () {
	      if (!isScheduledToShow) {
	        removeFollowCursorListener();
	      }

	      if (instance.props.aria) {
	        getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria));
	      }

	      instance.popperInstance.disableEventListeners();
	      instance.popperInstance.options.placement = instance.props.placement;
	      popper.parentNode.removeChild(popper);
	      instance.props.onHidden(instance);
	      instance.state.isMounted = false;
	    });
	  }
	  /**
	   * Destroys the tooltip
	   */


	  function destroy(destroyTargetInstances) {
	    if (instance.state.isDestroyed) {
	      return;
	    }

	    isBeingDestroyed = true; // If the popper is currently mounted to the DOM, we want to ensure it gets
	    // hidden and unmounted instantly upon destruction

	    if (instance.state.isMounted) {
	      hide(0);
	    }

	    removeTriggersFromReference();
	    delete reference._tippy;
	    var target = instance.props.target;

	    if (target && destroyTargetInstances && isRealElement(reference)) {
	      arrayFrom(reference.querySelectorAll(target)).forEach(function (child) {
	        if (child._tippy) {
	          child._tippy.destroy();
	        }
	      });
	    }

	    if (instance.popperInstance) {
	      instance.popperInstance.destroy();
	    }

	    isBeingDestroyed = false;
	    instance.state.isDestroyed = true;
	  }
	}

	/**
	 * Groups an array of instances by taking control of their props during
	 * certain lifecycles.
	 */
	function group(instances) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$delay = _ref.delay,
	      delay = _ref$delay === void 0 ? instances[0].props.delay : _ref$delay,
	      _ref$duration = _ref.duration,
	      duration = _ref$duration === void 0 ? 0 : _ref$duration;

	  var isAnyTippyOpen = false;
	  instances.forEach(function (instance) {
	    if (instance._originalProps) {
	      instance.set(instance._originalProps);
	    } else {
	      instance._originalProps = _extends$1$1({}, instance.props);
	    }
	  });

	  function setIsAnyTippyOpen(value) {
	    isAnyTippyOpen = value;
	    updateInstances();
	  }

	  function onShow(instance) {
	    instance._originalProps.onShow(instance);

	    instances.forEach(function (instance) {
	      instance.set({
	        duration: duration
	      });

	      if (instance.state.isVisible) {
	        instance.hide();
	      }
	    });
	    setIsAnyTippyOpen(true);
	  }

	  function onHide(instance) {
	    instance._originalProps.onHide(instance);

	    setIsAnyTippyOpen(false);
	  }

	  function onShown(instance) {
	    instance._originalProps.onShown(instance);

	    instance.set({
	      duration: instance._originalProps.duration
	    });
	  }

	  function updateInstances() {
	    instances.forEach(function (instance) {
	      instance.set({
	        onShow: onShow,
	        onShown: onShown,
	        onHide: onHide,
	        delay: isAnyTippyOpen ? [0, Array.isArray(delay) ? delay[1] : delay] : delay,
	        duration: isAnyTippyOpen ? duration : instance._originalProps.duration
	      });
	    });
	  }

	  updateInstances();
	}

	var globalEventListenersBound = false;
	/**
	 * Exported module
	 */

	function tippy(targets, options) {
	  validateOptions(options || {}, defaultProps);

	  if (!globalEventListenersBound) {
	    bindGlobalEventListeners();
	    globalEventListenersBound = true;
	  }

	  var props = _extends$1$1({}, defaultProps, {}, options); // If they are specifying a virtual positioning reference, we need to polyfill
	  // some native DOM props


	  if (isBareVirtualElement(targets)) {
	    polyfillElementPrototypeProperties(targets);
	  }

	  var instances = getArrayOfElements(targets).reduce(function (acc, reference) {
	    var instance = reference && createTippy(reference, props);

	    if (instance) {
	      acc.push(instance);
	    }

	    return acc;
	  }, []);
	  return isSingular(targets) ? instances[0] : instances;
	}
	/**
	 * Static props
	 */


	tippy.version = version;
	tippy.defaults = defaultProps;
	/**
	 * Static methods
	 */

	tippy.setDefaults = function (partialDefaults) {
	  Object.keys(partialDefaults).forEach(function (key) {
	    // @ts-ignore
	    defaultProps[key] = partialDefaults[key];
	  });
	};

	tippy.hideAll = hideAll;
	tippy.group = group;
	/**
	 * Auto-init tooltips for elements with a `data-tippy="..."` attribute
	 */

	function autoInit() {
	  arrayFrom(document.querySelectorAll('[data-tippy]')).forEach(function (el) {
	    var content = el.getAttribute('data-tippy');

	    if (content) {
	      tippy(el, {
	        content: content
	      });
	    }
	  });
	}

	if (isBrowser$1$1) {
	  setTimeout(autoInit);
	}

	/**
	 * Injects a string of CSS styles to a style node in <head>
	 */

	function injectCSS(css) {
	  if (isBrowser$1$1) {
	    var style = document.createElement('style');
	    style.type = 'text/css';
	    style.textContent = css;
	    style.setAttribute('data-tippy-stylesheet', '');
	    var head = document.head;
	    var firstStyleOrLinkTag = head.querySelector('style,link');

	    if (firstStyleOrLinkTag) {
	      head.insertBefore(style, firstStyleOrLinkTag);
	    } else {
	      head.appendChild(style);
	    }
	  }
	}

	injectCSS(css);

	var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule$1(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var humps = createCommonjsModule$1(function (module) {
	(function(global) {

	  var _processKeys = function(convert, obj, options) {
	    if(!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {
	      return obj;
	    }

	    var output,
	        i = 0,
	        l = 0;

	    if(_isArray(obj)) {
	      output = [];
	      for(l=obj.length; i<l; i++) {
	        output.push(_processKeys(convert, obj[i], options));
	      }
	    }
	    else {
	      output = {};
	      for(var key in obj) {
	        if(Object.prototype.hasOwnProperty.call(obj, key)) {
	          output[convert(key, options)] = _processKeys(convert, obj[key], options);
	        }
	      }
	    }
	    return output;
	  };

	  // String conversion methods

	  var separateWords = function(string, options) {
	    options = options || {};
	    var separator = options.separator || '_';
	    var split = options.split || /(?=[A-Z])/;

	    return string.split(split).join(separator);
	  };

	  var camelize = function(string) {
	    if (_isNumerical(string)) {
	      return string;
	    }
	    string = string.replace(/[\-_\s]+(.)?/g, function(match, chr) {
	      return chr ? chr.toUpperCase() : '';
	    });
	    // Ensure 1st char is always lowercase
	    return string.substr(0, 1).toLowerCase() + string.substr(1);
	  };

	  var pascalize = function(string) {
	    var camelized = camelize(string);
	    // Ensure 1st char is always uppercase
	    return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);
	  };

	  var decamelize = function(string, options) {
	    return separateWords(string, options).toLowerCase();
	  };

	  // Utilities
	  // Taken from Underscore.js

	  var toString = Object.prototype.toString;

	  var _isFunction = function(obj) {
	    return typeof(obj) === 'function';
	  };
	  var _isObject = function(obj) {
	    return obj === Object(obj);
	  };
	  var _isArray = function(obj) {
	    return toString.call(obj) == '[object Array]';
	  };
	  var _isDate = function(obj) {
	    return toString.call(obj) == '[object Date]';
	  };
	  var _isRegExp = function(obj) {
	    return toString.call(obj) == '[object RegExp]';
	  };
	  var _isBoolean = function(obj) {
	    return toString.call(obj) == '[object Boolean]';
	  };

	  // Performant way to determine if obj coerces to a number
	  var _isNumerical = function(obj) {
	    obj = obj - 0;
	    return obj === obj;
	  };

	  // Sets up function which handles processing keys
	  // allowing the convert function to be modified by a callback
	  var _processor = function(convert, options) {
	    var callback = options && 'process' in options ? options.process : options;

	    if(typeof(callback) !== 'function') {
	      return convert;
	    }

	    return function(string, options) {
	      return callback(string, convert, options);
	    }
	  };

	  var humps = {
	    camelize: camelize,
	    decamelize: decamelize,
	    pascalize: pascalize,
	    depascalize: decamelize,
	    camelizeKeys: function(object, options) {
	      return _processKeys(_processor(camelize, options), object);
	    },
	    decamelizeKeys: function(object, options) {
	      return _processKeys(_processor(decamelize, options), object, options);
	    },
	    pascalizeKeys: function(object, options) {
	      return _processKeys(_processor(pascalize, options), object);
	    },
	    depascalizeKeys: function () {
	      return this.decamelizeKeys.apply(this, arguments);
	    }
	  };

	  if ( module.exports) {
	    module.exports = humps;
	  } else {
	    global.humps = humps;
	  }

	})(commonjsGlobal$1);
	});

	function _defineProperty$1e(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function ownKeys$W(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    if (enumerableOnly) { symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    }); }
	    keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2(target) {
	  var arguments$1 = arguments;

	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments$1[i] != null ? arguments$1[i] : {};

	    if (i % 2) {
	      ownKeys$W(Object(source), true).forEach(function (key) {
	        _defineProperty$1e(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	    } else {
	      ownKeys$W(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	  }

	  return target;
	}

	var booleanProps = {
	  a11y: true,
	  allowHTML: true,
	  animateFill: true,
	  arrow: false,
	  flip: true,
	  flipOnUpdate: false,
	  followCursor: false,
	  hideOnClick: true,
	  ignoreAttributes: false,
	  inertia: false,
	  interactive: false,
	  lazy: true,
	  multiple: false,
	  showOnInit: false,
	  sticky: false,
	  touch: true,
	  touchHold: false
	};
	var defaultProps$1 = _objectSpread2({
	  animation: 'shift-away',
	  appendTo: function appendTo() {
	    return document.body;
	  },
	  aria: 'describedby',
	  arrowType: 'sharp',
	  boundary: 'scrollParent',
	  content: '',
	  delay: 0,
	  distance: 10,
	  duration: [325, 275],
	  flipBehavior: 'flip',
	  interactiveBorder: 2,
	  interactiveDebounce: 0,
	  maxWidth: 350,
	  offset: 0,
	  onHidden: function onHidden() {},
	  onHide: function onHide() {},
	  onMount: function onMount() {},
	  onShow: function onShow() {},
	  onShown: function onShown() {},
	  placement: 'top',
	  popperOptions: {},
	  role: 'tooltip',
	  size: 'regular',
	  target: '',
	  theme: 'dark',
	  trigger: 'mouseenter focus',
	  updateDuration: 0,
	  wait: null,
	  zIndex: 9999
	}, booleanProps);

	//
	var script = {
	  props: ["to", "toSelector", "toElement", "content", "enabled", "visible", "triggerTarget"],
	  data: function data() {
	    return {
	      tip: null,
	      options: {}
	    };
	  },
	  mounted: function mounted() {
	    var elm = this.toElement;

	    if (elm == null) {
	      if (this.to) {
	        elm = document.querySelector("[name='".concat(this.to, "']"));
	      } else if (this.toSelector) {
	        elm = document.querySelector(this.toSelector);
	      } else {
	        elm = this.$refs.trigger;
	      }
	    }

	    this.tip = tippy(elm, this.getOptions());
	    this.$emit("onCreate", this.tip);
	    this.$emit("init", this.tip);

	    if (this.enabled === false) {
	      this.tip.disable();
	    }

	    if (this.isManualTrigger && this.visible === true) {
	      this.tip.show();
	    }
	  },
	  watch: {
	    content: function content() {
	      if (this.tip) {
	        this.tip.set(this.getOptions());
	      }
	    },
	    enabled: function enabled(val) {
	      if (!this.tip) { return; }

	      if (val) {
	        this.tip.enable();
	      } else {
	        this.tip.hide();
	        this.tip.disable();
	      }
	    },
	    visible: function visible(val) {
	      if (!this.tip) { return; }

	      if (val) {
	        this.tip.show();
	      } else {
	        this.tip.hide();
	      }
	    }
	  },
	  updated: function updated() {
	    if (this.tip && !this.content) {
	      this.tip.set(this.getOptions());
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (!this.tip) { return; }
	    this.tip.destroy();
	  },
	  computed: {
	    isManualTrigger: function isManualTrigger() {
	      return this.options.trigger === "manual";
	    }
	  },
	  methods: {
	    tippy: function tippy() {
	      return this.tip;
	    },
	    filterOptions: function filterOptions() {
	      var getValue = function getValue(key, value) {
	        if (booleanProps.hasOwnProperty(key)) {
	          if (value === "") { return true; }
	          if (value === "false") { return false; }
	          if (value === "true") { return true; }
	        }

	        return value;
	      };

	      for (var _i = 0, _Object$keys = Object.keys(this.options); _i < _Object$keys.length; _i++) {
	        var key = _Object$keys[_i];

	        if (!defaultProps$1.hasOwnProperty(key)) {
	          // We're replacing this.options anyway, we don't have to worry about modifying the object
	          delete this.options[key];
	        }

	        this.options[key] = getValue(key, this.options[key]);
	      }

	      return this.options;
	    },
	    getOptions: function getOptions() {
	      var _this = this;

	      this.options = humps.camelizeKeys(this.$attrs);
	      this.filterOptions();

	      if (!this.options.onShow && this.$listeners && this.$listeners["show"]) {
	        this.options.onShow = function () {
	          var _this$$listeners$show;

	          return (_this$$listeners$show = _this.$listeners["show"]).fns.apply(_this$$listeners$show, arguments);
	        };
	      }

	      if (!this.options.onShown) {
	        this.options.onShown = function () {
	          var arguments$1 = arguments;

	          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments$1[_key];
	          }

	          _this.$emit.apply(_this, ["shown"].concat(args));
	        };
	      }

	      if (!this.options.onHidden) {
	        this.options.onHidden = function () {
	          var arguments$1 = arguments;

	          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	            args[_key2] = arguments$1[_key2];
	          }

	          _this.$emit.apply(_this, ["hidden"].concat(args));
	        };
	      }

	      if (!this.options.onHide && this.$listeners && this.$listeners["hide"]) {
	        this.options.onHide = function () {
	          var _this$$listeners$hide;

	          return (_this$$listeners$hide = _this.$listeners["hide"]).fns.apply(_this$$listeners$hide, arguments);
	        };
	      }

	      if (!this.options.onMount) {
	        this.options.onMount = function () {
	          var arguments$1 = arguments;

	          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	            args[_key3] = arguments$1[_key3];
	          }

	          _this.$emit.apply(_this, ["mount"].concat(args));
	        };
	      }

	      if (!this.options.hasOwnProperty("content")) {
	        this.options.content = this.content ? this.content : this.$refs.content;
	      }

	      this.options.triggerTarget = this.triggerTarget;
	      return this.options;
	    }
	  }
	};

	function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	    if (typeof shadowMode !== 'boolean') {
	        createInjectorSSR = createInjector;
	        createInjector = shadowMode;
	        shadowMode = false;
	    }
	    // Vue.extend constructor export interop.
	    var options = typeof script === 'function' ? script.options : script;
	    // render functions
	    if (template && template.render) {
	        options.render = template.render;
	        options.staticRenderFns = template.staticRenderFns;
	        options._compiled = true;
	        // functional template
	        if (isFunctionalTemplate) {
	            options.functional = true;
	        }
	    }
	    // scopedId
	    if (scopeId) {
	        options._scopeId = scopeId;
	    }
	    var hook;
	    if (moduleIdentifier) {
	        // server build
	        hook = function (context) {
	            // 2.3 injection
	            context =
	                context || // cached call
	                    (this.$vnode && this.$vnode.ssrContext) || // stateful
	                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
	            // 2.2 with runInNewContext: true
	            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	                context = __VUE_SSR_CONTEXT__;
	            }
	            // inject component styles
	            if (style) {
	                style.call(this, createInjectorSSR(context));
	            }
	            // register component module identifier for async chunk inference
	            if (context && context._registeredComponents) {
	                context._registeredComponents.add(moduleIdentifier);
	            }
	        };
	        // used by ssr in case component is cached and beforeCreate
	        // never gets called
	        options._ssrRegister = hook;
	    }
	    else if (style) {
	        hook = shadowMode
	            ? function (context) {
	                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
	            }
	            : function (context) {
	                style.call(this, createInjector(context));
	            };
	    }
	    if (hook) {
	        if (options.functional) {
	            // register for functional component in vue file
	            var originalRender = options.render;
	            options.render = function renderWithStyleInjection(h, context) {
	                hook.call(context);
	                return originalRender(h, context);
	            };
	        }
	        else {
	            // inject component registration as beforeCreate hook
	            var existing = options.beforeCreate;
	            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	    }
	    return script;
	}

	var isOldIE = typeof navigator !== 'undefined' &&
	    /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	/* script */
	var __vue_script__ = script;
	/* template */

	var __vue_render__ = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c("span", [_c("span", {
	    ref: "trigger"
	  }, [_vm._t("trigger")], 2), _vm._v(" "), _c("span", {
	    ref: "content"
	  }, [_vm._t("default")], 2)]);
	};

	var __vue_staticRenderFns__ = [];
	__vue_render__._withStripped = true;
	/* style */

	var __vue_inject_styles__ = undefined;
	/* scoped */

	var __vue_scope_id__ = undefined;
	/* module identifier */

	var __vue_module_identifier__ = undefined;
	/* functional template */

	var __vue_is_functional_template__ = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__ = normalizeComponent({
	  render: __vue_render__,
	  staticRenderFns: __vue_staticRenderFns__
	}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

	var tippyDirective = 'tippy';
	var plugin$3 = {
	  install: function install(Vue) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    tippyDirective = options.directive || 'tippy';
	    tippy.setDefaults(options || {});

	    function createTippy(el, binding, vnode) {
	      var handlers = vnode.data && vnode.data.on || vnode.componentOptions && vnode.componentOptions.listeners;
	      var opts = binding.value || {};
	      opts = Object.assign({}, options, opts);

	      if (handlers && handlers['show']) {
	        opts.onShow = function () {
	          var _handlers$show;

	          return (_handlers$show = handlers['show']).fns.apply(_handlers$show, arguments);
	        };
	      }

	      if (handlers && handlers['shown']) {
	        opts.onShown = function () {
	          var _handlers$shown;

	          (_handlers$shown = handlers['shown']).fns.apply(_handlers$shown, arguments);
	        };
	      }

	      if (handlers && handlers['hidden']) {
	        opts.onHidden = function () {
	          var _handlers$hidden;

	          (_handlers$hidden = handlers['hidden']).fns.apply(_handlers$hidden, arguments);
	        };
	      }

	      if (handlers && handlers['hide']) {
	        opts.onHide = function () {
	          var _handlers$hide;

	          return (_handlers$hide = handlers['hide']).fns.apply(_handlers$hide, arguments);
	        };
	      }

	      if (handlers && handlers['mount']) {
	        opts.onMount = function () {
	          var _handlers$mount;

	          (_handlers$mount = handlers['mount']).fns.apply(_handlers$mount, arguments);
	        };
	      }

	      if (el.getAttribute('title') && !opts.content) {
	        opts.content = el.getAttribute('title');
	      }

	      if (el.getAttribute('content') && !opts.content) {
	        opts.content = el.getAttribute('content');
	      }

	      tippy(el, opts);

	      if (opts.showOnLoad) {
	        el._tippy.show();
	      }

	      Vue.nextTick(function () {
	        if (handlers && handlers['init']) {
	          handlers['init'].fns(el._tippy, el);
	        }
	      });
	    }

	    Vue.directive(tippyDirective, {
	      inserted: function inserted(el, binding, vnode) {
	        Vue.nextTick(function () {
	          createTippy(el, binding, vnode);
	        });
	      },
	      unbind: function unbind(el) {
	        el._tippy && el._tippy.destroy();
	      },
	      componentUpdated: function componentUpdated(el, binding, vnode) {
	        if (el._tippy) {
	          var opts = binding.value || {};

	          if (el.getAttribute('title') && !opts.content) {
	            opts.content = el.getAttribute('title');
	          }

	          if (el.getAttribute('content') && !opts.content) {
	            opts.content = el.getAttribute('content');
	          }

	          el._tippy.set(opts);
	        }
	      }
	    });
	  }
	};

	if (typeof window !== 'undefined' && window.Vue) {
	  window.Vue.use(plugin$3);
	  window.Vue.component('tippy', __vue_component__);
	}

	var noty = createCommonjsModule(function (module, exports) {
	/* 
	  @package NOTY - Dependency-free notification library 
	  @version version: 3.2.0-beta 
	  @contributors https://github.com/needim/noty/graphs/contributors 
	  @documentation Examples and Documentation - https://ned.im/noty 
	  @license Licensed under the MIT licenses: http://www.opensource.org/licenses/mit-license.php 
	*/

	(function webpackUniversalModuleDefinition(root, factory) {
		{ module.exports = factory(); }
	})(commonjsGlobal, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId]) {
	/******/ 			return installedModules[moduleId].exports;
	/******/ 		}
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			i: moduleId,
	/******/ 			l: false,
	/******/ 			exports: {}
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.l = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// identity function for calling harmony imports with the correct context
	/******/ 	__webpack_require__.i = function(value) { return value; };
	/******/
	/******/ 	// define getter function for harmony exports
	/******/ 	__webpack_require__.d = function(exports, name, getter) {
	/******/ 		if(!__webpack_require__.o(exports, name)) {
	/******/ 			Object.defineProperty(exports, name, {
	/******/ 				configurable: false,
	/******/ 				enumerable: true,
	/******/ 				get: getter
	/******/ 			});
	/******/ 		}
	/******/ 	};
	/******/
	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
	/******/ 	__webpack_require__.n = function(module) {
	/******/ 		var getter = module && module.__esModule ?
	/******/ 			function getDefault() { return module['default']; } :
	/******/ 			function getModuleExports() { return module; };
	/******/ 		__webpack_require__.d(getter, 'a', getter);
	/******/ 		return getter;
	/******/ 	};
	/******/
	/******/ 	// Object.prototype.hasOwnProperty.call
	/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(__webpack_require__.s = 6);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function(module, exports, __webpack_require__) {


	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.css = exports.deepExtend = exports.animationEndEvents = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.inArray = inArray;
	exports.stopPropagation = stopPropagation;
	exports.generateID = generateID;
	exports.outerHeight = outerHeight;
	exports.addListener = addListener;
	exports.hasClass = hasClass;
	exports.addClass = addClass;
	exports.removeClass = removeClass;
	exports.remove = remove;
	exports.classList = classList;
	exports.visibilityChangeFlow = visibilityChangeFlow;
	exports.createAudioElements = createAudioElements;

	var _api = __webpack_require__(1);

	var API = _interopRequireWildcard(_api);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }

	var animationEndEvents = exports.animationEndEvents = 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend';

	function inArray(needle, haystack, argStrict) {
	  var key = void 0;
	  var strict = !!argStrict;

	  if (strict) {
	    for (key in haystack) {
	      if (haystack.hasOwnProperty(key) && haystack[key] === needle) {
	        return true;
	      }
	    }
	  } else {
	    for (key in haystack) {
	      if (haystack.hasOwnProperty(key) && haystack[key] === needle) {
	        return true;
	      }
	    }
	  }
	  return false;
	}

	function stopPropagation(evt) {
	  evt = evt || window.event;

	  if (typeof evt.stopPropagation !== 'undefined') {
	    evt.stopPropagation();
	  } else {
	    evt.cancelBubble = true;
	  }
	}

	var deepExtend = exports.deepExtend = function deepExtend(out) {
	  var arguments$1 = arguments;

	  out = out || {};

	  for (var i = 1; i < arguments.length; i++) {
	    var obj = arguments$1[i];

	    if (!obj) { continue; }

	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        if (Array.isArray(obj[key])) {
	          out[key] = obj[key];
	        } else if (_typeof(obj[key]) === 'object' && obj[key] !== null) {
	          out[key] = deepExtend(out[key], obj[key]);
	        } else {
	          out[key] = obj[key];
	        }
	      }
	    }
	  }

	  return out;
	};

	function generateID() {
	  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	  var id = 'noty_' + prefix + '_';

	  id += 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = Math.random() * 16 | 0;
	    var v = c === 'x' ? r : r & 0x3 | 0x8;
	    return v.toString(16);
	  });

	  return id;
	}

	function outerHeight(el) {
	  var height = el.offsetHeight;
	  var style = window.getComputedStyle(el);

	  height += parseInt(style.marginTop) + parseInt(style.marginBottom);
	  return height;
	}

	var css = exports.css = function () {
	  var cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'];
	  var cssProps = {};

	  function camelCase(string) {
	    return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function (match, letter) {
	      return letter.toUpperCase();
	    });
	  }

	  function getVendorProp(name) {
	    var style = document.body.style;
	    if (name in style) { return name; }

	    var i = cssPrefixes.length;
	    var capName = name.charAt(0).toUpperCase() + name.slice(1);
	    var vendorName = void 0;

	    while (i--) {
	      vendorName = cssPrefixes[i] + capName;
	      if (vendorName in style) { return vendorName; }
	    }

	    return name;
	  }

	  function getStyleProp(name) {
	    name = camelCase(name);
	    return cssProps[name] || (cssProps[name] = getVendorProp(name));
	  }

	  function applyCss(element, prop, value) {
	    prop = getStyleProp(prop);
	    element.style[prop] = value;
	  }

	  return function (element, properties) {
	    var args = arguments;
	    var prop = void 0;
	    var value = void 0;

	    if (args.length === 2) {
	      for (prop in properties) {
	        if (properties.hasOwnProperty(prop)) {
	          value = properties[prop];
	          if (value !== undefined && properties.hasOwnProperty(prop)) {
	            applyCss(element, prop, value);
	          }
	        }
	      }
	    } else {
	      applyCss(element, args[1], args[2]);
	    }
	  };
	}();

	function addListener(el, events, cb) {
	  var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

	  events = events.split(' ');
	  for (var i = 0; i < events.length; i++) {
	    if (document.addEventListener) {
	      el.addEventListener(events[i], cb, useCapture);
	    } else if (document.attachEvent) {
	      el.attachEvent('on' + events[i], cb);
	    }
	  }
	}

	function hasClass(element, name) {
	  var list = typeof element === 'string' ? element : classList(element);
	  return list.indexOf(' ' + name + ' ') >= 0;
	}

	function addClass(element, name) {
	  var oldList = classList(element);
	  var newList = oldList + name;

	  if (hasClass(oldList, name)) { return; }

	  // Trim the opening space.
	  element.className = newList.substring(1);
	}

	function removeClass(element, name) {
	  var oldList = classList(element);
	  var newList = void 0;

	  if (!hasClass(element, name)) { return; }

	  // Replace the class name.
	  newList = oldList.replace(' ' + name + ' ', ' ');

	  // Trim the opening and closing spaces.
	  element.className = newList.substring(1, newList.length - 1);
	}

	function remove(element) {
	  if (element.parentNode) {
	    element.parentNode.removeChild(element);
	  }
	}

	function classList(element) {
	  return (' ' + (element && element.className || '') + ' ').replace(/\s+/gi, ' ');
	}

	function visibilityChangeFlow() {
	  var hidden = void 0;
	  var visibilityChange = void 0;
	  if (typeof document.hidden !== 'undefined') {
	    // Opera 12.10 and Firefox 18 and later support
	    hidden = 'hidden';
	    visibilityChange = 'visibilitychange';
	  } else if (typeof document.msHidden !== 'undefined') {
	    hidden = 'msHidden';
	    visibilityChange = 'msvisibilitychange';
	  } else if (typeof document.webkitHidden !== 'undefined') {
	    hidden = 'webkitHidden';
	    visibilityChange = 'webkitvisibilitychange';
	  }

	  function onVisibilityChange() {
	    API.PageHidden = document[hidden];
	    handleVisibilityChange();
	  }

	  function onBlur() {
	    API.PageHidden = true;
	    handleVisibilityChange();
	  }

	  function onFocus() {
	    API.PageHidden = false;
	    handleVisibilityChange();
	  }

	  function handleVisibilityChange() {
	    if (API.PageHidden) { stopAll(); }else { resumeAll(); }
	  }

	  function stopAll() {
	    setTimeout(function () {
	      Object.keys(API.Store).forEach(function (id) {
	        if (API.Store.hasOwnProperty(id)) {
	          if (API.Store[id].options.visibilityControl) {
	            API.Store[id].stop();
	          }
	        }
	      });
	    }, 100);
	  }

	  function resumeAll() {
	    setTimeout(function () {
	      Object.keys(API.Store).forEach(function (id) {
	        if (API.Store.hasOwnProperty(id)) {
	          if (API.Store[id].options.visibilityControl) {
	            API.Store[id].resume();
	          }
	        }
	      });
	      API.queueRenderAll();
	    }, 100);
	  }

	  if (visibilityChange) {
	    addListener(document, visibilityChange, onVisibilityChange);
	  }

	  addListener(window, 'blur', onBlur);
	  addListener(window, 'focus', onFocus);
	}

	function createAudioElements(ref) {
	  if (ref.hasSound) {
	    var audioElement = document.createElement('audio');

	    ref.options.sounds.sources.forEach(function (s) {
	      var source = document.createElement('source');
	      source.src = s;
	      source.type = 'audio/' + getExtension(s);
	      audioElement.appendChild(source);
	    });

	    if (ref.barDom) {
	      ref.barDom.appendChild(audioElement);
	    } else {
	      document.querySelector('body').appendChild(audioElement);
	    }

	    audioElement.volume = ref.options.sounds.volume;

	    if (!ref.soundPlayed) {
	      audioElement.play();
	      ref.soundPlayed = true;
	    }

	    audioElement.onended = function () {
	      remove(audioElement);
	    };
	  }
	}

	function getExtension(fileName) {
	  return fileName.match(/\.([^.]+)$/)[1];
	}

	/***/ }),
	/* 1 */
	/***/ (function(module, exports, __webpack_require__) {


	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Defaults = exports.Store = exports.Queues = exports.DefaultMaxVisible = exports.docTitle = exports.DocModalCount = exports.PageHidden = undefined;
	exports.getQueueCounts = getQueueCounts;
	exports.addToQueue = addToQueue;
	exports.removeFromQueue = removeFromQueue;
	exports.queueRender = queueRender;
	exports.queueRenderAll = queueRenderAll;
	exports.ghostFix = ghostFix;
	exports.build = build;
	exports.hasButtons = hasButtons;
	exports.handleModal = handleModal;
	exports.handleModalClose = handleModalClose;
	exports.queueClose = queueClose;
	exports.dequeueClose = dequeueClose;
	exports.fire = fire;
	exports.openFlow = openFlow;
	exports.closeFlow = closeFlow;

	var _utils = __webpack_require__(0);

	var Utils = _interopRequireWildcard(_utils);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }

	var PageHidden = exports.PageHidden = false;
	var DocModalCount = exports.DocModalCount = 0;

	var DocTitleProps = {
	  originalTitle: null,
	  count: 0,
	  changed: false,
	  timer: -1
	};

	var docTitle = exports.docTitle = {
	  increment: function increment() {
	    DocTitleProps.count++;

	    docTitle._update();
	  },

	  decrement: function decrement() {
	    DocTitleProps.count--;

	    if (DocTitleProps.count <= 0) {
	      docTitle._clear();
	      return;
	    }

	    docTitle._update();
	  },

	  _update: function _update() {
	    var title = document.title;

	    if (!DocTitleProps.changed) {
	      DocTitleProps.originalTitle = title;
	      document.title = '(' + DocTitleProps.count + ') ' + title;
	      DocTitleProps.changed = true;
	    } else {
	      document.title = '(' + DocTitleProps.count + ') ' + DocTitleProps.originalTitle;
	    }
	  },

	  _clear: function _clear() {
	    if (DocTitleProps.changed) {
	      DocTitleProps.count = 0;
	      document.title = DocTitleProps.originalTitle;
	      DocTitleProps.changed = false;
	    }
	  }
	};

	var DefaultMaxVisible = exports.DefaultMaxVisible = 5;

	var Queues = exports.Queues = {
	  global: {
	    maxVisible: DefaultMaxVisible,
	    queue: []
	  }
	};

	var Store = exports.Store = {};

	var Defaults = exports.Defaults = {
	  type: 'alert',
	  layout: 'topRight',
	  theme: 'mint',
	  text: '',
	  timeout: false,
	  progressBar: true,
	  closeWith: ['click'],
	  animation: {
	    open: 'noty_effects_open',
	    close: 'noty_effects_close'
	  },
	  id: false,
	  force: false,
	  killer: false,
	  queue: 'global',
	  container: false,
	  buttons: [],
	  callbacks: {
	    beforeShow: null,
	    onShow: null,
	    afterShow: null,
	    onClose: null,
	    afterClose: null,
	    onClick: null,
	    onHover: null,
	    onTemplate: null
	  },
	  sounds: {
	    sources: [],
	    volume: 1,
	    conditions: []
	  },
	  titleCount: {
	    conditions: []
	  },
	  modal: false,
	  visibilityControl: false

	  /**
	   * @param {string} queueName
	   * @return {object}
	   */
	};function getQueueCounts() {
	  var queueName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'global';

	  var count = 0;
	  var max = DefaultMaxVisible;

	  if (Queues.hasOwnProperty(queueName)) {
	    max = Queues[queueName].maxVisible;
	    Object.keys(Store).forEach(function (i) {
	      if (Store[i].options.queue === queueName && !Store[i].closed) { count++; }
	    });
	  }

	  return {
	    current: count,
	    maxVisible: max
	  };
	}

	/**
	 * @param {Noty} ref
	 * @return {void}
	 */
	function addToQueue(ref) {
	  if (!Queues.hasOwnProperty(ref.options.queue)) {
	    Queues[ref.options.queue] = { maxVisible: DefaultMaxVisible, queue: [] };
	  }

	  Queues[ref.options.queue].queue.push(ref);
	}

	/**
	 * @param {Noty} ref
	 * @return {void}
	 */
	function removeFromQueue(ref) {
	  if (Queues.hasOwnProperty(ref.options.queue)) {
	    var queue = [];
	    Object.keys(Queues[ref.options.queue].queue).forEach(function (i) {
	      if (Queues[ref.options.queue].queue[i].id !== ref.id) {
	        queue.push(Queues[ref.options.queue].queue[i]);
	      }
	    });
	    Queues[ref.options.queue].queue = queue;
	  }
	}

	/**
	 * @param {string} queueName
	 * @return {void}
	 */
	function queueRender() {
	  var queueName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'global';

	  if (Queues.hasOwnProperty(queueName)) {
	    var noty = Queues[queueName].queue.shift();

	    if (noty) { noty.show(); }
	  }
	}

	/**
	 * @return {void}
	 */
	function queueRenderAll() {
	  Object.keys(Queues).forEach(function (queueName) {
	    queueRender(queueName);
	  });
	}

	/**
	 * @param {Noty} ref
	 * @return {void}
	 */
	function ghostFix(ref) {
	  var ghostID = Utils.generateID('ghost');
	  var ghost = document.createElement('div');
	  ghost.setAttribute('id', ghostID);
	  Utils.css(ghost, {
	    height: Utils.outerHeight(ref.barDom) + 'px'
	  });

	  ref.barDom.insertAdjacentHTML('afterend', ghost.outerHTML);

	  Utils.remove(ref.barDom);
	  ghost = document.getElementById(ghostID);
	  Utils.addClass(ghost, 'noty_fix_effects_height');
	  Utils.addListener(ghost, Utils.animationEndEvents, function () {
	    Utils.remove(ghost);
	  });
	}

	/**
	 * @param {Noty} ref
	 * @return {void}
	 */
	function build(ref) {
	  findOrCreateContainer(ref);

	  var markup = '<div class="noty_body">' + ref.options.text + '</div>' + buildButtons(ref) + '<div class="noty_progressbar"></div>';

	  ref.barDom = document.createElement('div');
	  ref.barDom.setAttribute('id', ref.id);
	  Utils.addClass(ref.barDom, 'noty_bar noty_type__' + ref.options.type + ' noty_theme__' + ref.options.theme);

	  ref.barDom.innerHTML = markup;

	  fire(ref, 'onTemplate');
	}

	/**
	 * @param {Noty} ref
	 * @return {boolean}
	 */
	function hasButtons(ref) {
	  return !!(ref.options.buttons && Object.keys(ref.options.buttons).length);
	}

	/**
	 * @param {Noty} ref
	 * @return {string}
	 */
	function buildButtons(ref) {
	  if (hasButtons(ref)) {
	    var buttons = document.createElement('div');
	    Utils.addClass(buttons, 'noty_buttons');

	    Object.keys(ref.options.buttons).forEach(function (key) {
	      buttons.appendChild(ref.options.buttons[key].dom);
	    });

	    ref.options.buttons.forEach(function (btn) {
	      buttons.appendChild(btn.dom);
	    });
	    return buttons.outerHTML;
	  }
	  return '';
	}

	/**
	 * @param {Noty} ref
	 * @return {void}
	 */
	function handleModal(ref) {
	  if (ref.options.modal) {
	    if (DocModalCount === 0) {
	      createModal();
	    }

	    exports.DocModalCount = DocModalCount += 1;
	  }
	}

	/**
	 * @param {Noty} ref
	 * @return {void}
	 */
	function handleModalClose(ref) {
	  if (ref.options.modal && DocModalCount > 0) {
	    exports.DocModalCount = DocModalCount -= 1;

	    if (DocModalCount <= 0) {
	      var modal = document.querySelector('.noty_modal');

	      if (modal) {
	        Utils.removeClass(modal, 'noty_modal_open');
	        Utils.addClass(modal, 'noty_modal_close');
	        Utils.addListener(modal, Utils.animationEndEvents, function () {
	          Utils.remove(modal);
	        });
	      }
	    }
	  }
	}

	/**
	 * @return {void}
	 */
	function createModal() {
	  var body = document.querySelector('body');
	  var modal = document.createElement('div');
	  Utils.addClass(modal, 'noty_modal');
	  body.insertBefore(modal, body.firstChild);
	  Utils.addClass(modal, 'noty_modal_open');

	  Utils.addListener(modal, Utils.animationEndEvents, function () {
	    Utils.removeClass(modal, 'noty_modal_open');
	  });
	}

	/**
	 * @param {Noty} ref
	 * @return {void}
	 */
	function findOrCreateContainer(ref) {
	  if (ref.options.container) {
	    ref.layoutDom = document.querySelector(ref.options.container);
	    return;
	  }

	  var layoutID = 'noty_layout__' + ref.options.layout;
	  ref.layoutDom = document.querySelector('div#' + layoutID);

	  if (!ref.layoutDom) {
	    ref.layoutDom = document.createElement('div');
	    ref.layoutDom.setAttribute('id', layoutID);
	    ref.layoutDom.setAttribute('role', 'alert');
	    ref.layoutDom.setAttribute('aria-live', 'polite');
	    Utils.addClass(ref.layoutDom, 'noty_layout');
	    document.querySelector('body').appendChild(ref.layoutDom);
	  }
	}

	/**
	 * @param {Noty} ref
	 * @return {void}
	 */
	function queueClose(ref) {
	  if (ref.options.timeout) {
	    if (ref.options.progressBar && ref.progressDom) {
	      Utils.css(ref.progressDom, {
	        transition: 'width ' + ref.options.timeout + 'ms linear',
	        width: '0%'
	      });
	    }

	    clearTimeout(ref.closeTimer);

	    ref.closeTimer = setTimeout(function () {
	      ref.close();
	    }, ref.options.timeout);
	  }
	}

	/**
	 * @param {Noty} ref
	 * @return {void}
	 */
	function dequeueClose(ref) {
	  if (ref.options.timeout && ref.closeTimer) {
	    clearTimeout(ref.closeTimer);
	    ref.closeTimer = -1;

	    if (ref.options.progressBar && ref.progressDom) {
	      Utils.css(ref.progressDom, {
	        transition: 'width 0ms linear',
	        width: '100%'
	      });
	    }
	  }
	}

	/**
	 * @param {Noty} ref
	 * @param {string} eventName
	 * @return {void}
	 */
	function fire(ref, eventName) {
	  if (ref.listeners.hasOwnProperty(eventName)) {
	    ref.listeners[eventName].forEach(function (cb) {
	      if (typeof cb === 'function') {
	        cb.apply(ref);
	      }
	    });
	  }
	}

	/**
	 * @param {Noty} ref
	 * @return {void}
	 */
	function openFlow(ref) {
	  fire(ref, 'afterShow');
	  queueClose(ref);

	  Utils.addListener(ref.barDom, 'mouseenter', function () {
	    dequeueClose(ref);
	  });

	  Utils.addListener(ref.barDom, 'mouseleave', function () {
	    queueClose(ref);
	  });
	}

	/**
	 * @param {Noty} ref
	 * @return {void}
	 */
	function closeFlow(ref) {
	  delete Store[ref.id];
	  ref.closing = false;
	  fire(ref, 'afterClose');

	  Utils.remove(ref.barDom);

	  if (ref.layoutDom.querySelectorAll('.noty_bar').length === 0 && !ref.options.container) {
	    Utils.remove(ref.layoutDom);
	  }

	  if (Utils.inArray('docVisible', ref.options.titleCount.conditions) || Utils.inArray('docHidden', ref.options.titleCount.conditions)) {
	    docTitle.decrement();
	  }

	  queueRender(ref.options.queue);
	}

	/***/ }),
	/* 2 */
	/***/ (function(module, exports, __webpack_require__) {


	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NotyButton = undefined;

	var _utils = __webpack_require__(0);

	var Utils = _interopRequireWildcard(_utils);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NotyButton = exports.NotyButton = function NotyButton(html, classes, cb) {
	  var _this = this;

	  var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

	  _classCallCheck(this, NotyButton);

	  this.dom = document.createElement('button');
	  this.dom.innerHTML = html;
	  this.id = attributes.id = attributes.id || Utils.generateID('button');
	  this.cb = cb;
	  Object.keys(attributes).forEach(function (propertyName) {
	    _this.dom.setAttribute(propertyName, attributes[propertyName]);
	  });
	  Utils.addClass(this.dom, classes || 'noty_btn');

	  return this;
	};

	/***/ }),
	/* 3 */
	/***/ (function(module, exports, __webpack_require__) {


	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Push = exports.Push = function () {
	  function Push() {
	    var workerPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/service-worker.js';

	    _classCallCheck(this, Push);

	    this.subData = {};
	    this.workerPath = workerPath;
	    this.listeners = {
	      onPermissionGranted: [],
	      onPermissionDenied: [],
	      onSubscriptionSuccess: [],
	      onSubscriptionCancel: [],
	      onWorkerError: [],
	      onWorkerSuccess: [],
	      onWorkerNotSupported: []
	    };
	    return this;
	  }

	  /**
	   * @param {string} eventName
	   * @param {function} cb
	   * @return {Push}
	   */


	  _createClass(Push, [{
	    key: 'on',
	    value: function on(eventName) {
	      var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

	      if (typeof cb === 'function' && this.listeners.hasOwnProperty(eventName)) {
	        this.listeners[eventName].push(cb);
	      }

	      return this;
	    }
	  }, {
	    key: 'fire',
	    value: function fire(eventName) {
	      var _this = this;

	      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	      if (this.listeners.hasOwnProperty(eventName)) {
	        this.listeners[eventName].forEach(function (cb) {
	          if (typeof cb === 'function') {
	            cb.apply(_this, params);
	          }
	        });
	      }
	    }
	  }, {
	    key: 'create',
	    value: function create() {
	      console.log('NOT IMPLEMENTED YET');
	    }

	    /**
	     * @return {boolean}
	     */

	  }, {
	    key: 'isSupported',
	    value: function isSupported() {
	      var result = false;

	      try {
	        result = window.Notification || window.webkitNotifications || navigator.mozNotification || window.external && window.external.msIsSiteMode() !== undefined;
	      } catch (e) {}

	      return result;
	    }

	    /**
	     * @return {string}
	     */

	  }, {
	    key: 'getPermissionStatus',
	    value: function getPermissionStatus() {
	      var perm = 'default';

	      if (window.Notification && window.Notification.permissionLevel) {
	        perm = window.Notification.permissionLevel;
	      } else if (window.webkitNotifications && window.webkitNotifications.checkPermission) {
	        switch (window.webkitNotifications.checkPermission()) {
	          case 1:
	            perm = 'default';
	            break;
	          case 0:
	            perm = 'granted';
	            break;
	          default:
	            perm = 'denied';
	        }
	      } else if (window.Notification && window.Notification.permission) {
	        perm = window.Notification.permission;
	      } else if (navigator.mozNotification) {
	        perm = 'granted';
	      } else if (window.external && window.external.msIsSiteMode() !== undefined) {
	        perm = window.external.msIsSiteMode() ? 'granted' : 'default';
	      }

	      return perm.toString().toLowerCase();
	    }

	    /**
	     * @return {string}
	     */

	  }, {
	    key: 'getEndpoint',
	    value: function getEndpoint(subscription) {
	      var endpoint = subscription.endpoint;
	      var subscriptionId = subscription.subscriptionId;

	      // fix for Chrome < 45
	      if (subscriptionId && endpoint.indexOf(subscriptionId) === -1) {
	        endpoint += '/' + subscriptionId;
	      }

	      return endpoint;
	    }

	    /**
	     * @return {boolean}
	     */

	  }, {
	    key: 'isSWRegistered',
	    value: function isSWRegistered() {
	      try {
	        return navigator.serviceWorker.controller.state === 'activated';
	      } catch (e) {
	        return false;
	      }
	    }

	    /**
	     * @return {void}
	     */

	  }, {
	    key: 'unregisterWorker',
	    value: function unregisterWorker() {
	      var self = this;
	      if ('serviceWorker' in navigator) {
	        navigator.serviceWorker.getRegistrations().then(function (registrations) {
	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;

	          try {
	            for (var _iterator = registrations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var registration = _step.value;

	              registration.unregister();
	              self.fire('onSubscriptionCancel');
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }
	        });
	      }
	    }

	    /**
	     * @return {void}
	     */

	  }, {
	    key: 'requestSubscription',
	    value: function requestSubscription() {
	      var _this2 = this;

	      var userVisibleOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

	      var self = this;
	      var current = this.getPermissionStatus();
	      var cb = function cb(result) {
	        if (result === 'granted') {
	          _this2.fire('onPermissionGranted');

	          if ('serviceWorker' in navigator) {
	            navigator.serviceWorker.register(_this2.workerPath).then(function () {
	              navigator.serviceWorker.ready.then(function (serviceWorkerRegistration) {
	                self.fire('onWorkerSuccess');
	                serviceWorkerRegistration.pushManager.subscribe({
	                  userVisibleOnly: userVisibleOnly
	                }).then(function (subscription) {
	                  var key = subscription.getKey('p256dh');
	                  var token = subscription.getKey('auth');

	                  self.subData = {
	                    endpoint: self.getEndpoint(subscription),
	                    p256dh: key ? window.btoa(String.fromCharCode.apply(null, new Uint8Array(key))) : null,
	                    auth: token ? window.btoa(String.fromCharCode.apply(null, new Uint8Array(token))) : null
	                  };

	                  self.fire('onSubscriptionSuccess', [self.subData]);
	                }).catch(function (err) {
	                  self.fire('onWorkerError', [err]);
	                });
	              });
	            });
	          } else {
	            self.fire('onWorkerNotSupported');
	          }
	        } else if (result === 'denied') {
	          _this2.fire('onPermissionDenied');
	          _this2.unregisterWorker();
	        }
	      };

	      if (current === 'default') {
	        if (window.Notification && window.Notification.requestPermission) {
	          window.Notification.requestPermission(cb);
	        } else if (window.webkitNotifications && window.webkitNotifications.checkPermission) {
	          window.webkitNotifications.requestPermission(cb);
	        }
	      } else {
	        cb(current);
	      }
	    }
	  }]);

	  return Push;
	}();

	/***/ }),
	/* 4 */
	/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {var require;/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.1.1
	 */

	(function (global, factory) {
		  module.exports = factory() ;
	}(this, (function () {
	function objectOrFunction(x) {
	  var type = typeof x;
	  return x !== null && (type === 'object' || type === 'function');
	}

	function isFunction(x) {
	  return typeof x === 'function';
	}

	var _isArray = undefined;
	if (Array.isArray) {
	  _isArray = Array.isArray;
	} else {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	}

	var isArray = _isArray;

	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;

	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};

	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}

	function setAsap(asapFn) {
	  asap = asapFn;
	}

	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}

	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }

	  return useSetTimeout();
	}

	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });

	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}

	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}

	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}

	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];

	    callback(arg);

	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }

	  len = 0;
	}

	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(9);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}

	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}

	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;

	  var parent = this;

	  var child = new this.constructor(noop);

	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }

	  var _state = parent._state;

	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }

	  return child;
	}

	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:

	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = Promise.resolve(1);

	  promise.then(function(value){
	    // value === 1
	  });
	  ```

	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve$1(object) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }

	  var promise = new Constructor(noop);
	  resolve(promise, object);
	  return promise;
	}

	var PROMISE_ID = Math.random().toString(36).substring(16);

	function noop() {}

	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;

	var GET_THEN_ERROR = new ErrorObject();

	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}

	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}

	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}

	function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then$$1.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}

	function handleForeignThenable(promise, thenable, then$$1) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then$$1, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;

	      reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));

	    if (!sealed && error) {
	      sealed = true;
	      reject(promise, error);
	    }
	  }, promise);
	}

	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return resolve(promise, value);
	    }, function (reason) {
	      return reject(promise, reason);
	    });
	  }
	}

	function handleMaybeThenable(promise, maybeThenable, then$$1) {
	  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$1 === GET_THEN_ERROR) {
	      reject(promise, GET_THEN_ERROR.error);
	      GET_THEN_ERROR.error = null;
	    } else if (then$$1 === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$1)) {
	      handleForeignThenable(promise, maybeThenable, then$$1);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}

	function resolve(promise, value) {
	  if (promise === value) {
	    reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}

	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }

	  publish(promise);
	}

	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }

	  promise._result = value;
	  promise._state = FULFILLED;

	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}

	function reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;

	  asap(publishRejection, promise);
	}

	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;

	  parent._onerror = null;

	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;

	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}

	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;

	  if (subscribers.length === 0) {
	    return;
	  }

	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;

	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];

	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }

	  promise._subscribers.length = 0;
	}

	function ErrorObject() {
	  this.error = null;
	}

	var TRY_CATCH_ERROR = new ErrorObject();

	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}

	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;

	  if (hasCallback) {
	    value = tryCatch(callback, detail);

	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value.error = null;
	    } else {
	      succeeded = true;
	    }

	    if (promise === value) {
	      reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }

	  if (promise._state !== PENDING) ; else if (hasCallback && succeeded) {
	      resolve(promise, value);
	    } else if (failed) {
	      reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      reject(promise, value);
	    }
	}

	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      resolve(promise, value);
	    }, function rejectPromise(reason) {
	      reject(promise, reason);
	    });
	  } catch (e) {
	    reject(promise, e);
	  }
	}

	var id = 0;
	function nextId() {
	  return id++;
	}

	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}

	function Enumerator$1(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);

	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }

	  if (isArray(input)) {
	    this.length = input.length;
	    this._remaining = input.length;

	    this._result = new Array(this.length);

	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate(input);
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    reject(this.promise, validationError());
	  }
	}

	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	}

	Enumerator$1.prototype._enumerate = function (input) {
	  for (var i = 0; this._state === PENDING && i < input.length; i++) {
	    this._eachEntry(input[i], i);
	  }
	};

	Enumerator$1.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$1 = c.resolve;

	  if (resolve$$1 === resolve$1) {
	    var _then = getThen(entry);

	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise$2) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$1) {
	        return resolve$$1(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$1(entry), i);
	  }
	};

	Enumerator$1.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;

	  if (promise._state === PENDING) {
	    this._remaining--;

	    if (state === REJECTED) {
	      reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }

	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};

	Enumerator$1.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;

	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};

	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.

	  Example:

	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];

	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```

	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:

	  Example:

	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];

	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```

	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all$1(entries) {
	  return new Enumerator$1(this, entries).promise;
	}

	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.

	  Example:

	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });

	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```

	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:

	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });

	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });

	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```

	  An example real-world use case is implementing timeouts:

	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```

	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race$1(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;

	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}

	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:

	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject$1(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  reject(promise, reason);
	  return promise;
	}

	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}

	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}

	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.

	  Terminology
	  -----------

	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.

	  A promise can be in one of three states: pending, fulfilled, or rejected.

	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.

	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.


	  Basic Usage:
	  ------------

	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);

	    // on failure
	    reject(reason);
	  });

	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Advanced Usage:
	  ---------------

	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.

	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();

	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();

	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }

	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```

	  Unlike callbacks, promises are great composable primitives.

	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON

	    return values;
	  });
	  ```

	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise$2(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];

	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();
	  }
	}

	Promise$2.all = all$1;
	Promise$2.race = race$1;
	Promise$2.resolve = resolve$1;
	Promise$2.reject = reject$1;
	Promise$2._setScheduler = setScheduler;
	Promise$2._setAsap = setAsap;
	Promise$2._asap = asap;

	Promise$2.prototype = {
	  constructor: Promise$2,

	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.
	  
	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```
	  
	    Chaining
	    --------
	  
	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.
	  
	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });
	  
	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	  
	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```
	  
	    Assimilation
	    ------------
	  
	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```
	  
	    If the assimliated promise rejects, then the downstream promise will also reject.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```
	  
	    Simple Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let result;
	  
	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```
	  
	    Advanced Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let author, books;
	  
	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	  
	    function foundBooks(books) {
	  
	    }
	  
	    function failure(reason) {
	  
	    }
	  
	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,

	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.
	  
	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }
	  
	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }
	  
	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};

	/*global self*/
	function polyfill$1() {
	    var local = undefined;

	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }

	    var P = local.Promise;

	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }

	        if (promiseToString === '[object Promise]' && !P.cast) {
	            return;
	        }
	    }

	    local.Promise = Promise$2;
	}

	// Strange compat..
	Promise$2.polyfill = polyfill$1;
	Promise$2.Promise = Promise$2;

	return Promise$2;

	})));



	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(8)));

	/***/ }),
	/* 5 */
	/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

	/***/ }),
	/* 6 */
	/***/ (function(module, exports, __webpack_require__) {


	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }(); /* global VERSION */

	__webpack_require__(5);

	var _es6Promise = __webpack_require__(4);

	var _es6Promise2 = _interopRequireDefault(_es6Promise);

	var _utils = __webpack_require__(0);

	var Utils = _interopRequireWildcard(_utils);

	var _api = __webpack_require__(1);

	var API = _interopRequireWildcard(_api);

	var _button = __webpack_require__(2);

	var _push = __webpack_require__(3);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Noty = function () {
	  /**
	   * @param {object} options
	   * @return {Noty}
	   */
	  function Noty() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, Noty);

	    this.options = Utils.deepExtend({}, API.Defaults, options);

	    if (API.Store[this.options.id]) {
	      return API.Store[this.options.id];
	    }

	    this.id = this.options.id || Utils.generateID('bar');
	    this.closeTimer = -1;
	    this.barDom = null;
	    this.layoutDom = null;
	    this.progressDom = null;
	    this.showing = false;
	    this.shown = false;
	    this.closed = false;
	    this.closing = false;
	    this.killable = this.options.timeout || this.options.closeWith.length > 0;
	    this.hasSound = this.options.sounds.sources.length > 0;
	    this.soundPlayed = false;
	    this.listeners = {
	      beforeShow: [],
	      onShow: [],
	      afterShow: [],
	      onClose: [],
	      afterClose: [],
	      onClick: [],
	      onHover: [],
	      onTemplate: []
	    };
	    this.promises = {
	      show: null,
	      close: null
	    };
	    this.on('beforeShow', this.options.callbacks.beforeShow);
	    this.on('onShow', this.options.callbacks.onShow);
	    this.on('afterShow', this.options.callbacks.afterShow);
	    this.on('onClose', this.options.callbacks.onClose);
	    this.on('afterClose', this.options.callbacks.afterClose);
	    this.on('onClick', this.options.callbacks.onClick);
	    this.on('onHover', this.options.callbacks.onHover);
	    this.on('onTemplate', this.options.callbacks.onTemplate);

	    return this;
	  }

	  /**
	   * @param {string} eventName
	   * @param {function} cb
	   * @return {Noty}
	   */


	  _createClass(Noty, [{
	    key: 'on',
	    value: function on(eventName) {
	      var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

	      if (typeof cb === 'function' && this.listeners.hasOwnProperty(eventName)) {
	        this.listeners[eventName].push(cb);
	      }

	      return this;
	    }

	    /**
	     * @return {Noty}
	     */

	  }, {
	    key: 'show',
	    value: function show() {
	      var _this = this;

	      if (this.showing || this.shown) {
	        return this; // preventing multiple show
	      }

	      if (this.options.killer === true) {
	        Noty.closeAll();
	      } else if (typeof this.options.killer === 'string') {
	        Noty.closeAll(this.options.killer);
	      }

	      var queueCounts = API.getQueueCounts(this.options.queue);

	      if (queueCounts.current >= queueCounts.maxVisible || API.PageHidden && this.options.visibilityControl) {
	        API.addToQueue(this);

	        if (API.PageHidden && this.hasSound && Utils.inArray('docHidden', this.options.sounds.conditions)) {
	          Utils.createAudioElements(this);
	        }

	        if (API.PageHidden && Utils.inArray('docHidden', this.options.titleCount.conditions)) {
	          API.docTitle.increment();
	        }

	        return this;
	      }

	      API.Store[this.id] = this;

	      API.fire(this, 'beforeShow');

	      this.showing = true;

	      if (this.closing) {
	        this.showing = false;
	        return this;
	      }

	      API.build(this);
	      API.handleModal(this);

	      if (this.options.force) {
	        this.layoutDom.insertBefore(this.barDom, this.layoutDom.firstChild);
	      } else {
	        this.layoutDom.appendChild(this.barDom);
	      }

	      if (this.hasSound && !this.soundPlayed && Utils.inArray('docVisible', this.options.sounds.conditions)) {
	        Utils.createAudioElements(this);
	      }

	      if (Utils.inArray('docVisible', this.options.titleCount.conditions)) {
	        API.docTitle.increment();
	      }

	      this.shown = true;
	      this.closed = false;

	      // bind button events if any
	      if (API.hasButtons(this)) {
	        Object.keys(this.options.buttons).forEach(function (key) {
	          var btn = _this.barDom.querySelector('#' + _this.options.buttons[key].id);
	          Utils.addListener(btn, 'click', function (e) {
	            Utils.stopPropagation(e);
	            _this.options.buttons[key].cb(_this);
	          });
	        });
	      }

	      this.progressDom = this.barDom.querySelector('.noty_progressbar');

	      if (Utils.inArray('click', this.options.closeWith)) {
	        Utils.addClass(this.barDom, 'noty_close_with_click');
	        Utils.addListener(this.barDom, 'click', function (e) {
	          Utils.stopPropagation(e);
	          API.fire(_this, 'onClick');
	          _this.close();
	        }, false);
	      }

	      Utils.addListener(this.barDom, 'mouseenter', function () {
	        API.fire(_this, 'onHover');
	      }, false);

	      if (this.options.timeout) { Utils.addClass(this.barDom, 'noty_has_timeout'); }
	      if (this.options.progressBar) {
	        Utils.addClass(this.barDom, 'noty_has_progressbar');
	      }

	      if (Utils.inArray('button', this.options.closeWith)) {
	        Utils.addClass(this.barDom, 'noty_close_with_button');

	        var closeButton = document.createElement('div');
	        Utils.addClass(closeButton, 'noty_close_button');
	        closeButton.innerHTML = '×';
	        this.barDom.appendChild(closeButton);

	        Utils.addListener(closeButton, 'click', function (e) {
	          Utils.stopPropagation(e);
	          _this.close();
	        }, false);
	      }

	      API.fire(this, 'onShow');

	      if (this.options.animation.open === null) {
	        this.promises.show = new _es6Promise2.default(function (resolve) {
	          resolve();
	        });
	      } else if (typeof this.options.animation.open === 'function') {
	        this.promises.show = new _es6Promise2.default(this.options.animation.open.bind(this));
	      } else {
	        Utils.addClass(this.barDom, this.options.animation.open);
	        this.promises.show = new _es6Promise2.default(function (resolve) {
	          Utils.addListener(_this.barDom, Utils.animationEndEvents, function () {
	            Utils.removeClass(_this.barDom, _this.options.animation.open);
	            resolve();
	          });
	        });
	      }

	      this.promises.show.then(function () {
	        var _t = _this;
	        setTimeout(function () {
	          API.openFlow(_t);
	        }, 100);
	      });

	      return this;
	    }

	    /**
	     * @return {Noty}
	     */

	  }, {
	    key: 'stop',
	    value: function stop() {
	      API.dequeueClose(this);
	      return this;
	    }

	    /**
	     * @return {Noty}
	     */

	  }, {
	    key: 'resume',
	    value: function resume() {
	      API.queueClose(this);
	      return this;
	    }

	    /**
	     * @param {int|boolean} ms
	     * @return {Noty}
	     */

	  }, {
	    key: 'setTimeout',
	    value: function (_setTimeout) {
	      function setTimeout(_x) {
	        return _setTimeout.apply(this, arguments);
	      }

	      setTimeout.toString = function () {
	        return _setTimeout.toString();
	      };

	      return setTimeout;
	    }(function (ms) {
	      this.stop();
	      this.options.timeout = ms;

	      if (this.barDom) {
	        if (this.options.timeout) {
	          Utils.addClass(this.barDom, 'noty_has_timeout');
	        } else {
	          Utils.removeClass(this.barDom, 'noty_has_timeout');
	        }

	        var _t = this;
	        setTimeout(function () {
	          // ugly fix for progressbar display bug
	          _t.resume();
	        }, 100);
	      }

	      return this;
	    })

	    /**
	     * @param {string} html
	     * @param {boolean} optionsOverride
	     * @return {Noty}
	     */

	  }, {
	    key: 'setText',
	    value: function setText(html) {
	      var optionsOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	      if (this.barDom) {
	        this.barDom.querySelector('.noty_body').innerHTML = html;
	      }

	      if (optionsOverride) { this.options.text = html; }

	      return this;
	    }

	    /**
	     * @param {string} type
	     * @param {boolean} optionsOverride
	     * @return {Noty}
	     */

	  }, {
	    key: 'setType',
	    value: function setType(type) {
	      var _this2 = this;

	      var optionsOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	      if (this.barDom) {
	        var classList = Utils.classList(this.barDom).split(' ');

	        classList.forEach(function (c) {
	          if (c.substring(0, 11) === 'noty_type__') {
	            Utils.removeClass(_this2.barDom, c);
	          }
	        });

	        Utils.addClass(this.barDom, 'noty_type__' + type);
	      }

	      if (optionsOverride) { this.options.type = type; }

	      return this;
	    }

	    /**
	     * @param {string} theme
	     * @param {boolean} optionsOverride
	     * @return {Noty}
	     */

	  }, {
	    key: 'setTheme',
	    value: function setTheme(theme) {
	      var _this3 = this;

	      var optionsOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	      if (this.barDom) {
	        var classList = Utils.classList(this.barDom).split(' ');

	        classList.forEach(function (c) {
	          if (c.substring(0, 12) === 'noty_theme__') {
	            Utils.removeClass(_this3.barDom, c);
	          }
	        });

	        Utils.addClass(this.barDom, 'noty_theme__' + theme);
	      }

	      if (optionsOverride) { this.options.theme = theme; }

	      return this;
	    }

	    /**
	     * @return {Noty}
	     */

	  }, {
	    key: 'close',
	    value: function close() {
	      var _this4 = this;

	      if (this.closed) { return this; }

	      if (!this.shown) {
	        // it's in the queue
	        API.removeFromQueue(this);
	        return this;
	      }

	      API.fire(this, 'onClose');

	      this.closing = true;

	      if (this.options.animation.close === null || this.options.animation.close === false) {
	        this.promises.close = new _es6Promise2.default(function (resolve) {
	          resolve();
	        });
	      } else if (typeof this.options.animation.close === 'function') {
	        this.promises.close = new _es6Promise2.default(this.options.animation.close.bind(this));
	      } else {
	        Utils.addClass(this.barDom, this.options.animation.close);
	        this.promises.close = new _es6Promise2.default(function (resolve) {
	          Utils.addListener(_this4.barDom, Utils.animationEndEvents, function () {
	            if (_this4.options.force) {
	              Utils.remove(_this4.barDom);
	            } else {
	              API.ghostFix(_this4);
	            }
	            resolve();
	          });
	        });
	      }

	      this.promises.close.then(function () {
	        API.closeFlow(_this4);
	        API.handleModalClose(_this4);
	      });

	      this.closed = true;

	      return this;
	    }

	    // API functions

	    /**
	     * @param {boolean|string} queueName
	     * @return {Noty}
	     */

	  }], [{
	    key: 'closeAll',
	    value: function closeAll() {
	      var queueName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	      Object.keys(API.Store).forEach(function (id) {
	        if (queueName) {
	          if (API.Store[id].options.queue === queueName && API.Store[id].killable) {
	            API.Store[id].close();
	          }
	        } else if (API.Store[id].killable) {
	          API.Store[id].close();
	        }
	      });
	      return this;
	    }

	    /**
	     * @param {string} queueName
	     * @return {Noty}
	     */

	  }, {
	    key: 'clearQueue',
	    value: function clearQueue() {
	      var queueName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'global';

	      if (API.Queues.hasOwnProperty(queueName)) {
	        API.Queues[queueName].queue = [];
	      }
	      return this;
	    }

	    /**
	     * @return {API.Queues}
	     */

	  }, {
	    key: 'overrideDefaults',


	    /**
	     * @param {Object} obj
	     * @return {Noty}
	     */
	    value: function overrideDefaults(obj) {
	      API.Defaults = Utils.deepExtend({}, API.Defaults, obj);
	      return this;
	    }

	    /**
	     * @param {int} amount
	     * @param {string} queueName
	     * @return {Noty}
	     */

	  }, {
	    key: 'setMaxVisible',
	    value: function setMaxVisible() {
	      var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : API.DefaultMaxVisible;
	      var queueName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'global';

	      if (!API.Queues.hasOwnProperty(queueName)) {
	        API.Queues[queueName] = { maxVisible: amount, queue: [] };
	      }

	      API.Queues[queueName].maxVisible = amount;
	      return this;
	    }

	    /**
	     * @param {string} innerHtml
	     * @param {String} classes
	     * @param {Function} cb
	     * @param {Object} attributes
	     * @return {NotyButton}
	     */

	  }, {
	    key: 'button',
	    value: function button(innerHtml) {
	      var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var cb = arguments[2];
	      var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

	      return new _button.NotyButton(innerHtml, classes, cb, attributes);
	    }

	    /**
	     * @return {string}
	     */

	  }, {
	    key: 'version',
	    value: function version() {
	      return "3.2.0-beta";
	    }

	    /**
	     * @param {String} workerPath
	     * @return {Push}
	     */

	  }, {
	    key: 'Push',
	    value: function Push(workerPath) {
	      return new _push.Push(workerPath);
	    }
	  }, {
	    key: 'Queues',
	    get: function get() {
	      return API.Queues;
	    }

	    /**
	     * @return {API.PageHidden}
	     */

	  }, {
	    key: 'PageHidden',
	    get: function get() {
	      return API.PageHidden;
	    }
	  }]);

	  return Noty;
	}();

	// Document visibility change controller


	exports.default = Noty;
	if (typeof window !== 'undefined') {
	  Utils.visibilityChangeFlow();
	}
	module.exports = exports['default'];

	/***/ }),
	/* 7 */
	/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ());
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var arguments$1 = arguments;

	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments$1[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] };

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


	/***/ }),
	/* 8 */
	/***/ (function(module, exports) {

	var g;

	// This works in non-strict mode
	g = (function() {
		return this;
	})();

	try {
		// This works if eval is allowed (see CSP)
		g = g || Function("return this")() || (1,eval)("this");
	} catch(e) {
		// This works if the window reference is available
		if(typeof window === "object")
			{ g = window; }
	}

	// g can still be undefined, but nothing to do about it...
	// We return undefined, instead of nothing here, so it's
	// easier to handle this case. if(!global) { ...}

	module.exports = g;


	/***/ }),
	/* 9 */
	/***/ (function(module, exports) {

	/* (ignored) */

	/***/ })
	/******/ ]);
	});

	});

	var Noty = unwrapExports(noty);

	var defaults$1 = {
	  layout: 'topRight',
	  theme: 'mint',
	  timeout: 5000,
	  progressBar: true,
	  closeWith: ['click']
	};
	var VueNoty = {
	  options: {},
	  setOptions: function setOptions(opts) {
	    this.options = Object.assign({}, defaults$1, opts);
	    return this;
	  },
	  create: function create(params) {
	    return new Noty(params);
	  },
	  show: function show(text) {
	    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'alert';
	    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    var params = Object.assign({}, this.options, opts, {
	      type: type,
	      text: text
	    });
	    var noty = this.create(params);
	    noty.show();
	    return noty;
	  },
	  success: function success(text) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    return this.show(text, 'success', opts);
	  },
	  error: function error(text) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    return this.show(text, 'error', opts);
	  },
	  warning: function warning(text) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    return this.show(text, 'warning', opts);
	  },
	  info: function info(text) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    return this.show(text, 'info', opts);
	  }
	};
	var NotyPlugin = {
	  install: function install(Vue, opts) {
	    var noty = VueNoty.setOptions(opts);
	    Vue.prototype.$noty = noty;
	    Vue.noty = noty;
	  }
	};

	function _defineProperty$1f(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function ownKeys$X(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    if (enumerableOnly) symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    });
	    keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2$1(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};

	    if (i % 2) {
	      ownKeys$X(Object(source), true).forEach(function (key) {
	        _defineProperty$1f(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	    } else {
	      ownKeys$X(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	  }

	  return target;
	}

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};

	  var target = _objectWithoutPropertiesLoose(source, excluded);

	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	function _toConsumableArray$9(arr) {
	  return _arrayWithoutHoles$9(arr) || _iterableToArray$9(arr) || _nonIterableSpread$9();
	}

	function _arrayWithoutHoles$9(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  }
	}

	function _iterableToArray$9(iter) {
	  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
	}

	function _nonIterableSpread$9() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance");
	}

	var genericInstall = function genericInstall(Vue) {
	  Vue._ = lodash__default;
	  Object.defineProperties(Vue.prototype, {
	    _: {
	      get: function get() {
	        return lodash__default;
	      }
	    }
	  });
	};

	var LodashPlugin = {
	  install: function install(Vue, options) {
	    if (options && options.name) {
	      Vue[options.name] = lodash__default;
	      Object.defineProperties(Vue.prototype, _defineProperty$1f({}, options.name, {
	        get: function get() {
	          return lodash__default;
	        }
	      }));
	    }

	    genericInstall(Vue);
	  }
	};

	/**
	  * vee-validate v3.2.0
	  * (c) 2019 Abdelrahman Awad
	  * @license MIT
	  */

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        var arguments$1 = arguments;

	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments$1[i];
	            for (var p in s) { if (Object.prototype.hasOwnProperty.call(s, p)) { t[p] = s[p]; } }
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	function __awaiter(thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) { throw t[1]; } return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) { throw new TypeError("Generator is already executing."); }
	        while (_) { try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) { return t; }
	            if (y = 0, t) { op = [op[0] & 2, t.value]; }
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) { _.ops.pop(); }
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; } }
	        if (op[0] & 5) { throw op[1]; } return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	function __spreadArrays() {
	    var arguments$1 = arguments;

	    for (var s = 0, i = 0, il = arguments.length; i < il; i++) { s += arguments$1[i].length; }
	    for (var r = Array(s), k = 0, i = 0; i < il; i++)
	        { for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	            { r[k] = a[j]; } }
	    return r;
	}

	function isNaN$1(value) {
	    // NaN is the one value that does not equal itself.
	    // eslint-disable-next-line
	    return value !== value;
	}
	function isNullOrUndefined(value) {
	    return value === null || value === undefined;
	}
	function isEmptyArray(arr) {
	    return Array.isArray(arr) && arr.length === 0;
	}
	var isObject$2 = function (obj) {
	    return obj !== null && obj && typeof obj === 'object' && !Array.isArray(obj);
	};
	/**
	 * Shallow object comparison.
	 */
	function isEqual(lhs, rhs) {
	    if (lhs instanceof RegExp && rhs instanceof RegExp) {
	        return isEqual(lhs.source, rhs.source) && isEqual(lhs.flags, rhs.flags);
	    }
	    if (Array.isArray(lhs) && Array.isArray(rhs)) {
	        if (lhs.length !== rhs.length)
	            { return false; }
	        for (var i = 0; i < lhs.length; i++) {
	            if (!isEqual(lhs[i], rhs[i])) {
	                return false;
	            }
	        }
	        return true;
	    }
	    // if both are objects, compare each key recursively.
	    if (isObject$2(lhs) && isObject$2(rhs)) {
	        return (Object.keys(lhs).every(function (key) {
	            return isEqual(lhs[key], rhs[key]);
	        }) &&
	            Object.keys(rhs).every(function (key) {
	                return isEqual(lhs[key], rhs[key]);
	            }));
	    }
	    if (isNaN$1(lhs) && isNaN$1(rhs)) {
	        return true;
	    }
	    return lhs === rhs;
	}
	// Checks if a given value is not an empty string or null or undefined.
	function isSpecified(val) {
	    if (val === '') {
	        return false;
	    }
	    return !isNullOrUndefined(val);
	}
	function isCallable(fn) {
	    return typeof fn === 'function';
	}
	function isLocator(value) {
	    return isCallable(value) && !!value.__locatorRef;
	}

	function findIndex$2(arrayLike, predicate) {
	    var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);
	    if (isCallable(array.findIndex)) {
	        return array.findIndex(predicate);
	    }
	    /* istanbul ignore next */
	    for (var i = 0; i < array.length; i++) {
	        if (predicate(array[i], i)) {
	            return i;
	        }
	    }
	    /* istanbul ignore next */
	    return -1;
	}
	/**
	 * finds the first element that satisfies the predicate callback, polyfills array.find
	 */
	function find$2(arrayLike, predicate) {
	    var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);
	    var idx = findIndex$2(array, predicate);
	    return idx === -1 ? undefined : array[idx];
	}
	function includes$2(collection, item) {
	    return collection.indexOf(item) !== -1;
	}
	/**
	 * Converts an array-like object to array, provides a simple polyfill for Array.from
	 */
	function toArray(arrayLike) {
	    if (isCallable(Array.from)) {
	        return Array.from(arrayLike);
	    }
	    /* istanbul ignore next */
	    return _copyArray(arrayLike);
	}
	/* istanbul ignore next */
	function _copyArray(arrayLike) {
	    var array = [];
	    var length = arrayLike.length;
	    for (var i = 0; i < length; i++) {
	        array.push(arrayLike[i]);
	    }
	    return array;
	}
	function values$1(obj) {
	    if (isCallable(Object.values)) {
	        return Object.values(obj);
	    }
	    // fallback to keys()
	    /* istanbul ignore next */
	    return Object.keys(obj).map(function (k) { return obj[k]; });
	}
	function merge$1(target, source) {
	    Object.keys(source).forEach(function (key) {
	        if (isObject$2(source[key])) {
	            if (!target[key]) {
	                target[key] = {};
	            }
	            merge$1(target[key], source[key]);
	            return;
	        }
	        target[key] = source[key];
	    });
	    return target;
	}

	function createFlags() {
	    return {
	        untouched: true,
	        touched: false,
	        dirty: false,
	        pristine: true,
	        valid: false,
	        invalid: false,
	        validated: false,
	        pending: false,
	        required: false,
	        changed: false,
	        passed: false,
	        failed: false
	    };
	}

	function identity$1(x) {
	    return x;
	}
	function debounce$2(fn, wait, token) {
	    if (wait === void 0) { wait = 0; }
	    if (token === void 0) { token = { cancelled: false }; }
	    if (wait === 0) {
	        return fn;
	    }
	    var timeout;
	    return function () {
	        var arguments$1 = arguments;

	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments$1[_i];
	        }
	        var later = function () {
	            timeout = undefined;
	            // check if the fn call was cancelled.
	            if (!token.cancelled)
	                { fn.apply(void 0, args); }
	        };
	        // because we might want to use Node.js setTimout for SSR.
	        clearTimeout(timeout);
	        timeout = setTimeout(later, wait);
	    };
	}

	/**
	 * Emits a warning to the console
	 */
	function warn$2(message) {
	    console.warn("[vee-validate] " + message);
	}
	/**
	 * Replaces placeholder values in a string with their actual values
	 */
	function interpolate(template, values) {
	    return template.replace(/{([^}]+)}/g, function (_, p) {
	        return p in values ? values[p] : "{" + p + "}";
	    });
	}

	var RULES = {};
	function normalizeSchema(schema) {
	    var _a;
	    if ((_a = schema.params) === null || _a === void 0 ? void 0 : _a.length) {
	        schema.params = schema.params.map(function (param) {
	            if (typeof param === 'string') {
	                return { name: param };
	            }
	            return param;
	        });
	    }
	    return schema;
	}
	var RuleContainer = /** @class */ (function () {
	    function RuleContainer() {
	    }
	    RuleContainer.extend = function (name, schema) {
	        // if rule already exists, overwrite it.
	        var rule = normalizeSchema(schema);
	        if (RULES[name]) {
	            RULES[name] = merge$1(RULES[name], schema);
	            return;
	        }
	        RULES[name] = __assign({ lazy: false, computesRequired: false }, rule);
	    };
	    RuleContainer.isLazy = function (name) {
	        var _a;
	        return !!((_a = RULES[name]) === null || _a === void 0 ? void 0 : _a.lazy);
	    };
	    RuleContainer.isRequireRule = function (name) {
	        var _a;
	        return !!((_a = RULES[name]) === null || _a === void 0 ? void 0 : _a.computesRequired);
	    };
	    RuleContainer.getRuleDefinition = function (ruleName) {
	        return RULES[ruleName];
	    };
	    return RuleContainer;
	}());
	/**
	 * Adds a custom validator to the list of validation rules.
	 */
	function extend(name, schema) {
	    // makes sure new rules are properly formatted.
	    guardExtend(name, schema);
	    // Full schema object.
	    if (typeof schema === 'object') {
	        RuleContainer.extend(name, schema);
	        return;
	    }
	    RuleContainer.extend(name, {
	        validate: schema
	    });
	}
	/**
	 * Guards from extension violations.
	 */
	function guardExtend(name, validator) {
	    if (isCallable(validator)) {
	        return;
	    }
	    if (isCallable(validator.validate)) {
	        return;
	    }
	    if (RuleContainer.getRuleDefinition(name)) {
	        return;
	    }
	    throw new Error("Extension Error: The validator '" + name + "' must be a function or have a 'validate' method.");
	}

	var DEFAULT_CONFIG = {
	    defaultMessage: "{_field_} is not valid.",
	    skipOptional: true,
	    classes: {
	        touched: 'touched',
	        untouched: 'untouched',
	        valid: 'valid',
	        invalid: 'invalid',
	        pristine: 'pristine',
	        dirty: 'dirty' // control has been interacted with
	    },
	    bails: true,
	    mode: 'aggressive',
	    useConstraintAttrs: true
	};
	var currentConfig = __assign({}, DEFAULT_CONFIG);
	var getConfig = function () { return currentConfig; };
	var setConfig$1 = function (newConf) {
	    currentConfig = __assign(__assign({}, currentConfig), newConf);
	};
	var configure = function (cfg) {
	    setConfig$1(cfg);
	};

	/**
	 * Normalizes the given rules expression.
	 */
	function normalizeRules(rules) {
	    // if falsy value return an empty object.
	    var acc = {};
	    Object.defineProperty(acc, '_$$isNormalized', {
	        value: true,
	        writable: false,
	        enumerable: false,
	        configurable: false
	    });
	    if (!rules) {
	        return acc;
	    }
	    // Object is already normalized, skip.
	    if (isObject$2(rules) && rules._$$isNormalized) {
	        return rules;
	    }
	    if (isObject$2(rules)) {
	        return Object.keys(rules).reduce(function (prev, curr) {
	            var params = [];
	            if (rules[curr] === true) {
	                params = [];
	            }
	            else if (Array.isArray(rules[curr])) {
	                params = rules[curr];
	            }
	            else if (isObject$2(rules[curr])) {
	                params = rules[curr];
	            }
	            else {
	                params = [rules[curr]];
	            }
	            if (rules[curr] !== false) {
	                prev[curr] = buildParams(curr, params);
	            }
	            return prev;
	        }, acc);
	    }
	    /* istanbul ignore if */
	    if (typeof rules !== 'string') {
	        warn$2('rules must be either a string or an object.');
	        return acc;
	    }
	    return rules.split('|').reduce(function (prev, rule) {
	        var parsedRule = parseRule(rule);
	        if (!parsedRule.name) {
	            return prev;
	        }
	        prev[parsedRule.name] = buildParams(parsedRule.name, parsedRule.params);
	        return prev;
	    }, acc);
	}
	function buildParams(ruleName, provided) {
	    var ruleSchema = RuleContainer.getRuleDefinition(ruleName);
	    if (!ruleSchema) {
	        return provided;
	    }
	    var params = {};
	    if (!ruleSchema.params && !Array.isArray(provided)) {
	        throw new Error('You provided an object params to a rule that has no defined schema.');
	    }
	    // Rule probably uses an array for their args, keep it as is.
	    if (Array.isArray(provided) && !ruleSchema.params) {
	        return provided;
	    }
	    var definedParams;
	    // collect the params schema.
	    if (!ruleSchema.params || (ruleSchema.params.length < provided.length && Array.isArray(provided))) {
	        var lastDefinedParam_1;
	        // collect any additional parameters in the last item.
	        definedParams = provided.map(function (_, idx) {
	            var _a;
	            var param = (_a = ruleSchema.params) === null || _a === void 0 ? void 0 : _a[idx];
	            lastDefinedParam_1 = param || lastDefinedParam_1;
	            if (!param) {
	                param = lastDefinedParam_1;
	            }
	            return param;
	        });
	    }
	    else {
	        definedParams = ruleSchema.params;
	    }
	    // Match the provided array length with a temporary schema.
	    for (var i = 0; i < definedParams.length; i++) {
	        var options = definedParams[i];
	        var value = options.default;
	        // if the provided is an array, map element value.
	        if (Array.isArray(provided)) {
	            if (i in provided) {
	                value = provided[i];
	            }
	        }
	        else {
	            // If the param exists in the provided object.
	            if (options.name in provided) {
	                value = provided[options.name];
	                // if the provided is the first param value.
	            }
	            else if (definedParams.length === 1) {
	                value = provided;
	            }
	        }
	        // if the param is a target, resolve the target value.
	        if (options.isTarget) {
	            value = createLocator(value, options.cast);
	        }
	        // A target param using interpolation
	        if (typeof value === 'string' && value[0] === '@') {
	            value = createLocator(value.slice(1), options.cast);
	        }
	        // If there is a transformer defined.
	        if (!isLocator(value) && options.cast) {
	            value = options.cast(value);
	        }
	        // already been set, probably multiple values.
	        if (params[options.name]) {
	            params[options.name] = Array.isArray(params[options.name]) ? params[options.name] : [params[options.name]];
	            params[options.name].push(value);
	        }
	        else {
	            // set the value.
	            params[options.name] = value;
	        }
	    }
	    return params;
	}
	/**
	 * Parses a rule string expression.
	 */
	var parseRule = function (rule) {
	    var params = [];
	    var name = rule.split(':')[0];
	    if (includes$2(rule, ':')) {
	        params = rule
	            .split(':')
	            .slice(1)
	            .join(':')
	            .split(',');
	    }
	    return { name: name, params: params };
	};
	function createLocator(value, castFn) {
	    var locator = function (crossTable) {
	        var val = crossTable[value];
	        return castFn ? castFn(val) : val;
	    };
	    locator.__locatorRef = value;
	    return locator;
	}
	function extractLocators(params) {
	    if (Array.isArray(params)) {
	        return params.filter(isLocator);
	    }
	    return Object.keys(params)
	        .filter(function (key) { return isLocator(params[key]); })
	        .map(function (key) { return params[key]; });
	}

	/**
	 * Validates a value against the rules.
	 */
	function validate(value, rules, options) {
	    if (options === void 0) { options = {}; }
	    var _a, _b, _c, _d, _e, _f;
	    return __awaiter(this, void 0, void 0, function () {
	        var shouldBail, skipIfEmpty, field, result, errors, failedRules, regenerateMap;
	        return __generator(this, function (_g) {
	            switch (_g.label) {
	                case 0:
	                    shouldBail = (_a = options) === null || _a === void 0 ? void 0 : _a.bails;
	                    skipIfEmpty = (_b = options) === null || _b === void 0 ? void 0 : _b.skipIfEmpty;
	                    field = {
	                        name: ((_c = options) === null || _c === void 0 ? void 0 : _c.name) || '{field}',
	                        rules: normalizeRules(rules),
	                        bails: (shouldBail !== null && shouldBail !== void 0 ? shouldBail : true),
	                        skipIfEmpty: (skipIfEmpty !== null && skipIfEmpty !== void 0 ? skipIfEmpty : true),
	                        forceRequired: false,
	                        crossTable: ((_d = options) === null || _d === void 0 ? void 0 : _d.values) || {},
	                        names: ((_e = options) === null || _e === void 0 ? void 0 : _e.names) || {},
	                        customMessages: ((_f = options) === null || _f === void 0 ? void 0 : _f.customMessages) || {}
	                    };
	                    return [4 /*yield*/, _validate(field, value, options)];
	                case 1:
	                    result = _g.sent();
	                    errors = [];
	                    failedRules = {};
	                    regenerateMap = {};
	                    result.errors.forEach(function (e) {
	                        var msg = e.msg();
	                        errors.push(msg);
	                        failedRules[e.rule] = msg;
	                        regenerateMap[e.rule] = e.msg;
	                    });
	                    return [2 /*return*/, {
	                            valid: result.valid,
	                            errors: errors,
	                            failedRules: failedRules,
	                            regenerateMap: regenerateMap
	                        }];
	            }
	        });
	    });
	}
	/**
	 * Starts the validation process.
	 */
	function _validate(field, value, _a) {
	    var _b = (_a === void 0 ? {} : _a).isInitial, isInitial = _b === void 0 ? false : _b;
	    return __awaiter(this, void 0, void 0, function () {
	        var _c, shouldSkip, errors, rules, length, i, rule, result;
	        return __generator(this, function (_d) {
	            switch (_d.label) {
	                case 0: return [4 /*yield*/, _shouldSkip(field, value)];
	                case 1:
	                    _c = _d.sent(), shouldSkip = _c.shouldSkip, errors = _c.errors;
	                    if (shouldSkip) {
	                        return [2 /*return*/, {
	                                valid: !errors.length,
	                                errors: errors
	                            }];
	                    }
	                    rules = Object.keys(field.rules).filter(function (rule) { return !RuleContainer.isRequireRule(rule); });
	                    length = rules.length;
	                    i = 0;
	                    _d.label = 2;
	                case 2:
	                    if (!(i < length)) { return [3 /*break*/, 5]; }
	                    if (isInitial && RuleContainer.isLazy(rules[i])) {
	                        return [3 /*break*/, 4];
	                    }
	                    rule = rules[i];
	                    return [4 /*yield*/, _test(field, value, {
	                            name: rule,
	                            params: field.rules[rule]
	                        })];
	                case 3:
	                    result = _d.sent();
	                    if (!result.valid && result.error) {
	                        errors.push(result.error);
	                        if (field.bails) {
	                            return [2 /*return*/, {
	                                    valid: false,
	                                    errors: errors
	                                }];
	                        }
	                    }
	                    _d.label = 4;
	                case 4:
	                    i++;
	                    return [3 /*break*/, 2];
	                case 5: return [2 /*return*/, {
	                        valid: !errors.length,
	                        errors: errors
	                    }];
	            }
	        });
	    });
	}
	function _shouldSkip(field, value) {
	    return __awaiter(this, void 0, void 0, function () {
	        var requireRules, length, errors, isEmpty, isEmptyAndOptional, isRequired, i, rule, result;
	        return __generator(this, function (_a) {
	            switch (_a.label) {
	                case 0:
	                    requireRules = Object.keys(field.rules).filter(RuleContainer.isRequireRule);
	                    length = requireRules.length;
	                    errors = [];
	                    isEmpty = isNullOrUndefined(value) || value === '' || isEmptyArray(value);
	                    isEmptyAndOptional = isEmpty && field.skipIfEmpty;
	                    isRequired = false;
	                    i = 0;
	                    _a.label = 1;
	                case 1:
	                    if (!(i < length)) { return [3 /*break*/, 4]; }
	                    rule = requireRules[i];
	                    return [4 /*yield*/, _test(field, value, {
	                            name: rule,
	                            params: field.rules[rule]
	                        })];
	                case 2:
	                    result = _a.sent();
	                    if (!isObject$2(result)) {
	                        throw new Error('Require rules has to return an object (see docs)');
	                    }
	                    if (result.required) {
	                        isRequired = true;
	                    }
	                    if (!result.valid && result.error) {
	                        errors.push(result.error);
	                        // Exit early as the field is required and failed validation.
	                        if (field.bails) {
	                            return [2 /*return*/, {
	                                    shouldSkip: true,
	                                    errors: errors
	                                }];
	                        }
	                    }
	                    _a.label = 3;
	                case 3:
	                    i++;
	                    return [3 /*break*/, 1];
	                case 4:
	                    if (isEmpty && !isRequired && !field.skipIfEmpty) {
	                        return [2 /*return*/, {
	                                shouldSkip: false,
	                                errors: errors
	                            }];
	                    }
	                    // field is configured to run through the pipeline regardless
	                    if (!field.bails && !isEmptyAndOptional) {
	                        return [2 /*return*/, {
	                                shouldSkip: false,
	                                errors: errors
	                            }];
	                    }
	                    // skip if the field is not required and has an empty value.
	                    return [2 /*return*/, {
	                            shouldSkip: !isRequired && isEmpty,
	                            errors: errors
	                        }];
	            }
	        });
	    });
	}
	/**
	 * Tests a single input value against a rule.
	 */
	function _test(field, value, rule) {
	    return __awaiter(this, void 0, void 0, function () {
	        var ruleSchema, normalizedValue, params, result, values_1;
	        return __generator(this, function (_a) {
	            switch (_a.label) {
	                case 0:
	                    ruleSchema = RuleContainer.getRuleDefinition(rule.name);
	                    if (!ruleSchema || !ruleSchema.validate) {
	                        throw new Error("No such validator '" + rule.name + "' exists.");
	                    }
	                    normalizedValue = ruleSchema.castValue ? ruleSchema.castValue(value) : value;
	                    params = fillTargetValues(rule.params, field.crossTable);
	                    return [4 /*yield*/, ruleSchema.validate(normalizedValue, params)];
	                case 1:
	                    result = _a.sent();
	                    if (typeof result === 'string') {
	                        values_1 = __assign(__assign({}, (params || {})), { _field_: field.name, _value_: value, _rule_: rule.name });
	                        return [2 /*return*/, {
	                                valid: false,
	                                error: { rule: rule.name, msg: function () { return interpolate(result, values_1); } }
	                            }];
	                    }
	                    if (!isObject$2(result)) {
	                        result = { valid: result, data: {} };
	                    }
	                    return [2 /*return*/, {
	                            valid: result.valid,
	                            required: result.required,
	                            data: result.data || {},
	                            error: result.valid ? undefined : _generateFieldError(field, value, ruleSchema, rule.name, params, result.data)
	                        }];
	            }
	        });
	    });
	}
	/**
	 * Generates error messages.
	 */
	function _generateFieldError(field, value, ruleSchema, ruleName, params, data) {
	    var message = field.customMessages[ruleName] || ruleSchema.message;
	    var ruleTargets = _getRuleTargets(field, ruleSchema, ruleName);
	    var _a = _getUserTargets(field, ruleSchema, ruleName, message), userTargets = _a.userTargets, userMessage = _a.userMessage;
	    var values = __assign(__assign(__assign(__assign(__assign({}, (params || {})), (data || {})), { _field_: field.name, _value_: value, _rule_: ruleName }), ruleTargets), userTargets);
	    return {
	        msg: function () { return _normalizeMessage(userMessage || getConfig().defaultMessage, field.name, values); },
	        rule: ruleName
	    };
	}
	function _getRuleTargets(field, ruleSchema, ruleName) {
	    var params = ruleSchema.params;
	    if (!params) {
	        return {};
	    }
	    var numTargets = params.filter(function (param) { return param.isTarget; }).length;
	    if (numTargets <= 0) {
	        return {};
	    }
	    var names = {};
	    var ruleConfig = field.rules[ruleName];
	    if (!Array.isArray(ruleConfig) && isObject$2(ruleConfig)) {
	        ruleConfig = params.map(function (param) {
	            return ruleConfig[param.name];
	        });
	    }
	    for (var index = 0; index < params.length; index++) {
	        var param = params[index];
	        if (!param.isTarget) {
	            continue;
	        }
	        var key = ruleConfig[index];
	        if (isLocator(key)) {
	            key = key.__locatorRef;
	        }
	        var name_1 = field.names[key] || key;
	        if (numTargets === 1) {
	            names._target_ = name_1;
	            break;
	        }
	        names["_" + param.name + "Target_"] = name_1;
	    }
	    return names;
	}
	function _getUserTargets(field, ruleSchema, ruleName, userMessage) {
	    var userTargets = {};
	    var rules = field.rules[ruleName];
	    var params = ruleSchema.params || [];
	    // early return if no rules
	    if (!rules) {
	        return {};
	    }
	    // check all rules to convert targets
	    Object.keys(rules).forEach(function (key, index) {
	        // get the rule
	        var rule = rules[key];
	        if (!isLocator(rule)) {
	            return {};
	        }
	        // get associated parameter
	        var param = params[index];
	        if (!param) {
	            return {};
	        }
	        // grab the name of the target
	        var name = rule.__locatorRef;
	        var placeholder = "_" + name + "Target_";
	        userTargets[placeholder] = field.names[name] || name;
	        userTargets[name] = field.names[name] || name;
	        // update template if it's a string
	        if (typeof userMessage === 'string') {
	            var rx = new RegExp("{" + param.name + "}", 'g');
	            userMessage = userMessage.replace(rx, "{" + placeholder + "}");
	        }
	    });
	    return {
	        userTargets: userTargets,
	        userMessage: userMessage
	    };
	}
	function _normalizeMessage(template, field, values) {
	    if (typeof template === 'function') {
	        return template(field, values);
	    }
	    return interpolate(template, __assign(__assign({}, values), { _field_: field }));
	}
	function fillTargetValues(params, crossTable) {
	    if (Array.isArray(params)) {
	        return params;
	    }
	    var values = {};
	    var normalize = function (value) {
	        if (isLocator(value)) {
	            return value(crossTable);
	        }
	        return value;
	    };
	    Object.keys(params).forEach(function (param) {
	        values[param] = normalize(params[param]);
	    });
	    return values;
	}

	var aggressive = function () { return ({
	    on: ['input', 'blur']
	}); };
	var lazy = function () { return ({
	    on: ['change']
	}); };
	var eager = function (_a) {
	    var errors = _a.errors;
	    if (errors.length) {
	        return {
	            on: ['input', 'change']
	        };
	    }
	    return {
	        on: ['change', 'blur']
	    };
	};
	var passive = function () { return ({
	    on: []
	}); };
	var modes = {
	    aggressive: aggressive,
	    eager: eager,
	    passive: passive,
	    lazy: lazy
	};

	var EVENT_BUS = new Vue();
	function localeChanged() {
	    EVENT_BUS.$emit('change:locale');
	}

	var Dictionary = /** @class */ (function () {
	    function Dictionary(locale, dictionary) {
	        this.container = {};
	        this.locale = locale;
	        this.merge(dictionary);
	    }
	    Dictionary.prototype.resolve = function (field, rule, values) {
	        return this.format(this.locale, field, rule, values);
	    };
	    Dictionary.prototype.format = function (locale, field, rule, values) {
	        var _a, _b, _c, _d, _e, _f, _g, _h;
	        var message;
	        // find if specific message for that field was specified.
	        message = ((_c = (_b = (_a = this.container[locale]) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c[rule]) || ((_e = (_d = this.container[locale]) === null || _d === void 0 ? void 0 : _d.messages) === null || _e === void 0 ? void 0 : _e[rule]);
	        if (!message) {
	            message = '{field} is not valid';
	        }
	        field = (_h = (_g = (_f = this.container[locale]) === null || _f === void 0 ? void 0 : _f.names) === null || _g === void 0 ? void 0 : _g[field], (_h !== null && _h !== void 0 ? _h : field));
	        return isCallable(message) ? message(field, values) : interpolate(message, __assign(__assign({}, values), { _field_: field }));
	    };
	    Dictionary.prototype.merge = function (dictionary) {
	        merge$1(this.container, dictionary);
	    };
	    Dictionary.prototype.hasRule = function (name) {
	        var _a, _b;
	        return !!((_b = (_a = this.container[this.locale]) === null || _a === void 0 ? void 0 : _a.messages) === null || _b === void 0 ? void 0 : _b[name]);
	    };
	    return Dictionary;
	}());
	var DICTIONARY;
	function localize(locale, dictionary) {
	    var _a;
	    if (!DICTIONARY) {
	        DICTIONARY = new Dictionary('en', {});
	        setConfig$1({
	            defaultMessage: function (field, values) {
	                var _a;
	                return DICTIONARY.resolve(field, (_a = values) === null || _a === void 0 ? void 0 : _a._rule_, values || {});
	            }
	        });
	    }
	    if (typeof locale === 'string') {
	        DICTIONARY.locale = locale;
	        if (dictionary) {
	            DICTIONARY.merge((_a = {}, _a[locale] = dictionary, _a));
	        }
	        localeChanged();
	        return;
	    }
	    DICTIONARY.merge(locale);
	}

	var isEvent$1 = function (evt) {
	    if (!evt) {
	        return false;
	    }
	    if (typeof Event !== 'undefined' && isCallable(Event) && evt instanceof Event) {
	        return true;
	    }
	    // this is for IE
	    /* istanbul ignore next */
	    if (evt && evt.srcElement) {
	        return true;
	    }
	    return false;
	};
	function normalizeEventValue(value) {
	    var _a, _b;
	    if (!isEvent$1(value)) {
	        return value;
	    }
	    var input = value.target;
	    if (input.type === 'file' && input.files) {
	        return toArray(input.files);
	    }
	    // If the input has a `v-model.number` modifier applied.
	    if ((_a = input._vModifiers) === null || _a === void 0 ? void 0 : _a.number) {
	        // as per the spec the v-model.number uses parseFloat
	        var valueAsNumber = parseFloat(input.value);
	        if (isNaN$1(valueAsNumber)) {
	            return input.value;
	        }
	        return valueAsNumber;
	    }
	    if ((_b = input._vModifiers) === null || _b === void 0 ? void 0 : _b.trim) {
	        var trimmedValue = typeof input.value === 'string' ? input.value.trim() : input.value;
	        return trimmedValue;
	    }
	    return input.value;
	}

	var isTextInput = function (vnode) {
	    var _a, _b;
	    var attrs = ((_a = vnode.data) === null || _a === void 0 ? void 0 : _a.attrs) || vnode.elm;
	    // it will fallback to being a text input per browsers spec.
	    if (vnode.tag === 'input' && (!attrs || !attrs.type)) {
	        return true;
	    }
	    if (vnode.tag === 'textarea') {
	        return true;
	    }
	    return includes$2(['text', 'password', 'search', 'email', 'tel', 'url', 'number'], (_b = attrs) === null || _b === void 0 ? void 0 : _b.type);
	};
	// export const isCheckboxOrRadioInput = (vnode: VNode): boolean => {
	//   const attrs = (vnode.data && vnode.data.attrs) || vnode.elm;
	//   return includes(['radio', 'checkbox'], attrs && attrs.type);
	// };
	// Gets the model object on the vnode.
	function findModel(vnode) {
	    if (!vnode.data) {
	        return undefined;
	    }
	    // Component Model
	    // THIS IS NOT TYPED IN OFFICIAL VUE TYPINGS
	    // eslint-disable-next-line
	    var nonStandardVNodeData = vnode.data;
	    if ('model' in nonStandardVNodeData) {
	        return nonStandardVNodeData.model;
	    }
	    if (!vnode.data.directives) {
	        return undefined;
	    }
	    return find$2(vnode.data.directives, function (d) { return d.name === 'model'; });
	}
	function findValue(vnode) {
	    var _a, _b, _c;
	    var model = findModel(vnode);
	    if (model) {
	        return { value: model.value };
	    }
	    var config = findModelConfig(vnode);
	    var prop = ((_a = config) === null || _a === void 0 ? void 0 : _a.prop) || 'value';
	    if (((_b = vnode.componentOptions) === null || _b === void 0 ? void 0 : _b.propsData) && prop in vnode.componentOptions.propsData) {
	        var propsDataWithValue = vnode.componentOptions.propsData;
	        return { value: propsDataWithValue[prop] };
	    }
	    if (((_c = vnode.data) === null || _c === void 0 ? void 0 : _c.domProps) && 'value' in vnode.data.domProps) {
	        return { value: vnode.data.domProps.value };
	    }
	    return undefined;
	}
	function extractChildren(vnode) {
	    if (Array.isArray(vnode)) {
	        return vnode;
	    }
	    if (Array.isArray(vnode.children)) {
	        return vnode.children;
	    }
	    /* istanbul ignore next */
	    if (vnode.componentOptions && Array.isArray(vnode.componentOptions.children)) {
	        return vnode.componentOptions.children;
	    }
	    return [];
	}
	function extractVNodes(vnode) {
	    if (!Array.isArray(vnode) && findValue(vnode) !== undefined) {
	        return [vnode];
	    }
	    var children = extractChildren(vnode);
	    return children.reduce(function (nodes, node) {
	        var candidates = extractVNodes(node);
	        if (candidates.length) {
	            nodes.push.apply(nodes, candidates);
	        }
	        return nodes;
	    }, []);
	}
	// Resolves v-model config if exists.
	function findModelConfig(vnode) {
	    /* istanbul ignore next */
	    if (!vnode.componentOptions)
	        { return null; }
	    // This is also not typed in the standard Vue TS.
	    return vnode.componentOptions.Ctor.options.model;
	}
	// Adds a listener to vnode listener object.
	function mergeVNodeListeners(obj, eventName, handler) {
	    // no listener at all.
	    if (isNullOrUndefined(obj[eventName])) {
	        obj[eventName] = [handler];
	        return;
	    }
	    // Is an invoker.
	    if (isCallable(obj[eventName]) && obj[eventName].fns) {
	        var invoker = obj[eventName];
	        invoker.fns = Array.isArray(invoker.fns) ? invoker.fns : [invoker.fns];
	        if (!includes$2(invoker.fns, handler)) {
	            invoker.fns.push(handler);
	        }
	        return;
	    }
	    if (isCallable(obj[eventName])) {
	        var prev = obj[eventName];
	        obj[eventName] = [prev];
	    }
	    if (Array.isArray(obj[eventName]) && !includes$2(obj[eventName], handler)) {
	        obj[eventName].push(handler);
	    }
	}
	// Adds a listener to a native HTML vnode.
	function addNativeNodeListener(node, eventName, handler) {
	    /* istanbul ignore next */
	    if (!node.data) {
	        node.data = {};
	    }
	    if (isNullOrUndefined(node.data.on)) {
	        node.data.on = {};
	    }
	    mergeVNodeListeners(node.data.on, eventName, handler);
	}
	// Adds a listener to a Vue component vnode.
	function addComponentNodeListener(node, eventName, handler) {
	    /* istanbul ignore next */
	    if (!node.componentOptions) {
	        return;
	    }
	    /* istanbul ignore next */
	    if (!node.componentOptions.listeners) {
	        node.componentOptions.listeners = {};
	    }
	    mergeVNodeListeners(node.componentOptions.listeners, eventName, handler);
	}
	function addVNodeListener(vnode, eventName, handler) {
	    if (vnode.componentOptions) {
	        addComponentNodeListener(vnode, eventName, handler);
	        return;
	    }
	    addNativeNodeListener(vnode, eventName, handler);
	}
	// Determines if `change` should be used over `input` for listeners.
	function getInputEventName(vnode, model) {
	    var _a, _b;
	    // Is a component.
	    if (vnode.componentOptions) {
	        var event_1 = (findModelConfig(vnode) || { event: 'input' }).event;
	        return event_1;
	    }
	    // Lazy Models typically use change event
	    if ((_b = (_a = model) === null || _a === void 0 ? void 0 : _a.modifiers) === null || _b === void 0 ? void 0 : _b.lazy) {
	        return 'change';
	    }
	    // is a textual-type input.
	    if (isTextInput(vnode)) {
	        return 'input';
	    }
	    return 'change';
	}
	function resolveTextualRules(vnode) {
	    var _a;
	    var attrs = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.attrs;
	    var rules = {};
	    if (!attrs)
	        { return rules; }
	    if (attrs.type === 'email' && RuleContainer.getRuleDefinition('email')) {
	        rules.email = ['multiple' in attrs];
	    }
	    if (attrs.pattern && RuleContainer.getRuleDefinition('regex')) {
	        rules.regex = attrs.pattern;
	    }
	    if (attrs.maxlength >= 0 && RuleContainer.getRuleDefinition('max')) {
	        rules.max = attrs.maxlength;
	    }
	    if (attrs.minlength >= 0 && RuleContainer.getRuleDefinition('min')) {
	        rules.min = attrs.minlength;
	    }
	    if (attrs.type === 'number') {
	        if (isSpecified(attrs.min) && RuleContainer.getRuleDefinition('min_value')) {
	            rules.min_value = Number(attrs.min);
	        }
	        if (isSpecified(attrs.max) && RuleContainer.getRuleDefinition('max_value')) {
	            rules.max_value = Number(attrs.max);
	        }
	    }
	    return rules;
	}
	function resolveRules(vnode) {
	    var _a;
	    var htmlTags = ['input', 'select'];
	    var attrs = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.attrs;
	    if (!includes$2(htmlTags, vnode.tag) || !attrs) {
	        return {};
	    }
	    var rules = {};
	    if ('required' in attrs && attrs.required !== false && RuleContainer.getRuleDefinition('required')) {
	        rules.required = attrs.type === 'checkbox' ? [true] : true;
	    }
	    if (isTextInput(vnode)) {
	        return normalizeRules(__assign(__assign({}, rules), resolveTextualRules(vnode)));
	    }
	    return normalizeRules(rules);
	}
	function normalizeChildren(context, slotProps) {
	    if (context.$scopedSlots.default) {
	        return context.$scopedSlots.default(slotProps) || [];
	    }
	    return context.$slots.default || [];
	}

	/**
	 * Determines if a provider needs to run validation.
	 */
	function shouldValidate(ctx, value) {
	    // when an immediate/initial validation is needed and wasn't done before.
	    if (!ctx._ignoreImmediate && ctx.immediate) {
	        return true;
	    }
	    // when the value changes for whatever reason.
	    if (ctx.value !== value && ctx.normalizedEvents.length) {
	        return true;
	    }
	    // when it needs validation due to props/cross-fields changes.
	    if (ctx._needsValidation) {
	        return true;
	    }
	    // when the initial value is undefined and the field wasn't rendered yet.
	    if (!ctx.initialized && value === undefined) {
	        return true;
	    }
	    return false;
	}
	function createValidationCtx(ctx) {
	    return __assign(__assign({}, ctx.flags), { errors: ctx.errors, classes: ctx.classes, failedRules: ctx.failedRules, reset: function () { return ctx.reset(); }, validate: function () {
	            var arguments$1 = arguments;

	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments$1[_i];
	            }
	            return ctx.validate.apply(ctx, args);
	        }, ariaInput: {
	            'aria-invalid': ctx.flags.invalid ? 'true' : 'false',
	            'aria-required': ctx.isRequired ? 'true' : 'false',
	            'aria-errormessage': "vee_" + ctx.id
	        }, ariaMsg: {
	            id: "vee_" + ctx.id,
	            'aria-live': ctx.errors.length ? 'assertive' : 'off'
	        } });
	}
	function onRenderUpdate(vm, value) {
	    if (!vm.initialized) {
	        vm.initialValue = value;
	    }
	    var validateNow = shouldValidate(vm, value);
	    vm._needsValidation = false;
	    vm.value = value;
	    vm._ignoreImmediate = true;
	    if (!validateNow) {
	        return;
	    }
	    var validate = function () { return vm.validateSilent().then(vm.immediate || vm.flags.validated ? vm.applyResult : identity$1); };
	    if (vm.initialized) {
	        validate();
	        return;
	    }
	    vm.$once('hook:mounted', function () { return validate(); });
	}
	function computeModeSetting(ctx) {
	    var compute = (isCallable(ctx.mode) ? ctx.mode : modes[ctx.mode]);
	    return compute(ctx);
	}
	// Creates the common handlers for a validatable context.
	function createCommonHandlers(vm) {
	    if (!vm.$veeOnInput) {
	        vm.$veeOnInput = function (e) {
	            vm.syncValue(e); // track and keep the value updated.
	            vm.setFlags({ dirty: true, pristine: false });
	        };
	    }
	    var onInput = vm.$veeOnInput;
	    if (!vm.$veeOnBlur) {
	        vm.$veeOnBlur = function () {
	            vm.setFlags({ touched: true, untouched: false });
	        };
	    }
	    // Blur event listener.
	    var onBlur = vm.$veeOnBlur;
	    var onValidate = vm.$veeHandler;
	    var mode = computeModeSetting(vm);
	    // Handle debounce changes.
	    if (!onValidate || vm.$veeDebounce !== vm.debounce) {
	        onValidate = debounce$2(function () {
	            vm.$nextTick(function () {
	                var pendingPromise = vm.validateSilent();
	                // avoids race conditions between successive validations.
	                vm._pendingValidation = pendingPromise;
	                pendingPromise.then(function (result) {
	                    if (pendingPromise === vm._pendingValidation) {
	                        vm.applyResult(result);
	                        vm._pendingValidation = undefined;
	                    }
	                });
	            });
	        }, mode.debounce || vm.debounce);
	        // Cache the handler so we don't create it each time.
	        vm.$veeHandler = onValidate;
	        // cache the debounce value so we detect if it was changed.
	        vm.$veeDebounce = vm.debounce;
	    }
	    return { onInput: onInput, onBlur: onBlur, onValidate: onValidate };
	}
	// Adds all plugin listeners to the vnode.
	function addListeners(vm, node) {
	    var _a;
	    var value = findValue(node);
	    // cache the input eventName.
	    vm._inputEventName = vm._inputEventName || getInputEventName(node, findModel(node));
	    onRenderUpdate(vm, (_a = value) === null || _a === void 0 ? void 0 : _a.value);
	    var _b = createCommonHandlers(vm), onInput = _b.onInput, onBlur = _b.onBlur, onValidate = _b.onValidate;
	    addVNodeListener(node, vm._inputEventName, onInput);
	    addVNodeListener(node, 'blur', onBlur);
	    // add the validation listeners.
	    vm.normalizedEvents.forEach(function (evt) {
	        addVNodeListener(node, evt, onValidate);
	    });
	    vm.initialized = true;
	}

	var PROVIDER_COUNTER = 0;
	function data$1() {
	    var errors = [];
	    var defaultValues = {
	        errors: errors,
	        value: undefined,
	        initialized: false,
	        initialValue: undefined,
	        flags: createFlags(),
	        failedRules: {},
	        isActive: true,
	        id: ''
	    };
	    return defaultValues;
	}
	var ValidationProvider = Vue.extend({
	    inject: {
	        $_veeObserver: {
	            from: '$_veeObserver',
	            default: function () {
	                if (!this.$vnode.context.$_veeObserver) {
	                    this.$vnode.context.$_veeObserver = createObserver();
	                }
	                return this.$vnode.context.$_veeObserver;
	            }
	        }
	    },
	    props: {
	        vid: {
	            type: String,
	            default: ''
	        },
	        name: {
	            type: String,
	            default: null
	        },
	        mode: {
	            type: [String, Function],
	            default: function () {
	                return getConfig().mode;
	            }
	        },
	        rules: {
	            type: [Object, String],
	            default: null
	        },
	        immediate: {
	            type: Boolean,
	            default: false
	        },
	        bails: {
	            type: Boolean,
	            default: function () { return getConfig().bails; }
	        },
	        skipIfEmpty: {
	            type: Boolean,
	            default: function () { return getConfig().skipOptional; }
	        },
	        debounce: {
	            type: Number,
	            default: 0
	        },
	        tag: {
	            type: String,
	            default: 'span'
	        },
	        slim: {
	            type: Boolean,
	            default: false
	        },
	        disabled: {
	            type: Boolean,
	            default: false
	        },
	        customMessages: {
	            type: Object,
	            default: function () {
	                return {};
	            }
	        }
	    },
	    watch: {
	        rules: {
	            deep: true,
	            handler: function (val, oldVal) {
	                this._needsValidation = !isEqual(val, oldVal);
	            }
	        }
	    },
	    data: data$1,
	    computed: {
	        fieldDeps: function () {
	            var _this = this;
	            return Object.keys(this.normalizedRules).reduce(function (acc, rule) {
	                var deps = extractLocators(_this.normalizedRules[rule]).map(function (dep) { return dep.__locatorRef; });
	                acc.push.apply(acc, deps);
	                deps.forEach(function (depName) {
	                    watchCrossFieldDep(_this, depName);
	                });
	                return acc;
	            }, []);
	        },
	        normalizedEvents: function () {
	            var _this = this;
	            var on = computeModeSetting(this).on;
	            return (on || []).map(function (e) {
	                if (e === 'input') {
	                    return _this._inputEventName;
	                }
	                return e;
	            });
	        },
	        isRequired: function () {
	            var rules = __assign(__assign({}, this._resolvedRules), this.normalizedRules);
	            var isRequired = Object.keys(rules).some(RuleContainer.isRequireRule);
	            this.flags.required = !!isRequired;
	            return isRequired;
	        },
	        classes: function () {
	            var names = getConfig().classes;
	            return computeClassObj(names, this.flags);
	        },
	        normalizedRules: function () {
	            return normalizeRules(this.rules);
	        }
	    },
	    created: function () {
	        var _this = this;
	        var onLocaleChanged = function () {
	            if (!_this.flags.validated) {
	                return;
	            }
	            var regenerateMap = _this._regenerateMap;
	            if (regenerateMap) {
	                var errors_1 = [];
	                var failedRules_1 = {};
	                Object.keys(regenerateMap).forEach(function (rule) {
	                    var msg = regenerateMap[rule]();
	                    errors_1.push(msg);
	                    failedRules_1[rule] = msg;
	                });
	                _this.applyResult({ errors: errors_1, failedRules: failedRules_1, regenerateMap: regenerateMap });
	                return;
	            }
	            _this.validate();
	        };
	        EVENT_BUS.$on('change:locale', onLocaleChanged);
	        this.$on('hook:beforeDestroy', function () {
	            EVENT_BUS.$off('change:locale', onLocaleChanged);
	        });
	    },
	    render: function (h) {
	        var _this = this;
	        this.registerField();
	        var ctx = createValidationCtx(this);
	        var children = normalizeChildren(this, ctx);
	        // Handle single-root slot.
	        extractVNodes(children).forEach(function (input) {
	            // resolved rules are not reactive because it has a new reference each time.
	            // causing infinite render-loops.
	            // So we are comparing them manually to decide if we need to validate or not.
	            var resolved = getConfig().useConstraintAttrs ? resolveRules(input) : {};
	            if (!isEqual(_this._resolvedRules, resolved)) {
	                _this._needsValidation = true;
	            }
	            _this._resolvedRules = resolved;
	            addListeners(_this, input);
	        });
	        return this.slim && children.length <= 1 ? children[0] : h(this.tag, children);
	    },
	    beforeDestroy: function () {
	        // cleanup reference.
	        this.$_veeObserver.unsubscribe(this.id);
	    },
	    activated: function () {
	        this.isActive = true;
	    },
	    deactivated: function () {
	        this.isActive = false;
	    },
	    methods: {
	        setFlags: function (flags) {
	            var _this = this;
	            Object.keys(flags).forEach(function (flag) {
	                _this.flags[flag] = flags[flag];
	            });
	        },
	        syncValue: function (v) {
	            var value = normalizeEventValue(v);
	            this.value = value;
	            this.flags.changed = this.initialValue !== value;
	        },
	        reset: function () {
	            this.errors = [];
	            this.initialValue = this.value;
	            var flags = createFlags();
	            flags.required = this.isRequired;
	            this.setFlags(flags);
	            this.validateSilent();
	        },
	        validate: function () {
	            var arguments$1 = arguments;

	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments$1[_i];
	            }
	            return __awaiter(this, void 0, void 0, function () {
	                var result;
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            if (args.length > 0) {
	                                this.syncValue(args[0]);
	                            }
	                            return [4 /*yield*/, this.validateSilent()];
	                        case 1:
	                            result = _a.sent();
	                            this.applyResult(result);
	                            return [2 /*return*/, result];
	                    }
	                });
	            });
	        },
	        validateSilent: function () {
	            return __awaiter(this, void 0, void 0, function () {
	                var rules, result;
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            this.setFlags({ pending: true });
	                            rules = __assign(__assign({}, this._resolvedRules), this.normalizedRules);
	                            Object.defineProperty(rules, '_$$isNormalized', {
	                                value: true,
	                                writable: false,
	                                enumerable: false,
	                                configurable: false
	                            });
	                            return [4 /*yield*/, validate(this.value, rules, __assign(__assign({ name: this.name }, createLookup(this)), { bails: this.bails, skipIfEmpty: this.skipIfEmpty, isInitial: !this.initialized, customMessages: this.customMessages }))];
	                        case 1:
	                            result = _a.sent();
	                            this.setFlags({
	                                pending: false,
	                                valid: result.valid,
	                                invalid: !result.valid
	                            });
	                            return [2 /*return*/, result];
	                    }
	                });
	            });
	        },
	        setErrors: function (errors) {
	            this.applyResult({ errors: errors, failedRules: {} });
	        },
	        applyResult: function (_a) {
	            var errors = _a.errors, failedRules = _a.failedRules, regenerateMap = _a.regenerateMap;
	            this.errors = errors;
	            this._regenerateMap = regenerateMap;
	            this.failedRules = __assign({}, (failedRules || {}));
	            this.setFlags({
	                valid: !errors.length,
	                passed: !errors.length,
	                invalid: !!errors.length,
	                failed: !!errors.length,
	                validated: true,
	                changed: this.value !== this.initialValue
	            });
	        },
	        registerField: function () {
	            updateRenderingContextRefs(this);
	        }
	    }
	});
	function computeClassObj(names, flags) {
	    var acc = {};
	    var keys = Object.keys(flags);
	    var length = keys.length;
	    var _loop_1 = function (i) {
	        var flag = keys[i];
	        var className = (names && names[flag]) || flag;
	        var value = flags[flag];
	        if (isNullOrUndefined(value)) {
	            return "continue";
	        }
	        if ((flag === 'valid' || flag === 'invalid') && !flags.validated) {
	            return "continue";
	        }
	        if (typeof className === 'string') {
	            acc[className] = value;
	        }
	        else if (Array.isArray(className)) {
	            className.forEach(function (cls) {
	                acc[cls] = value;
	            });
	        }
	    };
	    for (var i = 0; i < length; i++) {
	        _loop_1(i);
	    }
	    return acc;
	}
	function createLookup(vm) {
	    var providers = vm.$_veeObserver.refs;
	    var reduced = {
	        names: {},
	        values: {}
	    };
	    return vm.fieldDeps.reduce(function (acc, depName) {
	        if (!providers[depName]) {
	            return acc;
	        }
	        acc.values[depName] = providers[depName].value;
	        acc.names[depName] = providers[depName].name;
	        return acc;
	    }, reduced);
	}
	function extractId(vm) {
	    if (vm.vid) {
	        return vm.vid;
	    }
	    if (vm.name) {
	        return vm.name;
	    }
	    if (vm.id) {
	        return vm.id;
	    }
	    PROVIDER_COUNTER++;
	    return "_vee_" + PROVIDER_COUNTER;
	}
	function updateRenderingContextRefs(vm) {
	    var providedId = extractId(vm);
	    var id = vm.id;
	    // Nothing has changed.
	    if (!vm.isActive || (id === providedId && vm.$_veeObserver.refs[id])) {
	        return;
	    }
	    // vid was changed.
	    if (id !== providedId && vm.$_veeObserver.refs[id] === vm) {
	        vm.$_veeObserver.unsubscribe(id);
	    }
	    vm.id = providedId;
	    vm.$_veeObserver.subscribe(vm);
	}
	function createObserver() {
	    return {
	        refs: {},
	        subscribe: function (vm) {
	            this.refs[vm.id] = vm;
	        },
	        unsubscribe: function (id) {
	            delete this.refs[id];
	        }
	    };
	}
	function watchCrossFieldDep(ctx, depName, withHooks) {
	    if (withHooks === void 0) { withHooks = true; }
	    var providers = ctx.$_veeObserver.refs;
	    if (!ctx._veeWatchers) {
	        ctx._veeWatchers = {};
	    }
	    if (!providers[depName] && withHooks) {
	        return ctx.$once('hook:mounted', function () {
	            watchCrossFieldDep(ctx, depName, false);
	        });
	    }
	    if (!isCallable(ctx._veeWatchers[depName]) && providers[depName]) {
	        ctx._veeWatchers[depName] = providers[depName].$watch('value', function () {
	            if (ctx.flags.validated) {
	                ctx._needsValidation = true;
	                ctx.validate();
	            }
	        });
	    }
	}

	var FLAGS_STRATEGIES = [
	    ['pristine', 'every'],
	    ['dirty', 'some'],
	    ['touched', 'some'],
	    ['untouched', 'every'],
	    ['valid', 'every'],
	    ['invalid', 'some'],
	    ['pending', 'some'],
	    ['validated', 'every'],
	    ['changed', 'some'],
	    ['passed', 'every'],
	    ['failed', 'some']
	];
	var OBSERVER_COUNTER = 0;
	function data$1$1() {
	    var refs = {};
	    var errors = {};
	    var flags = createObserverFlags();
	    var fields = {};
	    // FIXME: Not sure of this one can be typed, circular type reference.
	    var observers = [];
	    return {
	        id: '',
	        refs: refs,
	        observers: observers,
	        errors: errors,
	        flags: flags,
	        fields: fields
	    };
	}
	function provideSelf() {
	    return {
	        $_veeObserver: this
	    };
	}
	var ValidationObserver = Vue.extend({
	    name: 'ValidationObserver',
	    provide: provideSelf,
	    inject: {
	        $_veeObserver: {
	            from: '$_veeObserver',
	            default: function () {
	                if (!this.$vnode.context.$_veeObserver) {
	                    return null;
	                }
	                return this.$vnode.context.$_veeObserver;
	            }
	        }
	    },
	    props: {
	        tag: {
	            type: String,
	            default: 'span'
	        },
	        vid: {
	            type: String,
	            default: function () {
	                return "obs_" + OBSERVER_COUNTER++;
	            }
	        },
	        slim: {
	            type: Boolean,
	            default: false
	        },
	        disabled: {
	            type: Boolean,
	            default: false
	        }
	    },
	    data: data$1$1,
	    created: function () {
	        var _this = this;
	        this.id = this.vid;
	        register(this);
	        var onChange = debounce$2(function (_a) {
	            var errors = _a.errors, flags = _a.flags, fields = _a.fields;
	            _this.errors = errors;
	            _this.flags = flags;
	            _this.fields = fields;
	        }, 16);
	        this.$watch(function () {
	            var vms = __spreadArrays(values$1(_this.refs), _this.observers);
	            var errors = {};
	            var flags = createObserverFlags();
	            var fields = {};
	            var length = vms.length;
	            for (var i = 0; i < length; i++) {
	                var vm = vms[i];
	                // validation provider
	                if (Array.isArray(vm.errors)) {
	                    errors[vm.id] = vm.errors;
	                    fields[vm.id] = __assign({ id: vm.id, name: vm.name, failedRules: vm.failedRules }, vm.flags);
	                    continue;
	                }
	                // Nested observer, merge errors and fields
	                errors = __assign(__assign({}, errors), vm.errors);
	                fields = __assign(__assign({}, fields), vm.fields);
	            }
	            FLAGS_STRATEGIES.forEach(function (_a) {
	                var flag = _a[0], method = _a[1];
	                flags[flag] = vms[method](function (vm) { return vm.flags[flag]; });
	            });
	            return { errors: errors, flags: flags, fields: fields };
	        }, onChange);
	    },
	    activated: function () {
	        register(this);
	    },
	    deactivated: function () {
	        unregister(this);
	    },
	    beforeDestroy: function () {
	        unregister(this);
	    },
	    render: function (h) {
	        var children = normalizeChildren(this, prepareSlotProps(this));
	        return this.slim && children.length <= 1 ? children[0] : h(this.tag, { on: this.$listeners }, children);
	    },
	    methods: {
	        subscribe: function (subscriber, kind) {
	            var _a;
	            if (kind === void 0) { kind = 'provider'; }
	            if (kind === 'observer') {
	                this.observers.push(subscriber);
	                return;
	            }
	            this.refs = __assign(__assign({}, this.refs), (_a = {}, _a[subscriber.id] = subscriber, _a));
	        },
	        unsubscribe: function (id, kind) {
	            if (kind === void 0) { kind = 'provider'; }
	            if (kind === 'provider') {
	                var provider = this.refs[id];
	                if (!provider) {
	                    return;
	                }
	                this.$delete(this.refs, id);
	                return;
	            }
	            var idx = findIndex$2(this.observers, function (o) { return o.id === id; });
	            if (idx !== -1) {
	                this.observers.splice(idx, 1);
	            }
	        },
	        validate: function (_a) {
	            var _b = (_a === void 0 ? {} : _a).silent, silent = _b === void 0 ? false : _b;
	            return __awaiter(this, void 0, void 0, function () {
	                var results;
	                return __generator(this, function (_c) {
	                    switch (_c.label) {
	                        case 0: return [4 /*yield*/, Promise.all(__spreadArrays(values$1(this.refs)
	                                .filter(function (r) { return !r.disabled; })
	                                .map(function (ref) { return ref[silent ? 'validateSilent' : 'validate']().then(function (r) { return r.valid; }); }), this.observers.filter(function (o) { return !o.disabled; }).map(function (obs) { return obs.validate({ silent: silent }); })))];
	                        case 1:
	                            results = _c.sent();
	                            return [2 /*return*/, results.every(function (r) { return r; })];
	                    }
	                });
	            });
	        },
	        handleSubmit: function (cb) {
	            return __awaiter(this, void 0, void 0, function () {
	                var isValid;
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0: return [4 /*yield*/, this.validate()];
	                        case 1:
	                            isValid = _a.sent();
	                            if (!isValid || !cb) {
	                                return [2 /*return*/];
	                            }
	                            return [2 /*return*/, cb()];
	                    }
	                });
	            });
	        },
	        reset: function () {
	            return __spreadArrays(values$1(this.refs), this.observers).forEach(function (ref) { return ref.reset(); });
	        },
	        setErrors: function (errors) {
	            var _this = this;
	            Object.keys(errors).forEach(function (key) {
	                var provider = _this.refs[key];
	                if (!provider)
	                    { return; }
	                provider.setErrors(errors[key] || []);
	            });
	            this.observers.forEach(function (observer) {
	                observer.setErrors(errors);
	            });
	        }
	    }
	});
	function unregister(vm) {
	    if (vm.$_veeObserver) {
	        vm.$_veeObserver.unsubscribe(vm.id, 'observer');
	    }
	}
	function register(vm) {
	    if (vm.$_veeObserver) {
	        vm.$_veeObserver.subscribe(vm, 'observer');
	    }
	}
	function prepareSlotProps(vm) {
	    return __assign(__assign({}, vm.flags), { errors: vm.errors, fields: vm.fields, validate: vm.validate, passes: vm.handleSubmit, handleSubmit: vm.handleSubmit, reset: vm.reset });
	}
	// Creates a modified version of validation flags
	function createObserverFlags() {
	    return __assign(__assign({}, createFlags()), { valid: true, invalid: false });
	}

	var code = "vi";
	var messages = {
		alpha: "{_field_} chỉ có thể chứa các kí tự chữ",
		alpha_dash: "{_field_} có thể chứa các kí tự chữ (A-Z a-z), số (0-9), gạch ngang (-) và gạch dưới (_)",
		alpha_num: "{_field_} chỉ có thể chứa các kí tự chữ và số",
		alpha_spaces: "{_field_} chỉ có thế chứa các kí tự và khoảng trắng",
		between: "{_field_} phải có giá trị nằm trong khoảng giữa {min} và {max}",
		confirmed: "{_field_} khác với {target}",
		digits: "Trường {_field_} chỉ có thể chứa các kí tự số và bắt buộc phải có độ dài là {length}",
		dimensions: "{_field_} phải có chiều rộng {width} pixels và chiều cao {height} pixels",
		email: "{_field_} phải là một địa chỉ email hợp lệ",
		excluded: "{_field_} phải chứa một giá trị hợp lệ",
		ext: "{_field_} phải là một tệp",
		image: "Trường {_field_} phải là một ảnh",
		oneOf: "{_field_} phải là một giá trị",
		max: "{_field_} không thể có nhiều hơn {length} kí tự",
		max_value: "{_field_} phải nhỏ hơn hoặc bằng {max}",
		mimes: "{_field_} phải chứa kiểu tệp phù hợp",
		min: "{_field_} phải chứa ít nhất {length} kí tự",
		min_value: "{_field_} phải lớn hơn hoặc bằng {min}",
		numeric: "{_field_} chỉ có thể có các kí tự số",
		regex: "{_field_} có định dạng không đúng",
		required: "{_field_} là bắt buộc",
		required_if: "{_field_} là bắt buộc",
		size: "{_field_} chỉ có thể chứa tệp nhỏ hơn {size}KB"
	};
	var vi = {
		code: code,
		messages: messages
	};

	/**
	  * vee-validate v3.2.0
	  * (c) 2019 Abdelrahman Awad
	  * @license MIT
	  */
	/**
	 * Some Alpha Regex helpers.
	 * https://github.com/chriso/validator.js/blob/master/src/lib/alpha.js
	 */
	var alpha = {
	    en: /^[A-Z]*$/i,
	    cs: /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]*$/i,
	    da: /^[A-ZÆØÅ]*$/i,
	    de: /^[A-ZÄÖÜß]*$/i,
	    es: /^[A-ZÁÉÍÑÓÚÜ]*$/i,
	    fr: /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]*$/i,
	    it: /^[A-Z\xC0-\xFF]*$/i,
	    lt: /^[A-ZĄČĘĖĮŠŲŪŽ]*$/i,
	    nl: /^[A-ZÉËÏÓÖÜ]*$/i,
	    hu: /^[A-ZÁÉÍÓÖŐÚÜŰ]*$/i,
	    pl: /^[A-ZĄĆĘŚŁŃÓŻŹ]*$/i,
	    pt: /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$/i,
	    ru: /^[А-ЯЁ]*$/i,
	    sk: /^[A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ]*$/i,
	    sr: /^[A-ZČĆŽŠĐ]*$/i,
	    sv: /^[A-ZÅÄÖ]*$/i,
	    tr: /^[A-ZÇĞİıÖŞÜ]*$/i,
	    uk: /^[А-ЩЬЮЯЄІЇҐ]*$/i,
	    ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]*$/,
	    az: /^[A-ZÇƏĞİıÖŞÜ]*$/i
	};
	var alphaSpaces = {
	    en: /^[A-Z\s]*$/i,
	    cs: /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ\s]*$/i,
	    da: /^[A-ZÆØÅ\s]*$/i,
	    de: /^[A-ZÄÖÜß\s]*$/i,
	    es: /^[A-ZÁÉÍÑÓÚÜ\s]*$/i,
	    fr: /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ\s]*$/i,
	    it: /^[A-Z\xC0-\xFF\s]*$/i,
	    lt: /^[A-ZĄČĘĖĮŠŲŪŽ\s]*$/i,
	    nl: /^[A-ZÉËÏÓÖÜ\s]*$/i,
	    hu: /^[A-ZÁÉÍÓÖŐÚÜŰ\s]*$/i,
	    pl: /^[A-ZĄĆĘŚŁŃÓŻŹ\s]*$/i,
	    pt: /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ\s]*$/i,
	    ru: /^[А-ЯЁ\s]*$/i,
	    sk: /^[A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ\s]*$/i,
	    sr: /^[A-ZČĆŽŠĐ\s]*$/i,
	    sv: /^[A-ZÅÄÖ\s]*$/i,
	    tr: /^[A-ZÇĞİıÖŞÜ\s]*$/i,
	    uk: /^[А-ЩЬЮЯЄІЇҐ\s]*$/i,
	    ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ\s]*$/,
	    az: /^[A-ZÇƏĞİıÖŞÜ\s]*$/i
	};
	var alphanumeric = {
	    en: /^[0-9A-Z]*$/i,
	    cs: /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]*$/i,
	    da: /^[0-9A-ZÆØÅ]$/i,
	    de: /^[0-9A-ZÄÖÜß]*$/i,
	    es: /^[0-9A-ZÁÉÍÑÓÚÜ]*$/i,
	    fr: /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]*$/i,
	    it: /^[0-9A-Z\xC0-\xFF]*$/i,
	    lt: /^[0-9A-ZĄČĘĖĮŠŲŪŽ]*$/i,
	    hu: /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]*$/i,
	    nl: /^[0-9A-ZÉËÏÓÖÜ]*$/i,
	    pl: /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]*$/i,
	    pt: /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$/i,
	    ru: /^[0-9А-ЯЁ]*$/i,
	    sk: /^[0-9A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ]*$/i,
	    sr: /^[0-9A-ZČĆŽŠĐ]*$/i,
	    sv: /^[0-9A-ZÅÄÖ]*$/i,
	    tr: /^[0-9A-ZÇĞİıÖŞÜ]*$/i,
	    uk: /^[0-9А-ЩЬЮЯЄІЇҐ]*$/i,
	    ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]*$/,
	    az: /^[0-9A-ZÇƏĞİıÖŞÜ]*$/i
	};
	var alphaDash = {
	    en: /^[0-9A-Z_-]*$/i,
	    cs: /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ_-]*$/i,
	    da: /^[0-9A-ZÆØÅ_-]*$/i,
	    de: /^[0-9A-ZÄÖÜß_-]*$/i,
	    es: /^[0-9A-ZÁÉÍÑÓÚÜ_-]*$/i,
	    fr: /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ_-]*$/i,
	    it: /^[0-9A-Z\xC0-\xFF_-]*$/i,
	    lt: /^[0-9A-ZĄČĘĖĮŠŲŪŽ_-]*$/i,
	    nl: /^[0-9A-ZÉËÏÓÖÜ_-]*$/i,
	    hu: /^[0-9A-ZÁÉÍÓÖŐÚÜŰ_-]*$/i,
	    pl: /^[0-9A-ZĄĆĘŚŁŃÓŻŹ_-]*$/i,
	    pt: /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ_-]*$/i,
	    ru: /^[0-9А-ЯЁ_-]*$/i,
	    sk: /^[0-9A-ZÁÄČĎÉÍĹĽŇÓŔŠŤÚÝŽ_-]*$/i,
	    sr: /^[0-9A-ZČĆŽŠĐ_-]*$/i,
	    sv: /^[0-9A-ZÅÄÖ_-]*$/i,
	    tr: /^[0-9A-ZÇĞİıÖŞÜ_-]*$/i,
	    uk: /^[0-9А-ЩЬЮЯЄІЇҐ_-]*$/i,
	    ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ_-]*$/,
	    az: /^[0-9A-ZÇƏĞİıÖŞÜ_-]*$/i
	};

	var validate$1 = function (value, _a) {
	    var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return validate$1(val, { locale: locale }); });
	    }
	    // Match at least one locale.
	    if (!locale) {
	        return Object.keys(alpha).some(function (loc) { return alpha[loc].test(value); });
	    }
	    return (alpha[locale] || alpha.en).test(value);
	};
	var params = [
	    {
	        name: 'locale'
	    }
	];
	var alpha$1 = {
	    validate: validate$1,
	    params: params
	};

	var validate$1$1 = function (value, _a) {
	    var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return validate$1$1(val, { locale: locale }); });
	    }
	    // Match at least one locale.
	    if (!locale) {
	        return Object.keys(alphaDash).some(function (loc) { return alphaDash[loc].test(value); });
	    }
	    return (alphaDash[locale] || alphaDash.en).test(value);
	};
	var params$1 = [
	    {
	        name: 'locale'
	    }
	];
	var alpha_dash = {
	    validate: validate$1$1,
	    params: params$1
	};

	var validate$2 = function (value, _a) {
	    var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return validate$2(val, { locale: locale }); });
	    }
	    // Match at least one locale.
	    if (!locale) {
	        return Object.keys(alphanumeric).some(function (loc) { return alphanumeric[loc].test(value); });
	    }
	    return (alphanumeric[locale] || alphanumeric.en).test(value);
	};
	var params$2 = [
	    {
	        name: 'locale'
	    }
	];
	var alpha_num = {
	    validate: validate$2,
	    params: params$2
	};

	var validate$3 = function (value, _a) {
	    var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return validate$3(val, { locale: locale }); });
	    }
	    // Match at least one locale.
	    if (!locale) {
	        return Object.keys(alphaSpaces).some(function (loc) { return alphaSpaces[loc].test(value); });
	    }
	    return (alphaSpaces[locale] || alphaSpaces.en).test(value);
	};
	var params$3 = [
	    {
	        name: 'locale'
	    }
	];
	var alpha_spaces = {
	    validate: validate$3,
	    params: params$3
	};

	var validate$4 = function (value, _a) {
	    var _b = _a === void 0 ? {} : _a, min = _b.min, max = _b.max;
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return !!validate$4(val, { min: min, max: max }); });
	    }
	    return Number(min) <= value && Number(max) >= value;
	};
	var params$4 = [
	    {
	        name: 'min'
	    },
	    {
	        name: 'max'
	    }
	];
	var between = {
	    validate: validate$4,
	    params: params$4
	};

	var validate$5 = function (value, _a) {
	    var target = _a.target;
	    return String(value) === String(target);
	};
	var params$5 = [
	    {
	        name: 'target',
	        isTarget: true
	    }
	];
	var confirmed = {
	    validate: validate$5,
	    params: params$5
	};

	var validate$6 = function (value, _a) {
	    var length = _a.length;
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return validate$6(val, { length: length }); });
	    }
	    var strVal = String(value);
	    return /^[0-9]*$/.test(strVal) && strVal.length === length;
	};
	var params$6 = [
	    {
	        name: 'length',
	        cast: function (value) {
	            return Number(value);
	        }
	    }
	];
	var digits = {
	    validate: validate$6,
	    params: params$6
	};

	var validateImage = function (file, width, height) {
	    var URL = window.URL || window.webkitURL;
	    return new Promise(function (resolve) {
	        var image = new Image();
	        image.onerror = function () { return resolve(false); };
	        image.onload = function () { return resolve(image.width === width && image.height === height); };
	        image.src = URL.createObjectURL(file);
	    });
	};
	var validate$7 = function (files, _a) {
	    var width = _a.width, height = _a.height;
	    var list = [];
	    files = Array.isArray(files) ? files : [files];
	    for (var i = 0; i < files.length; i++) {
	        // if file is not an image, reject.
	        if (!/\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(files[i].name)) {
	            return Promise.resolve(false);
	        }
	        list.push(files[i]);
	    }
	    return Promise.all(list.map(function (file) { return validateImage(file, width, height); })).then(function (values) {
	        return values.every(function (v) { return v; });
	    });
	};
	var params$7 = [
	    {
	        name: 'width',
	        cast: function (value) {
	            return Number(value);
	        }
	    },
	    {
	        name: 'height',
	        cast: function (value) {
	            return Number(value);
	        }
	    }
	];
	var dimensions = {
	    validate: validate$7,
	    params: params$7
	};

	var validate$8 = function (value, _a) {
	    var multiple = (_a === void 0 ? {} : _a).multiple;
	    // eslint-disable-next-line
	    var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
	    if (multiple && !Array.isArray(value)) {
	        value = String(value)
	            .split(',')
	            .map(function (emailStr) { return emailStr.trim(); });
	    }
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return re.test(String(val)); });
	    }
	    return re.test(String(value));
	};
	var params$8 = [
	    {
	        name: 'multiple',
	        default: false
	    }
	];
	var email = {
	    validate: validate$8,
	    params: params$8
	};

	function isNullOrUndefined$1(value) {
	    return value === null || value === undefined;
	}
	function isEmptyArray$1(arr) {
	    return Array.isArray(arr) && arr.length === 0;
	}
	function isCallable$1(fn) {
	    return typeof fn === 'function';
	}

	function includes$3(collection, item) {
	    return collection.indexOf(item) !== -1;
	}
	/**
	 * Converts an array-like object to array, provides a simple polyfill for Array.from
	 */
	function toArray$1(arrayLike) {
	    if (isCallable$1(Array.from)) {
	        return Array.from(arrayLike);
	    }
	    /* istanbul ignore next */
	    return _copyArray$1(arrayLike);
	}
	/* istanbul ignore next */
	function _copyArray$1(arrayLike) {
	    var array = [];
	    var length = arrayLike.length;
	    for (var i = 0; i < length; i++) {
	        array.push(arrayLike[i]);
	    }
	    return array;
	}

	var validate$9 = function (value, options) {
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return validate$9(val, options); });
	    }
	    return toArray$1(options).some(function (item) {
	        // eslint-disable-next-line
	        return item == value;
	    });
	};
	var oneOf = {
	    validate: validate$9
	};

	var validate$a = function (value, args) {
	    return !validate$9(value, args);
	};
	var excluded = {
	    validate: validate$a
	};

	var validate$b = function (files, extensions) {
	    var regex = new RegExp(".(" + extensions.join('|') + ")$", 'i');
	    if (Array.isArray(files)) {
	        return files.every(function (file) { return regex.test(file.name); });
	    }
	    return regex.test(files.name);
	};
	var ext = {
	    validate: validate$b
	};

	var validate$c = function (files) {
	    var regex = /\.(jpg|svg|jpeg|png|bmp|gif)$/i;
	    if (Array.isArray(files)) {
	        return files.every(function (file) { return regex.test(file.name); });
	    }
	    return regex.test(files.name);
	};
	var image = {
	    validate: validate$c
	};

	var validate$d = function (value) {
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return /^-?[0-9]+$/.test(String(val)); });
	    }
	    return /^-?[0-9]+$/.test(String(value));
	};
	var integer = {
	    validate: validate$d
	};

	var validate$e = function (value, _a) {
	    var other = _a.other;
	    return value === other;
	};
	var params$9 = [
	    {
	        name: 'other'
	    }
	];
	var is$2 = {
	    validate: validate$e,
	    params: params$9
	};

	var validate$f = function (value, _a) {
	    var other = _a.other;
	    return value !== other;
	};
	var params$a = [
	    {
	        name: 'other'
	    }
	];
	var is_not = {
	    validate: validate$f,
	    params: params$a
	};

	var validate$g = function (value, _a) {
	    var length = _a.length;
	    if (isNullOrUndefined$1(value)) {
	        return false;
	    }
	    if (typeof value === 'number') {
	        value = String(value);
	    }
	    if (!value.length) {
	        value = toArray$1(value);
	    }
	    return value.length === length;
	};
	var params$b = [
	    {
	        name: 'length',
	        cast: function (value) { return Number(value); }
	    }
	];
	var length = {
	    validate: validate$g,
	    params: params$b
	};

	var validate$h = function (value, _a) {
	    var length = _a.length;
	    if (isNullOrUndefined$1(value)) {
	        return length >= 0;
	    }
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return validate$h(val, { length: length }); });
	    }
	    return String(value).length <= length;
	};
	var params$c = [
	    {
	        name: 'length',
	        cast: function (value) {
	            return Number(value);
	        }
	    }
	];
	var max$2 = {
	    validate: validate$h,
	    params: params$c
	};

	var validate$i = function (value, _a) {
	    var max = _a.max;
	    if (isNullOrUndefined$1(value) || value === '') {
	        return false;
	    }
	    if (Array.isArray(value)) {
	        return value.length > 0 && value.every(function (val) { return validate$i(val, { max: max }); });
	    }
	    return Number(value) <= max;
	};
	var params$d = [
	    {
	        name: 'max',
	        cast: function (value) {
	            return Number(value);
	        }
	    }
	];
	var max_value = {
	    validate: validate$i,
	    params: params$d
	};

	var validate$j = function (files, mimes) {
	    var regex = new RegExp(mimes.join('|').replace('*', '.+') + "$", 'i');
	    if (Array.isArray(files)) {
	        return files.every(function (file) { return regex.test(file.type); });
	    }
	    return regex.test(files.type);
	};
	var mimes = {
	    validate: validate$j
	};

	var validate$k = function (value, _a) {
	    var length = _a.length;
	    if (isNullOrUndefined$1(value)) {
	        return false;
	    }
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return validate$k(val, { length: length }); });
	    }
	    return String(value).length >= length;
	};
	var params$e = [
	    {
	        name: 'length',
	        cast: function (value) {
	            return Number(value);
	        }
	    }
	];
	var min$3 = {
	    validate: validate$k,
	    params: params$e
	};

	var validate$l = function (value, _a) {
	    var min = _a.min;
	    if (isNullOrUndefined$1(value) || value === '') {
	        return false;
	    }
	    if (Array.isArray(value)) {
	        return value.length > 0 && value.every(function (val) { return validate$l(val, { min: min }); });
	    }
	    return Number(value) >= min;
	};
	var params$f = [
	    {
	        name: 'min',
	        cast: function (value) {
	            return Number(value);
	        }
	    }
	];
	var min_value = {
	    validate: validate$l,
	    params: params$f
	};

	var ar = /^[٠١٢٣٤٥٦٧٨٩]+$/;
	var en = /^[0-9]+$/;
	var validate$m = function (value) {
	    var testValue = function (val) {
	        var strValue = String(val);
	        return en.test(strValue) || ar.test(strValue);
	    };
	    if (Array.isArray(value)) {
	        return value.every(testValue);
	    }
	    return testValue(value);
	};
	var numeric = {
	    validate: validate$m
	};

	var validate$n = function (value, _a) {
	    var regex = _a.regex;
	    if (Array.isArray(value)) {
	        return value.every(function (val) { return validate$n(val, { regex: regex }); });
	    }
	    return regex.test(String(value));
	};
	var params$g = [
	    {
	        name: 'regex',
	        cast: function (value) {
	            if (typeof value === 'string') {
	                return new RegExp(value);
	            }
	            return value;
	        }
	    }
	];
	var regex = {
	    validate: validate$n,
	    params: params$g
	};

	var validate$o = function (value, _a) {
	    var allowFalse = (_a === void 0 ? { allowFalse: true } : _a).allowFalse;
	    var result = {
	        valid: false,
	        required: true
	    };
	    if (isNullOrUndefined$1(value) || isEmptyArray$1(value)) {
	        return result;
	    }
	    // incase a field considers `false` as an empty value like checkboxes.
	    if (value === false && !allowFalse) {
	        return result;
	    }
	    result.valid = !!String(value).trim().length;
	    return result;
	};
	var computesRequired = true;
	var params$h = [
	    {
	        name: 'allowFalse',
	        default: true
	    }
	];
	var required = {
	    validate: validate$o,
	    params: params$h,
	    computesRequired: computesRequired
	};

	var testEmpty = function (value) {
	    return isEmptyArray$1(value) || includes$3([false, null, undefined], value) || !String(value).trim().length;
	};
	var validate$p = function (value, _a) {
	    var target = _a.target, values = _a.values;
	    var required;
	    if (values && values.length) {
	        if (!Array.isArray(values) && typeof values === 'string') {
	            values = [values];
	        }
	        // eslint-disable-next-line
	        required = values.some(function (val) { return val == String(target).trim(); });
	    }
	    else {
	        required = !testEmpty(target);
	    }
	    if (!required) {
	        return {
	            valid: true,
	            required: required
	        };
	    }
	    return {
	        valid: !testEmpty(value),
	        required: required
	    };
	};
	var params$i = [
	    {
	        name: 'target',
	        isTarget: true
	    },
	    {
	        name: 'values'
	    }
	];
	var computesRequired$1 = true;
	var required_if = {
	    validate: validate$p,
	    params: params$i,
	    computesRequired: computesRequired$1
	};

	var validate$q = function (files, _a) {
	    var size = _a.size;
	    if (isNaN(size)) {
	        return false;
	    }
	    var nSize = size * 1024;
	    if (!Array.isArray(files)) {
	        return files.size <= nSize;
	    }
	    for (var i = 0; i < files.length; i++) {
	        if (files[i].size > nSize) {
	            return false;
	        }
	    }
	    return true;
	};
	var params$j = [
	    {
	        name: 'size',
	        cast: function (value) {
	            return Number(value);
	        }
	    }
	];
	var size = {
	    validate: validate$q,
	    params: params$j
	};

	var rules = /*#__PURE__*/Object.freeze({
		__proto__: null,
		alpha: alpha$1,
		alpha_dash: alpha_dash,
		alpha_num: alpha_num,
		alpha_spaces: alpha_spaces,
		between: between,
		confirmed: confirmed,
		digits: digits,
		dimensions: dimensions,
		email: email,
		excluded: excluded,
		ext: ext,
		image: image,
		integer: integer,
		is: is$2,
		is_not: is_not,
		length: length,
		max: max$2,
		max_value: max_value,
		mimes: mimes,
		min: min$3,
		min_value: min_value,
		numeric: numeric,
		oneOf: oneOf,
		regex: regex,
		required: required,
		required_if: required_if,
		size: size
	});

	var validate$r = function validate(value, _ref) {
	  var _ref$format = _ref.format,
	      format = _ref$format === void 0 ? 'D/M/Y' : _ref$format;
	  return moment$1(value, format, true).isValid();
	};

	var date = {
	  validate: validate$r,
	  params: ['format'],
	  message: '{_field_} không hợp lệ'
	};



	var ownRules = /*#__PURE__*/Object.freeze({
		__proto__: null,
		date: date
	});

	var VeeValidatePlugin = {
	  install: function install(Vue, options) {
	    configure({
	      classes: {
	        valid: 'is-valid',
	        invalid: 'is-invalid'
	      }
	    });
	    localize('vi', {
	      code: vi.code,
	      messages: _objectSpread2$1({}, vi.messages, {
	        integer: '{_field_} phải là một số nguyên'
	      })
	    });
	    extend('date_to', {
	      params: ['date'],
	      validate: function validate(value, _ref) {
	        var to_date = _ref.to_date;
	        var toDate = to_date ? to_date : moment().format('D/M/Y');
	        var toTimestamp = moment(toDate, 'D/M/Y').valueOf();
	        var valueTimestamp = moment(value, 'D/M/Y').valueOf();
	        if (valueTimestamp <= toTimestamp) { return true; }
	        return "{_field_} ph\u1EA3i nh\u1ECF ho\u1EB7c b\u1EB1ng ng\xE0y ".concat(toDate);
	      }
	    });
	    extend('required_if_field', {
	      params: ['field', 'target'],
	      validate: function validate(value, _ref2) {
	        var field = _ref2.field,
	            target = _ref2.target;
	        if (value) { return true; }
	        if (target) { return true; }
	        if (field === 'tuoi') { return 'Ngày sinh hoặc tuổi không được để trống'; }
	        return 'Tuổi hoặc ngày sinh không được để trống';
	      },
	      computesRequired: true
	    });
	    lodash.map(rules, function (obj, name) {
	      return extend(name, obj);
	    });
	    lodash.map(ownRules, function (validateFn, k) {
	      return extend(k, validateFn);
	    });
	    Vue.component('ValidationProvider', ValidationProvider);
	    Vue.component('ValidationObserver', ValidationObserver);
	  }
	};

	var bootstrapDatepicker = createCommonjsModule(function (module, exports) {
	/*!
	 * Datepicker for Bootstrap v1.9.0 (https://github.com/uxsolutions/bootstrap-datepicker)
	 *
	 * Licensed under the Apache License v2.0 (http://www.apache.org/licenses/LICENSE-2.0)
	 */

	(function(factory){
	    {
	        factory($$1);
	    }
	}(function($, undefined$1){
		function UTCDate(){
			return new Date(Date.UTC.apply(Date, arguments));
		}
		function UTCToday(){
			var today = new Date();
			return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
		}
		function isUTCEquals(date1, date2) {
			return (
				date1.getUTCFullYear() === date2.getUTCFullYear() &&
				date1.getUTCMonth() === date2.getUTCMonth() &&
				date1.getUTCDate() === date2.getUTCDate()
			);
		}
		function alias(method, deprecationMsg){
			return function(){
				if (deprecationMsg !== undefined$1) {
					$.fn.datepicker.deprecated(deprecationMsg);
				}

				return this[method].apply(this, arguments);
			};
		}
		function isValidDate(d) {
			return d && !isNaN(d.getTime());
		}

		var DateArray = (function(){
			var extras = {
				get: function(i){
					return this.slice(i)[0];
				},
				contains: function(d){
					// Array.indexOf is not cross-browser;
					// $.inArray doesn't work with Dates
					var val = d && d.valueOf();
					for (var i=0, l=this.length; i < l; i++)
	          // Use date arithmetic to allow dates with different times to match
	          { if (0 <= this[i].valueOf() - val && this[i].valueOf() - val < 1000*60*60*24)
							{ return i; } }
					return -1;
				},
				remove: function(i){
					this.splice(i,1);
				},
				replace: function(new_array){
					if (!new_array)
						{ return; }
					if (!$.isArray(new_array))
						{ new_array = [new_array]; }
					this.clear();
					this.push.apply(this, new_array);
				},
				clear: function(){
					this.length = 0;
				},
				copy: function(){
					var a = new DateArray();
					a.replace(this);
					return a;
				}
			};

			return function(){
				var a = [];
				a.push.apply(a, arguments);
				$.extend(a, extras);
				return a;
			};
		})();


		// Picker object

		var Datepicker = function(element, options){
			$.data(element, 'datepicker', this);

			this._events = [];
			this._secondaryEvents = [];

			this._process_options(options);

			this.dates = new DateArray();
			this.viewDate = this.o.defaultViewDate;
			this.focusDate = null;

			this.element = $(element);
			this.isInput = this.element.is('input');
			this.inputField = this.isInput ? this.element : this.element.find('input');
			this.component = this.element.hasClass('date') ? this.element.find('.add-on, .input-group-addon, .input-group-append, .input-group-prepend, .btn') : false;
			if (this.component && this.component.length === 0)
				{ this.component = false; }
			this.isInline = !this.component && this.element.is('div');

			this.picker = $(DPGlobal.template);

			// Checking templates and inserting
			if (this._check_template(this.o.templates.leftArrow)) {
				this.picker.find('.prev').html(this.o.templates.leftArrow);
			}

			if (this._check_template(this.o.templates.rightArrow)) {
				this.picker.find('.next').html(this.o.templates.rightArrow);
			}

			this._buildEvents();
			this._attachEvents();

			if (this.isInline){
				this.picker.addClass('datepicker-inline').appendTo(this.element);
			}
			else {
				this.picker.addClass('datepicker-dropdown dropdown-menu');
			}

			if (this.o.rtl){
				this.picker.addClass('datepicker-rtl');
			}

			if (this.o.calendarWeeks) {
				this.picker.find('.datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear')
					.attr('colspan', function(i, val){
						return Number(val) + 1;
					});
			}

			this._process_options({
				startDate: this._o.startDate,
				endDate: this._o.endDate,
				daysOfWeekDisabled: this.o.daysOfWeekDisabled,
				daysOfWeekHighlighted: this.o.daysOfWeekHighlighted,
				datesDisabled: this.o.datesDisabled
			});

			this._allow_update = false;
			this.setViewMode(this.o.startView);
			this._allow_update = true;

			this.fillDow();
			this.fillMonths();

			this.update();

			if (this.isInline){
				this.show();
			}
		};

		Datepicker.prototype = {
			constructor: Datepicker,

			_resolveViewName: function(view){
				$.each(DPGlobal.viewModes, function(i, viewMode){
					if (view === i || $.inArray(view, viewMode.names) !== -1){
						view = i;
						return false;
					}
				});

				return view;
			},

			_resolveDaysOfWeek: function(daysOfWeek){
				if (!$.isArray(daysOfWeek))
					{ daysOfWeek = daysOfWeek.split(/[,\s]*/); }
				return $.map(daysOfWeek, Number);
			},

			_check_template: function(tmp){
				try {
					// If empty
					if (tmp === undefined$1 || tmp === "") {
						return false;
					}
					// If no html, everything ok
					if ((tmp.match(/[<>]/g) || []).length <= 0) {
						return true;
					}
					// Checking if html is fine
					var jDom = $(tmp);
					return jDom.length > 0;
				}
				catch (ex) {
					return false;
				}
			},

			_process_options: function(opts){
				// Store raw options for reference
				this._o = $.extend({}, this._o, opts);
				// Processed options
				var o = this.o = $.extend({}, this._o);

				// Check if "de-DE" style date is available, if not language should
				// fallback to 2 letter code eg "de"
				var lang = o.language;
				if (!dates[lang]){
					lang = lang.split('-')[0];
					if (!dates[lang])
						{ lang = defaults.language; }
				}
				o.language = lang;

				// Retrieve view index from any aliases
				o.startView = this._resolveViewName(o.startView);
				o.minViewMode = this._resolveViewName(o.minViewMode);
				o.maxViewMode = this._resolveViewName(o.maxViewMode);

				// Check view is between min and max
				o.startView = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, o.startView));

				// true, false, or Number > 0
				if (o.multidate !== true){
					o.multidate = Number(o.multidate) || false;
					if (o.multidate !== false)
						{ o.multidate = Math.max(0, o.multidate); }
				}
				o.multidateSeparator = String(o.multidateSeparator);

				o.weekStart %= 7;
				o.weekEnd = (o.weekStart + 6) % 7;

				var format = DPGlobal.parseFormat(o.format);
				if (o.startDate !== -Infinity){
					if (!!o.startDate){
						if (o.startDate instanceof Date)
							{ o.startDate = this._local_to_utc(this._zero_time(o.startDate)); }
						else
							{ o.startDate = DPGlobal.parseDate(o.startDate, format, o.language, o.assumeNearbyYear); }
					}
					else {
						o.startDate = -Infinity;
					}
				}
				if (o.endDate !== Infinity){
					if (!!o.endDate){
						if (o.endDate instanceof Date)
							{ o.endDate = this._local_to_utc(this._zero_time(o.endDate)); }
						else
							{ o.endDate = DPGlobal.parseDate(o.endDate, format, o.language, o.assumeNearbyYear); }
					}
					else {
						o.endDate = Infinity;
					}
				}

				o.daysOfWeekDisabled = this._resolveDaysOfWeek(o.daysOfWeekDisabled||[]);
				o.daysOfWeekHighlighted = this._resolveDaysOfWeek(o.daysOfWeekHighlighted||[]);

				o.datesDisabled = o.datesDisabled||[];
				if (!$.isArray(o.datesDisabled)) {
					o.datesDisabled = o.datesDisabled.split(',');
				}
				o.datesDisabled = $.map(o.datesDisabled, function(d){
					return DPGlobal.parseDate(d, format, o.language, o.assumeNearbyYear);
				});

				var plc = String(o.orientation).toLowerCase().split(/\s+/g),
					_plc = o.orientation.toLowerCase();
				plc = $.grep(plc, function(word){
					return /^auto|left|right|top|bottom$/.test(word);
				});
				o.orientation = {x: 'auto', y: 'auto'};
				if (!_plc || _plc === 'auto')
					; // no action
				else if (plc.length === 1){
					switch (plc[0]){
						case 'top':
						case 'bottom':
							o.orientation.y = plc[0];
							break;
						case 'left':
						case 'right':
							o.orientation.x = plc[0];
							break;
					}
				}
				else {
					_plc = $.grep(plc, function(word){
						return /^left|right$/.test(word);
					});
					o.orientation.x = _plc[0] || 'auto';

					_plc = $.grep(plc, function(word){
						return /^top|bottom$/.test(word);
					});
					o.orientation.y = _plc[0] || 'auto';
				}
				if (o.defaultViewDate instanceof Date || typeof o.defaultViewDate === 'string') {
					o.defaultViewDate = DPGlobal.parseDate(o.defaultViewDate, format, o.language, o.assumeNearbyYear);
				} else if (o.defaultViewDate) {
					var year = o.defaultViewDate.year || new Date().getFullYear();
					var month = o.defaultViewDate.month || 0;
					var day = o.defaultViewDate.day || 1;
					o.defaultViewDate = UTCDate(year, month, day);
				} else {
					o.defaultViewDate = UTCToday();
				}
			},
			_applyEvents: function(evs){
				for (var i=0, el, ch, ev; i < evs.length; i++){
					el = evs[i][0];
					if (evs[i].length === 2){
						ch = undefined$1;
						ev = evs[i][1];
					} else if (evs[i].length === 3){
						ch = evs[i][1];
						ev = evs[i][2];
					}
					el.on(ev, ch);
				}
			},
			_unapplyEvents: function(evs){
				for (var i=0, el, ev, ch; i < evs.length; i++){
					el = evs[i][0];
					if (evs[i].length === 2){
						ch = undefined$1;
						ev = evs[i][1];
					} else if (evs[i].length === 3){
						ch = evs[i][1];
						ev = evs[i][2];
					}
					el.off(ev, ch);
				}
			},
			_buildEvents: function(){
	            var events = {
	                keyup: $.proxy(function(e){
	                    if ($.inArray(e.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1)
	                        { this.update(); }
	                }, this),
	                keydown: $.proxy(this.keydown, this),
	                paste: $.proxy(this.paste, this)
	            };

	            if (this.o.showOnFocus === true) {
	                events.focus = $.proxy(this.show, this);
	            }

	            if (this.isInput) { // single input
	                this._events = [
	                    [this.element, events]
	                ];
	            }
	            // component: input + button
	            else if (this.component && this.inputField.length) {
	                this._events = [
	                    // For components that are not readonly, allow keyboard nav
	                    [this.inputField, events],
	                    [this.component, {
	                        click: $.proxy(this.show, this)
	                    }]
	                ];
	            }
				else {
					this._events = [
						[this.element, {
							click: $.proxy(this.show, this),
							keydown: $.proxy(this.keydown, this)
						}]
					];
				}
				this._events.push(
					// Component: listen for blur on element descendants
					[this.element, '*', {
						blur: $.proxy(function(e){
							this._focused_from = e.target;
						}, this)
					}],
					// Input: listen for blur on element
					[this.element, {
						blur: $.proxy(function(e){
							this._focused_from = e.target;
						}, this)
					}]
				);

				if (this.o.immediateUpdates) {
					// Trigger input updates immediately on changed year/month
					this._events.push([this.element, {
						'changeYear changeMonth': $.proxy(function(e){
							this.update(e.date);
						}, this)
					}]);
				}

				this._secondaryEvents = [
					[this.picker, {
						click: $.proxy(this.click, this)
					}],
					[this.picker, '.prev, .next', {
						click: $.proxy(this.navArrowsClick, this)
					}],
					[this.picker, '.day:not(.disabled)', {
						click: $.proxy(this.dayCellClick, this)
					}],
					[$(window), {
						resize: $.proxy(this.place, this)
					}],
					[$(document), {
						'mousedown touchstart': $.proxy(function(e){
							// Clicked outside the datepicker, hide it
							if (!(
								this.element.is(e.target) ||
								this.element.find(e.target).length ||
								this.picker.is(e.target) ||
								this.picker.find(e.target).length ||
								this.isInline
							)){
								this.hide();
							}
						}, this)
					}]
				];
			},
			_attachEvents: function(){
				this._detachEvents();
				this._applyEvents(this._events);
			},
			_detachEvents: function(){
				this._unapplyEvents(this._events);
			},
			_attachSecondaryEvents: function(){
				this._detachSecondaryEvents();
				this._applyEvents(this._secondaryEvents);
			},
			_detachSecondaryEvents: function(){
				this._unapplyEvents(this._secondaryEvents);
			},
			_trigger: function(event, altdate){
				var date = altdate || this.dates.get(-1),
					local_date = this._utc_to_local(date);

				this.element.trigger({
					type: event,
					date: local_date,
					viewMode: this.viewMode,
					dates: $.map(this.dates, this._utc_to_local),
					format: $.proxy(function(ix, format){
						if (arguments.length === 0){
							ix = this.dates.length - 1;
							format = this.o.format;
						} else if (typeof ix === 'string'){
							format = ix;
							ix = this.dates.length - 1;
						}
						format = format || this.o.format;
						var date = this.dates.get(ix);
						return DPGlobal.formatDate(date, format, this.o.language);
					}, this)
				});
			},

			show: function(){
				if (this.inputField.is(':disabled') || (this.inputField.prop('readonly') && this.o.enableOnReadonly === false))
					{ return; }
				if (!this.isInline)
					{ this.picker.appendTo(this.o.container); }
				this.place();
				this.picker.show();
				this._attachSecondaryEvents();
				this._trigger('show');
				if ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && this.o.disableTouchKeyboard) {
					$(this.element).blur();
				}
				return this;
			},

			hide: function(){
				if (this.isInline || !this.picker.is(':visible'))
					{ return this; }
				this.focusDate = null;
				this.picker.hide().detach();
				this._detachSecondaryEvents();
				this.setViewMode(this.o.startView);

				if (this.o.forceParse && this.inputField.val())
					{ this.setValue(); }
				this._trigger('hide');
				return this;
			},

			destroy: function(){
				this.hide();
				this._detachEvents();
				this._detachSecondaryEvents();
				this.picker.remove();
				delete this.element.data().datepicker;
				if (!this.isInput){
					delete this.element.data().date;
				}
				return this;
			},

			paste: function(e){
				var dateString;
				if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.types
					&& $.inArray('text/plain', e.originalEvent.clipboardData.types) !== -1) {
					dateString = e.originalEvent.clipboardData.getData('text/plain');
				} else if (window.clipboardData) {
					dateString = window.clipboardData.getData('Text');
				} else {
					return;
				}
				this.setDate(dateString);
				this.update();
				e.preventDefault();
			},

			_utc_to_local: function(utc){
				if (!utc) {
					return utc;
				}

				var local = new Date(utc.getTime() + (utc.getTimezoneOffset() * 60000));

				if (local.getTimezoneOffset() !== utc.getTimezoneOffset()) {
					local = new Date(utc.getTime() + (local.getTimezoneOffset() * 60000));
				}

				return local;
			},
			_local_to_utc: function(local){
				return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
			},
			_zero_time: function(local){
				return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
			},
			_zero_utc_time: function(utc){
				return utc && UTCDate(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate());
			},

			getDates: function(){
				return $.map(this.dates, this._utc_to_local);
			},

			getUTCDates: function(){
				return $.map(this.dates, function(d){
					return new Date(d);
				});
			},

			getDate: function(){
				return this._utc_to_local(this.getUTCDate());
			},

			getUTCDate: function(){
				var selected_date = this.dates.get(-1);
				if (selected_date !== undefined$1) {
					return new Date(selected_date);
				} else {
					return null;
				}
			},

			clearDates: function(){
				this.inputField.val('');
				this.update();
				this._trigger('changeDate');

				if (this.o.autoclose) {
					this.hide();
				}
			},

			setDates: function(){
				var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
				this.update.apply(this, args);
				this._trigger('changeDate');
				this.setValue();
				return this;
			},

			setUTCDates: function(){
				var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
				this.setDates.apply(this, $.map(args, this._utc_to_local));
				return this;
			},

			setDate: alias('setDates'),
			setUTCDate: alias('setUTCDates'),
			remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead'),

			setValue: function(){
				var formatted = this.getFormattedDate();
				this.inputField.val(formatted);
				return this;
			},

			getFormattedDate: function(format){
				if (format === undefined$1)
					{ format = this.o.format; }

				var lang = this.o.language;
				return $.map(this.dates, function(d){
					return DPGlobal.formatDate(d, format, lang);
				}).join(this.o.multidateSeparator);
			},

			getStartDate: function(){
				return this.o.startDate;
			},

			setStartDate: function(startDate){
				this._process_options({startDate: startDate});
				this.update();
				this.updateNavArrows();
				return this;
			},

			getEndDate: function(){
				return this.o.endDate;
			},

			setEndDate: function(endDate){
				this._process_options({endDate: endDate});
				this.update();
				this.updateNavArrows();
				return this;
			},

			setDaysOfWeekDisabled: function(daysOfWeekDisabled){
				this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
				this.update();
				return this;
			},

			setDaysOfWeekHighlighted: function(daysOfWeekHighlighted){
				this._process_options({daysOfWeekHighlighted: daysOfWeekHighlighted});
				this.update();
				return this;
			},

			setDatesDisabled: function(datesDisabled){
				this._process_options({datesDisabled: datesDisabled});
				this.update();
				return this;
			},

			place: function(){
				if (this.isInline)
					{ return this; }
				var calendarWidth = this.picker.outerWidth(),
					calendarHeight = this.picker.outerHeight(),
					visualPadding = 10,
					container = $(this.o.container),
					windowWidth = container.width(),
					scrollTop = this.o.container === 'body' ? $(document).scrollTop() : container.scrollTop(),
					appendOffset = container.offset();

				var parentsZindex = [0];
				this.element.parents().each(function(){
					var itemZIndex = $(this).css('z-index');
					if (itemZIndex !== 'auto' && Number(itemZIndex) !== 0) { parentsZindex.push(Number(itemZIndex)); }
				});
				var zIndex = Math.max.apply(Math, parentsZindex) + this.o.zIndexOffset;
				var offset = this.component ? this.component.parent().offset() : this.element.offset();
				var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
				var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
				var left = offset.left - appendOffset.left;
				var top = offset.top - appendOffset.top;

				if (this.o.container !== 'body') {
					top += scrollTop;
				}

				this.picker.removeClass(
					'datepicker-orient-top datepicker-orient-bottom '+
					'datepicker-orient-right datepicker-orient-left'
				);

				if (this.o.orientation.x !== 'auto'){
					this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
					if (this.o.orientation.x === 'right')
						{ left -= calendarWidth - width; }
				}
				// auto x orientation is best-placement: if it crosses a window
				// edge, fudge it sideways
				else {
					if (offset.left < 0) {
						// component is outside the window on the left side. Move it into visible range
						this.picker.addClass('datepicker-orient-left');
						left -= offset.left - visualPadding;
					} else if (left + calendarWidth > windowWidth) {
						// the calendar passes the widow right edge. Align it to component right side
						this.picker.addClass('datepicker-orient-right');
						left += width - calendarWidth;
					} else {
						if (this.o.rtl) {
							// Default to right
							this.picker.addClass('datepicker-orient-right');
						} else {
							// Default to left
							this.picker.addClass('datepicker-orient-left');
						}
					}
				}

				// auto y orientation is best-situation: top or bottom, no fudging,
				// decision based on which shows more of the calendar
				var yorient = this.o.orientation.y,
					top_overflow;
				if (yorient === 'auto'){
					top_overflow = -scrollTop + top - calendarHeight;
					yorient = top_overflow < 0 ? 'bottom' : 'top';
				}

				this.picker.addClass('datepicker-orient-' + yorient);
				if (yorient === 'top')
					{ top -= calendarHeight + parseInt(this.picker.css('padding-top')); }
				else
					{ top += height; }

				if (this.o.rtl) {
					var right = windowWidth - (left + width);
					this.picker.css({
						top: top,
						right: right,
						zIndex: zIndex
					});
				} else {
					this.picker.css({
						top: top,
						left: left,
						zIndex: zIndex
					});
				}
				return this;
			},

			_allow_update: true,
			update: function(){
				if (!this._allow_update)
					{ return this; }

				var oldDates = this.dates.copy(),
					dates = [],
					fromArgs = false;
				if (arguments.length){
					$.each(arguments, $.proxy(function(i, date){
						if (date instanceof Date)
							{ date = this._local_to_utc(date); }
						dates.push(date);
					}, this));
					fromArgs = true;
				} else {
					dates = this.isInput
							? this.element.val()
							: this.element.data('date') || this.inputField.val();
					if (dates && this.o.multidate)
						{ dates = dates.split(this.o.multidateSeparator); }
					else
						{ dates = [dates]; }
					delete this.element.data().date;
				}

				dates = $.map(dates, $.proxy(function(date){
					return DPGlobal.parseDate(date, this.o.format, this.o.language, this.o.assumeNearbyYear);
				}, this));
				dates = $.grep(dates, $.proxy(function(date){
					return (
						!this.dateWithinRange(date) ||
						!date
					);
				}, this), true);
				this.dates.replace(dates);

				if (this.o.updateViewDate) {
					if (this.dates.length)
						{ this.viewDate = new Date(this.dates.get(-1)); }
					else if (this.viewDate < this.o.startDate)
						{ this.viewDate = new Date(this.o.startDate); }
					else if (this.viewDate > this.o.endDate)
						{ this.viewDate = new Date(this.o.endDate); }
					else
						{ this.viewDate = this.o.defaultViewDate; }
				}

				if (fromArgs){
					// setting date by clicking
					this.setValue();
					this.element.change();
				}
				else if (this.dates.length){
					// setting date by typing
					if (String(oldDates) !== String(this.dates) && fromArgs) {
						this._trigger('changeDate');
						this.element.change();
					}
				}
				if (!this.dates.length && oldDates.length) {
					this._trigger('clearDate');
					this.element.change();
				}

				this.fill();
				return this;
			},

			fillDow: function(){
	      if (this.o.showWeekDays) {
				var dowCnt = this.o.weekStart,
					html = '<tr>';
				if (this.o.calendarWeeks){
					html += '<th class="cw">&#160;</th>';
				}
				while (dowCnt < this.o.weekStart + 7){
					html += '<th class="dow';
	        if ($.inArray(dowCnt, this.o.daysOfWeekDisabled) !== -1)
	          { html += ' disabled'; }
	        html += '">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
				}
				html += '</tr>';
				this.picker.find('.datepicker-days thead').append(html);
	      }
			},

			fillMonths: function(){
	      var localDate = this._utc_to_local(this.viewDate);
				var html = '';
				var focused;
				for (var i = 0; i < 12; i++){
					focused = localDate && localDate.getMonth() === i ? ' focused' : '';
					html += '<span class="month' + focused + '">' + dates[this.o.language].monthsShort[i] + '</span>';
				}
				this.picker.find('.datepicker-months td').html(html);
			},

			setRange: function(range){
				if (!range || !range.length)
					{ delete this.range; }
				else
					{ this.range = $.map(range, function(d){
						return d.valueOf();
					}); }
				this.fill();
			},

			getClassNames: function(date){
				var cls = [],
					year = this.viewDate.getUTCFullYear(),
					month = this.viewDate.getUTCMonth(),
					today = UTCToday();
				if (date.getUTCFullYear() < year || (date.getUTCFullYear() === year && date.getUTCMonth() < month)){
					cls.push('old');
				} else if (date.getUTCFullYear() > year || (date.getUTCFullYear() === year && date.getUTCMonth() > month)){
					cls.push('new');
				}
				if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
					{ cls.push('focused'); }
				// Compare internal UTC date with UTC today, not local today
				if (this.o.todayHighlight && isUTCEquals(date, today)) {
					cls.push('today');
				}
				if (this.dates.contains(date) !== -1)
					{ cls.push('active'); }
				if (!this.dateWithinRange(date)){
					cls.push('disabled');
				}
				if (this.dateIsDisabled(date)){
					cls.push('disabled', 'disabled-date');
				}
				if ($.inArray(date.getUTCDay(), this.o.daysOfWeekHighlighted) !== -1){
					cls.push('highlighted');
				}

				if (this.range){
					if (date > this.range[0] && date < this.range[this.range.length-1]){
						cls.push('range');
					}
					if ($.inArray(date.valueOf(), this.range) !== -1){
						cls.push('selected');
					}
					if (date.valueOf() === this.range[0]){
	          cls.push('range-start');
	        }
	        if (date.valueOf() === this.range[this.range.length-1]){
	          cls.push('range-end');
	        }
				}
				return cls;
			},

			_fill_yearsView: function(selector, cssClass, factor, year, startYear, endYear, beforeFn){
				var html = '';
				var step = factor / 10;
				var view = this.picker.find(selector);
				var startVal = Math.floor(year / factor) * factor;
				var endVal = startVal + step * 9;
				var focusedVal = Math.floor(this.viewDate.getFullYear() / step) * step;
				var selected = $.map(this.dates, function(d){
					return Math.floor(d.getUTCFullYear() / step) * step;
				});

				var classes, tooltip, before;
				for (var currVal = startVal - step; currVal <= endVal + step; currVal += step) {
					classes = [cssClass];
					tooltip = null;

					if (currVal === startVal - step) {
						classes.push('old');
					} else if (currVal === endVal + step) {
						classes.push('new');
					}
					if ($.inArray(currVal, selected) !== -1) {
						classes.push('active');
					}
					if (currVal < startYear || currVal > endYear) {
						classes.push('disabled');
					}
					if (currVal === focusedVal) {
					  classes.push('focused');
	        }

					if (beforeFn !== $.noop) {
						before = beforeFn(new Date(currVal, 0, 1));
						if (before === undefined$1) {
							before = {};
						} else if (typeof before === 'boolean') {
							before = {enabled: before};
						} else if (typeof before === 'string') {
							before = {classes: before};
						}
						if (before.enabled === false) {
							classes.push('disabled');
						}
						if (before.classes) {
							classes = classes.concat(before.classes.split(/\s+/));
						}
						if (before.tooltip) {
							tooltip = before.tooltip;
						}
					}

					html += '<span class="' + classes.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + '>' + currVal + '</span>';
				}

				view.find('.datepicker-switch').text(startVal + '-' + endVal);
				view.find('td').html(html);
			},

			fill: function(){
				var d = new Date(this.viewDate),
					year = d.getUTCFullYear(),
					month = d.getUTCMonth(),
					startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
					startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
					endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
					endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
					todaytxt = dates[this.o.language].today || dates['en'].today || '',
					cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
	        titleFormat = dates[this.o.language].titleFormat || dates['en'].titleFormat,
	        todayDate = UTCToday(),
	        titleBtnVisible = (this.o.todayBtn === true || this.o.todayBtn === 'linked') && todayDate >= this.o.startDate && todayDate <= this.o.endDate && !this.weekOfDateIsDisabled(todayDate),
					tooltip,
					before;
				if (isNaN(year) || isNaN(month))
					{ return; }
				this.picker.find('.datepicker-days .datepicker-switch')
							.text(DPGlobal.formatDate(d, titleFormat, this.o.language));
				this.picker.find('tfoot .today')
							.text(todaytxt)
	            .css('display', titleBtnVisible ? 'table-cell' : 'none');
				this.picker.find('tfoot .clear')
							.text(cleartxt)
							.css('display', this.o.clearBtn === true ? 'table-cell' : 'none');
				this.picker.find('thead .datepicker-title')
							.text(this.o.title)
							.css('display', typeof this.o.title === 'string' && this.o.title !== '' ? 'table-cell' : 'none');
				this.updateNavArrows();
				this.fillMonths();
				var prevMonth = UTCDate(year, month, 0),
					day = prevMonth.getUTCDate();
				prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
				var nextMonth = new Date(prevMonth);
				if (prevMonth.getUTCFullYear() < 100){
	        nextMonth.setUTCFullYear(prevMonth.getUTCFullYear());
	      }
				nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
				nextMonth = nextMonth.valueOf();
				var html = [];
				var weekDay, clsName;
				while (prevMonth.valueOf() < nextMonth){
					weekDay = prevMonth.getUTCDay();
					if (weekDay === this.o.weekStart){
						html.push('<tr>');
						if (this.o.calendarWeeks){
							// ISO 8601: First week contains first thursday.
							// ISO also states week starts on Monday, but we can be more abstract here.
							var
								// Start of current week: based on weekstart/current date
								ws = new Date(+prevMonth + (this.o.weekStart - weekDay - 7) % 7 * 864e5),
								// Thursday of this week
								th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
								// First Thursday of year, year from thursday
								yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),
								// Calendar week: ms between thursdays, div ms per day, div 7 days
								calWeek = (th - yth) / 864e5 / 7 + 1;
							html.push('<td class="cw">'+ calWeek +'</td>');
						}
					}
					clsName = this.getClassNames(prevMonth);
					clsName.push('day');

					var content = prevMonth.getUTCDate();

					if (this.o.beforeShowDay !== $.noop){
						before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
						if (before === undefined$1)
							{ before = {}; }
						else if (typeof before === 'boolean')
							{ before = {enabled: before}; }
						else if (typeof before === 'string')
							{ before = {classes: before}; }
						if (before.enabled === false)
							{ clsName.push('disabled'); }
						if (before.classes)
							{ clsName = clsName.concat(before.classes.split(/\s+/)); }
						if (before.tooltip)
							{ tooltip = before.tooltip; }
						if (before.content)
							{ content = before.content; }
					}

					//Check if uniqueSort exists (supported by jquery >=1.12 and >=2.2)
					//Fallback to unique function for older jquery versions
					if ($.isFunction($.uniqueSort)) {
						clsName = $.uniqueSort(clsName);
					} else {
						clsName = $.unique(clsName);
					}

					html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + ' data-date="' + prevMonth.getTime().toString() + '">' + content + '</td>');
					tooltip = null;
					if (weekDay === this.o.weekEnd){
						html.push('</tr>');
					}
					prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
				}
				this.picker.find('.datepicker-days tbody').html(html.join(''));

				var monthsTitle = dates[this.o.language].monthsTitle || dates['en'].monthsTitle || 'Months';
				var months = this.picker.find('.datepicker-months')
							.find('.datepicker-switch')
								.text(this.o.maxViewMode < 2 ? monthsTitle : year)
								.end()
							.find('tbody span').removeClass('active');

				$.each(this.dates, function(i, d){
					if (d.getUTCFullYear() === year)
						{ months.eq(d.getUTCMonth()).addClass('active'); }
				});

				if (year < startYear || year > endYear){
					months.addClass('disabled');
				}
				if (year === startYear){
					months.slice(0, startMonth).addClass('disabled');
				}
				if (year === endYear){
					months.slice(endMonth+1).addClass('disabled');
				}

				if (this.o.beforeShowMonth !== $.noop){
					var that = this;
					$.each(months, function(i, month){
	          var moDate = new Date(year, i, 1);
	          var before = that.o.beforeShowMonth(moDate);
						if (before === undefined$1)
							{ before = {}; }
						else if (typeof before === 'boolean')
							{ before = {enabled: before}; }
						else if (typeof before === 'string')
							{ before = {classes: before}; }
						if (before.enabled === false && !$(month).hasClass('disabled'))
						    { $(month).addClass('disabled'); }
						if (before.classes)
						    { $(month).addClass(before.classes); }
						if (before.tooltip)
						    { $(month).prop('title', before.tooltip); }
					});
				}

				// Generating decade/years picker
				this._fill_yearsView(
					'.datepicker-years',
					'year',
					10,
					year,
					startYear,
					endYear,
					this.o.beforeShowYear
				);

				// Generating century/decades picker
				this._fill_yearsView(
					'.datepicker-decades',
					'decade',
					100,
					year,
					startYear,
					endYear,
					this.o.beforeShowDecade
				);

				// Generating millennium/centuries picker
				this._fill_yearsView(
					'.datepicker-centuries',
					'century',
					1000,
					year,
					startYear,
					endYear,
					this.o.beforeShowCentury
				);
			},

			updateNavArrows: function(){
				if (!this._allow_update)
					{ return; }

				var d = new Date(this.viewDate),
					year = d.getUTCFullYear(),
					month = d.getUTCMonth(),
					startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
					startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
					endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
					endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
					prevIsDisabled,
					nextIsDisabled,
					factor = 1;
				switch (this.viewMode){
					case 4:
						factor *= 10;
						/* falls through */
					case 3:
						factor *= 10;
						/* falls through */
					case 2:
						factor *= 10;
						/* falls through */
					case 1:
						prevIsDisabled = Math.floor(year / factor) * factor <= startYear;
						nextIsDisabled = Math.floor(year / factor) * factor + factor > endYear;
						break;
					case 0:
						prevIsDisabled = year <= startYear && month <= startMonth;
						nextIsDisabled = year >= endYear && month >= endMonth;
						break;
				}

				this.picker.find('.prev').toggleClass('disabled', prevIsDisabled);
				this.picker.find('.next').toggleClass('disabled', nextIsDisabled);
			},

			click: function(e){
				e.preventDefault();
				e.stopPropagation();

				var target, day, year, month;
				target = $(e.target);

				// Clicked on the switch
				if (target.hasClass('datepicker-switch') && this.viewMode !== this.o.maxViewMode){
					this.setViewMode(this.viewMode + 1);
				}

				// Clicked on today button
				if (target.hasClass('today') && !target.hasClass('day')){
					this.setViewMode(0);
					this._setDate(UTCToday(), this.o.todayBtn === 'linked' ? null : 'view');
				}

				// Clicked on clear button
				if (target.hasClass('clear')){
					this.clearDates();
				}

				if (!target.hasClass('disabled')){
					// Clicked on a month, year, decade, century
					if (target.hasClass('month')
							|| target.hasClass('year')
							|| target.hasClass('decade')
							|| target.hasClass('century')) {
						this.viewDate.setUTCDate(1);

						day = 1;
						if (this.viewMode === 1){
							month = target.parent().find('span').index(target);
							year = this.viewDate.getUTCFullYear();
							this.viewDate.setUTCMonth(month);
						} else {
							month = 0;
							year = Number(target.text());
							this.viewDate.setUTCFullYear(year);
						}

						this._trigger(DPGlobal.viewModes[this.viewMode - 1].e, this.viewDate);

						if (this.viewMode === this.o.minViewMode){
							this._setDate(UTCDate(year, month, day));
						} else {
							this.setViewMode(this.viewMode - 1);
							this.fill();
						}
					}
				}

				if (this.picker.is(':visible') && this._focused_from){
					this._focused_from.focus();
				}
				delete this._focused_from;
			},

			dayCellClick: function(e){
				var $target = $(e.currentTarget);
				var timestamp = $target.data('date');
				var date = new Date(timestamp);

				if (this.o.updateViewDate) {
					if (date.getUTCFullYear() !== this.viewDate.getUTCFullYear()) {
						this._trigger('changeYear', this.viewDate);
					}

					if (date.getUTCMonth() !== this.viewDate.getUTCMonth()) {
						this._trigger('changeMonth', this.viewDate);
					}
				}
				this._setDate(date);
			},

			// Clicked on prev or next
			navArrowsClick: function(e){
				var $target = $(e.currentTarget);
				var dir = $target.hasClass('prev') ? -1 : 1;
				if (this.viewMode !== 0){
					dir *= DPGlobal.viewModes[this.viewMode].navStep * 12;
				}
				this.viewDate = this.moveMonth(this.viewDate, dir);
				this._trigger(DPGlobal.viewModes[this.viewMode].e, this.viewDate);
				this.fill();
			},

			_toggle_multidate: function(date){
				var ix = this.dates.contains(date);
				if (!date){
					this.dates.clear();
				}

				if (ix !== -1){
					if (this.o.multidate === true || this.o.multidate > 1 || this.o.toggleActive){
						this.dates.remove(ix);
					}
				} else if (this.o.multidate === false) {
					this.dates.clear();
					this.dates.push(date);
				}
				else {
					this.dates.push(date);
				}

				if (typeof this.o.multidate === 'number')
					{ while (this.dates.length > this.o.multidate)
						{ this.dates.remove(0); } }
			},

			_setDate: function(date, which){
				if (!which || which === 'date')
					{ this._toggle_multidate(date && new Date(date)); }
				if ((!which && this.o.updateViewDate) || which === 'view')
					{ this.viewDate = date && new Date(date); }

				this.fill();
				this.setValue();
				if (!which || which !== 'view') {
					this._trigger('changeDate');
				}
				this.inputField.trigger('change');
				if (this.o.autoclose && (!which || which === 'date')){
					this.hide();
				}
			},

			moveDay: function(date, dir){
				var newDate = new Date(date);
				newDate.setUTCDate(date.getUTCDate() + dir);

				return newDate;
			},

			moveWeek: function(date, dir){
				return this.moveDay(date, dir * 7);
			},

			moveMonth: function(date, dir){
				if (!isValidDate(date))
					{ return this.o.defaultViewDate; }
				if (!dir)
					{ return date; }
				var new_date = new Date(date.valueOf()),
					day = new_date.getUTCDate(),
					month = new_date.getUTCMonth(),
					mag = Math.abs(dir),
					new_month, test;
				dir = dir > 0 ? 1 : -1;
				if (mag === 1){
					test = dir === -1
						// If going back one month, make sure month is not current month
						// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
						? function(){
							return new_date.getUTCMonth() === month;
						}
						// If going forward one month, make sure month is as expected
						// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
						: function(){
							return new_date.getUTCMonth() !== new_month;
						};
					new_month = month + dir;
					new_date.setUTCMonth(new_month);
					// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
					new_month = (new_month + 12) % 12;
				}
				else {
					// For magnitudes >1, move one month at a time...
					for (var i=0; i < mag; i++)
						// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
						{ new_date = this.moveMonth(new_date, dir); }
					// ...then reset the day, keeping it in the new month
					new_month = new_date.getUTCMonth();
					new_date.setUTCDate(day);
					test = function(){
						return new_month !== new_date.getUTCMonth();
					};
				}
				// Common date-resetting loop -- if date is beyond end of month, make it
				// end of month
				while (test()){
					new_date.setUTCDate(--day);
					new_date.setUTCMonth(new_month);
				}
				return new_date;
			},

			moveYear: function(date, dir){
				return this.moveMonth(date, dir*12);
			},

			moveAvailableDate: function(date, dir, fn){
				do {
					date = this[fn](date, dir);

					if (!this.dateWithinRange(date))
						{ return false; }

					fn = 'moveDay';
				}
				while (this.dateIsDisabled(date));

				return date;
			},

			weekOfDateIsDisabled: function(date){
				return $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1;
			},

			dateIsDisabled: function(date){
				return (
					this.weekOfDateIsDisabled(date) ||
					$.grep(this.o.datesDisabled, function(d){
						return isUTCEquals(date, d);
					}).length > 0
				);
			},

			dateWithinRange: function(date){
				return date >= this.o.startDate && date <= this.o.endDate;
			},

			keydown: function(e){
				if (!this.picker.is(':visible')){
					if (e.keyCode === 40 || e.keyCode === 27) { // allow down to re-show picker
						this.show();
						e.stopPropagation();
	        }
					return;
				}
				var dateChanged = false,
					dir, newViewDate,
					focusDate = this.focusDate || this.viewDate;
				switch (e.keyCode){
					case 27: // escape
						if (this.focusDate){
							this.focusDate = null;
							this.viewDate = this.dates.get(-1) || this.viewDate;
							this.fill();
						}
						else
							{ this.hide(); }
						e.preventDefault();
						e.stopPropagation();
						break;
					case 37: // left
					case 38: // up
					case 39: // right
					case 40: // down
						if (!this.o.keyboardNavigation || this.o.daysOfWeekDisabled.length === 7)
							{ break; }
						dir = e.keyCode === 37 || e.keyCode === 38 ? -1 : 1;
	          if (this.viewMode === 0) {
	  					if (e.ctrlKey){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');

	  						if (newViewDate)
	  							{ this._trigger('changeYear', this.viewDate); }
	  					} else if (e.shiftKey){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');

	  						if (newViewDate)
	  							{ this._trigger('changeMonth', this.viewDate); }
	  					} else if (e.keyCode === 37 || e.keyCode === 39){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveDay');
	  					} else if (!this.weekOfDateIsDisabled(focusDate)){
	  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveWeek');
	  					}
	          } else if (this.viewMode === 1) {
	            if (e.keyCode === 38 || e.keyCode === 40) {
	              dir = dir * 4;
	            }
	            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');
	          } else if (this.viewMode === 2) {
	            if (e.keyCode === 38 || e.keyCode === 40) {
	              dir = dir * 4;
	            }
	            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');
	          }
						if (newViewDate){
							this.focusDate = this.viewDate = newViewDate;
							this.setValue();
							this.fill();
							e.preventDefault();
						}
						break;
					case 13: // enter
						if (!this.o.forceParse)
							{ break; }
						focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
						if (this.o.keyboardNavigation) {
							this._toggle_multidate(focusDate);
							dateChanged = true;
						}
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.setValue();
						this.fill();
						if (this.picker.is(':visible')){
							e.preventDefault();
							e.stopPropagation();
							if (this.o.autoclose)
								{ this.hide(); }
						}
						break;
					case 9: // tab
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.fill();
						this.hide();
						break;
				}
				if (dateChanged){
					if (this.dates.length)
						{ this._trigger('changeDate'); }
					else
						{ this._trigger('clearDate'); }
					this.inputField.trigger('change');
				}
			},

			setViewMode: function(viewMode){
				this.viewMode = viewMode;
				this.picker
					.children('div')
					.hide()
					.filter('.datepicker-' + DPGlobal.viewModes[this.viewMode].clsName)
						.show();
				this.updateNavArrows();
	      this._trigger('changeViewMode', new Date(this.viewDate));
			}
		};

		var DateRangePicker = function(element, options){
			$.data(element, 'datepicker', this);
			this.element = $(element);
			this.inputs = $.map(options.inputs, function(i){
				return i.jquery ? i[0] : i;
			});
			delete options.inputs;

			this.keepEmptyValues = options.keepEmptyValues;
			delete options.keepEmptyValues;

			datepickerPlugin.call($(this.inputs), options)
				.on('changeDate', $.proxy(this.dateUpdated, this));

			this.pickers = $.map(this.inputs, function(i){
				return $.data(i, 'datepicker');
			});
			this.updateDates();
		};
		DateRangePicker.prototype = {
			updateDates: function(){
				this.dates = $.map(this.pickers, function(i){
					return i.getUTCDate();
				});
				this.updateRanges();
			},
			updateRanges: function(){
				var range = $.map(this.dates, function(d){
					return d.valueOf();
				});
				$.each(this.pickers, function(i, p){
					p.setRange(range);
				});
			},
			clearDates: function(){
				$.each(this.pickers, function(i, p){
					p.clearDates();
				});
			},
			dateUpdated: function(e){
				// `this.updating` is a workaround for preventing infinite recursion
				// between `changeDate` triggering and `setUTCDate` calling.  Until
				// there is a better mechanism.
				if (this.updating)
					{ return; }
				this.updating = true;

				var dp = $.data(e.target, 'datepicker');

				if (dp === undefined$1) {
					return;
				}

				var new_date = dp.getUTCDate(),
					keep_empty_values = this.keepEmptyValues,
					i = $.inArray(e.target, this.inputs),
					j = i - 1,
					k = i + 1,
					l = this.inputs.length;
				if (i === -1)
					{ return; }

				$.each(this.pickers, function(i, p){
					if (!p.getUTCDate() && (p === dp || !keep_empty_values))
						{ p.setUTCDate(new_date); }
				});

				if (new_date < this.dates[j]){
					// Date being moved earlier/left
					while (j >= 0 && new_date < this.dates[j]){
						this.pickers[j--].setUTCDate(new_date);
					}
				} else if (new_date > this.dates[k]){
					// Date being moved later/right
					while (k < l && new_date > this.dates[k]){
						this.pickers[k++].setUTCDate(new_date);
					}
				}
				this.updateDates();

				delete this.updating;
			},
			destroy: function(){
				$.map(this.pickers, function(p){ p.destroy(); });
				$(this.inputs).off('changeDate', this.dateUpdated);
				delete this.element.data().datepicker;
			},
			remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead')
		};

		function opts_from_el(el, prefix){
			// Derive options from element data-attrs
			var data = $(el).data(),
				out = {}, inkey,
				replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
			prefix = new RegExp('^' + prefix.toLowerCase());
			function re_lower(_,a){
				return a.toLowerCase();
			}
			for (var key in data)
				{ if (prefix.test(key)){
					inkey = key.replace(replace, re_lower);
					out[inkey] = data[key];
				} }
			return out;
		}

		function opts_from_locale(lang){
			// Derive options from locale plugins
			var out = {};
			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			if (!dates[lang]){
				lang = lang.split('-')[0];
				if (!dates[lang])
					{ return; }
			}
			var d = dates[lang];
			$.each(locale_opts, function(i,k){
				if (k in d)
					{ out[k] = d[k]; }
			});
			return out;
		}

		var old = $.fn.datepicker;
		var datepickerPlugin = function(option){
			var args = Array.apply(null, arguments);
			args.shift();
			var internal_return;
			this.each(function(){
				var $this = $(this),
					data = $this.data('datepicker'),
					options = typeof option === 'object' && option;
				if (!data){
					var elopts = opts_from_el(this, 'date'),
						// Preliminary otions
						xopts = $.extend({}, defaults, elopts, options),
						locopts = opts_from_locale(xopts.language),
						// Options priority: js args, data-attrs, locales, defaults
						opts = $.extend({}, defaults, locopts, elopts, options);
					if ($this.hasClass('input-daterange') || opts.inputs){
						$.extend(opts, {
							inputs: opts.inputs || $this.find('input').toArray()
						});
						data = new DateRangePicker(this, opts);
					}
					else {
						data = new Datepicker(this, opts);
					}
					$this.data('datepicker', data);
				}
				if (typeof option === 'string' && typeof data[option] === 'function'){
					internal_return = data[option].apply(data, args);
				}
			});

			if (
				internal_return === undefined$1 ||
				internal_return instanceof Datepicker ||
				internal_return instanceof DateRangePicker
			)
				{ return this; }

			if (this.length > 1)
				{ throw new Error('Using only allowed for the collection of a single element (' + option + ' function)'); }
			else
				{ return internal_return; }
		};
		$.fn.datepicker = datepickerPlugin;

		var defaults = $.fn.datepicker.defaults = {
			assumeNearbyYear: false,
			autoclose: false,
			beforeShowDay: $.noop,
			beforeShowMonth: $.noop,
			beforeShowYear: $.noop,
			beforeShowDecade: $.noop,
			beforeShowCentury: $.noop,
			calendarWeeks: false,
			clearBtn: false,
			toggleActive: false,
			daysOfWeekDisabled: [],
			daysOfWeekHighlighted: [],
			datesDisabled: [],
			endDate: Infinity,
			forceParse: true,
			format: 'mm/dd/yyyy',
			keepEmptyValues: false,
			keyboardNavigation: true,
			language: 'en',
			minViewMode: 0,
			maxViewMode: 4,
			multidate: false,
			multidateSeparator: ',',
			orientation: "auto",
			rtl: false,
			startDate: -Infinity,
			startView: 0,
			todayBtn: false,
			todayHighlight: false,
			updateViewDate: true,
			weekStart: 0,
			disableTouchKeyboard: false,
			enableOnReadonly: true,
			showOnFocus: true,
			zIndexOffset: 10,
			container: 'body',
			immediateUpdates: false,
			title: '',
			templates: {
				leftArrow: '&#x00AB;',
				rightArrow: '&#x00BB;'
			},
	    showWeekDays: true
		};
		var locale_opts = $.fn.datepicker.locale_opts = [
			'format',
			'rtl',
			'weekStart'
		];
		$.fn.datepicker.Constructor = Datepicker;
		var dates = $.fn.datepicker.dates = {
			en: {
				days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
				daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
				daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
				months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
				monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
				today: "Today",
				clear: "Clear",
				titleFormat: "MM yyyy"
			}
		};

		var DPGlobal = {
			viewModes: [
				{
					names: ['days', 'month'],
					clsName: 'days',
					e: 'changeMonth'
				},
				{
					names: ['months', 'year'],
					clsName: 'months',
					e: 'changeYear',
					navStep: 1
				},
				{
					names: ['years', 'decade'],
					clsName: 'years',
					e: 'changeDecade',
					navStep: 10
				},
				{
					names: ['decades', 'century'],
					clsName: 'decades',
					e: 'changeCentury',
					navStep: 100
				},
				{
					names: ['centuries', 'millennium'],
					clsName: 'centuries',
					e: 'changeMillennium',
					navStep: 1000
				}
			],
			validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
			nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
			parseFormat: function(format){
				if (typeof format.toValue === 'function' && typeof format.toDisplay === 'function')
	                { return format; }
	            // IE treats \0 as a string end in inputs (truncating the value),
				// so it's a bad format delimiter, anyway
				var separators = format.replace(this.validParts, '\0').split('\0'),
					parts = format.match(this.validParts);
				if (!separators || !separators.length || !parts || parts.length === 0){
					throw new Error("Invalid date format.");
				}
				return {separators: separators, parts: parts};
			},
			parseDate: function(date, format, language, assumeNearby){
				if (!date)
					{ return undefined$1; }
				if (date instanceof Date)
					{ return date; }
				if (typeof format === 'string')
					{ format = DPGlobal.parseFormat(format); }
				if (format.toValue)
					{ return format.toValue(date, format, language); }
				var fn_map = {
						d: 'moveDay',
						m: 'moveMonth',
						w: 'moveWeek',
						y: 'moveYear'
					},
					dateAliases = {
						yesterday: '-1d',
						today: '+0d',
						tomorrow: '+1d'
					},
					parts, part, dir, i, fn;
				if (date in dateAliases){
					date = dateAliases[date];
				}
				if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(date)){
					parts = date.match(/([\-+]\d+)([dmwy])/gi);
					date = new Date();
					for (i=0; i < parts.length; i++){
						part = parts[i].match(/([\-+]\d+)([dmwy])/i);
						dir = Number(part[1]);
						fn = fn_map[part[2].toLowerCase()];
						date = Datepicker.prototype[fn](date, dir);
					}
					return Datepicker.prototype._zero_utc_time(date);
				}

				parts = date && date.match(this.nonpunctuation) || [];

				function applyNearbyYear(year, threshold){
					if (threshold === true)
						{ threshold = 10; }

					// if year is 2 digits or less, than the user most likely is trying to get a recent century
					if (year < 100){
						year += 2000;
						// if the new year is more than threshold years in advance, use last century
						if (year > ((new Date()).getFullYear()+threshold)){
							year -= 100;
						}
					}

					return year;
				}

				var parsed = {},
					setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
					setters_map = {
						yyyy: function(d,v){
							return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
						},
						m: function(d,v){
							if (isNaN(d))
								{ return d; }
							v -= 1;
							while (v < 0) { v += 12; }
							v %= 12;
							d.setUTCMonth(v);
							while (d.getUTCMonth() !== v)
								{ d.setUTCDate(d.getUTCDate()-1); }
							return d;
						},
						d: function(d,v){
							return d.setUTCDate(v);
						}
					},
					val, filtered;
				setters_map['yy'] = setters_map['yyyy'];
				setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
				setters_map['dd'] = setters_map['d'];
				date = UTCToday();
				var fparts = format.parts.slice();
				// Remove noop parts
				if (parts.length !== fparts.length){
					fparts = $(fparts).filter(function(i,p){
						return $.inArray(p, setters_order) !== -1;
					}).toArray();
				}
				// Process remainder
				function match_part(){
					var m = this.slice(0, parts[i].length),
						p = parts[i].slice(0, m.length);
					return m.toLowerCase() === p.toLowerCase();
				}
				if (parts.length === fparts.length){
					var cnt;
					for (i=0, cnt = fparts.length; i < cnt; i++){
						val = parseInt(parts[i], 10);
						part = fparts[i];
						if (isNaN(val)){
							switch (part){
								case 'MM':
									filtered = $(dates[language].months).filter(match_part);
									val = $.inArray(filtered[0], dates[language].months) + 1;
									break;
								case 'M':
									filtered = $(dates[language].monthsShort).filter(match_part);
									val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
									break;
							}
						}
						parsed[part] = val;
					}
					var _date, s;
					for (i=0; i < setters_order.length; i++){
						s = setters_order[i];
						if (s in parsed && !isNaN(parsed[s])){
							_date = new Date(date);
							setters_map[s](_date, parsed[s]);
							if (!isNaN(_date))
								{ date = _date; }
						}
					}
				}
				return date;
			},
			formatDate: function(date, format, language){
				if (!date)
					{ return ''; }
				if (typeof format === 'string')
					{ format = DPGlobal.parseFormat(format); }
				if (format.toDisplay)
	                { return format.toDisplay(date, format, language); }
	            var val = {
					d: date.getUTCDate(),
					D: dates[language].daysShort[date.getUTCDay()],
					DD: dates[language].days[date.getUTCDay()],
					m: date.getUTCMonth() + 1,
					M: dates[language].monthsShort[date.getUTCMonth()],
					MM: dates[language].months[date.getUTCMonth()],
					yy: date.getUTCFullYear().toString().substring(2),
					yyyy: date.getUTCFullYear()
				};
				val.dd = (val.d < 10 ? '0' : '') + val.d;
				val.mm = (val.m < 10 ? '0' : '') + val.m;
				date = [];
				var seps = $.extend([], format.separators);
				for (var i=0, cnt = format.parts.length; i <= cnt; i++){
					if (seps.length)
						{ date.push(seps.shift()); }
					date.push(val[format.parts[i]]);
				}
				return date.join('');
			},
			headTemplate: '<thead>'+
				              '<tr>'+
				                '<th colspan="7" class="datepicker-title"></th>'+
				              '</tr>'+
								'<tr>'+
									'<th class="prev">'+defaults.templates.leftArrow+'</th>'+
									'<th colspan="5" class="datepicker-switch"></th>'+
									'<th class="next">'+defaults.templates.rightArrow+'</th>'+
								'</tr>'+
							'</thead>',
			contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
			footTemplate: '<tfoot>'+
								'<tr>'+
									'<th colspan="7" class="today"></th>'+
								'</tr>'+
								'<tr>'+
									'<th colspan="7" class="clear"></th>'+
								'</tr>'+
							'</tfoot>'
		};
		DPGlobal.template = '<div class="datepicker">'+
								'<div class="datepicker-days">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										'<tbody></tbody>'+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-months">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-years">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-decades">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-centuries">'+
									'<table class="table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
							'</div>';

		$.fn.datepicker.DPGlobal = DPGlobal;


		/* DATEPICKER NO CONFLICT
		* =================== */

		$.fn.datepicker.noConflict = function(){
			$.fn.datepicker = old;
			return this;
		};

		/* DATEPICKER VERSION
		 * =================== */
		$.fn.datepicker.version = '1.9.0';

		$.fn.datepicker.deprecated = function(msg){
			var console = window.console;
			if (console && console.warn) {
				console.warn('DEPRECATED: ' + msg);
			}
		};


		/* DATEPICKER DATA-API
		* ================== */

		$(document).on(
			'focus.datepicker.data-api click.datepicker.data-api',
			'[data-provide="datepicker"]',
			function(e){
				var $this = $(this);
				if ($this.data('datepicker'))
					{ return; }
				e.preventDefault();
				// component click requires us to explicitly show it
				datepickerPlugin.call($this, 'show');
			}
		);
		$(function(){
			datepickerPlugin.call($('[data-provide="datepicker-inline"]'));
		});

	}));
	});

	!function(a){a.fn.datepicker.dates.vi={days:["Chủ nhật","Thứ hai","Thứ ba","Thứ tư","Thứ năm","Thứ sáu","Thứ bảy"],daysShort:["CN","Thứ 2","Thứ 3","Thứ 4","Thứ 5","Thứ 6","Thứ 7"],daysMin:["CN","T2","T3","T4","T5","T6","T7"],months:["Tháng 1","Tháng 2","Tháng 3","Tháng 4","Tháng 5","Tháng 6","Tháng 7","Tháng 8","Tháng 9","Tháng 10","Tháng 11","Tháng 12"],monthsShort:["Th1","Th2","Th3","Th4","Th5","Th6","Th7","Th8","Th9","Th10","Th11","Th12"],today:"Hôm nay",clear:"Xóa",format:"dd/mm/yyyy"};}(jQuery);

	//
	var datepickerOpts = {
	  format: 'dd/mm/yyyy',
	  todayBtn: "linked",
	  language: "vi",
	  clearBtn: true,
	  autoclose: true,
	  todayHighlight: true
	};
	var script$1 = {
	  name: 'field-input',
	  inheritAttrs: false,
	  props: {
	    rules: {
	      type: [Object, String],
	      "default": ""
	    },
	    // must be included in props
	    value: {
	      type: null
	    },
	    widget: String
	  },
	  data: function data() {
	    return {
	      innerValue: ""
	    };
	  },
	  computed: {
	    vid: function vid() {
	      if (this.$attrs.vid) { return this.$attrs.vid; }
	      return this.strArr2Dot("".concat(this.$attrs.name));
	    }
	  },
	  watch: {
	    // Handles internal model changes.
	    innerValue: function innerValue(newVal) {
	      this.$emit("input", newVal);
	    },
	    // Handles external model changes.
	    value: function value(newVal) {
	      this.innerValue = newVal;
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;

	    if (this.widget === 'datepicker') {
	      $$1(this.$refs.input.$el).datepicker(datepickerOpts).on('changeDate', function (e) {
	        _this.innerValue = e.target.value;
	      });

	      if (!this.$attrs.placeholder) {
	        this.$attrs.placeholder = 'DD/MM/YYYY';
	      }
	    }
	  },
	  created: function created() {
	    if (!lodash.isUndefined(this.value)) {
	      this.innerValue = this.value;
	    }
	  },
	  methods: {
	    strArr2Dot: function strArr2Dot(str) {
	      return str.replace('][', '.').replace('[', '.').replace(']', '');
	    }
	  }
	};

	function normalizeComponent$1(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	    if (typeof shadowMode !== 'boolean') {
	        createInjectorSSR = createInjector;
	        createInjector = shadowMode;
	        shadowMode = false;
	    }
	    // Vue.extend constructor export interop.
	    var options = typeof script === 'function' ? script.options : script;
	    // render functions
	    if (template && template.render) {
	        options.render = template.render;
	        options.staticRenderFns = template.staticRenderFns;
	        options._compiled = true;
	        // functional template
	        if (isFunctionalTemplate) {
	            options.functional = true;
	        }
	    }
	    // scopedId
	    if (scopeId) {
	        options._scopeId = scopeId;
	    }
	    var hook;
	    if (moduleIdentifier) {
	        // server build
	        hook = function (context) {
	            // 2.3 injection
	            context =
	                context || // cached call
	                    (this.$vnode && this.$vnode.ssrContext) || // stateful
	                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
	            // 2.2 with runInNewContext: true
	            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	                context = __VUE_SSR_CONTEXT__;
	            }
	            // inject component styles
	            if (style) {
	                style.call(this, createInjectorSSR(context));
	            }
	            // register component module identifier for async chunk inference
	            if (context && context._registeredComponents) {
	                context._registeredComponents.add(moduleIdentifier);
	            }
	        };
	        // used by ssr in case component is cached and beforeCreate
	        // never gets called
	        options._ssrRegister = hook;
	    }
	    else if (style) {
	        hook = shadowMode
	            ? function (context) {
	                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
	            }
	            : function (context) {
	                style.call(this, createInjector(context));
	            };
	    }
	    if (hook) {
	        if (options.functional) {
	            // register for functional component in vue file
	            var originalRender = options.render;
	            options.render = function renderWithStyleInjection(h, context) {
	                hook.call(context);
	                return originalRender(h, context);
	            };
	        }
	        else {
	            // inject component registration as beforeCreate hook
	            var existing = options.beforeCreate;
	            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	    }
	    return script;
	}

	/* script */
	var __vue_script__$1 = script$1;
	/* template */
	var __vue_render__$1 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("ValidationProvider", {
	    attrs: { vid: _vm.vid, name: _vm.$attrs.label, rules: _vm.rules },
	    scopedSlots: _vm._u([
	      {
	        key: "default",
	        fn: function(v) {
	          return [
	            _c(
	              "b-form-group",
	              {
	                attrs: {
	                  "label-class":
	                    v.invalid && v.touched
	                      ? "font-weight-semibold text-danger"
	                      : "",
	                  "label-for": _vm.$attrs.id,
	                  label: _vm.$attrs.label
	                }
	              },
	              [
	                _c(
	                  "b-form-input",
	                  _vm._b(
	                    {
	                      ref: "input",
	                      attrs: {
	                        id: _vm.$attrs.id,
	                        state: v.errors[0]
	                          ? false
	                          : v.valid && v.touched
	                          ? true
	                          : null
	                      },
	                      model: {
	                        value: _vm.innerValue,
	                        callback: function($$v) {
	                          _vm.innerValue = $$v;
	                        },
	                        expression: "innerValue"
	                      }
	                    },
	                    "b-form-input",
	                    _vm.$attrs,
	                    false
	                  )
	                ),
	                _vm._v(" "),
	                _c("b-form-invalid-feedback", { staticClass: "form-text" }, [
	                  _vm._v(_vm._s(v.errors[0]))
	                ])
	              ],
	              1
	            )
	          ]
	        }
	      }
	    ])
	  })
	};
	var __vue_staticRenderFns__$1 = [];
	__vue_render__$1._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$1 = undefined;
	  /* scoped */
	  var __vue_scope_id__$1 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$1 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$1 = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$1 = normalizeComponent$1(
	    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
	    __vue_inject_styles__$1,
	    __vue_script__$1,
	    __vue_scope_id__$1,
	    __vue_is_functional_template__$1,
	    __vue_module_identifier__$1,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var fieldMixin = {
	  options: [Array, Object],
	  computed: {
	    vid: function vid() {
	      // if(this.id) return this.id
	      // if(this.$attrs.id) return this.$attrs.id
	      return this.strArr2Dot("".concat(this.$attrs.name));
	    },
	    items: function items() {
	      var arr = this.options;

	      if (lodash.isPlainObject(this.options)) {
	        arr = [];
	        lodash.map(this.options, function (v, k) {
	          arr.push({
	            text: v,
	            value: k
	          });
	        });
	      }

	      if (this.prompt && lodash.isArray(arr)) {
	        var label = lodash.isBoolean(this.prompt) ? "Ch\u1ECDn ".concat(lodash.toLower(this.$attrs.label)) : this.prompt;
	        arr = [{
	          text: label,
	          value: null
	        }].concat(_toConsumableArray$9(arr));
	      }

	      return arr;
	    }
	  },
	  methods: {
	    strArr2Dot: function strArr2Dot(str) {
	      return str.replace('][', '.').replace('[', '.').replace(']', '');
	    }
	  }
	};

	if ($$1.fn.depdropLocales) {
	  $$1.fn.depdropLocales['vi'] = {
	    loadingText: 'Đang tải ...',
	    placeholder: 'Chọn ...',
	    emptyMsg: 'Không có dữ liệu'
	  };
	}

	var script$2 = {
	  name: 'field-select',
	  inheritAttrs: false,
	  mixins: [fieldMixin],
	  props: {
	    rules: {
	      type: [Object, String],
	      "default": ""
	    },
	    // must be included in props
	    value: {
	      type: null
	    },
	    options: [Array, Object],
	    prompt: [Boolean, String],
	    depends: Array,
	    url: String
	  },
	  data: function data() {
	    return {
	      innerValue: "" // innerOptions: []

	    };
	  },
	  watch: {
	    // Handles internal model changes.
	    innerValue: function innerValue(newVal) {
	      this.$emit("input", newVal);
	    },
	    // Handles external model changes.
	    value: function value(newVal) {
	      this.innerValue = newVal;
	    }
	  },
	  created: function created() {
	    if (!lodash.isUndefined(this.value)) {
	      this.innerValue = this.value;
	    }

	    if (this.url) ;
	  },
	  mounted: function mounted() {
	    if (this.url && this.depends) {
	      var depdropOptions = {
	        depends: this.depends,
	        url: this.url,
	        language: 'vi'
	      };

	      if (this.parentsHasValue()) {
	        depdropOptions = _objectSpread2$1({}, depdropOptions, {
	          initialize: true,
	          ajaxSettings: {
	            data: {
	              value: this.innerValue
	            }
	          }
	        });
	      }

	      $$1(this.$refs.select.$el).depdrop(depdropOptions);
	    }
	  },
	  methods: {
	    parentsHasValue: function parentsHasValue() {
	      for (var k in this.depends) {
	        var val = $$1("#".concat(this.depends[k])).val();
	        if (val) { return true; }
	      }

	      return false;
	    }
	  }
	};

	/* script */
	var __vue_script__$2 = script$2;

	/* template */
	var __vue_render__$2 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("ValidationProvider", {
	    ref: "validator",
	    attrs: { name: _vm.$attrs.label, rules: _vm.rules, vid: _vm.vid },
	    scopedSlots: _vm._u([
	      {
	        key: "default",
	        fn: function(ref) {
	          var invalid = ref.invalid;
	          var valid = ref.valid;
	          var touched = ref.touched;
	          var errors = ref.errors;
	          return [
	            _c(
	              "b-form-group",
	              {
	                attrs: {
	                  "label-class":
	                    invalid && touched
	                      ? "font-weight-semibold text-danger"
	                      : "",
	                  "label-for": _vm.$attrs.id,
	                  label: _vm.$attrs.label
	                }
	              },
	              [
	                _c(
	                  "b-form-select",
	                  _vm._b(
	                    {
	                      ref: "select",
	                      attrs: {
	                        id: _vm.$attrs.id,
	                        state: errors[0]
	                          ? false
	                          : valid && touched
	                          ? true
	                          : null,
	                        options: _vm.items
	                      },
	                      model: {
	                        value: _vm.innerValue,
	                        callback: function($$v) {
	                          _vm.innerValue = $$v;
	                        },
	                        expression: "innerValue"
	                      }
	                    },
	                    "b-form-select",
	                    _vm.$attrs,
	                    false
	                  )
	                ),
	                _vm._v(" "),
	                _c("b-form-invalid-feedback", [_vm._v(_vm._s(errors[0]))])
	              ],
	              1
	            )
	          ]
	        }
	      }
	    ])
	  })
	};
	var __vue_staticRenderFns__$2 = [];
	__vue_render__$2._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$2 = undefined;
	  /* scoped */
	  var __vue_scope_id__$2 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$2 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$2 = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$2 = normalizeComponent$1(
	    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
	    __vue_inject_styles__$2,
	    __vue_script__$2,
	    __vue_scope_id__$2,
	    __vue_is_functional_template__$2,
	    __vue_module_identifier__$2,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	//
	var script$3 = {
	  name: 'field-checkbox',
	  inheritAttrs: false,
	  mixins: [fieldMixin],
	  props: {
	    rules: {
	      type: [Object, String],
	      "default": ""
	    },
	    // must be included in props
	    value: {
	      type: null
	    }
	  },
	  data: function data() {
	    return {
	      innerValue: ""
	    };
	  },
	  watch: {
	    // Handles internal model changes.
	    innerValue: function innerValue(newVal) {
	      this.$emit("input", newVal);
	    },
	    // Handles external model changes.
	    value: function value(newVal) {
	      this.innerValue = newVal;
	    }
	  },
	  created: function created() {
	    if (!lodash.isUndefined(this.value)) {
	      this.innerValue = this.value;
	    }
	  }
	};

	/* script */
	var __vue_script__$3 = script$3;

	/* template */
	var __vue_render__$3 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("ValidationProvider", {
	    attrs: { name: _vm.$attrs.name, rules: _vm.rules },
	    scopedSlots: _vm._u([
	      {
	        key: "default",
	        fn: function(ref) {
	          var invalid = ref.invalid;
	          var valid = ref.valid;
	          var touched = ref.touched;
	          var errors = ref.errors;
	          return [
	            _c(
	              "b-form-group",
	              _vm._b(
	                { attrs: { "label-for": _vm.vid } },
	                "b-form-group",
	                _vm.$attrs,
	                false
	              ),
	              [
	                _c("b-form-checkbox-group", {
	                  attrs: {
	                    state: errors[0] ? false : valid && touched ? true : null,
	                    options: _vm.items
	                  },
	                  model: {
	                    value: _vm.innerValue,
	                    callback: function($$v) {
	                      _vm.innerValue = $$v;
	                    },
	                    expression: "innerValue"
	                  }
	                }),
	                _vm._v(" "),
	                _c("b-form-invalid-feedback", [_vm._v(_vm._s(errors[0]))])
	              ],
	              1
	            )
	          ]
	        }
	      }
	    ])
	  })
	};
	var __vue_staticRenderFns__$3 = [];
	__vue_render__$3._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$3 = undefined;
	  /* scoped */
	  var __vue_scope_id__$3 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$3 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$3 = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$3 = normalizeComponent$1(
	    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
	    __vue_inject_styles__$3,
	    __vue_script__$3,
	    __vue_scope_id__$3,
	    __vue_is_functional_template__$3,
	    __vue_module_identifier__$3,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	//
	var script$4 = {
	  name: 'field-radio',
	  inheritAttrs: false,
	  mixins: [fieldMixin],
	  props: {
	    rules: {
	      type: [Object, String],
	      "default": ""
	    },
	    // must be included in props
	    value: {
	      type: null
	    },
	    options: [Array, Object]
	  },
	  data: function data() {
	    return {
	      innerValue: null
	    };
	  },
	  watch: {
	    // Handles internal model changes.
	    innerValue: function innerValue(newVal) {
	      this.$emit("input", newVal);
	    },
	    // Handles external model changes.
	    value: function value(newVal) {
	      this.innerValue = newVal;
	    }
	  },
	  created: function created() {
	    if (!lodash.isUndefined(this.value)) {
	      this.innerValue = this.value;
	    }
	  }
	};

	/* script */
	var __vue_script__$4 = script$4;

	/* template */
	var __vue_render__$4 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("ValidationProvider", {
	    attrs: { name: _vm.$attrs.name, vid: _vm.vid, rules: _vm.rules },
	    scopedSlots: _vm._u([
	      {
	        key: "default",
	        fn: function(ref) {
	          var invalid = ref.invalid;
	          var valid = ref.valid;
	          var touched = ref.touched;
	          var errors = ref.errors;
	          return [
	            _c(
	              "b-form-group",
	              {
	                attrs: { "label-for": _vm.$attrs.id, label: _vm.$attrs.label }
	              },
	              [
	                _c(
	                  "b-form-radio-group",
	                  _vm._b(
	                    {
	                      attrs: {
	                        state: errors[0]
	                          ? false
	                          : valid && touched
	                          ? true
	                          : null,
	                        options: _vm.items,
	                        disabled: _vm.$attrs.disabled
	                      },
	                      model: {
	                        value: _vm.innerValue,
	                        callback: function($$v) {
	                          _vm.innerValue = $$v;
	                        },
	                        expression: "innerValue"
	                      }
	                    },
	                    "b-form-radio-group",
	                    _vm.$attrs,
	                    false
	                  )
	                ),
	                _vm._v(" "),
	                _c("b-form-invalid-feedback", [_vm._v(_vm._s(errors[0]))])
	              ],
	              1
	            )
	          ]
	        }
	      }
	    ])
	  })
	};
	var __vue_staticRenderFns__$4 = [];
	__vue_render__$4._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$4 = undefined;
	  /* scoped */
	  var __vue_scope_id__$4 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$4 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$4 = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$4 = normalizeComponent$1(
	    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
	    __vue_inject_styles__$4,
	    __vue_script__$4,
	    __vue_scope_id__$4,
	    __vue_is_functional_template__$4,
	    __vue_module_identifier__$4,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );



	var inputs = /*#__PURE__*/Object.freeze({
		__proto__: null,
		FieldInput: __vue_component__$1,
		FieldSelect: __vue_component__$2,
		FieldCheckbox: __vue_component__$3,
		FieldRadio: __vue_component__$4
	});

	var mixin = {
	  methods: {
	    only: function only(object, paths) {
	      var itemsSort = [];
	      var items = lodash.pick(object, paths);
	      paths.map(function (key) {
	        return lodash.hasIn(items, key) && itemsSort.push(_objectSpread2$1({}, lodash.get(items, key), {
	          name: key
	        }));
	      });
	      return itemsSort;
	    }
	  }
	};



	var mixins = /*#__PURE__*/Object.freeze({
		__proto__: null,
		schema: mixin
	});

	var jquery_sticky = createCommonjsModule(function (module) {
	// Sticky Plugin v1.0.4 for jQuery
	// =============
	// Author: Anthony Garand
	// Improvements by German M. Bravo (Kronuz) and Ruud Kamphuis (ruudk)
	// Improvements by Leonardo C. Daronco (daronco)
	// Created: 02/14/2011
	// Date: 07/20/2015
	// Website: http://stickyjs.com/
	// Description: Makes an element on the page stick on the screen as you scroll
	//              It will only set the 'top' and 'position' of your element, you
	//              might need to adjust the width in some cases.

	(function (factory) {
	    if ( module.exports) {
	        // Node/CommonJS
	        module.exports = factory($$1);
	    } else {
	        // Browser globals
	        factory(jQuery);
	    }
	}(function ($) {
	    var slice = Array.prototype.slice; // save ref to original slice()
	    var splice = Array.prototype.splice; // save ref to original slice()

	  var defaults = {
	      topSpacing: 0,
	      bottomSpacing: 0,
	      className: 'is-sticky',
	      wrapperClassName: 'sticky-wrapper',
	      center: false,
	      getWidthFrom: '',
	      widthFromWrapper: true, // works only when .getWidthFrom is empty
	      responsiveWidth: false,
	      zIndex: 'auto'
	    },
	    $window = $(window),
	    $document = $(document),
	    sticked = [],
	    windowHeight = $window.height(),
	    scroller = function() {
	      var scrollTop = $window.scrollTop(),
	        documentHeight = $document.height(),
	        dwh = documentHeight - windowHeight,
	        extra = (scrollTop > dwh) ? dwh - scrollTop : 0;

	      for (var i = 0, l = sticked.length; i < l; i++) {
	        var s = sticked[i],
	          elementTop = s.stickyWrapper.offset().top,
	          etse = elementTop - s.topSpacing - extra;

	        //update height in case of dynamic content
	        s.stickyWrapper.css('height', s.stickyElement.outerHeight());

	        if (scrollTop <= etse) {
	          if (s.currentTop !== null) {
	            s.stickyElement
	              .css({
	                'width': '',
	                'position': '',
	                'top': '',
	                'z-index': ''
	              });
	            s.stickyElement.parent().removeClass(s.className);
	            s.stickyElement.trigger('sticky-end', [s]);
	            s.currentTop = null;
	          }
	        }
	        else {
	          var newTop = documentHeight - s.stickyElement.outerHeight()
	            - s.topSpacing - s.bottomSpacing - scrollTop - extra;
	          if (newTop < 0) {
	            newTop = newTop + s.topSpacing;
	          } else {
	            newTop = s.topSpacing;
	          }
	          if (s.currentTop !== newTop) {
	            var newWidth;
	            if (s.getWidthFrom) {
	                newWidth = $(s.getWidthFrom).width() || null;
	            } else if (s.widthFromWrapper) {
	                newWidth = s.stickyWrapper.width();
	            }
	            if (newWidth == null) {
	                newWidth = s.stickyElement.width();
	            }
	            s.stickyElement
	              .css('width', newWidth)
	              .css('position', 'fixed')
	              .css('top', newTop)
	              .css('z-index', s.zIndex);

	            s.stickyElement.parent().addClass(s.className);

	            if (s.currentTop === null) {
	              s.stickyElement.trigger('sticky-start', [s]);
	            } else {
	              // sticky is started but it have to be repositioned
	              s.stickyElement.trigger('sticky-update', [s]);
	            }

	            if (s.currentTop === s.topSpacing && s.currentTop > newTop || s.currentTop === null && newTop < s.topSpacing) {
	              // just reached bottom || just started to stick but bottom is already reached
	              s.stickyElement.trigger('sticky-bottom-reached', [s]);
	            } else if(s.currentTop !== null && newTop === s.topSpacing && s.currentTop < newTop) {
	              // sticky is started && sticked at topSpacing && overflowing from top just finished
	              s.stickyElement.trigger('sticky-bottom-unreached', [s]);
	            }

	            s.currentTop = newTop;
	          }

	          // Check if sticky has reached end of container and stop sticking
	          var stickyWrapperContainer = s.stickyWrapper.parent();
	          var unstick = (s.stickyElement.offset().top + s.stickyElement.outerHeight() >= stickyWrapperContainer.offset().top + stickyWrapperContainer.outerHeight()) && (s.stickyElement.offset().top <= s.topSpacing);

	          if( unstick ) {
	            s.stickyElement
	              .css('position', 'absolute')
	              .css('top', '')
	              .css('bottom', 0)
	              .css('z-index', '');
	          } else {
	            s.stickyElement
	              .css('position', 'fixed')
	              .css('top', newTop)
	              .css('bottom', '')
	              .css('z-index', s.zIndex);
	          }
	        }
	      }
	    },
	    resizer = function() {
	      windowHeight = $window.height();

	      for (var i = 0, l = sticked.length; i < l; i++) {
	        var s = sticked[i];
	        var newWidth = null;
	        if (s.getWidthFrom) {
	            if (s.responsiveWidth) {
	                newWidth = $(s.getWidthFrom).width();
	            }
	        } else if(s.widthFromWrapper) {
	            newWidth = s.stickyWrapper.width();
	        }
	        if (newWidth != null) {
	            s.stickyElement.css('width', newWidth);
	        }
	      }
	    },
	    methods = {
	      init: function(options) {
	        var o = $.extend({}, defaults, options);
	        return this.each(function() {
	          var stickyElement = $(this);

	          var stickyId = stickyElement.attr('id');
	          var wrapperId = stickyId ? stickyId + '-' + defaults.wrapperClassName : defaults.wrapperClassName;
	          var wrapper = $('<div></div>')
	            .attr('id', wrapperId)
	            .addClass(o.wrapperClassName);

	          stickyElement.wrapAll(wrapper);

	          var stickyWrapper = stickyElement.parent();

	          if (o.center) {
	            stickyWrapper.css({width:stickyElement.outerWidth(),marginLeft:"auto",marginRight:"auto"});
	          }

	          if (stickyElement.css("float") === "right") {
	            stickyElement.css({"float":"none"}).parent().css({"float":"right"});
	          }

	          o.stickyElement = stickyElement;
	          o.stickyWrapper = stickyWrapper;
	          o.currentTop    = null;

	          sticked.push(o);

	          methods.setWrapperHeight(this);
	          methods.setupChangeListeners(this);
	        });
	      },

	      setWrapperHeight: function(stickyElement) {
	        var element = $(stickyElement);
	        var stickyWrapper = element.parent();
	        if (stickyWrapper) {
	          stickyWrapper.css('height', element.outerHeight());
	        }
	      },

	      setupChangeListeners: function(stickyElement) {
	        if (window.MutationObserver) {
	          var mutationObserver = new window.MutationObserver(function(mutations) {
	            if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) {
	              methods.setWrapperHeight(stickyElement);
	            }
	          });
	          mutationObserver.observe(stickyElement, {subtree: true, childList: true});
	        } else {
	          stickyElement.addEventListener('DOMNodeInserted', function() {
	            methods.setWrapperHeight(stickyElement);
	          }, false);
	          stickyElement.addEventListener('DOMNodeRemoved', function() {
	            methods.setWrapperHeight(stickyElement);
	          }, false);
	        }
	      },
	      update: scroller,
	      unstick: function(options) {
	        return this.each(function() {
	          var that = this;
	          var unstickyElement = $(that);

	          var removeIdx = -1;
	          var i = sticked.length;
	          while (i-- > 0) {
	            if (sticked[i].stickyElement.get(0) === that) {
	                splice.call(sticked,i,1);
	                removeIdx = i;
	            }
	          }
	          if(removeIdx !== -1) {
	            unstickyElement.unwrap();
	            unstickyElement
	              .css({
	                'width': '',
	                'position': '',
	                'top': '',
	                'float': '',
	                'z-index': ''
	              })
	            ;
	          }
	        });
	      }
	    };

	  // should be more efficient than using $window.scroll(scroller) and $window.resize(resizer):
	  if (window.addEventListener) {
	    window.addEventListener('scroll', scroller, false);
	    window.addEventListener('resize', resizer, false);
	  } else if (window.attachEvent) {
	    window.attachEvent('onscroll', scroller);
	    window.attachEvent('onresize', resizer);
	  }

	  $.fn.sticky = function(method) {
	    if (methods[method]) {
	      return methods[method].apply(this, slice.call(arguments, 1));
	    } else if (typeof method === 'object' || !method ) {
	      return methods.init.apply( this, arguments );
	    } else {
	      $.error('Method ' + method + ' does not exist on jQuery.sticky');
	    }
	  };

	  $.fn.unstick = function(method) {
	    if (methods[method]) {
	      return methods[method].apply(this, slice.call(arguments, 1));
	    } else if (typeof method === 'object' || !method ) {
	      return methods.unstick.apply( this, arguments );
	    } else {
	      $.error('Method ' + method + ' does not exist on jQuery.sticky');
	    }
	  };
	  $(function() {
	    setTimeout(scroller, 0);
	  });
	}));
	});

	var sticky = {
	  name: 'sticky',
	  inserted: function inserted(el, binding) {
	    $(el).sticky({
	      topSpacing: 0,
	      zIndex: 1000
	    });
	  }
	};



	var directives = /*#__PURE__*/Object.freeze({
		__proto__: null,
		sticky: sticky
	});



	var components = /*#__PURE__*/Object.freeze({
		__proto__: null
	});

	var FormPlugin$1 = {
	  install: function install(Vue, options) {
	    Vue.use(Vue2Filters);
	    Vue.use(VeeValidatePlugin);
	    Vue.use(LodashPlugin);
	    Vue.use(plugin$2);
	    Vue.use(plugin$3);
	    Vue.use(NotyPlugin);
	    Vue.component("tippy", __vue_component__);
	    Vue.component('v-ladda', LaddaComponent);
	    lodash.map(components, function (component) {
	      return Vue.component(component.name, component);
	    }); // Register Inputs

	    lodash.map(inputs, function (component) {
	      return Vue.component(component.name, component);
	    });
	    lodash.map(mixins, function (fns) {
	      return Vue.mixin(fns);
	    });
	    lodash.map(directives, function (directive) {
	      return Vue.directive(directive.name, directive);
	    });
	  }
	};

	var module = {
	  // namespaced: true,
	  state: {
	    items: [// {is_diachi: null, is_benhnhan: null, dienthoai: '', sonha: '', tenduong: '', to_kp: '', khupho: '', tinh: '', qh: '', px: '', tinh_dc_khac: '', disabled: false},
	    ]
	  },
	  getters: {
	    lastXm: function lastXm(state, getters) {
	      if (lodash.last(state)) { return lodash.last(state); }
	      return {
	        is_diachi: null,
	        is_benhnhan: null
	      };
	    } // preLastXm: (state, getters) => {
	    //     return head(takeRight(state.items, 2))
	    // },
	    // prepreLastXm: (state, getters) => {
	    //     return head(takeRight(state.items, 3))
	    // },
	    // shownChuyenca(state, {lastXm, preLastXm}){
	    //     return state.items.length > 1 && (
	    //         lastXm.tinh == 'HCM' &&
	    //         (
	    //             preLastXm.tinh !== lastXm.tinh ||
	    //             preLastXm.qh !== lastXm.qh ||
	    //             preLastXm.px !== lastXm.px
	    //         )
	    //     );
	    // }

	  },
	  mutations: {
	    PREPEND_XACMINHS: function PREPEND_XACMINHS(state, payload) {
	      state.items = [].concat(_toConsumableArray$9(payload), _toConsumableArray$9(state.items));
	    },
	    ADD_XM: function ADD_XM(state) {
	      state.items.push({
	        id: null,
	        is_diachi: null,
	        is_benhnhan: null,
	        dienthoai: '',
	        sonha: '',
	        tenduong: '',
	        to_kp: '',
	        khupho: '',
	        tinh: 'HCM',
	        qh: null,
	        px: null,
	        tinh_dc_khac: null
	      });
	      this.commit('XACMINH');
	    },
	    REMOVE_XM: function REMOVE_XM(state) {
	      state.items.splice(state.items.length - 1, 1);
	    }
	  },
	  actions: {
	    onChangeXacminh: {
	      root: true,
	      handler: function handler(_ref, _ref2) {
	        var commit = _ref.commit,
	            state = _ref.state,
	            rootState = _ref.rootState;
	        var after = _ref2.after;
	        var val = after.items,
	            lastXm = lodash.last(val),
	            preLastXm = lodash.head(lodash.takeRight(val, 2)),
	            prepreLastXm = lodash.head(lodash.takeRight(val, 3));
	        console.log(val);

	        if (lastXm.is_benhnhan == 0 && !lodash.isNull(lastXm.is_diachi)) {
	          commit('ADD_XM');
	          console.log(1);
	        }

	        if (val.length > 1) {
	          if (preLastXm.is_benhnhan == 1) {
	            commit('REMOVE_XM');
	            console.log(2);
	          }

	          if (lastXm.is_diachi == 1 && val.length % 2 == 0 && (lastXm.tinh && lastXm.tinh != preLastXm.tinh || lastXm.qh && lastXm.qh != preLastXm.qh || lastXm.px && lastXm.px != preLastXm.px)) {
	            rootState.is_xacminh || commit('ADD_XM');
	            console.log(rootState.is_xacminh);
	            console.log(4);
	          }

	          if (val.length % 2 != 0 && lodash.isNull(lastXm.is_diachi) && lodash.isNull(lastXm.is_benhnhan)) {
	            commit('REMOVE_XM');
	            console.log(6);
	          }

	          if (lastXm.is_diachi && lastXm.tinh && lastXm.tinh == preLastXm.tinh && lastXm.qh && lastXm.qh == preLastXm.qh && lastXm.px && lastXm.px == preLastXm.px) {
	            console.log('SHOWN_DIEUTRA');
	            !rootState.shownDieutra && commit('SHOWN_DIEUTRA', true);
	          } else {
	            rootState.shownDieutra && commit('SHOWN_DIEUTRA', false);
	          }
	        }

	        if (val.length == 1) {
	          if (lastXm.is_diachi && lastXm.is_benhnhan) {
	            !rootState.shownDieutra && commit('SHOWN_DIEUTRA', true);
	          } else {
	            rootState.shownDieutra && commit('SHOWN_DIEUTRA', false);
	          }
	        }

	        Vue.nextTick(function () {
	          state.items.map(function (v, k) {
	            if (k % 2 == 0) {
	              if (state.items[k].is_diachi === 0 && state.items[k].is_benhnhan == 1) {
	                state.items[k].is_benhnhan = null;
	              }
	            }
	          });
	        });
	      }
	    }
	  }
	};

	var schema = {};

	Vue.use(Vuex__default);
	var store = new Vuex__default.Store({
	  strict: true,
	  modules: {
	    xacminh: module
	  },
	  state: {
	    dm: {},
	    form: {},
	    disabled_px1: false,
	    disabled_px2: false,
	    shownDieutra: false,
	    is_xacminh: false,
	    schema: schema,
	    user: {},
	    loading: false
	  },
	  getters: {
	    loai_xm_cb: function loai_xm_cb(_ref) {
	      var xacminh = _ref.xacminh,
	          dm = _ref.dm,
	          form = _ref.form;
	      var val = xacminh.items,
	          danhmuc = dm.xacminh_cb,
	          lastXm = lodash.last(val),
	          preLastXm = lodash.head(lodash.takeRight(val, 2)),
	          status = null;

	      if (val.length % 2 == 0) {
	        if (lastXm.is_diachi == 0) {
	          if (preLastXm.tinh != lastXm.tinh || preLastXm.tinh == lastXm.tinh && preLastXm.qh == lastXm.qh && preLastXm.px == lastXm.px) {
	            status = 3;
	            console.log("xm-".concat(1));
	          }

	          if (preLastXm.qh != lastXm.qh && preLastXm.tinh == lastXm.tinh) {
	            status = 2;
	            console.log("xm-".concat(2));
	          }

	          if (preLastXm.px != lastXm.px && preLastXm.qh == lastXm.qh) {
	            status = 1;
	            console.log("xm-".concat(3));
	          }
	        }

	        if (lastXm.is_diachi == 1) {
	          if (preLastXm.tinh == lastXm.tinh && preLastXm.qh == lastXm.qh && preLastXm.px == lastXm.px) {
	            status = form.chuandoan == 1 ? 8 : 7;
	            console.log("xm-".concat(4));
	          }

	          if (preLastXm.tinh != lastXm.tinh) {
	            status = 6;
	            console.log("xm-".concat(5));
	          }

	          if (preLastXm.qh != lastXm.qh && preLastXm.tinh == lastXm.tinh) {
	            status = 5;
	            console.log("xm-".concat(6));
	          }

	          if (preLastXm.px != lastXm.px && preLastXm.qh == lastXm.qh) {
	            status = 4;
	            console.log("xm-".concat(7));
	          }
	        }
	      } // 1, 3, 5


	      if (val.length % 2 != 0) {
	        if (val.length == 1 && lastXm.is_diachi && lastXm.is_benhnhan) {
	          status = form.chuandoan == 1 ? 8 : 7;
	          console.log("xm-".concat(8));
	        }

	        if (val.length > 1) {
	          // 7,8
	          if (lastXm.is_diachi && lastXm.is_benhnhan && preLastXm.tinh == lastXm.tinh && preLastXm.qh == lastXm.qh && preLastXm.px == lastXm.px) {
	            status = form.chuandoan == 1 ? 8 : 7;
	            console.log("xm-".concat(9));
	          }

	          if (preLastXm.tinh != lastXm.tinh) {
	            status = 6;
	            console.log("xm-".concat(10));
	          }

	          if (preLastXm.qh != lastXm.qh && preLastXm.tinh == lastXm.tinh) {
	            status = 5;
	            console.log("xm-".concat(11));
	          }

	          if (preLastXm.px != lastXm.px && preLastXm.qh == lastXm.qh) {
	            status = 4;
	            console.log("xm-".concat(12));
	          }
	        }
	      }

	      return status;
	    }
	  },
	  mutations: {
	    LOADING: function LOADING(state) {
	      state.loading = true;
	    },
	    LOADED: function LOADED(state) {
	      state.loading = false;
	    },
	    UPDATE_LATLNG: function UPDATE_LATLNG(state, _ref2) {
	      var lat = _ref2.lat,
	          lng = _ref2.lng;
	      state.form.lat = lat;
	      state.form.lng = lng;
	    },
	    UPDATE_FORM: function UPDATE_FORM(state, _ref3) {
	      var xacminh = _ref3.xacminh,
	          form = _objectWithoutProperties(_ref3, ["xacminh"]);

	      state.form = _objectSpread2$1({}, state.form, {}, form);
	    },
	    UPDATE_STORE: function UPDATE_STORE(state) {
	      var _window$appData = window.appData,
	          dm = _window$appData.dm,
	          form = _window$appData.form,
	          schema = _window$appData.schema,
	          xacminh = _window$appData.xacminh,
	          user = _window$appData.user;
	      state.user = user;
	      lodash.map(dm, function (v, k) {
	        state.dm[k] = lodash.isArray(v) ? v : lodash.map(v, function (v1, k1) {
	          return {
	            value: k1,
	            text: v1
	          };
	        });
	      });
	      state.form = form;
	      lodash.map(schema, function (v, k) {
	        state.schema[v.name] = v;
	      });

	      if (xacminh) {
	        var lastXm = lodash.last(xacminh);
	        state.xacminh.items = xacminh;

	        if (xacminh.length == 1 && lastXm.is_diachi && lastXm.is_benhnhan) {
	          state.shownDieutra = true;
	        }

	        if (lastXm.is_diachi) {
	          if (xacminh.length == 1 && lastXm.is_diachi && lastXm.is_benhnhan) {
	            state.shownDieutra = true;
	          }

	          if (xacminh.length > 1) {
	            var preLastXm = lodash.head(lodash.takeRight(xacminh, 2));

	            if (lastXm.tinh == preLastXm.tinh && lastXm.qh == preLastXm.qh && lastXm.px == preLastXm.px && lastXm.is_diachi) {
	              if (xacminh.length % 2 != 0 && lastXm.is_benhnhan) {
	                // 3,5
	                state.shownDieutra = true;
	              }

	              if (xacminh.length % 2 == 0) {
	                // 2,4,6
	                state.shownDieutra = true;
	              }
	            } else {
	              if (lastXm.tinh == 'HCM') {
	                var disabled = false;
	                var _user = state.user;

	                if (lodash.includes(_user.roles, 'phuong') && lastXm.px !== _user.maphuong) {
	                  disabled = true;
	                }

	                state.xacminh.items.push(_objectSpread2$1({}, lastXm, {
	                  disabled: disabled,
	                  is_diachi: null,
	                  is_benhnhan: null
	                }));
	              }
	            }
	          }
	        }
	      }
	    },
	    CHECK_DISABLED: function CHECK_DISABLED(state) {
	      var xms = state.xacminh.items;

	      if (xms.length > 2) {
	        state.disabled_px1 = true;
	      }
	    },
	    SHOWN_DIEUTRA: function SHOWN_DIEUTRA(state, payload) {
	      state.shownDieutra = payload;
	    },
	    XACMINH: function XACMINH(state) {
	      state.is_xacminh = true;
	    }
	  }
	});

	var script$5 = {
	  name: 'header-part',
	  props: ['shownChuyenca'],
	  computed: _objectSpread2$1({}, Vuex.mapState(['form', 'xacminh', 'shownDieutra', 'dm', 'loading', 'user']), {
	    loai_dt_item: function loai_dt_item() {
	      var loai_dt = this.form.loaidieutra,
	          colors = {
	        0: 'danger',
	        1: 'warning',
	        2: 'info',
	        3: 'primary'
	      },
	          status = this.dm.loaidieutra.find(function (v) {
	        return v.value == loai_dt;
	      });
	      status.variant = colors[status.value];
	      return status;
	    },
	    xacminh_cb_item: function xacminh_cb_item() {
	      var val = this.form.loai_xm_cb;
	      return this.dm.xacminh_cb.find(function (v) {
	        return v.value == val;
	      }) || {};
	    },
	    unLockedBtn: function unLockedBtn() {
	      var maphuong = this.user.maphuong,
	          px2 = lodash.get(lodash.last(this.form.xacminh), 'px'); // if (isNull(px2) || maphuong == px2 || includes(this.user.roles, 'quan')) {
	      //     return true
	      // }

	      return true;
	    }
	  })
	};

	/* script */
	var __vue_script__$5 = script$5;

	/* template */
	var __vue_render__$5 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "b-card-header",
	    {
	      directives: [{ name: "sticky", rawName: "v-sticky" }],
	      staticClass: "bg-white header-elements-inline"
	    },
	    [
	      _c(
	        "div",
	        { staticClass: "card-title  font-weight-semibold text-primary" },
	        [
	          _c("div", { staticClass: "float-left" }, [
	            _c("i", { staticClass: "icon-map5 position-left" }),
	            _vm._v(
	              " " +
	                _vm._s(
	                  _vm._f("uppercase")(
	                    _vm._f("or")(_vm.form.hoten, "Phiếu điều tra SXH")
	                  )
	                ) +
	                "\n            "
	            ),
	            _c(
	              "span",
	              { staticClass: "ml-2" },
	              [
	                _c(
	                  "b-badge",
	                  {
	                    attrs: {
	                      variant: _vm.loai_dt_item.variant,
	                      "data-value": _vm.loai_dt_item.value
	                    }
	                  },
	                  [_vm._v(_vm._s(_vm.loai_dt_item.text))]
	                ),
	                _vm._v(" "),
	                _c(
	                  "b-badge",
	                  {
	                    staticClass: "ml-2",
	                    attrs: {
	                      variant: "info",
	                      "data-value": _vm.xacminh_cb_item.value
	                    }
	                  },
	                  [_vm._v(_vm._s(_vm.xacminh_cb_item.text))]
	                )
	              ],
	              1
	            )
	          ])
	        ]
	      ),
	      _vm._v(" "),
	      _c("div", { staticClass: "header-elements" }, [
	        _c(
	          "li",
	          { staticClass: "list-inline-item" },
	          [
	            _vm.unLockedBtn
	              ? _c(
	                  "b-form-group",
	                  { staticClass: "text-right" },
	                  [
	                    _c(
	                      "v-ladda",
	                      {
	                        attrs: {
	                          type: "submit",
	                          "button-class":
	                            "btn btn-" +
	                            (_vm.shownChuyenca ? "danger" : "primary"),
	                          loading: _vm.loading
	                        }
	                      },
	                      [
	                        _vm.shownChuyenca
	                          ? _c("span", [_vm._v("Lưu và chuyển ca")])
	                          : _c("span", [_vm._v("Lưu phiếu")])
	                      ]
	                    )
	                  ],
	                  1
	                )
	              : _c(
	                  "div",
	                  [
	                    _c(
	                      "b-badge",
	                      {
	                        staticClass: "text-uppercase",
	                        attrs: { variant: "danger" }
	                      },
	                      [_vm._v("Bạn không đủ quyền để cập nhật phiếu")]
	                    )
	                  ],
	                  1
	                )
	          ],
	          1
	        )
	      ])
	    ]
	  )
	};
	var __vue_staticRenderFns__$5 = [];
	__vue_render__$5._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$5 = undefined;
	  /* scoped */
	  var __vue_scope_id__$5 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$5 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$5 = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$5 = normalizeComponent$1(
	    { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
	    __vue_inject_styles__$5,
	    __vue_script__$5,
	    __vue_scope_id__$5,
	    __vue_is_functional_template__$5,
	    __vue_module_identifier__$5,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var script$6 = {
	  name: 'map-part',
	  computed: _objectSpread2$1({}, Vuex.mapState(['form', 'schema']))
	};

	/* script */
	var __vue_script__$6 = script$6;

	/* template */
	var __vue_render__$6 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    [
	      _c(
	        "b-row",
	        [
	          _vm._l(_vm.only(_vm.schema, ["lat", "lng", "chuandoan_bd"]), function(
	            i,
	            k
	          ) {
	            return _c(
	              "b-col",
	              { key: k, attrs: { md: i.md } },
	              [_c("field-sxh", { attrs: { name: i.name } })],
	              1
	            )
	          }),
	          _vm._v(" "),
	          _vm.form.chuandoan_bd === "KHAC"
	            ? _c(
	                "b-col",
	                [_c("field-sxh", { attrs: { name: "chuandoan_bd_khac" } })],
	                1
	              )
	            : _vm._e()
	        ],
	        2
	      ),
	      _vm._v(" "),
	      _c(
	        "b-row",
	        _vm._l(
	          _vm.only(_vm.schema, ["me", "ngaybaocao", "ma_icd", "shs"]),
	          function(i, k) {
	            return _c(
	              "b-col",
	              { key: k },
	              [_c("field-sxh", { attrs: { name: i.name } })],
	              1
	            )
	          }
	        ),
	        1
	      ),
	      _vm._v(" "),
	      _c(
	        "b-row",
	        [
	          _c(
	            "b-col",
	            { attrs: { md: "6" } },
	            [_c("field-sxh", { attrs: { name: "ht_dieutri" } })],
	            1
	          ),
	          _vm._v(" "),
	          _c(
	            "b-col",
	            {
	              staticClass: "text-right pt-4",
	              attrs: { md: "3", "offset-md": "3" }
	            },
	            [
	              _c(
	                "button",
	                {
	                  staticClass:
	                    "btn btn-outline bg-primary-400 text-primary-400 border-primary-400 btn-sm",
	                  attrs: { type: "button" }
	                },
	                [_vm._v("Hiển thị ca cùng nhà")]
	              )
	            ]
	          )
	        ],
	        1
	      )
	    ],
	    1
	  )
	};
	var __vue_staticRenderFns__$6 = [];
	__vue_render__$6._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$6 = undefined;
	  /* scoped */
	  var __vue_scope_id__$6 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$6 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$6 = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$6 = normalizeComponent$1(
	    { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
	    __vue_inject_styles__$6,
	    __vue_script__$6,
	    __vue_scope_id__$6,
	    __vue_is_functional_template__$6,
	    __vue_module_identifier__$6,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var script$7 = {
	  name: 'xacminh-part',
	  computed: _objectSpread2$1({}, Vuex.mapGetters(['lastXm']), {}, Vuex.mapState(['form', 'schema', 'xacminh', 'dm', 'shownDieutra']))
	};

	/* script */
	var __vue_script__$7 = script$7;

	/* template */
	var __vue_render__$7 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", [
	    _vm._m(0),
	    _vm._v(" "),
	    _c(
	      "div",
	      [
	        _c(
	          "b-row",
	          [
	            _vm._l(
	              _vm.only(_vm.schema, ["ngaynhanthongbao", "ngaydieutra", "maso"]),
	              function(i, k) {
	                return _c(
	                  "b-col",
	                  { key: k },
	                  [_c("field-sxh", { attrs: { name: i.name } })],
	                  1
	                )
	              }
	            ),
	            _vm._v(" "),
	            _c("b-col")
	          ],
	          2
	        ),
	        _vm._v(" "),
	        _vm._m(1),
	        _vm._v(" "),
	        _c(
	          "b-row",
	          _vm._l(
	            _vm.only(_vm.schema, ["hoten", "phai", "ngaysinh", "tuoi"]),
	            function(i, k) {
	              return _c(
	                "b-col",
	                { key: k },
	                [_c("field-sxh", { attrs: { name: i.name } })],
	                1
	              )
	            }
	          ),
	          1
	        ),
	        _vm._v(" "),
	        _vm._l(_vm.xacminh.items, function(v, k) {
	          return _c(
	            "div",
	            { key: k },
	            [
	              _c(
	                "b-row",
	                [
	                  _vm._l(
	                    _vm.only(_vm.schema, [
	                      "is_diachi",
	                      "is_benhnhan",
	                      "dienthoai"
	                    ]),
	                    function(i, k1) {
	                      return _c(
	                        "b-col",
	                        { key: k1 },
	                        [
	                          !(i.name === "is_benhnhan" && k % 2)
	                            ? _c("field-sxh", {
	                                attrs: {
	                                  id: "field-" + k + "-" + i.name,
	                                  name: "xacminh[" + k + "][" + i.name + "]",
	                                  nameKey: i.name,
	                                  path: "xacminh.items." + k + "." + i.name,
	                                  label:
	                                    _vm.schema[i.name].label +
	                                    " (" +
	                                    (k + 1) +
	                                    ")"
	                                }
	                              })
	                            : _vm._e()
	                        ],
	                        1
	                      )
	                    }
	                  ),
	                  _vm._v(" "),
	                  k === 0
	                    ? _c("b-col", [
	                        _c(
	                          "div",
	                          {
	                            staticClass: "form-group",
	                            attrs: { role: "group", id: "__BVID__113" }
	                          },
	                          [
	                            _c(
	                              "label",
	                              { staticClass: "d-block" },
	                              [
	                                _c("span", [_vm._v("Vị trí (cũ)")]),
	                                _vm._v(" "),
	                                _c(
	                                  "b-badge",
	                                  {
	                                    directives: [
	                                      { name: "tippy", rawName: "v-tippy" }
	                                    ],
	                                    staticClass: "ml-2",
	                                    attrs: {
	                                      content: "Tìm kiếm trên Google",
	                                      href:
	                                        "https://www.google.com/maps/search/" +
	                                        _vm.form.vitri,
	                                      variant: "info",
	                                      target: "_blank"
	                                    }
	                                  },
	                                  [_vm._v("Google")]
	                                ),
	                                _vm._v(" "),
	                                _c(
	                                  "b-badge",
	                                  {
	                                    directives: [
	                                      { name: "tippy", rawName: "v-tippy" }
	                                    ],
	                                    attrs: {
	                                      content: "Tìm kiếm trên Vietbando",
	                                      href:
	                                        "http://maps.vietbando.com/maps/?sk=" +
	                                        _vm.form.vitri,
	                                      variant: "secondary",
	                                      target: "_blank"
	                                    }
	                                  },
	                                  [_vm._v("Vietbando")]
	                                )
	                              ],
	                              1
	                            ),
	                            _vm._v(" "),
	                            _c("div", [
	                              _vm._v(
	                                "\n                            " +
	                                  _vm._s(_vm.form.vitri) +
	                                  "\n                        "
	                              )
	                            ])
	                          ]
	                        )
	                      ])
	                    : _vm._e()
	                ],
	                2
	              ),
	              _vm._v(" "),
	              (k + 1) % 2 != 0 || ((k + 1) % 2 == 0 && v.is_diachi == 1)
	                ? _c(
	                    "div",
	                    [
	                      _c(
	                        "b-row",
	                        _vm._l(
	                          _vm.only(_vm.schema, [
	                            "sonha",
	                            "duong",
	                            "to_dp",
	                            "khupho"
	                          ]),
	                          function(i, k1) {
	                            return _c(
	                              "b-col",
	                              { key: k1 },
	                              [
	                                _c("field-sxh", {
	                                  attrs: {
	                                    id: "field-" + k + "-" + i.name,
	                                    name: "xacminh[" + k + "][" + i.name + "]",
	                                    nameKey: i.name,
	                                    path: "xacminh.items." + k + "." + i.name,
	                                    label:
	                                      _vm.schema[i.name].label +
	                                      " (" +
	                                      (k + 1) +
	                                      ")"
	                                  }
	                                })
	                              ],
	                              1
	                            )
	                          }
	                        ),
	                        1
	                      ),
	                      _vm._v(" "),
	                      _c(
	                        "b-row",
	                        [
	                          _c(
	                            "b-col",
	                            { attrs: { md: "6" } },
	                            [
	                              _c("field-sxh", {
	                                attrs: {
	                                  id: "field-" + k + "-tinh",
	                                  name: "xacminh[" + k + "][tinh]",
	                                  nameKey: "tinh",
	                                  path: "xacminh.items." + k + ".tinh",
	                                  label:
	                                    _vm.schema["tinh"].label +
	                                    " (" +
	                                    (k + 1) +
	                                    ")"
	                                }
	                              })
	                            ],
	                            1
	                          ),
	                          _vm._v(" "),
	                          v.tinh === "HCM"
	                            ? _c(
	                                "b-col",
	                                [
	                                  _c("field-sxh", {
	                                    attrs: {
	                                      id: "field-" + k + "-qh",
	                                      name: "xacminh[" + k + "][qh]",
	                                      nameKey: "qh",
	                                      path: "xacminh.items." + k + ".qh",
	                                      label:
	                                        _vm.schema["qh"].label +
	                                        " (" +
	                                        (k + 1) +
	                                        ")"
	                                    }
	                                  })
	                                ],
	                                1
	                              )
	                            : _vm._e(),
	                          _vm._v(" "),
	                          v.tinh === "HCM"
	                            ? _c(
	                                "b-col",
	                                [
	                                  _c("field-sxh", {
	                                    attrs: {
	                                      id: "field-" + k + "-px",
	                                      name: "xacminh[" + k + "][px]",
	                                      nameKey: "px",
	                                      path: "xacminh.items." + k + ".px",
	                                      label:
	                                        _vm.schema["px"].label +
	                                        " (" +
	                                        (k + 1) +
	                                        ")",
	                                      depends: ["field-" + k + "-qh"]
	                                    }
	                                  })
	                                ],
	                                1
	                              )
	                            : _vm._e(),
	                          _vm._v(" "),
	                          v.tinh === "TinhKhac"
	                            ? _c(
	                                "b-col",
	                                [
	                                  _c("field-sxh", {
	                                    attrs: {
	                                      id: "field-" + k + "-tinh_dc_khac",
	                                      name: "xacminh[" + k + "][tinh_dc_khac]",
	                                      nameKey: "tinh_dc_khac",
	                                      path:
	                                        "xacminh.items." + k + ".tinh_dc_khac",
	                                      label:
	                                        _vm.schema["tinh_dc_khac"].label +
	                                        " (" +
	                                        (k + 1) +
	                                        ")"
	                                    }
	                                  })
	                                ],
	                                1
	                              )
	                            : _vm._e()
	                        ],
	                        1
	                      )
	                    ],
	                    1
	                  )
	                : _vm._e()
	            ],
	            1
	          )
	        }),
	        _vm._v(" "),
	        _vm.shownDieutra
	          ? _c(
	              "b-row",
	              [
	                _c(
	                  "b-col",
	                  [_c("field-sxh", { attrs: { name: "benhnoikhac" } })],
	                  1
	                )
	              ],
	              1
	            )
	          : _vm._e(),
	        _vm._v(" "),
	        _vm.form.benhnoikhac == 1
	          ? _c(
	              "div",
	              [
	                _c(
	                  "b-row",
	                  _vm._l(
	                    _vm.only(_vm.schema, [
	                      "sonhakhac",
	                      "duongkhac",
	                      "tokhac",
	                      "khuphokhac"
	                    ]),
	                    function(i, k) {
	                      return _c(
	                        "b-col",
	                        { key: k, attrs: { md: i.md } },
	                        [_c("field-sxh", { attrs: { name: i.name } })],
	                        1
	                      )
	                    }
	                  ),
	                  1
	                ),
	                _vm._v(" "),
	                _c(
	                  "b-row",
	                  [
	                    _c(
	                      "b-col",
	                      { attrs: { md: "6" } },
	                      [_c("field-sxh", { attrs: { name: "tinhkhac" } })],
	                      1
	                    ),
	                    _vm._v(" "),
	                    _vm._l(_vm.only(_vm.schema, ["qhkhac", "pxkhac"]), function(
	                      i,
	                      k
	                    ) {
	                      return _vm.form.tinhkhac === "HCM"
	                        ? _c(
	                            "b-col",
	                            { key: k, attrs: { md: i.md } },
	                            [_c("field-sxh", { attrs: { name: i.name } })],
	                            1
	                          )
	                        : _vm._e()
	                    }),
	                    _vm._v(" "),
	                    _vm.form.tinhkhac === "TinhKhac"
	                      ? _c(
	                          "b-col",
	                          [_c("field-sxh", { attrs: { name: "tinhnoikhac" } })],
	                          1
	                        )
	                      : _vm._e()
	                  ],
	                  2
	                )
	              ],
	              1
	            )
	          : _vm._e()
	      ],
	      2
	    )
	  ])
	};
	var __vue_staticRenderFns__$7 = [
	  function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("header", [
	      _c("p", { staticClass: "text-primary" }, [_vm._v("Phiếu điều tra")]),
	      _vm._v(" "),
	      _c("p", { staticClass: "text-primary" }, [
	        _vm._v("Ca bệnh sốt xuất huyết Dengue")
	      ])
	    ])
	  },
	  function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("div", { staticClass: "phieu-title mb-2" }, [
	      _c(
	        "span",
	        {
	          staticClass: "badge badge-flat badge-pill border-primary text-primary"
	        },
	        [_vm._v("1")]
	      ),
	      _vm._v(" Xác minh ca bệnh\n        ")
	    ])
	  }
	];
	__vue_render__$7._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$7 = undefined;
	  /* scoped */
	  var __vue_scope_id__$7 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$7 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$7 = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$7 = normalizeComponent$1(
	    { render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 },
	    __vue_inject_styles__$7,
	    __vue_script__$7,
	    __vue_scope_id__$7,
	    __vue_is_functional_template__$7,
	    __vue_module_identifier__$7,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var script$8 = {
	  name: 'dieutra-part',
	  computed: _objectSpread2$1({}, Vuex.mapState(['dm', 'form', 'schema']))
	};

	/* script */
	var __vue_script__$8 = script$8;

	/* template */
	var __vue_render__$8 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    [
	      _c(
	        "b-row",
	        _vm._l(_vm.only(_vm.schema, ["songuoicutru", "cutruduoi15"]), function(
	          i,
	          k
	        ) {
	          return _c(
	            "b-col",
	            { key: k },
	            [_c("field-sxh", { attrs: { name: i.name } })],
	            1
	          )
	        }),
	        1
	      ),
	      _vm._v(" "),
	      _vm._m(0),
	      _vm._v(" "),
	      _c(
	        "b-row",
	        { staticClass: "mt-2" },
	        [
	          _c(
	            "b-col",
	            [
	              _c(
	                "b-row",
	                [
	                  _c("b-col", [_c("field-sxh", { attrs: { name: "tpbv" } })], 1)
	                ],
	                1
	              ),
	              _vm._v(" "),
	              _c(
	                "b-row",
	                [
	                  _vm.form.tpbv
	                    ? _c(
	                        "b-col",
	                        { attrs: { md: "6" } },
	                        [_c("field-sxh", { attrs: { name: "tpbv_bv" } })],
	                        1
	                      )
	                    : _vm._e()
	                ],
	                1
	              )
	            ],
	            1
	          ),
	          _vm._v(" "),
	          _vm.form.tpbv == 0
	            ? _c(
	                "b-col",
	                [
	                  _c(
	                    "b-row",
	                    [
	                      _c(
	                        "b-col",
	                        [_c("field-sxh", { attrs: { name: "phcd" } })],
	                        1
	                      ),
	                      _vm._v(" "),
	                      _vm.form.phcd == 1
	                        ? _c(
	                            "b-col",
	                            [_c("field-sxh", { attrs: { name: "nhapvien" } })],
	                            1
	                          )
	                        : _vm._e()
	                    ],
	                    1
	                  ),
	                  _vm._v(" "),
	                  _vm.form.nhapvien == 1
	                    ? _c("field-sxh", { attrs: { name: "nhapvien_bv" } })
	                    : _vm._e()
	                ],
	                1
	              )
	            : _vm._e()
	        ],
	        1
	      ),
	      _vm._v(" "),
	      _c(
	        "b-row",
	        _vm._l(
	          _vm.only(_vm.schema, ["ngaymacbenh", "ngaynhapvien", "nghenghiep"]),
	          function(i, k) {
	            return _c(
	              "b-col",
	              { key: k, attrs: { md: i.md } },
	              [_c("field-sxh", { attrs: { name: i.name } })],
	              1
	            )
	          }
	        ),
	        1
	      ),
	      _vm._v(" "),
	      _c(
	        "b-row",
	        [
	          _c("b-col", [_c("field-sxh", { attrs: { name: "xetnghiem" } })], 1),
	          _vm._v(" "),
	          _vm._l(
	            _vm.only(_vm.schema, ["ngaylaymau", "loai_xn", "ketqua_xn"]),
	            function(i, k) {
	              return _vm.form.xetnghiem == 1
	                ? _c(
	                    "b-col",
	                    { key: k },
	                    [_c("field-sxh", { attrs: { name: i.name } })],
	                    1
	                  )
	                : _vm._e()
	            }
	          )
	        ],
	        2
	      ),
	      _vm._v(" "),
	      _c(
	        "b-row",
	        [
	          _vm._l(
	            _vm.only(_vm.schema, ["dclamviec", "dclamviec_tinh"]),
	            function(i, k) {
	              return _c(
	                "b-col",
	                { key: k, attrs: { md: i.md } },
	                [_c("field-sxh", { attrs: { name: i.name } })],
	                1
	              )
	            }
	          ),
	          _vm._v(" "),
	          _vm._l(_vm.only(_vm.schema, ["dclamviecqh", "dclamviecpx"]), function(
	            i,
	            k
	          ) {
	            return _vm.form.dclamviec_tinh == "79"
	              ? _c(
	                  "b-col",
	                  { key: "dclamviec-" + k, attrs: { md: i.md } },
	                  [_c("field-sxh", { attrs: { name: i.name } })],
	                  1
	                )
	              : _vm._e()
	          })
	        ],
	        2
	      ),
	      _vm._v(" "),
	      _c("field-sxh", { attrs: { name: "noilamviec_sxh" } }),
	      _vm._v(" "),
	      _c("div", { staticClass: "form-group" }, [
	        _vm._v(
	          "\n        Trong vòng 2 tuần trước khi bị bệnh, BN có đi đến hay thường đến những nơi nào sau đây (đánh dấu nhiều ô):\n    "
	        )
	      ]),
	      _vm._v(" "),
	      _c(
	        "div",
	        [
	          _vm._l(
	            _vm.only(_vm.schema, [
	              "nhacobnsxh",
	              "nhaconguoibenh",
	              "bvpk",
	              "nhatho",
	              "dinh",
	              "congvien",
	              "noihoihop",
	              "noixd",
	              "cafe",
	              "noichannuoi",
	              "noibancay",
	              "vuaphelieu"
	            ]),
	            function(i, k) {
	              return _c(
	                "b-row",
	                { key: k },
	                [
	                  _c("b-col", { attrs: { md: "3" } }, [
	                    _vm._v(
	                      "\n                " +
	                        _vm._s(i.labelInline) +
	                        "\n            "
	                    )
	                  ]),
	                  _vm._v(" "),
	                  _c(
	                    "b-col",
	                    { attrs: { md: "9" } },
	                    [_c("field-sxh", { attrs: { name: i.name } })],
	                    1
	                  )
	                ],
	                1
	              )
	            }
	          ),
	          _vm._v(" "),
	          _c(
	            "b-row",
	            [
	              _c("b-col", { attrs: { md: "3" } }, [
	                _vm._v(
	                  "\n                " +
	                    _vm._s(_vm.schema.noikhac.labelInline) +
	                    "\n            "
	                )
	              ]),
	              _vm._v(" "),
	              _c(
	                "b-col",
	                { attrs: { md: "3" } },
	                [_c("field-sxh", { attrs: { name: "noikhac" } })],
	                1
	              ),
	              _vm._v(" "),
	              _vm.form.noikhac == 1
	                ? _c(
	                    "b-col",
	                    { attrs: { md: "6" } },
	                    [_c("field-sxh", { attrs: { name: "noikhac_ghichu" } })],
	                    1
	                  )
	                : _vm._e()
	            ],
	            1
	          )
	        ],
	        2
	      ),
	      _vm._v(" "),
	      _c("div", { staticClass: "form-group" }, [
	        _vm._v(
	          "\n        Các điểm đã đến ghi ở trên thuộc địa bàn (đánh dấu nhiều ô):\n    "
	        )
	      ]),
	      _vm._v(" "),
	      _vm._l(
	        _vm.only(_vm.schema, [
	          "diemden_px",
	          "diemden_pxkhac",
	          "diemden_qhkhac"
	        ]),
	        function(i, k) {
	          return _c(
	            "b-row",
	            { key: k },
	            [
	              _c("b-col", { attrs: { md: "3" } }, [
	                _vm._v("\n            " + _vm._s(i.labelInline) + "\n        ")
	              ]),
	              _vm._v(" "),
	              _c(
	                "b-col",
	                { attrs: { md: "9" } },
	                [_c("field-sxh", { attrs: { name: i.name } })],
	                1
	              )
	            ],
	            1
	          )
	        }
	      ),
	      _vm._v(" "),
	      _c("div", { staticClass: "form-group" }, [
	        _vm._v("\n        Trong vòng 1 tháng qua, tại gia đình\n    ")
	      ]),
	      _vm._v(" "),
	      _c(
	        "b-row",
	        [
	          _c(
	            "b-col",
	            { attrs: { md: "4" } },
	            [_c("field-sxh", { attrs: { name: "gdcosxh" } })],
	            1
	          ),
	          _vm._v(" "),
	          _vm._l(_vm.only(_vm.schema, ["gdsonguoisxh", "gdso15t"]), function(
	            i,
	            k
	          ) {
	            return _vm.form.gdcosxh == 1
	              ? _c(
	                  "b-col",
	                  { key: k, attrs: { md: "3" } },
	                  [_c("field-sxh", { attrs: { name: i.name } })],
	                  1
	                )
	              : _vm._e()
	          })
	        ],
	        2
	      ),
	      _vm._v(" "),
	      _c(
	        "b-row",
	        [
	          _c(
	            "b-col",
	            { attrs: { md: "4" } },
	            [_c("field-sxh", { attrs: { name: "gdthuocsxh" } })],
	            1
	          ),
	          _vm._v(" "),
	          _vm._l(
	            _vm.only(_vm.schema, ["gdthuocsxhsonguoi", "gdthuocsxh15t"]),
	            function(i, k) {
	              return _vm.form.gdthuocsxh == 1
	                ? _c(
	                    "b-col",
	                    { key: k, attrs: { md: "3" } },
	                    [_c("field-sxh", { attrs: { name: i.name } })],
	                    1
	                  )
	                : _vm._e()
	            }
	          )
	        ],
	        2
	      ),
	      _vm._v(" "),
	      _c("div", { staticClass: "form-group" }, [
	        _vm._v(
	          "\n        (nếu có người mắc bệnh SXH, điều tra ca bệnh tiếp tục theo mẫu điều tra này)\n    "
	        )
	      ]),
	      _vm._v(" "),
	      _vm._m(1),
	      _vm._v(" "),
	      _c("p", [_vm._v("Khảo sát khi ca bệnh là ca chỉ điểm / ca đầu tiên.")]),
	      _vm._v(" "),
	      _vm._m(2),
	      _vm._v(" "),
	      _c("p", [
	        _vm._v(
	          "Khảo sát nhà ca bệnh và 15 nhà chung quanh theo mẫu khảo sát lăng quăng."
	        )
	      ]),
	      _vm._v(" "),
	      _c(
	        "div",
	        { staticClass: "form-inline" },
	        [
	          _c("label", { staticClass: "control-label mr-2" }, [
	            _vm._v("Kết quả:")
	          ]),
	          _vm._v(" "),
	          _vm._l(_vm.only(_vm.schema, ["bi", "ci"]), function(i, k) {
	            return _c(
	              "div",
	              { key: k, staticClass: "mr-2" },
	              [_c("field-sxh", { attrs: { name: i.name } })],
	              1
	            )
	          })
	        ],
	        2
	      )
	    ],
	    2
	  )
	};
	var __vue_staticRenderFns__$8 = [
	  function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("div", { staticClass: "phieu-title mb-10" }, [
	      _c(
	        "span",
	        {
	          staticClass:
	            "badge badge-flat badge-pill border-primary text-primary bold"
	        },
	        [_vm._v("2")]
	      ),
	      _vm._v(" Điều tra dịch tễ\n    ")
	    ])
	  },
	  function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("div", { staticClass: "phieu-title mb-2" }, [
	      _c(
	        "span",
	        {
	          staticClass:
	            "badge badge-flat badge-pill border-primary text-primary bold"
	        },
	        [_vm._v("3")]
	      ),
	      _vm._v(" Khảo sát lăng quăng\n    ")
	    ])
	  },
	  function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("ul", [
	      _c("li", [
	        _vm._v(
	          "Mục đích khảo sát là để có quyết định xử lý như ổ dịch nhỏ hay không."
	        )
	      ]),
	      _vm._v(" "),
	      _c("li", [
	        _vm._v(
	          "Nếu là các ca thứ phát chỉ khảo sát trong quá trình xử lý ổ dịch."
	        )
	      ])
	    ])
	  }
	];
	__vue_render__$8._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$8 = undefined;
	  /* scoped */
	  var __vue_scope_id__$8 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$8 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$8 = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$8 = normalizeComponent$1(
	    { render: __vue_render__$8, staticRenderFns: __vue_staticRenderFns__$8 },
	    __vue_inject_styles__$8,
	    __vue_script__$8,
	    __vue_scope_id__$8,
	    __vue_is_functional_template__$8,
	    __vue_module_identifier__$8,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var script$9 = {
	  name: 'xuly-part',
	  computed: _objectSpread2$1({}, Vuex.mapState(['form', 'schema']))
	};

	/* script */
	var __vue_script__$9 = script$9;

	/* template */
	var __vue_render__$9 = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    [
	      _vm._m(0),
	      _vm._v(" "),
	      _c("p", { staticClass: "font-weight-semibold text-primary" }, [
	        _vm._v("Ca bệnh")
	      ]),
	      _vm._v(" "),
	      _c(
	        "b-row",
	        [
	          _c(
	            "b-col",
	            { staticClass: "font-weight-semibold", attrs: { md: "4" } },
	            [
	              _vm._v(
	                "\n            " +
	                  _vm._s(_vm._.get(_vm.schema, "cachidiem.labelInline")) +
	                  "\n        "
	              )
	            ]
	          ),
	          _vm._v(" "),
	          _c(
	            "b-col",
	            { attrs: { md: "4" } },
	            [_c("field-sxh", { attrs: { name: "cachidiem" } })],
	            1
	          )
	        ],
	        1
	      ),
	      _vm._v(" "),
	      _vm.form.cachidiem == 1
	        ? _c(
	            "div",
	            [
	              _c("div", { staticClass: "form-group font-weight-semibold" }, [
	                _vm._v(" Dự kiến xử lý")
	              ]),
	              _vm._v(" "),
	              _vm._l(
	                _vm.only(_vm.schema, ["dietlangquang", "giamsattheodoi"]),
	                function(i, k) {
	                  return _c(
	                    "b-row",
	                    { key: k },
	                    [
	                      _c("b-col", { attrs: { md: "4" } }, [
	                        _vm._v(
	                          "\n                " +
	                            _vm._s(i.labelInline) +
	                            "\n            "
	                        )
	                      ]),
	                      _vm._v(" "),
	                      _c(
	                        "b-col",
	                        { attrs: { md: "4" } },
	                        [_c("field-sxh", { attrs: { name: i.name } })],
	                        1
	                      )
	                    ],
	                    1
	                  )
	                }
	              ),
	              _vm._v(" "),
	              _c(
	                "b-row",
	                [
	                  _c("b-col", { attrs: { md: "4" } }, [
	                    _vm._v(
	                      "\n                " +
	                        _vm._s(_vm._.get(_vm.schema, "xulyonho.labelInline")) +
	                        "\n            "
	                    )
	                  ]),
	                  _vm._v(" "),
	                  _c(
	                    "b-col",
	                    { attrs: { md: "4" } },
	                    [_c("field-sxh", { attrs: { name: "xulyonho" } })],
	                    1
	                  )
	                ],
	                1
	              ),
	              _vm._v(" "),
	              _vm.form.xulyonho == 0
	                ? _c(
	                    "b-row",
	                    [
	                      _c("b-col", { attrs: { md: "4" } }, [
	                        _vm._v(
	                          "\n                " +
	                            _vm._s(
	                              _vm._.get(_vm.schema, "xulyorong.labelInline")
	                            ) +
	                            "\n            "
	                        )
	                      ]),
	                      _vm._v(" "),
	                      _c(
	                        "b-col",
	                        { attrs: { md: "4" } },
	                        [_c("field-sxh", { attrs: { name: "xulyorong" } })],
	                        1
	                      )
	                    ],
	                    1
	                  )
	                : _vm._e()
	            ],
	            2
	          )
	        : _vm._e(),
	      _vm._v(" "),
	      _vm.form.cachidiem == 0
	        ? _c(
	            "div",
	            [
	              _c(
	                "b-row",
	                [
	                  _c(
	                    "b-col",
	                    { staticClass: "font-weight-semibold", attrs: { md: "4" } },
	                    [
	                      _vm._v(
	                        "\n                2. Ca bệnh thứ phát\n            "
	                      )
	                    ]
	                  ),
	                  _vm._v(" "),
	                  _c(
	                    "b-col",
	                    { attrs: { md: "4" } },
	                    [_c("field-sxh", { attrs: { name: "cathuphat" } })],
	                    1
	                  )
	                ],
	                1
	              ),
	              _vm._v(" "),
	              _vm.form.cathuphat == 1
	                ? _c(
	                    "div",
	                    [
	                      _c(
	                        "b-row",
	                        [
	                          _c("b-col", { attrs: { md: "3" } }, [
	                            _vm._v(
	                              "\n                    Ổ dịch mới\n                "
	                            )
	                          ]),
	                          _vm._v(" "),
	                          _c(
	                            "b-col",
	                            { attrs: { md: "9" } },
	                            [_c("field-sxh", { attrs: { name: "odichmoi" } })],
	                            1
	                          )
	                        ],
	                        1
	                      ),
	                      _vm._v(" "),
	                      _vm.form.odichmoi == 0
	                        ? _c(
	                            "b-row",
	                            [
	                              _c("b-col", { attrs: { md: "3" } }, [
	                                _vm._v(
	                                  "\n                    Ổ dịch cũ đã xác định\n                "
	                                )
	                              ]),
	                              _vm._v(" "),
	                              _c(
	                                "b-col",
	                                { attrs: { md: "3" } },
	                                [
	                                  _c("field-sxh", {
	                                    attrs: { name: "odichcu" }
	                                  })
	                                ],
	                                1
	                              ),
	                              _vm._v(" "),
	                              _vm.form.odichcu == 1
	                                ? _c(
	                                    "b-col",
	                                    { attrs: { md: "3" } },
	                                    [
	                                      _c("field-sxh", {
	                                        attrs: { name: "odichcu_xuly" }
	                                      })
	                                    ],
	                                    1
	                                  )
	                                : _vm._e()
	                            ],
	                            1
	                          )
	                        : _vm._e(),
	                      _vm._v(" "),
	                      _c(
	                        "b-row",
	                        [
	                          _c(
	                            "b-col",
	                            [_c("field-sxh", { attrs: { name: "xuly" } })],
	                            1
	                          ),
	                          _vm._v(" "),
	                          _vm.form.xuly == 3
	                            ? _c(
	                                "b-col",
	                                [
	                                  _c("field-sxh", {
	                                    attrs: { name: "xuly_ngay" }
	                                  })
	                                ],
	                                1
	                              )
	                            : _vm._e()
	                        ],
	                        1
	                      )
	                    ],
	                    1
	                  )
	                : _vm._e()
	            ],
	            1
	          )
	        : _vm._e(),
	      _vm._v(" "),
	      _vm._m(1),
	      _vm._v(" "),
	      _vm.form.ht_dieutri == 1
	        ? _c(
	            "b-row",
	            [
	              _c(
	                "b-col",
	                [_c("field-sxh", { attrs: { name: "xuatvien" } })],
	                1
	              ),
	              _vm._v(" "),
	              _vm.form.xuatvien == 1
	                ? _c(
	                    "b-col",
	                    [_c("field-sxh", { attrs: { name: "ngayxuatvien" } })],
	                    1
	                  )
	                : _vm._e()
	            ],
	            1
	          )
	        : _vm._e(),
	      _vm._v(" "),
	      _vm.form.xuatvien == 1 || _vm.form.ht_dieutri == 0
	        ? _c(
	            "b-row",
	            [
	              _c(
	                "b-col",
	                [_c("field-sxh", { attrs: { name: "chuandoan" } })],
	                1
	              ),
	              _vm._v(" "),
	              _vm.form.chuandoan == 3
	                ? _c(
	                    "b-col",
	                    [_c("field-sxh", { attrs: { name: "chuandoan_khac" } })],
	                    1
	                  )
	                : _vm._e()
	            ],
	            1
	          )
	        : _vm._e(),
	      _vm._v(" "),
	      _vm._m(2)
	    ],
	    1
	  )
	};
	var __vue_staticRenderFns__$9 = [
	  function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("div", { staticClass: "phieu-title mb-2 mt-2" }, [
	      _c(
	        "span",
	        {
	          staticClass:
	            "badge badge-flat badge-pill border-primary text-primary bold"
	        },
	        [_vm._v("4")]
	      ),
	      _vm._v(" Hướng xử lý\n    ")
	    ])
	  },
	  function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("div", { staticClass: "phieu-title mb-2" }, [
	      _c(
	        "span",
	        {
	          staticClass:
	            "badge badge-flat badge-pill border-primary text-primary bold"
	        },
	        [_vm._v("5")]
	      ),
	      _vm._v(" Kết luận\n    ")
	    ])
	  },
	  function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("div", { staticClass: "form-group" }, [
	      _c("i", [
	        _vm._v(
	          "* Điều tra ghi phiếu đầy đủ và không bỏ sót bất kỳ nội dung nào. "
	        ),
	        _c("br"),
	        _vm._v(
	          "\n        * Mẫu phiếu được thực hiện:  ca bệnh thông báo khi bệnh nhân có ở tại nhà, cư trú có thể ở bất cứ nơi đâu, bệnh sốt xuất huyết hay là bệnh khác.\n    "
	        )
	      ])
	    ])
	  }
	];
	__vue_render__$9._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$9 = undefined;
	  /* scoped */
	  var __vue_scope_id__$9 = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$9 = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$9 = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$9 = normalizeComponent$1(
	    { render: __vue_render__$9, staticRenderFns: __vue_staticRenderFns__$9 },
	    __vue_inject_styles__$9,
	    __vue_script__$9,
	    __vue_scope_id__$9,
	    __vue_is_functional_template__$9,
	    __vue_module_identifier__$9,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var script$a = {
	  name: 'chuyenca-part',
	  computed: _objectSpread2$1({}, Vuex.mapState({
	    list_chuyenca: function list_chuyenca(state) {
	      return lodash.get(state, 'form.list_chuyenca', []);
	    }
	  }))
	};

	/* script */
	var __vue_script__$a = script$a;

	/* template */
	var __vue_render__$a = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c("div", { staticClass: "row mt-2" }, [
	    _c("div", { staticClass: "col-md-12" }, [
	      _c("h6", { staticClass: "text-info font-weight-semibold" }, [
	        _vm._v("Thông tin chuyển ca")
	      ]),
	      _vm._v(" "),
	      _c("table", { staticClass: "table table-bordered" }, [
	        _vm._m(0),
	        _vm._v(" "),
	        _c(
	          "tbody",
	          _vm._l(_vm.list_chuyenca, function(v, k) {
	            return _c("tr", { key: k }, [
	              _c("td", [_vm._v(_vm._s(k + 1))]),
	              _vm._v(" "),
	              _c("td", [_vm._v(_vm._s(v.chuyen.tenquan))]),
	              _vm._v(" "),
	              _c("td", [_vm._v(_vm._s(v.chuyen.tenphuong))]),
	              _vm._v(" "),
	              _c("td", [_vm._v(_vm._s(v.chuyen.hoten))]),
	              _vm._v(" "),
	              _c("td", [_vm._v(_vm._s(v.chuyen.sdt))]),
	              _vm._v(" "),
	              _c("td", [_vm._v(_vm._s(v.nhan.tenquan))]),
	              _vm._v(" "),
	              _c("td", [_vm._v(_vm._s(v.nhan.tenphuong))]),
	              _vm._v(" "),
	              _c("td", [_vm._v(_vm._s(v.nhan.hoten))]),
	              _vm._v(" "),
	              _c("td", [_vm._v(_vm._s(v.nhan.sdt))]),
	              _vm._v(" "),
	              _c("td", { domProps: { innerHTML: _vm._s(v.datetime) } })
	            ])
	          }),
	          0
	        )
	      ])
	    ])
	  ])
	};
	var __vue_staticRenderFns__$a = [
	  function() {
	    var _vm = this;
	    var _h = _vm.$createElement;
	    var _c = _vm._self._c || _h;
	    return _c("thead", [
	      _c("tr", [
	        _c("th", { attrs: { rowspan: "2" } }, [_vm._v("STT")]),
	        _vm._v(" "),
	        _c("th", { attrs: { colspan: "4" } }, [_vm._v("Chuyển ca")]),
	        _vm._v(" "),
	        _c("th", { attrs: { colspan: "4" } }, [_vm._v("Nhận ca")]),
	        _vm._v(" "),
	        _c("th", { attrs: { rowspan: "2" } }, [_vm._v("Thời gian")])
	      ]),
	      _vm._v(" "),
	      _c("tr", [
	        _c("th", [_vm._v("Quận")]),
	        _vm._v(" "),
	        _c("th", [_vm._v("Phường")]),
	        _vm._v(" "),
	        _c("th", [_vm._v("Người điều tra")]),
	        _vm._v(" "),
	        _c("th", [_vm._v("Số điện thoại")]),
	        _vm._v(" "),
	        _c("th", [_vm._v("Quận")]),
	        _vm._v(" "),
	        _c("th", [_vm._v("Phường")]),
	        _vm._v(" "),
	        _c("th", [_vm._v("Người điều tra")]),
	        _vm._v(" "),
	        _c("th", [_vm._v("Số điện thoại")])
	      ])
	    ])
	  }
	];
	__vue_render__$a._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$a = undefined;
	  /* scoped */
	  var __vue_scope_id__$a = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$a = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$a = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$a = normalizeComponent$1(
	    { render: __vue_render__$a, staticRenderFns: __vue_staticRenderFns__$a },
	    __vue_inject_styles__$a,
	    __vue_script__$a,
	    __vue_scope_id__$a,
	    __vue_is_functional_template__$a,
	    __vue_module_identifier__$a,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var capitalizeFirstLetter = function (string) {
	  if (!string || typeof string.charAt !== 'function') { return string; }
	  return string.charAt(0).toUpperCase() + string.slice(1);
	};

	var propsBinder = function (vueElement, leafletElement, props, options) {
	  var loop = function ( key ) {
	    var setMethodName = 'set' + capitalizeFirstLetter(key);
	    var deepValue = (props[key].type === Object) ||
	      (props[key].type === Array) ||
	      (Array.isArray(props[key].type));
	    if (props[key].custom && vueElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        vueElement[setMethodName](newVal, oldVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (setMethodName === 'setOptions') {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        L$1.setOptions(leafletElement, newVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (leafletElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        leafletElement[setMethodName](newVal);
	      }, {
	        deep: deepValue
	      });
	    }
	  };

	  for (var key in props) { loop( key ); }
	};

	var findRealParent = function (firstVueParent) {
	  var found = false;
	  while (firstVueParent && !found) {
	    if (firstVueParent.mapObject === undefined) {
	      firstVueParent = firstVueParent.$parent;
	    } else {
	      found = true;
	    }
	  }
	  return firstVueParent;
	};

	var capitalizeFirstLetter$1 = function (string) {
	  if (!string || typeof string.charAt !== 'function') { return string; }
	  return string.charAt(0).toUpperCase() + string.slice(1);
	};

	var propsBinder$1 = function (vueElement, leafletElement, props, options) {
	  var loop = function ( key ) {
	    var setMethodName = 'set' + capitalizeFirstLetter$1(key);
	    var deepValue = (props[key].type === Object) ||
	      (props[key].type === Array) ||
	      (Array.isArray(props[key].type));
	    if (props[key].custom && vueElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        vueElement[setMethodName](newVal, oldVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (setMethodName === 'setOptions') {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        L$1.setOptions(leafletElement, newVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (leafletElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        leafletElement[setMethodName](newVal);
	      }, {
	        deep: deepValue
	      });
	    }
	  };

	  for (var key in props) { loop( key ); }
	};

	var collectionCleaner = function (options) {
	  var result = {};
	  for (var key in options) {
	    var value = options[key];
	    if (value !== null && value !== undefined) {
	      result[key] = value;
	    }
	  }
	  return result;
	};

	var optionsMerger = function (props, instance) {
	  var options = instance.options && instance.options.constructor === Object ? instance.options : {};
	  props = props && props.constructor === Object ? props : {};
	  var result = collectionCleaner(options);
	  props = collectionCleaner(props);
	  var defaultProps = instance.$options.props;
	  for (var key in props) {
	    var def = defaultProps[key] ? defaultProps[key].default : Symbol('unique');
	    if (result[key] && def !== props[key]) {
	      console.warn((key + " props is overriding the value passed in the options props"));
	      result[key] = props[key];
	    } else if (!result[key]) {
	      result[key] = props[key];
	    }
	  }  return result;
	};

	var ControlMixin = {
	  props: {
	    position: {
	      type: String,
	      default: 'topright'
	    }
	  },
	  mounted: function mounted () {
	    this.controlOptions = {
	      position: this.position
	    };
	  },
	  beforeDestroy: function beforeDestroy () {
	    if (this.mapObject) {
	      this.mapObject.remove();
	    }
	  }
	};

	var Options = {
	  props: {
	    options: {
	      type: Object,
	      default: function () { return ({}); }
	    }
	  }
	};

	var script$b = {
	  name: 'LControlLayers',
	  mixins: [ControlMixin, Options],
	  props: {
	    collapsed: {
	      type: Boolean,
	      default: true,
	    },
	    autoZIndex: {
	      type: Boolean,
	      default: true,
	    },
	    hideSingleBase: {
	      type: Boolean,
	      default: false,
	    },
	    sortLayers: {
	      type: Boolean,
	      default: false,
	    },
	    sortFunction: {
	      type: Function,
	      default: undefined,
	    },
	  },
	  mounted: function mounted() {
	    var this$1 = this;

	    var options = optionsMerger(
	      Object.assign({}, this.controlOptions,
	        {collapsed: this.collapsed,
	        autoZIndex: this.autoZIndex,
	        hideSingleBase: this.hideSingleBase,
	        sortLayers: this.sortLayers,
	        sortFunction: this.sortFunction}),
	      this
	    );
	    this.mapObject = L$1.control.layers(null, null, options);
	    propsBinder$1(this, this.mapObject, this.$options.props);
	    this.$parent.registerLayerControl(this);
	    this.$nextTick(function () {
	      this$1.$emit('ready', this$1.mapObject);
	    });
	  },
	  methods: {
	    addLayer: function addLayer(layer) {
	      if (layer.layerType === 'base') {
	        this.mapObject.addBaseLayer(layer.mapObject, layer.name);
	      } else if (layer.layerType === 'overlay') {
	        this.mapObject.addOverlay(layer.mapObject, layer.name);
	      }
	    },
	    removeLayer: function removeLayer(layer) {
	      this.mapObject.removeLayer(layer.mapObject);
	    },
	  },
	  render: function render() {
	    return null;
	  },
	};

	function normalizeComponent$2(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	    if (typeof shadowMode !== 'boolean') {
	        createInjectorSSR = createInjector;
	        createInjector = shadowMode;
	        shadowMode = false;
	    }
	    // Vue.extend constructor export interop.
	    var options = typeof script === 'function' ? script.options : script;
	    // render functions
	    if (template && template.render) {
	        options.render = template.render;
	        options.staticRenderFns = template.staticRenderFns;
	        options._compiled = true;
	        // functional template
	        if (isFunctionalTemplate) {
	            options.functional = true;
	        }
	    }
	    // scopedId
	    if (scopeId) {
	        options._scopeId = scopeId;
	    }
	    var hook;
	    if (moduleIdentifier) {
	        // server build
	        hook = function (context) {
	            // 2.3 injection
	            context =
	                context || // cached call
	                    (this.$vnode && this.$vnode.ssrContext) || // stateful
	                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
	            // 2.2 with runInNewContext: true
	            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	                context = __VUE_SSR_CONTEXT__;
	            }
	            // inject component styles
	            if (style) {
	                style.call(this, createInjectorSSR(context));
	            }
	            // register component module identifier for async chunk inference
	            if (context && context._registeredComponents) {
	                context._registeredComponents.add(moduleIdentifier);
	            }
	        };
	        // used by ssr in case component is cached and beforeCreate
	        // never gets called
	        options._ssrRegister = hook;
	    }
	    else if (style) {
	        hook = shadowMode
	            ? function (context) {
	                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
	            }
	            : function (context) {
	                style.call(this, createInjector(context));
	            };
	    }
	    if (hook) {
	        if (options.functional) {
	            // register for functional component in vue file
	            var originalRender = options.render;
	            options.render = function renderWithStyleInjection(h, context) {
	                hook.call(context);
	                return originalRender(h, context);
	            };
	        }
	        else {
	            // inject component registration as beforeCreate hook
	            var existing = options.beforeCreate;
	            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	    }
	    return script;
	}

	var isOldIE$1 = typeof navigator !== 'undefined' &&
	    /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	/* script */
	var __vue_script__$b = script$b;

	/* template */

	  /* style */
	  var __vue_inject_styles__$b = undefined;
	  /* scoped */
	  var __vue_scope_id__$b = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$b = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$b = undefined;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$b = normalizeComponent$2(
	    {},
	    __vue_inject_styles__$b,
	    __vue_script__$b,
	    __vue_scope_id__$b,
	    __vue_is_functional_template__$b,
	    __vue_module_identifier__$b,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var capitalizeFirstLetter$2 = function (string) {
	  if (!string || typeof string.charAt !== 'function') { return string; }
	  return string.charAt(0).toUpperCase() + string.slice(1);
	};

	var propsBinder$2 = function (vueElement, leafletElement, props, options) {
	  var loop = function ( key ) {
	    var setMethodName = 'set' + capitalizeFirstLetter$2(key);
	    var deepValue = (props[key].type === Object) ||
	      (props[key].type === Array) ||
	      (Array.isArray(props[key].type));
	    if (props[key].custom && vueElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        vueElement[setMethodName](newVal, oldVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (setMethodName === 'setOptions') {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        L$1.setOptions(leafletElement, newVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (leafletElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        leafletElement[setMethodName](newVal);
	      }, {
	        deep: deepValue
	      });
	    }
	  };

	  for (var key in props) { loop( key ); }
	};

	var findRealParent$1 = function (firstVueParent) {
	  var found = false;
	  while (firstVueParent && !found) {
	    if (firstVueParent.mapObject === undefined) {
	      firstVueParent = firstVueParent.$parent;
	    } else {
	      found = true;
	    }
	  }
	  return firstVueParent;
	};

	var Layer = {
	  props: {
	    pane: {
	      type: String,
	      default: 'overlayPane',
	    },
	    attribution: {
	      type: String,
	      default: null,
	    },
	    name: {
	      type: String,
	      custom: true,
	      default: undefined,
	    },
	    layerType: {
	      type: String,
	      custom: true,
	      default: undefined,
	    },
	    visible: {
	      type: Boolean,
	      custom: true,
	      default: true,
	    },
	  },
	  mounted: function mounted() {
	    this.layerOptions = {
	      attribution: this.attribution,
	      pane: this.pane,
	    };
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.unbindPopup();
	    this.unbindTooltip();
	    this.parentContainer.removeLayer(this);
	  },
	  methods: {
	    setAttribution: function setAttribution(val, old) {
	      var attributionControl = this.$parent.mapObject.attributionControl;
	      attributionControl.removeAttribution(old).addAttribution(val);
	    },
	    setName: function setName() {
	      this.parentContainer.removeLayer(this);
	      if (this.visible) {
	        this.parentContainer.addLayer(this);
	      }
	    },
	    setLayerType: function setLayerType() {
	      this.parentContainer.removeLayer(this);
	      if (this.visible) {
	        this.parentContainer.addLayer(this);
	      }
	    },
	    setVisible: function setVisible(newVal) {
	      if (this.mapObject) {
	        if (newVal) {
	          this.parentContainer.addLayer(this);
	        } else {
	          this.parentContainer.hideLayer(this);
	        }
	      }
	    },
	    unbindTooltip: function unbindTooltip() {
	      var tooltip = this.mapObject ? this.mapObject.getTooltip() : null;
	      if (tooltip) {
	        tooltip.unbindTooltip();
	      }
	    },
	    unbindPopup: function unbindPopup() {
	      var popup = this.mapObject ? this.mapObject.getPopup() : null;
	      if (popup) {
	        popup.unbindPopup();
	      }
	    },
	    updateVisibleProp: function updateVisibleProp(value) {
	      this.$emit('update:visible', value);
	    },
	  },
	};

	var LayerGroupMixin = {
	  mixins: [Layer],
	  mounted: function mounted () {
	    this.layerGroupOptions = this.layerOptions;
	  },
	  methods: {
	    addLayer: function addLayer (layer, alreadyAdded) {
	      if (!alreadyAdded) {
	        this.mapObject.addLayer(layer.mapObject);
	      }
	      this.parentContainer.addLayer(layer, true);
	    },
	    removeLayer: function removeLayer (layer, alreadyRemoved) {
	      if (!alreadyRemoved) {
	        this.mapObject.removeLayer(layer.mapObject);
	      }
	      this.parentContainer.removeLayer(layer, true);
	    }
	  }
	};

	var Options$1 = {
	  props: {
	    options: {
	      type: Object,
	      default: function () { return ({}); }
	    }
	  }
	};

	//

	var script$c = {
	  name: 'LFeatureGroup',
	  mixins: [LayerGroupMixin, Options$1],
	  data: function data() {
	    return {
	      ready: false,
	    };
	  },
	  mounted: function mounted() {
	    var this$1 = this;

	    this.mapObject = L$1.featureGroup();
	    propsBinder$2(this, this.mapObject, this.$options.props);
	    L$1.DomEvent.on(this.mapObject, this.$listeners);
	    this.ready = true;
	    this.parentContainer = findRealParent$1(this.$parent);
	    if (this.visible) {
	      this.parentContainer.addLayer(this);
	    }
	    this.$nextTick(function () {
	      this$1.$emit('ready', this$1.mapObject);
	    });
	  },
	};

	function normalizeComponent$3(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	    if (typeof shadowMode !== 'boolean') {
	        createInjectorSSR = createInjector;
	        createInjector = shadowMode;
	        shadowMode = false;
	    }
	    // Vue.extend constructor export interop.
	    var options = typeof script === 'function' ? script.options : script;
	    // render functions
	    if (template && template.render) {
	        options.render = template.render;
	        options.staticRenderFns = template.staticRenderFns;
	        options._compiled = true;
	        // functional template
	        if (isFunctionalTemplate) {
	            options.functional = true;
	        }
	    }
	    // scopedId
	    if (scopeId) {
	        options._scopeId = scopeId;
	    }
	    var hook;
	    if (moduleIdentifier) {
	        // server build
	        hook = function (context) {
	            // 2.3 injection
	            context =
	                context || // cached call
	                    (this.$vnode && this.$vnode.ssrContext) || // stateful
	                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
	            // 2.2 with runInNewContext: true
	            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	                context = __VUE_SSR_CONTEXT__;
	            }
	            // inject component styles
	            if (style) {
	                style.call(this, createInjectorSSR(context));
	            }
	            // register component module identifier for async chunk inference
	            if (context && context._registeredComponents) {
	                context._registeredComponents.add(moduleIdentifier);
	            }
	        };
	        // used by ssr in case component is cached and beforeCreate
	        // never gets called
	        options._ssrRegister = hook;
	    }
	    else if (style) {
	        hook = shadowMode
	            ? function (context) {
	                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
	            }
	            : function (context) {
	                style.call(this, createInjector(context));
	            };
	    }
	    if (hook) {
	        if (options.functional) {
	            // register for functional component in vue file
	            var originalRender = options.render;
	            options.render = function renderWithStyleInjection(h, context) {
	                hook.call(context);
	                return originalRender(h, context);
	            };
	        }
	        else {
	            // inject component registration as beforeCreate hook
	            var existing = options.beforeCreate;
	            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	    }
	    return script;
	}

	var isOldIE$2 = typeof navigator !== 'undefined' &&
	    /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	/* script */
	var __vue_script__$c = script$c;

	/* template */
	var __vue_render__$b = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticStyle:{"display":"none"}},[(_vm.ready)?_vm._t("default"):_vm._e()],2)};
	var __vue_staticRenderFns__$b = [];

	  /* style */
	  var __vue_inject_styles__$c = undefined;
	  /* scoped */
	  var __vue_scope_id__$c = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$c = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$c = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$c = normalizeComponent$3(
	    { render: __vue_render__$b, staticRenderFns: __vue_staticRenderFns__$b },
	    __vue_inject_styles__$c,
	    __vue_script__$c,
	    __vue_scope_id__$c,
	    __vue_is_functional_template__$c,
	    __vue_module_identifier__$c,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var debounce$3 = function (fn, time) {
	  var timeout;

	  return function () {
	    var arguments$1 = arguments;

	    var args = [], len = arguments.length;
	    while ( len-- ) { args[ len ] = arguments$1[ len ]; }

	    var context = this;
	    if (timeout) {
	      clearTimeout(timeout);
	    }
	    timeout = setTimeout(function () {
	      fn.apply(context, args);
	      timeout = null;
	    }, time);
	  };
	};

	var capitalizeFirstLetter$3 = function (string) {
	  if (!string || typeof string.charAt !== 'function') { return string; }
	  return string.charAt(0).toUpperCase() + string.slice(1);
	};

	var propsBinder$3 = function (vueElement, leafletElement, props, options) {
	  var loop = function ( key ) {
	    var setMethodName = 'set' + capitalizeFirstLetter$3(key);
	    var deepValue = (props[key].type === Object) ||
	      (props[key].type === Array) ||
	      (Array.isArray(props[key].type));
	    if (props[key].custom && vueElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        vueElement[setMethodName](newVal, oldVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (setMethodName === 'setOptions') {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        L$1.setOptions(leafletElement, newVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (leafletElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        leafletElement[setMethodName](newVal);
	      }, {
	        deep: deepValue
	      });
	    }
	  };

	  for (var key in props) { loop( key ); }
	};

	var collectionCleaner$1 = function (options) {
	  var result = {};
	  for (var key in options) {
	    var value = options[key];
	    if (value !== null && value !== undefined) {
	      result[key] = value;
	    }
	  }
	  return result;
	};

	var optionsMerger$1 = function (props, instance) {
	  var options = instance.options && instance.options.constructor === Object ? instance.options : {};
	  props = props && props.constructor === Object ? props : {};
	  var result = collectionCleaner$1(options);
	  props = collectionCleaner$1(props);
	  var defaultProps = instance.$options.props;
	  for (var key in props) {
	    var def = defaultProps[key] ? defaultProps[key].default : Symbol('unique');
	    if (result[key] && def !== props[key]) {
	      console.warn((key + " props is overriding the value passed in the options props"));
	      result[key] = props[key];
	    } else if (!result[key]) {
	      result[key] = props[key];
	    }
	  }  return result;
	};

	var Options$2 = {
	  props: {
	    options: {
	      type: Object,
	      default: function () { return ({}); }
	    }
	  }
	};

	//

	var script$d = {
	  name: 'LMap',
	  mixins: [Options$2],
	  props: {
	    center: {
	      type: [Object, Array],
	      custom: true,
	      default: function () { return [0, 0]; },
	    },
	    bounds: {
	      type: [Array, Object],
	      custom: true,
	      default: null,
	    },
	    maxBounds: {
	      type: [Array, Object],
	      default: null,
	    },
	    zoom: {
	      type: Number,
	      custom: true,
	      default: 0,
	    },
	    minZoom: {
	      type: Number,
	      default: null,
	    },
	    maxZoom: {
	      type: Number,
	      default: null,
	    },
	    paddingBottomRight: {
	      type: Array,
	      custom: true,
	      default: null,
	    },
	    paddingTopLeft: {
	      type: Array,
	      custom: true,
	      default: null,
	    },
	    padding: {
	      type: Array,
	      custom: true,
	      default: null,
	    },
	    worldCopyJump: {
	      type: Boolean,
	      default: false,
	    },
	    crs: {
	      type: Object,
	      custom: true,
	      default: function () { return L$1.CRS.EPSG3857; },
	    },
	    maxBoundsViscosity: {
	      type: Number,
	      default: null,
	    },
	    inertia: {
	      type: Boolean,
	      default: null,
	    },
	    inertiaDeceleration: {
	      type: Number,
	      default: null,
	    },
	    inertiaMaxSpeed: {
	      type: Number,
	      default: null,
	    },
	    easeLinearity: {
	      type: Number,
	      default: null,
	    },
	    zoomAnimation: {
	      type: Boolean,
	      default: null,
	    },
	    zoomAnimationThreshold: {
	      type: Number,
	      default: null,
	    },
	    fadeAnimation: {
	      type: Boolean,
	      default: null,
	    },
	    markerZoomAnimation: {
	      type: Boolean,
	      default: null,
	    },
	    noBlockingAnimations: {
	      type: Boolean,
	      default: false,
	    },
	  },
	  data: function data() {
	    return {
	      ready: false,
	      lastSetCenter: null,
	      lastSetBounds: null,
	      lastSetZoom: null,
	      layerControl: undefined,
	      layersToAdd: [],
	      layersInControl: [],
	    };
	  },
	  computed: {
	    fitBoundsOptions: function fitBoundsOptions() {
	      var options = {
	        animate: this.noBlockingAnimations ? false : null,
	      };
	      if (this.padding) {
	        options.padding = this.padding;
	      } else {
	        if (this.paddingBottomRight) {
	          options.paddingBottomRight = this.paddingBottomRight;
	        }
	        if (this.paddingTopLeft) {
	          options.paddingTopLeft = this.paddingTopLeft;
	        }
	      }
	      return options;
	    },
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.mapObject) {
	      this.mapObject.remove();
	    }
	  },
	  mounted: function mounted() {
	    var this$1 = this;

	    var options = optionsMerger$1(
	      {
	        minZoom: this.minZoom,
	        maxZoom: this.maxZoom,
	        maxBounds: this.maxBounds,
	        maxBoundsViscosity: this.maxBoundsViscosity,
	        worldCopyJump: this.worldCopyJump,
	        crs: this.crs,
	        center: this.center,
	        zoom: this.zoom,
	        inertia: this.inertia,
	        inertiaDeceleration: this.inertiaDeceleration,
	        inertiaMaxSpeed: this.inertiaMaxSpeed,
	        easeLinearity: this.easeLinearity,
	        zoomAnimation: this.zoomAnimation,
	        zoomAnimationThreshold: this.zoomAnimationThreshold,
	        fadeAnimation: this.fadeAnimation,
	        markerZoomAnimation: this.markerZoomAnimation,
	      },
	      this
	    );
	    this.mapObject = L$1.map(this.$el, options);
	    this.setBounds(this.bounds);
	    this.mapObject.on('moveend', debounce$3(this.moveEndHandler, 100));
	    this.mapObject.on('overlayadd', this.overlayAddHandler);
	    this.mapObject.on('overlayremove', this.overlayRemoveHandler);
	    L$1.DomEvent.on(this.mapObject, this.$listeners);
	    propsBinder$3(this, this.mapObject, this.$options.props);
	    this.ready = true;
	    // DEPRECATED leaflet:load
	    this.$emit('leaflet:load');
	    this.$nextTick(function () {
	      this$1.$emit('ready', this$1.mapObject);
	    });
	  },
	  methods: {
	    registerLayerControl: function registerLayerControl(lControlLayers) {
	      var this$1 = this;

	      this.layerControl = lControlLayers;
	      this.mapObject.addControl(lControlLayers.mapObject);
	      this.layersToAdd.forEach(function (layer) {
	        this$1.layerControl.addLayer(layer);
	      });
	      this.layersToAdd = [];
	    },
	    addLayer: function addLayer(layer, alreadyAdded) {
	      if (layer.layerType !== undefined) {
	        if (this.layerControl === undefined) {
	          this.layersToAdd.push(layer);
	        } else {
	          var exist = this.layersInControl.find(
	            function (l) { return l.mapObject._leaflet_id === layer.mapObject._leaflet_id; }
	          );
	          if (!exist) {
	            this.layerControl.addLayer(layer);
	            this.layersInControl.push(layer);
	          }
	        }
	      }
	      if (!alreadyAdded && layer.visible !== false) {
	        this.mapObject.addLayer(layer.mapObject);
	      }
	    },
	    hideLayer: function hideLayer(layer) {
	      if (layer.layerType !== undefined) {
	        this.mapObject.removeLayer(layer.mapObject);
	      }
	    },
	    removeLayer: function removeLayer(layer, alreadyRemoved) {
	      if (layer.layerType !== undefined) {
	        if (this.layerControl === undefined) {
	          this.layersToAdd = this.layersToAdd.filter(
	            function (l) { return l.name !== layer.name; }
	          );
	        } else {
	          this.layerControl.removeLayer(layer);
	          this.layersInControl = this.layersInControl.filter(
	            function (l) { return l.mapObject._leaflet_id !== layer.mapObject._leaflet_id; }
	          );
	        }
	      }
	      if (!alreadyRemoved) {
	        this.mapObject.removeLayer(layer.mapObject);
	      }
	    },
	    setZoom: function setZoom(newVal, oldVal) {
	      this.mapObject.setZoom(newVal, {
	        animate: this.noBlockingAnimations ? false : null,
	      });
	    },
	    setCenter: function setCenter(newVal, oldVal) {
	      if (newVal == null) {
	        return;
	      }
	      var newCenter = L$1.latLng(newVal);
	      var oldCenter = this.lastSetCenter || this.mapObject.getCenter();
	      if (oldCenter.lat !== newCenter.lat || oldCenter.lng !== newCenter.lng) {
	        this.lastSetCenter = newCenter;
	        this.mapObject.panTo(newCenter, {
	          animate: this.noBlockingAnimations ? false : null,
	        });
	      }
	    },
	    setBounds: function setBounds(newVal, oldVal) {
	      if (!newVal) {
	        return;
	      }
	      var newBounds = L$1.latLngBounds(newVal);
	      if (!newBounds.isValid()) {
	        return;
	      }
	      var oldBounds = this.lastSetBounds || this.mapObject.getBounds();
	      var boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals
	      if (boundsChanged) {
	        this.lastSetBounds = newBounds;
	        this.mapObject.fitBounds(newBounds, this.fitBoundsOptions);
	      }
	    },
	    setPaddingBottomRight: function setPaddingBottomRight(newVal, oldVal) {
	      this.paddingBottomRight = newVal;
	    },
	    setPaddingTopLeft: function setPaddingTopLeft(newVal, oldVal) {
	      this.paddingTopLeft = newVal;
	    },
	    setPadding: function setPadding(newVal, oldVal) {
	      this.padding = newVal;
	    },
	    setCrs: function setCrs(newVal, oldVal) {
	      console.log('Changing CRS is not yet supported by Leaflet');
	    },
	    fitBounds: function fitBounds(bounds) {
	      this.mapObject.fitBounds(bounds, {
	        animate: this.noBlockingAnimations ? false : null,
	      });
	    },
	    moveEndHandler: function moveEndHandler() {
	      this.$emit('update:zoom', this.mapObject.getZoom());
	      var center = this.mapObject.getCenter();
	      this.$emit('update:center', center);
	      var bounds = this.mapObject.getBounds();
	      this.$emit('update:bounds', bounds);
	    },
	    overlayAddHandler: function overlayAddHandler(e) {
	      var layer = this.layersInControl.find(function (l) { return l.name === e.name; });
	      if (layer) {
	        layer.updateVisibleProp(true);
	      }
	    },
	    overlayRemoveHandler: function overlayRemoveHandler(e) {
	      var layer = this.layersInControl.find(function (l) { return l.name === e.name; });
	      if (layer) {
	        layer.updateVisibleProp(false);
	      }
	    },
	  },
	};

	function normalizeComponent$4(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	    if (typeof shadowMode !== 'boolean') {
	        createInjectorSSR = createInjector;
	        createInjector = shadowMode;
	        shadowMode = false;
	    }
	    // Vue.extend constructor export interop.
	    var options = typeof script === 'function' ? script.options : script;
	    // render functions
	    if (template && template.render) {
	        options.render = template.render;
	        options.staticRenderFns = template.staticRenderFns;
	        options._compiled = true;
	        // functional template
	        if (isFunctionalTemplate) {
	            options.functional = true;
	        }
	    }
	    // scopedId
	    if (scopeId) {
	        options._scopeId = scopeId;
	    }
	    var hook;
	    if (moduleIdentifier) {
	        // server build
	        hook = function (context) {
	            // 2.3 injection
	            context =
	                context || // cached call
	                    (this.$vnode && this.$vnode.ssrContext) || // stateful
	                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
	            // 2.2 with runInNewContext: true
	            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	                context = __VUE_SSR_CONTEXT__;
	            }
	            // inject component styles
	            if (style) {
	                style.call(this, createInjectorSSR(context));
	            }
	            // register component module identifier for async chunk inference
	            if (context && context._registeredComponents) {
	                context._registeredComponents.add(moduleIdentifier);
	            }
	        };
	        // used by ssr in case component is cached and beforeCreate
	        // never gets called
	        options._ssrRegister = hook;
	    }
	    else if (style) {
	        hook = shadowMode
	            ? function (context) {
	                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
	            }
	            : function (context) {
	                style.call(this, createInjector(context));
	            };
	    }
	    if (hook) {
	        if (options.functional) {
	            // register for functional component in vue file
	            var originalRender = options.render;
	            options.render = function renderWithStyleInjection(h, context) {
	                hook.call(context);
	                return originalRender(h, context);
	            };
	        }
	        else {
	            // inject component registration as beforeCreate hook
	            var existing = options.beforeCreate;
	            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	    }
	    return script;
	}

	var isOldIE$3 = typeof navigator !== 'undefined' &&
	    /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
	function createInjector(context) {
	    return function (id, style) { return addStyle(id, style); };
	}
	var HEAD;
	var styles = {};
	function addStyle(id, css) {
	    var group = isOldIE$3 ? css.media || 'default' : id;
	    var style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });
	    if (!style.ids.has(id)) {
	        style.ids.add(id);
	        var code = css.source;
	        if (css.map) {
	            // https://developer.chrome.com/devtools/docs/javascript-debugging
	            // this makes source maps inside style tags work properly in Chrome
	            code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
	            // http://stackoverflow.com/a/26603875
	            code +=
	                '\n/*# sourceMappingURL=data:application/json;base64,' +
	                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
	                    ' */';
	        }
	        if (!style.element) {
	            style.element = document.createElement('style');
	            style.element.type = 'text/css';
	            if (css.media)
	                { style.element.setAttribute('media', css.media); }
	            if (HEAD === undefined) {
	                HEAD = document.head || document.getElementsByTagName('head')[0];
	            }
	            HEAD.appendChild(style.element);
	        }
	        if ('styleSheet' in style.element) {
	            style.styles.push(code);
	            style.element.styleSheet.cssText = style.styles
	                .filter(Boolean)
	                .join('\n');
	        }
	        else {
	            var index = style.ids.size - 1;
	            var textNode = document.createTextNode(code);
	            var nodes = style.element.childNodes;
	            if (nodes[index])
	                { style.element.removeChild(nodes[index]); }
	            if (nodes.length)
	                { style.element.insertBefore(textNode, nodes[index]); }
	            else
	                { style.element.appendChild(textNode); }
	        }
	    }
	}

	/* script */
	var __vue_script__$d = script$d;

	/* template */
	var __vue_render__$c = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"vue2leaflet-map"},[(_vm.ready)?_vm._t("default"):_vm._e()],2)};
	var __vue_staticRenderFns__$c = [];

	  /* style */
	  var __vue_inject_styles__$d = function (inject) {
	    if (!inject) { return }
	    inject("data-v-4d388c28_0", { source: ".vue2leaflet-map{height:100%;width:100%}", map: undefined, media: undefined });

	  };
	  /* scoped */
	  var __vue_scope_id__$d = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$d = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$d = false;
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$d = normalizeComponent$4(
	    { render: __vue_render__$c, staticRenderFns: __vue_staticRenderFns__$c },
	    __vue_inject_styles__$d,
	    __vue_script__$d,
	    __vue_scope_id__$d,
	    __vue_is_functional_template__$d,
	    __vue_module_identifier__$d,
	    false,
	    createInjector,
	    undefined,
	    undefined
	  );

	var debounce$4 = function (fn, time) {
	  var timeout;

	  return function () {
	    var arguments$1 = arguments;

	    var args = [], len = arguments.length;
	    while ( len-- ) { args[ len ] = arguments$1[ len ]; }

	    var context = this;
	    if (timeout) {
	      clearTimeout(timeout);
	    }
	    timeout = setTimeout(function () {
	      fn.apply(context, args);
	      timeout = null;
	    }, time);
	  };
	};

	var capitalizeFirstLetter$4 = function (string) {
	  if (!string || typeof string.charAt !== 'function') { return string; }
	  return string.charAt(0).toUpperCase() + string.slice(1);
	};

	var propsBinder$4 = function (vueElement, leafletElement, props, options) {
	  var loop = function ( key ) {
	    var setMethodName = 'set' + capitalizeFirstLetter$4(key);
	    var deepValue = (props[key].type === Object) ||
	      (props[key].type === Array) ||
	      (Array.isArray(props[key].type));
	    if (props[key].custom && vueElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        vueElement[setMethodName](newVal, oldVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (setMethodName === 'setOptions') {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        L$1.setOptions(leafletElement, newVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (leafletElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        leafletElement[setMethodName](newVal);
	      }, {
	        deep: deepValue
	      });
	    }
	  };

	  for (var key in props) { loop( key ); }
	};

	var collectionCleaner$2 = function (options) {
	  var result = {};
	  for (var key in options) {
	    var value = options[key];
	    if (value !== null && value !== undefined) {
	      result[key] = value;
	    }
	  }
	  return result;
	};

	var optionsMerger$2 = function (props, instance) {
	  var options = instance.options && instance.options.constructor === Object ? instance.options : {};
	  props = props && props.constructor === Object ? props : {};
	  var result = collectionCleaner$2(options);
	  props = collectionCleaner$2(props);
	  var defaultProps = instance.$options.props;
	  for (var key in props) {
	    var def = defaultProps[key] ? defaultProps[key].default : Symbol('unique');
	    if (result[key] && def !== props[key]) {
	      console.warn((key + " props is overriding the value passed in the options props"));
	      result[key] = props[key];
	    } else if (!result[key]) {
	      result[key] = props[key];
	    }
	  }  return result;
	};

	var findRealParent$2 = function (firstVueParent) {
	  var found = false;
	  while (firstVueParent && !found) {
	    if (firstVueParent.mapObject === undefined) {
	      firstVueParent = firstVueParent.$parent;
	    } else {
	      found = true;
	    }
	  }
	  return firstVueParent;
	};

	var Layer$1 = {
	  props: {
	    pane: {
	      type: String,
	      default: 'overlayPane',
	    },
	    attribution: {
	      type: String,
	      default: null,
	    },
	    name: {
	      type: String,
	      custom: true,
	      default: undefined,
	    },
	    layerType: {
	      type: String,
	      custom: true,
	      default: undefined,
	    },
	    visible: {
	      type: Boolean,
	      custom: true,
	      default: true,
	    },
	  },
	  mounted: function mounted() {
	    this.layerOptions = {
	      attribution: this.attribution,
	      pane: this.pane,
	    };
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.unbindPopup();
	    this.unbindTooltip();
	    this.parentContainer.removeLayer(this);
	  },
	  methods: {
	    setAttribution: function setAttribution(val, old) {
	      var attributionControl = this.$parent.mapObject.attributionControl;
	      attributionControl.removeAttribution(old).addAttribution(val);
	    },
	    setName: function setName() {
	      this.parentContainer.removeLayer(this);
	      if (this.visible) {
	        this.parentContainer.addLayer(this);
	      }
	    },
	    setLayerType: function setLayerType() {
	      this.parentContainer.removeLayer(this);
	      if (this.visible) {
	        this.parentContainer.addLayer(this);
	      }
	    },
	    setVisible: function setVisible(newVal) {
	      if (this.mapObject) {
	        if (newVal) {
	          this.parentContainer.addLayer(this);
	        } else {
	          this.parentContainer.hideLayer(this);
	        }
	      }
	    },
	    unbindTooltip: function unbindTooltip() {
	      var tooltip = this.mapObject ? this.mapObject.getTooltip() : null;
	      if (tooltip) {
	        tooltip.unbindTooltip();
	      }
	    },
	    unbindPopup: function unbindPopup() {
	      var popup = this.mapObject ? this.mapObject.getPopup() : null;
	      if (popup) {
	        popup.unbindPopup();
	      }
	    },
	    updateVisibleProp: function updateVisibleProp(value) {
	      this.$emit('update:visible', value);
	    },
	  },
	};

	var Options$3 = {
	  props: {
	    options: {
	      type: Object,
	      default: function () { return ({}); }
	    }
	  }
	};

	var script$e = {
	  name: 'LMarker',
	  mixins: [Layer$1, Options$3],
	  props: {
	    pane: {
	      type: String,
	      default: 'markerPane'
	    },
	    draggable: {
	      type: Boolean,
	      custom: true,
	      default: false
	    },
	    latLng: {
	      type: [Object, Array],
	      custom: true,
	      default: null
	    },
	    icon: {
	      type: [Object],
	      custom: false,
	      default: function () { return new L$1.Icon.Default(); }
	    },
	    zIndexOffset: {
	      type: Number,
	      custom: false,
	      default: null
	    }
	  },
	  data: function data () {
	    return {
	      ready: false
	    };
	  },
	  mounted: function mounted () {
	    var this$1 = this;

	    var options = optionsMerger$2(Object.assign({}, this.layerOptions,
	      {icon: this.icon,
	      zIndexOffset: this.zIndexOffset,
	      draggable: this.draggable}), this);
	    this.mapObject = L$1.marker(this.latLng, options);
	    L$1.DomEvent.on(this.mapObject, this.$listeners);
	    this.mapObject.on('move', debounce$4(this.latLngSync, 100));
	    propsBinder$4(this, this.mapObject, this.$options.props);
	    this.parentContainer = findRealParent$2(this.$parent);
	    this.parentContainer.addLayer(this, !this.visible);
	    this.ready = true;
	    this.$nextTick(function () {
	      this$1.$emit('ready', this$1.mapObject);
	    });
	  },
	  methods: {
	    setDraggable: function setDraggable (newVal, oldVal) {
	      if (this.mapObject.dragging) {
	        newVal ? this.mapObject.dragging.enable() : this.mapObject.dragging.disable();
	      }
	    },
	    setLatLng: function setLatLng (newVal) {
	      if (newVal == null) {
	        return;
	      }

	      if (this.mapObject) {
	        var oldLatLng = this.mapObject.getLatLng();
	        var newLatLng = L$1.latLng(newVal);
	        if (newLatLng.lat !== oldLatLng.lat || newLatLng.lng !== oldLatLng.lng) {
	          this.mapObject.setLatLng(newLatLng);
	        }
	      }
	    },
	    latLngSync: function latLngSync (event) {
	      this.$emit('update:latLng', event.latlng);
	      this.$emit('update:lat-lng', event.latlng);
	    }
	  },
	  render: function (h) {
	    if (this.ready && this.$slots.default) {
	      return h('div', { style: { display: 'none' } }, this.$slots.default);
	    }
	    return null;
	  }
	};

	function normalizeComponent$5(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	    if (typeof shadowMode !== 'boolean') {
	        createInjectorSSR = createInjector;
	        createInjector = shadowMode;
	        shadowMode = false;
	    }
	    // Vue.extend constructor export interop.
	    var options = typeof script === 'function' ? script.options : script;
	    // render functions
	    if (template && template.render) {
	        options.render = template.render;
	        options.staticRenderFns = template.staticRenderFns;
	        options._compiled = true;
	        // functional template
	        if (isFunctionalTemplate) {
	            options.functional = true;
	        }
	    }
	    // scopedId
	    if (scopeId) {
	        options._scopeId = scopeId;
	    }
	    var hook;
	    if (moduleIdentifier) {
	        // server build
	        hook = function (context) {
	            // 2.3 injection
	            context =
	                context || // cached call
	                    (this.$vnode && this.$vnode.ssrContext) || // stateful
	                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
	            // 2.2 with runInNewContext: true
	            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	                context = __VUE_SSR_CONTEXT__;
	            }
	            // inject component styles
	            if (style) {
	                style.call(this, createInjectorSSR(context));
	            }
	            // register component module identifier for async chunk inference
	            if (context && context._registeredComponents) {
	                context._registeredComponents.add(moduleIdentifier);
	            }
	        };
	        // used by ssr in case component is cached and beforeCreate
	        // never gets called
	        options._ssrRegister = hook;
	    }
	    else if (style) {
	        hook = shadowMode
	            ? function (context) {
	                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
	            }
	            : function (context) {
	                style.call(this, createInjector(context));
	            };
	    }
	    if (hook) {
	        if (options.functional) {
	            // register for functional component in vue file
	            var originalRender = options.render;
	            options.render = function renderWithStyleInjection(h, context) {
	                hook.call(context);
	                return originalRender(h, context);
	            };
	        }
	        else {
	            // inject component registration as beforeCreate hook
	            var existing = options.beforeCreate;
	            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	    }
	    return script;
	}

	var isOldIE$4 = typeof navigator !== 'undefined' &&
	    /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	/* script */
	var __vue_script__$e = script$e;

	/* template */

	  /* style */
	  var __vue_inject_styles__$e = undefined;
	  /* scoped */
	  var __vue_scope_id__$e = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$e = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$e = undefined;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$e = normalizeComponent$5(
	    {},
	    __vue_inject_styles__$e,
	    __vue_script__$e,
	    __vue_scope_id__$e,
	    __vue_is_functional_template__$e,
	    __vue_module_identifier__$e,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var capitalizeFirstLetter$5 = function (string) {
	  if (!string || typeof string.charAt !== 'function') { return string; }
	  return string.charAt(0).toUpperCase() + string.slice(1);
	};

	var propsBinder$5 = function (vueElement, leafletElement, props, options) {
	  var loop = function ( key ) {
	    var setMethodName = 'set' + capitalizeFirstLetter$5(key);
	    var deepValue = (props[key].type === Object) ||
	      (props[key].type === Array) ||
	      (Array.isArray(props[key].type));
	    if (props[key].custom && vueElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        vueElement[setMethodName](newVal, oldVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (setMethodName === 'setOptions') {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        L$1.setOptions(leafletElement, newVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (leafletElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        leafletElement[setMethodName](newVal);
	      }, {
	        deep: deepValue
	      });
	    }
	  };

	  for (var key in props) { loop( key ); }
	};

	var collectionCleaner$3 = function (options) {
	  var result = {};
	  for (var key in options) {
	    var value = options[key];
	    if (value !== null && value !== undefined) {
	      result[key] = value;
	    }
	  }
	  return result;
	};

	var optionsMerger$3 = function (props, instance) {
	  var options = instance.options && instance.options.constructor === Object ? instance.options : {};
	  props = props && props.constructor === Object ? props : {};
	  var result = collectionCleaner$3(options);
	  props = collectionCleaner$3(props);
	  var defaultProps = instance.$options.props;
	  for (var key in props) {
	    var def = defaultProps[key] ? defaultProps[key].default : Symbol('unique');
	    if (result[key] && def !== props[key]) {
	      console.warn((key + " props is overriding the value passed in the options props"));
	      result[key] = props[key];
	    } else if (!result[key]) {
	      result[key] = props[key];
	    }
	  }  return result;
	};

	var findRealParent$3 = function (firstVueParent) {
	  var found = false;
	  while (firstVueParent && !found) {
	    if (firstVueParent.mapObject === undefined) {
	      firstVueParent = firstVueParent.$parent;
	    } else {
	      found = true;
	    }
	  }
	  return firstVueParent;
	};

	var Layer$2 = {
	  props: {
	    pane: {
	      type: String,
	      default: 'overlayPane',
	    },
	    attribution: {
	      type: String,
	      default: null,
	    },
	    name: {
	      type: String,
	      custom: true,
	      default: undefined,
	    },
	    layerType: {
	      type: String,
	      custom: true,
	      default: undefined,
	    },
	    visible: {
	      type: Boolean,
	      custom: true,
	      default: true,
	    },
	  },
	  mounted: function mounted() {
	    this.layerOptions = {
	      attribution: this.attribution,
	      pane: this.pane,
	    };
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.unbindPopup();
	    this.unbindTooltip();
	    this.parentContainer.removeLayer(this);
	  },
	  methods: {
	    setAttribution: function setAttribution(val, old) {
	      var attributionControl = this.$parent.mapObject.attributionControl;
	      attributionControl.removeAttribution(old).addAttribution(val);
	    },
	    setName: function setName() {
	      this.parentContainer.removeLayer(this);
	      if (this.visible) {
	        this.parentContainer.addLayer(this);
	      }
	    },
	    setLayerType: function setLayerType() {
	      this.parentContainer.removeLayer(this);
	      if (this.visible) {
	        this.parentContainer.addLayer(this);
	      }
	    },
	    setVisible: function setVisible(newVal) {
	      if (this.mapObject) {
	        if (newVal) {
	          this.parentContainer.addLayer(this);
	        } else {
	          this.parentContainer.hideLayer(this);
	        }
	      }
	    },
	    unbindTooltip: function unbindTooltip() {
	      var tooltip = this.mapObject ? this.mapObject.getTooltip() : null;
	      if (tooltip) {
	        tooltip.unbindTooltip();
	      }
	    },
	    unbindPopup: function unbindPopup() {
	      var popup = this.mapObject ? this.mapObject.getPopup() : null;
	      if (popup) {
	        popup.unbindPopup();
	      }
	    },
	    updateVisibleProp: function updateVisibleProp(value) {
	      this.$emit('update:visible', value);
	    },
	  },
	};

	var GridLayer = {
	  mixins: [Layer$2],
	  props: {
	    pane: {
	      type: String,
	      default: 'tilePane'
	    },
	    opacity: {
	      type: Number,
	      custom: false,
	      default: 1.0
	    },
	    zIndex: {
	      type: Number,
	      default: 1
	    },
	    tileSize: {
	      type: Number,
	      default: 256
	    },
	    noWrap: {
	      type: Boolean,
	      default: false
	    }
	  },
	  mounted: function mounted () {
	    this.gridLayerOptions = Object.assign({}, this.layerOptions,
	      {pane: this.pane,
	      opacity: this.opacity,
	      zIndex: this.zIndex,
	      tileSize: this.tileSize,
	      noWrap: this.noWrap});
	  }
	};

	var TileLayerMixin = {
	  mixins: [GridLayer],
	  props: {
	    tms: {
	      type: Boolean,
	      default: false
	    },
	    detectRetina: {
	      type: Boolean,
	      default: false
	    }
	  },
	  mounted: function mounted () {
	    this.tileLayerOptions = Object.assign({}, this.gridLayerOptions,
	      {tms: this.tms,
	      detectRetina: this.detectRetina});
	  },
	  render: function render () {
	    return null;
	  }
	};

	var Options$4 = {
	  props: {
	    options: {
	      type: Object,
	      default: function () { return ({}); }
	    }
	  }
	};

	//

	var script$f = {
	  name: 'LTileLayer',
	  mixins: [TileLayerMixin, Options$4],
	  props: {
	    url: {
	      type: String,
	      default: null
	    },
	    tileLayerClass: {
	      type: Function,
	      default: L$1.tileLayer
	    }
	  },
	  mounted: function mounted () {
	    var this$1 = this;

	    var options = optionsMerger$3(this.tileLayerOptions, this);
	    this.mapObject = this.tileLayerClass(this.url, options);
	    L$1.DomEvent.on(this.mapObject, this.$listeners);
	    propsBinder$5(this, this.mapObject, this.$options.props);
	    this.parentContainer = findRealParent$3(this.$parent);
	    this.parentContainer.addLayer(this, !this.visible);
	    this.$nextTick(function () {
	      this$1.$emit('ready', this$1.mapObject);
	    });
	  }
	};

	function normalizeComponent$6(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	    if (typeof shadowMode !== 'boolean') {
	        createInjectorSSR = createInjector;
	        createInjector = shadowMode;
	        shadowMode = false;
	    }
	    // Vue.extend constructor export interop.
	    var options = typeof script === 'function' ? script.options : script;
	    // render functions
	    if (template && template.render) {
	        options.render = template.render;
	        options.staticRenderFns = template.staticRenderFns;
	        options._compiled = true;
	        // functional template
	        if (isFunctionalTemplate) {
	            options.functional = true;
	        }
	    }
	    // scopedId
	    if (scopeId) {
	        options._scopeId = scopeId;
	    }
	    var hook;
	    if (moduleIdentifier) {
	        // server build
	        hook = function (context) {
	            // 2.3 injection
	            context =
	                context || // cached call
	                    (this.$vnode && this.$vnode.ssrContext) || // stateful
	                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
	            // 2.2 with runInNewContext: true
	            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	                context = __VUE_SSR_CONTEXT__;
	            }
	            // inject component styles
	            if (style) {
	                style.call(this, createInjectorSSR(context));
	            }
	            // register component module identifier for async chunk inference
	            if (context && context._registeredComponents) {
	                context._registeredComponents.add(moduleIdentifier);
	            }
	        };
	        // used by ssr in case component is cached and beforeCreate
	        // never gets called
	        options._ssrRegister = hook;
	    }
	    else if (style) {
	        hook = shadowMode
	            ? function (context) {
	                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
	            }
	            : function (context) {
	                style.call(this, createInjector(context));
	            };
	    }
	    if (hook) {
	        if (options.functional) {
	            // register for functional component in vue file
	            var originalRender = options.render;
	            options.render = function renderWithStyleInjection(h, context) {
	                hook.call(context);
	                return originalRender(h, context);
	            };
	        }
	        else {
	            // inject component registration as beforeCreate hook
	            var existing = options.beforeCreate;
	            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	    }
	    return script;
	}

	var isOldIE$5 = typeof navigator !== 'undefined' &&
	    /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	/* script */
	var __vue_script__$f = script$f;

	/* template */
	var __vue_render__$d = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div')};
	var __vue_staticRenderFns__$d = [];

	  /* style */
	  var __vue_inject_styles__$f = undefined;
	  /* scoped */
	  var __vue_scope_id__$f = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$f = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$f = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$f = normalizeComponent$6(
	    { render: __vue_render__$d, staticRenderFns: __vue_staticRenderFns__$d },
	    __vue_inject_styles__$f,
	    __vue_script__$f,
	    __vue_scope_id__$f,
	    __vue_is_functional_template__$f,
	    __vue_module_identifier__$f,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var capitalizeFirstLetter$6 = function (string) {
	  if (!string || typeof string.charAt !== 'function') { return string; }
	  return string.charAt(0).toUpperCase() + string.slice(1);
	};

	var propsBinder$6 = function (vueElement, leafletElement, props, options) {
	  var loop = function ( key ) {
	    var setMethodName = 'set' + capitalizeFirstLetter$6(key);
	    var deepValue = (props[key].type === Object) ||
	      (props[key].type === Array) ||
	      (Array.isArray(props[key].type));
	    if (props[key].custom && vueElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        vueElement[setMethodName](newVal, oldVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (setMethodName === 'setOptions') {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        L$1.setOptions(leafletElement, newVal);
	      }, {
	        deep: deepValue
	      });
	    } else if (leafletElement[setMethodName]) {
	      vueElement.$watch(key, function (newVal, oldVal) {
	        leafletElement[setMethodName](newVal);
	      }, {
	        deep: deepValue
	      });
	    }
	  };

	  for (var key in props) { loop( key ); }
	};

	var collectionCleaner$4 = function (options) {
	  var result = {};
	  for (var key in options) {
	    var value = options[key];
	    if (value !== null && value !== undefined) {
	      result[key] = value;
	    }
	  }
	  return result;
	};

	var optionsMerger$4 = function (props, instance) {
	  var options = instance.options && instance.options.constructor === Object ? instance.options : {};
	  props = props && props.constructor === Object ? props : {};
	  var result = collectionCleaner$4(options);
	  props = collectionCleaner$4(props);
	  var defaultProps = instance.$options.props;
	  for (var key in props) {
	    var def = defaultProps[key] ? defaultProps[key].default : Symbol('unique');
	    if (result[key] && def !== props[key]) {
	      console.warn((key + " props is overriding the value passed in the options props"));
	      result[key] = props[key];
	    } else if (!result[key]) {
	      result[key] = props[key];
	    }
	  }  return result;
	};

	var findRealParent$4 = function (firstVueParent) {
	  var found = false;
	  while (firstVueParent && !found) {
	    if (firstVueParent.mapObject === undefined) {
	      firstVueParent = firstVueParent.$parent;
	    } else {
	      found = true;
	    }
	  }
	  return firstVueParent;
	};

	var Layer$3 = {
	  props: {
	    pane: {
	      type: String,
	      default: 'overlayPane',
	    },
	    attribution: {
	      type: String,
	      default: null,
	    },
	    name: {
	      type: String,
	      custom: true,
	      default: undefined,
	    },
	    layerType: {
	      type: String,
	      custom: true,
	      default: undefined,
	    },
	    visible: {
	      type: Boolean,
	      custom: true,
	      default: true,
	    },
	  },
	  mounted: function mounted() {
	    this.layerOptions = {
	      attribution: this.attribution,
	      pane: this.pane,
	    };
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.unbindPopup();
	    this.unbindTooltip();
	    this.parentContainer.removeLayer(this);
	  },
	  methods: {
	    setAttribution: function setAttribution(val, old) {
	      var attributionControl = this.$parent.mapObject.attributionControl;
	      attributionControl.removeAttribution(old).addAttribution(val);
	    },
	    setName: function setName() {
	      this.parentContainer.removeLayer(this);
	      if (this.visible) {
	        this.parentContainer.addLayer(this);
	      }
	    },
	    setLayerType: function setLayerType() {
	      this.parentContainer.removeLayer(this);
	      if (this.visible) {
	        this.parentContainer.addLayer(this);
	      }
	    },
	    setVisible: function setVisible(newVal) {
	      if (this.mapObject) {
	        if (newVal) {
	          this.parentContainer.addLayer(this);
	        } else {
	          this.parentContainer.hideLayer(this);
	        }
	      }
	    },
	    unbindTooltip: function unbindTooltip() {
	      var tooltip = this.mapObject ? this.mapObject.getTooltip() : null;
	      if (tooltip) {
	        tooltip.unbindTooltip();
	      }
	    },
	    unbindPopup: function unbindPopup() {
	      var popup = this.mapObject ? this.mapObject.getPopup() : null;
	      if (popup) {
	        popup.unbindPopup();
	      }
	    },
	    updateVisibleProp: function updateVisibleProp(value) {
	      this.$emit('update:visible', value);
	    },
	  },
	};

	var GridLayer$1 = {
	  mixins: [Layer$3],
	  props: {
	    pane: {
	      type: String,
	      default: 'tilePane'
	    },
	    opacity: {
	      type: Number,
	      custom: false,
	      default: 1.0
	    },
	    zIndex: {
	      type: Number,
	      default: 1
	    },
	    tileSize: {
	      type: Number,
	      default: 256
	    },
	    noWrap: {
	      type: Boolean,
	      default: false
	    }
	  },
	  mounted: function mounted () {
	    this.gridLayerOptions = Object.assign({}, this.layerOptions,
	      {pane: this.pane,
	      opacity: this.opacity,
	      zIndex: this.zIndex,
	      tileSize: this.tileSize,
	      noWrap: this.noWrap});
	  }
	};

	var TileLayer = {
	  mixins: [GridLayer$1],
	  props: {
	    tms: {
	      type: Boolean,
	      default: false
	    },
	    detectRetina: {
	      type: Boolean,
	      default: false
	    }
	  },
	  mounted: function mounted () {
	    this.tileLayerOptions = Object.assign({}, this.gridLayerOptions,
	      {tms: this.tms,
	      detectRetina: this.detectRetina});
	  },
	  render: function render () {
	    return null;
	  }
	};

	var TileLayerWMS = {
	  mixins: [TileLayer],
	  props: {
	    layers: {
	      type: String,
	      default: ''
	    },
	    styles: {
	      type: String,
	      default: ''
	    },
	    format: {
	      type: String,
	      default: 'image/jpeg'
	    },
	    transparent: {
	      type: Boolean,
	      custom: false
	    },
	    version: {
	      type: String,
	      default: '1.1.1'
	    },
	    crs: {
	      default: null
	    },
	    upperCase: {
	      type: Boolean,
	      default: false
	    }
	  },
	  mounted: function mounted () {
	    this.tileLayerWMSOptions = Object.assign({}, this.tileLayerOptions,
	      {layers: this.layers,
	      styles: this.styles,
	      format: this.format,
	      transparent: this.transparent,
	      version: this.version,
	      crs: this.crs,
	      upperCase: this.upperCase});
	  }
	};

	var Options$5 = {
	  props: {
	    options: {
	      type: Object,
	      default: function () { return ({}); }
	    }
	  }
	};

	var script$g = {
	  name: 'LWMSTileLayer',
	  mixins: [TileLayerWMS, Options$5],
	  props: {
	    baseUrl: {
	      type: String,
	      default: null
	    }
	  },
	  mounted: function mounted () {
	    var this$1 = this;

	    var options = optionsMerger$4(this.tileLayerWMSOptions, this);
	    this.mapObject = L$1.tileLayer.wms(this.baseUrl, options);
	    L$1.DomEvent.on(this.mapObject, this.$listeners);
	    propsBinder$6(this, this.mapObject, this.$options.props);
	    this.parentContainer = findRealParent$4(this.$parent);
	    this.parentContainer.addLayer(this, !this.visible);
	    this.$nextTick(function () {
	      this$1.$emit('ready', this$1.mapObject);
	    });
	  }
	};

	function normalizeComponent$7(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	    if (typeof shadowMode !== 'boolean') {
	        createInjectorSSR = createInjector;
	        createInjector = shadowMode;
	        shadowMode = false;
	    }
	    // Vue.extend constructor export interop.
	    var options = typeof script === 'function' ? script.options : script;
	    // render functions
	    if (template && template.render) {
	        options.render = template.render;
	        options.staticRenderFns = template.staticRenderFns;
	        options._compiled = true;
	        // functional template
	        if (isFunctionalTemplate) {
	            options.functional = true;
	        }
	    }
	    // scopedId
	    if (scopeId) {
	        options._scopeId = scopeId;
	    }
	    var hook;
	    if (moduleIdentifier) {
	        // server build
	        hook = function (context) {
	            // 2.3 injection
	            context =
	                context || // cached call
	                    (this.$vnode && this.$vnode.ssrContext) || // stateful
	                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
	            // 2.2 with runInNewContext: true
	            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	                context = __VUE_SSR_CONTEXT__;
	            }
	            // inject component styles
	            if (style) {
	                style.call(this, createInjectorSSR(context));
	            }
	            // register component module identifier for async chunk inference
	            if (context && context._registeredComponents) {
	                context._registeredComponents.add(moduleIdentifier);
	            }
	        };
	        // used by ssr in case component is cached and beforeCreate
	        // never gets called
	        options._ssrRegister = hook;
	    }
	    else if (style) {
	        hook = shadowMode
	            ? function (context) {
	                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
	            }
	            : function (context) {
	                style.call(this, createInjector(context));
	            };
	    }
	    if (hook) {
	        if (options.functional) {
	            // register for functional component in vue file
	            var originalRender = options.render;
	            options.render = function renderWithStyleInjection(h, context) {
	                hook.call(context);
	                return originalRender(h, context);
	            };
	        }
	        else {
	            // inject component registration as beforeCreate hook
	            var existing = options.beforeCreate;
	            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	        }
	    }
	    return script;
	}

	var isOldIE$6 = typeof navigator !== 'undefined' &&
	    /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

	/* script */
	var __vue_script__$g = script$g;

	/* template */

	  /* style */
	  var __vue_inject_styles__$g = undefined;
	  /* scoped */
	  var __vue_scope_id__$g = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$g = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$g = undefined;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$g = normalizeComponent$7(
	    {},
	    __vue_inject_styles__$g,
	    __vue_script__$g,
	    __vue_scope_id__$g,
	    __vue_is_functional_template__$g,
	    __vue_module_identifier__$g,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	// Based on https://github.com/shramov/leaflet-plugins
	// GridLayer like https://avinmathew.com/leaflet-and-google-maps/ , but using MutationObserver instead of jQuery


	// 🍂class GridLayer.GoogleMutant
	// 🍂extends GridLayer
	L.GridLayer.GoogleMutant = L.GridLayer.extend({
		options: {
			minZoom: 0,
			maxZoom: 23,
			tileSize: 256,
			subdomains: 'abc',
			errorTileUrl: '',
			attribution: '',	// The mutant container will add its own attribution anyways.
			opacity: 1,
			continuousWorld: false,
			noWrap: false,
			// 🍂option type: String = 'roadmap'
			// Google's map type. Valid values are 'roadmap', 'satellite' or 'terrain'. 'hybrid' is not really supported.
			type: 'roadmap',
			maxNativeZoom: 21
		},

		initialize: function (options) {
			L.GridLayer.prototype.initialize.call(this, options);

			this._ready = !!window.google && !!window.google.maps && !!window.google.maps.Map;

			this._GAPIPromise = this._ready ? Promise.resolve(window.google) : new Promise(function (resolve, reject) {
				var checkCounter = 0;
				var intervalId = null;
				intervalId = setInterval(function () {
					if (checkCounter >= 10) {
						clearInterval(intervalId);
						return reject(new Error('window.google not found after 10 attempts'));
					}
					if (!!window.google && !!window.google.maps && !!window.google.maps.Map) {
						clearInterval(intervalId);
						return resolve(window.google);
					}
					checkCounter++;
				}, 500);
			});

			// Couple data structures indexed by tile key
			this._tileCallbacks = {};	// Callbacks for promises for tiles that are expected
			this._freshTiles = {};	// Tiles from the mutant which haven't been requested yet

			this._imagesPerTile = (this.options.type === 'hybrid') ? 2 : 1;

			this._boundOnMutatedImage = this._onMutatedImage.bind(this);
		},

		onAdd: function (map) {
			L.GridLayer.prototype.onAdd.call(this, map);
			this._initMutantContainer();

			this._GAPIPromise.then(function () {
				this._ready = true;
				this._map = map;

				this._initMutant();

				map.on('viewreset', this._reset, this);
				if (this.options.updateWhenIdle) {
					map.on('moveend', this._update, this);
				} else {
					map.on('move', this._update, this);
				}
				map.on('zoomend', this._handleZoomAnim, this);
				map.on('resize', this._resize, this);

				//handle layer being added to a map for which there are no Google tiles at the given zoom
				google.maps.event.addListenerOnce(this._mutant, 'idle', function () {
					this._checkZoomLevels();
					this._mutantIsReady = true;
				}.bind(this));

				//20px instead of 1em to avoid a slight overlap with google's attribution
				map._controlCorners.bottomright.style.marginBottom = '20px';
				map._controlCorners.bottomleft.style.marginBottom = '20px';

				this._reset();
				this._update();

				if (this._subLayers) {
					//restore previously added google layers
					for (var layerName in this._subLayers) {
						this._subLayers[layerName].setMap(this._mutant);
					}
				}
			}.bind(this));
		},

		onRemove: function (map) {
			L.GridLayer.prototype.onRemove.call(this, map);
			this._observer.disconnect();
			map._container.removeChild(this._mutantContainer);

			google.maps.event.clearListeners(map, 'idle');
			google.maps.event.clearListeners(this._mutant, 'idle');
			map.off('viewreset', this._reset, this);
			map.off('move', this._update, this);
			map.off('moveend', this._update, this);
			map.off('zoomend', this._handleZoomAnim, this);
			map.off('resize', this._resize, this);

			if (map._controlCorners) {
				map._controlCorners.bottomright.style.marginBottom = '0em';
				map._controlCorners.bottomleft.style.marginBottom = '0em';
			}
		},

		getAttribution: function () {
			return this.options.attribution;
		},

		setElementSize: function (e, size) {
			e.style.width = size.x + 'px';
			e.style.height = size.y + 'px';
		},


		addGoogleLayer: function (googleLayerName, options) {
			if (!this._subLayers) { this._subLayers = {}; }
			return this._GAPIPromise.then(function () {
				var Constructor = google.maps[googleLayerName];
				var googleLayer = new Constructor(options);
				googleLayer.setMap(this._mutant);
				this._subLayers[googleLayerName] = googleLayer;
				return googleLayer;
			}.bind(this));
		},

		removeGoogleLayer: function (googleLayerName) {
			var googleLayer = this._subLayers && this._subLayers[googleLayerName];
			if (!googleLayer) { return; }

			googleLayer.setMap(null);
			delete this._subLayers[googleLayerName];
		},


		_initMutantContainer: function () {
			if (!this._mutantContainer) {
				this._mutantContainer = L.DomUtil.create('div', 'leaflet-google-mutant leaflet-top leaflet-left');
				this._mutantContainer.id = '_MutantContainer_' + L.Util.stamp(this._mutantContainer);
				this._mutantContainer.style.zIndex = '800'; //leaflet map pane at 400, controls at 1000
				this._mutantContainer.style.pointerEvents = 'none';
				
				L.DomEvent.off(this._mutantContainer);

			}
			this._map.getContainer().appendChild(this._mutantContainer);

			this.setOpacity(this.options.opacity);
			this.setElementSize(this._mutantContainer, this._map.getSize());

			this._attachObserver(this._mutantContainer);
		},

		_initMutant: function () {
			if (!this._ready || !this._mutantContainer) { return; }

			if (this._mutant) {
				// reuse old _mutant, just make sure it has the correct size
				this._resize();
				return;
			}

			this._mutantCenter = new google.maps.LatLng(0, 0);

			var map = new google.maps.Map(this._mutantContainer, {
				center: this._mutantCenter,
				zoom: 0,
				tilt: 0,
				mapTypeId: this.options.type,
				disableDefaultUI: true,
				keyboardShortcuts: false,
				draggable: false,
				disableDoubleClickZoom: true,
				scrollwheel: false,
				streetViewControl: false,
				styles: this.options.styles || {},
				backgroundColor: 'transparent'
			});

			this._mutant = map;

			google.maps.event.addListenerOnce(map, 'idle', function () {
				var nodes = this._mutantContainer.querySelectorAll('a');
				for (var i = 0; i < nodes.length; i++) {
					nodes[i].style.pointerEvents = 'auto';
				}
			}.bind(this));

			// 🍂event spawned
			// Fired when the mutant has been created.
			this.fire('spawned', {mapObject: map});
		},

		_attachObserver: function _attachObserver (node) {
	// 		console.log('Gonna observe', node);

			if (!this._observer)
				{ this._observer = new MutationObserver(this._onMutations.bind(this)); }

			// pass in the target node, as well as the observer options
			this._observer.observe(node, { childList: true, subtree: true });

			// if we are reusing an old _mutantContainer, we must manually detect
			// all existing tiles in it
			Array.prototype.forEach.call(
				node.querySelectorAll('img'),
				this._boundOnMutatedImage
			);
		},

		_onMutations: function _onMutations (mutations) {
			for (var i = 0; i < mutations.length; ++i) {
				var mutation = mutations[i];
				for (var j = 0; j < mutation.addedNodes.length; ++j) {
					var node = mutation.addedNodes[j];

					if (node instanceof HTMLImageElement) {
						this._onMutatedImage(node);
					} else if (node instanceof HTMLElement) {
						Array.prototype.forEach.call(
							node.querySelectorAll('img'),
							this._boundOnMutatedImage
						);

						// Check for, and remove, the "Google Maps can't load correctly" div.
						// You *are* loading correctly, you dumbwit.
						if (node.style.backgroundColor === 'white') {
							L.DomUtil.remove(node);
						}
	                    
						// Check for, and remove, the "For development purposes only" divs on the aerial/hybrid tiles.
						if (node.textContent.indexOf('For development purposes only') === 0) {
							L.DomUtil.remove(node);
						}
	                    
						// Check for, and remove, the "Sorry, we have no imagery here"
						// empty <div>s. The [style*="text-align: center"] selector
						// avoids matching the attribution notice.
						// This empty div doesn't have a reference to the tile
						// coordinates, so it's not possible to mark the tile as
						// failed.
						Array.prototype.forEach.call(
							node.querySelectorAll('div[draggable=false][style*="text-align: center"]'),
							L.DomUtil.remove
						);
					}
				}
			}
		},

		// Only images which 'src' attrib match this will be considered for moving around.
		// Looks like some kind of string-based protobuf, maybe??
		// Only the roads (and terrain, and vector-based stuff) match this pattern
		_roadRegexp: /!1i(\d+)!2i(\d+)!3i(\d+)!/,

		// On the other hand, raster imagery matches this other pattern
		_satRegexp: /x=(\d+)&y=(\d+)&z=(\d+)/,

		// On small viewports, when zooming in/out, a static image is requested
		// This will not be moved around, just removed from the DOM.
		_staticRegExp: /StaticMapService\.GetMapImage/,

		_onMutatedImage: function _onMutatedImage (imgNode) {
	// 		if (imgNode.src) {
	// 			console.log('caught mutated image: ', imgNode.src);
	// 		}

			var coords;
			var match = imgNode.src.match(this._roadRegexp);
			var sublayer = 0;

			if (match) {
				coords = {
					z: match[1],
					x: match[2],
					y: match[3]
				};
				if (this._imagesPerTile > 1) { 
					imgNode.style.zIndex = 1;
					sublayer = 1;
				}
			} else {
				match = imgNode.src.match(this._satRegexp);
				if (match) {
					coords = {
						x: match[1],
						y: match[2],
						z: match[3]
					};
				}
	// 			imgNode.style.zIndex = 0;
				sublayer = 0;
			}

			if (coords) {
				var tileKey = this._tileCoordsToKey(coords);
				imgNode.style.position = 'absolute';
				imgNode.style.visibility = 'hidden';

				var key = tileKey + '/' + sublayer;
				// console.log('mutation for tile', key)
				//store img so it can also be used in subsequent tile requests
				this._freshTiles[key] = imgNode;

				if (key in this._tileCallbacks && this._tileCallbacks[key]) {
	// console.log('Fullfilling callback ', key);
					//fullfill most recent tileCallback because there maybe callbacks that will never get a 
					//corresponding mutation (because map moved to quickly...)
					this._tileCallbacks[key].pop()(imgNode); 
					if (!this._tileCallbacks[key].length) { delete this._tileCallbacks[key]; }
				} else {
					if (this._tiles[tileKey]) {
						//we already have a tile in this position (mutation is probably a google layer being added)
						//replace it
						var c = this._tiles[tileKey].el;
						var oldImg = (sublayer === 0) ? c.firstChild : c.firstChild.nextSibling;
						var cloneImgNode = this._clone(imgNode);
						c.replaceChild(cloneImgNode, oldImg);
					}
				}
			} else if (imgNode.src.match(this._staticRegExp)) {
				imgNode.style.visibility = 'hidden';
			}
		},


		createTile: function (coords, done) {
			var key = this._tileCoordsToKey(coords);

			var tileContainer = L.DomUtil.create('div');
			tileContainer.dataset.pending = this._imagesPerTile;
			done = done.bind(this, null, tileContainer);

			for (var i = 0; i < this._imagesPerTile; i++) {
				var key2 = key + '/' + i;
				if (key2 in this._freshTiles) {
					var imgNode = this._freshTiles[key2];
					tileContainer.appendChild(this._clone(imgNode));
					tileContainer.dataset.pending--;
	// 				console.log('Got ', key2, ' from _freshTiles');
				} else {
					this._tileCallbacks[key2] = this._tileCallbacks[key2] || [];
					this._tileCallbacks[key2].push( (function (c/*, k2*/) {
						return function (imgNode) {
							c.appendChild(this._clone(imgNode));
							c.dataset.pending--;
							if (!parseInt(c.dataset.pending)) { done(); }
	// 						console.log('Sent ', k2, ' to _tileCallbacks, still ', c.dataset.pending, ' images to go');
						}.bind(this);
					}.bind(this))(tileContainer/*, key2*/) );
				}
			}

			if (!parseInt(tileContainer.dataset.pending)) {
				L.Util.requestAnimFrame(done);
			}
			return tileContainer;
		},

		_clone: function (imgNode) {
			var clonedImgNode = imgNode.cloneNode(true);
			clonedImgNode.style.visibility = 'visible';
			return clonedImgNode;
		},

		_checkZoomLevels: function () {
			//setting the zoom level on the Google map may result in a different zoom level than the one requested
			//(it won't go beyond the level for which they have data).
			var zoomLevel = this._map.getZoom();
			var gMapZoomLevel = this._mutant.getZoom();
			if (!zoomLevel || !gMapZoomLevel) { return; }


			if ((gMapZoomLevel !== zoomLevel) || //zoom levels are out of sync, Google doesn't have data
				(gMapZoomLevel > this.options.maxNativeZoom)) { //at current location, Google does have data (contrary to maxNativeZoom)
				//Update maxNativeZoom
				this._setMaxNativeZoom(gMapZoomLevel);
			}
		},

		_setMaxNativeZoom: function (zoomLevel) {
			if (zoomLevel != this.options.maxNativeZoom) {
				this.options.maxNativeZoom = zoomLevel;
				this._resetView();
			}
		},

		_reset: function () {
			this._initContainer();
		},

		_update: function () {
			// zoom level check needs to happen before super's implementation (tile addition/creation)
			// otherwise tiles may be missed if maxNativeZoom is not yet correctly determined
			if (this._mutant) {
				var center = this._map.getCenter();
				var _center = new google.maps.LatLng(center.lat, center.lng);

				this._mutant.setCenter(_center);
				var zoom = this._map.getZoom();
				var fractionalLevel = zoom !== Math.round(zoom);
				var mutantZoom = this._mutant.getZoom();

				//ignore fractional zoom levels
				if (!fractionalLevel && (zoom != mutantZoom)) {
					this._mutant.setZoom(zoom);
								
					if (this._mutantIsReady) { this._checkZoomLevels(); }
					//else zoom level check will be done later by 'idle' handler
				}
			}

			L.GridLayer.prototype._update.call(this);
		},

		_resize: function () {
			var size = this._map.getSize();
			if (this._mutantContainer.style.width === size.x &&
				this._mutantContainer.style.height === size.y)
				{ return; }
			this.setElementSize(this._mutantContainer, size);
			if (!this._mutant) { return; }
			google.maps.event.trigger(this._mutant, 'resize');
		},

		_handleZoomAnim: function () {
			if (!this._mutant) { return; }
			var center = this._map.getCenter();
			var _center = new google.maps.LatLng(center.lat, center.lng);

			this._mutant.setCenter(_center);
			this._mutant.setZoom(Math.round(this._map.getZoom()));
		},

		// Agressively prune _freshtiles when a tile with the same key is removed,
		// this prevents a problem where Leaflet keeps a loaded tile longer than
		// GMaps, so that GMaps makes two requests but Leaflet only consumes one,
		// polluting _freshTiles with stale data.
		_removeTile: function (key) {
			if (!this._mutant) { return; }

			//give time for animations to finish before checking it tile should be pruned
			setTimeout(this._pruneTile.bind(this, key), 1000);


			return L.GridLayer.prototype._removeTile.call(this, key);
		},

		_pruneTile: function (key) {
			var gZoom = this._mutant.getZoom();
			var tileZoom = key.split(':')[2];
			var googleBounds = this._mutant.getBounds();
			var sw = googleBounds.getSouthWest();
			var ne = googleBounds.getNorthEast();
			var gMapBounds = L.latLngBounds([[sw.lat(), sw.lng()], [ne.lat(), ne.lng()]]);

			for (var i=0; i<this._imagesPerTile; i++) {
				var key2 = key + '/' + i;
				if (key2 in this._freshTiles) { 
					var tileBounds = this._map && this._keyToBounds(key);
					var stillVisible = this._map && tileBounds.overlaps(gMapBounds) && (tileZoom == gZoom);

					if (!stillVisible) { delete this._freshTiles[key2]; } 
	//				console.log('Prunning of ', key, (!stillVisible))
				}
			}
		}
	});


	// 🍂factory gridLayer.googleMutant(options)
	// Returns a new `GridLayer.GoogleMutant` given its options
	L.gridLayer.googleMutant = function (options) {
		return new L.GridLayer.GoogleMutant(options);
	};

	var props$$ = {
	  options: {
	    type: Object,
	    "default": function _default() {
	      return {};
	    }
	  },
	  apikey: {
	    type: String,
	    "default": function _default() {
	      return 'AIzaSyCLabehdilVD5BsAyl_Ogd9XJnmzaBenb8';
	    }
	  },
	  type: {
	    type: String,
	    "default": function _default() {
	      return 'roadmap';
	    }
	  },
	  tiled: {
	    type: Boolean,
	    "default": function _default() {
	      return true;
	    }
	  },
	  name: {
	    type: String,
	    "default": 'Google Maps'
	  },
	  layerType: {
	    type: String,
	    "default": 'base'
	  },
	  visible: {
	    type: Boolean,
	    "default": true
	  }
	};
	var script$h = {
	  name: 'l-google-layer',
	  props: props$$,
	  data: function data() {
	    return {
	      ready: false
	    };
	  },
	  mounted: function mounted() {
	    var type = this.convertType(this.type);
	    this.mapObject = this.tiled ? L$1.tileLayer("http://{s}.google.com/vt/lyrs=" + type + "&x={x}&y={y}&z={z}", _objectSpread2$1({
	      subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
	      attribution: '&copy; Google Maps'
	    }, this.options)) : gridLayer.googleMutant(this.options);
	    L$1__default.DomEvent.on(this.mapObject, this.$listeners);
	    propsBinder(this, this.mapObject, props$$); // if (!(typeof google === 'object' && typeof google.maps === 'object')) {
	    //     let googleapisscript = document.createElement('script');
	    //     googleapisscript.setAttribute('src', 'https://maps.googleapis.com/maps/api/js?key=' + this.apikey);
	    //     document.head.appendChild(googleapisscript);
	    // }

	    this.ready = true;
	    this.parentContainer = findRealParent(this.$parent);
	    this.parentContainer.addLayer(this, !this.visible);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.parentContainer.removeLayer(this);
	  },
	  methods: {
	    addLayer: function addLayer(layer, alreadyAdded) {
	      if (!alreadyAdded) {
	        this.mapObject.addLayer(layer.mapObject);
	      }
	    },
	    removeLayer: function removeLayer(layer, alreadyRemoved) {
	      if (!alreadyRemoved) {
	        this.mapObject.removeLayer(layer.mapObject);
	      }
	    },
	    convertType: function convertType(mapType) {
	      /*
	       h = roads only
	       m = standard roadmap
	       p = terrain
	       r = somehow altered roadmap
	       s = satellite only
	       t = terrain only
	       y = hybrid
	       */
	      switch (mapType) {
	        case 'roadmap':
	          return 'm';

	        case 'satellite':
	          return 's';

	        case 'terrain':
	          return 't';

	        case 'hybrid':
	          return 'y';

	        default:
	          return mapType;
	      }
	    }
	  }
	};

	/* script */
	var __vue_script__$h = script$h;

	/* template */
	var __vue_render__$e = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    { staticStyle: { display: "none" } },
	    [_vm.ready ? _vm._t("default") : _vm._e()],
	    2
	  )
	};
	var __vue_staticRenderFns__$e = [];
	__vue_render__$e._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$h = undefined;
	  /* scoped */
	  var __vue_scope_id__$h = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$h = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$h = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$h = normalizeComponent$1(
	    { render: __vue_render__$e, staticRenderFns: __vue_staticRenderFns__$e },
	    __vue_inject_styles__$h,
	    __vue_script__$h,
	    __vue_scope_id__$h,
	    __vue_is_functional_template__$h,
	    __vue_module_identifier__$h,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var L_Control_Locate = createCommonjsModule(function (module, exports) {
	/*!
	Copyright (c) 2016 Dominik Moritz

	This file is part of the leaflet locate control. It is licensed under the MIT license.
	You can find the project at: https://github.com/domoritz/leaflet-locatecontrol
	*/
	(function (factory, window) {
	     // see https://github.com/Leaflet/Leaflet/blob/master/PLUGIN-GUIDE.md#module-loaders
	     // for details on how to structure a leaflet plugin.

	    // define an AMD module that relies on 'leaflet'
	    {
	        if (typeof window !== 'undefined' && window.L) {
	            module.exports = factory(L);
	        } else {
	            module.exports = factory(L$1__default);
	        }
	    }

	    // attach your plugin to the global 'L' variable
	    if (typeof window !== 'undefined' && window.L){
	        window.L.Control.Locate = factory(L);
	    }
	} (function (L) {
	    var LDomUtilApplyClassesMethod = function(method, element, classNames) {
	        classNames = classNames.split(' ');
	        classNames.forEach(function(className) {
	            L.DomUtil[method].call(this, element, className);
	        });
	    };

	    var addClasses = function(el, names) { LDomUtilApplyClassesMethod('addClass', el, names); };
	    var removeClasses = function(el, names) { LDomUtilApplyClassesMethod('removeClass', el, names); };

	    /**
	     * Compatible with L.Circle but a true marker instead of a path
	     */
	    var LocationMarker = L.Marker.extend({
	        initialize: function (latlng, options) {
	            L.Util.setOptions(this, options);
	            this._latlng = latlng;
	            this.createIcon();
	        },

	        /**
	         * Create a styled circle location marker
	         */
	        createIcon: function() {
	            var opt = this.options;

	            var style = '';

	            if (opt.color !== undefined) {
	                style += 'stroke:'+opt.color+';';
	            }
	            if (opt.weight !== undefined) {
	                style += 'stroke-width:'+opt.weight+';';
	            }
	            if (opt.fillColor !== undefined) {
	                style += 'fill:'+opt.fillColor+';';
	            }
	            if (opt.fillOpacity !== undefined) {
	                style += 'fill-opacity:'+opt.fillOpacity+';';
	            }
	            if (opt.opacity !== undefined) {
	                style += 'opacity:'+opt.opacity+';';
	            }

	            var icon = this._getIconSVG(opt, style);

	            this._locationIcon = L.divIcon({
	                className: icon.className,
	                html: icon.svg,
	                iconSize: [icon.w,icon.h],
	            });

	            this.setIcon(this._locationIcon);
	        },

	        /**
	         * Return the raw svg for the shape
	         *
	         * Split so can be easily overridden
	         */
	        _getIconSVG: function(options, style) {
	            var r = options.radius;
	            var w = options.weight;
	            var s = r + w;
	            var s2 = s * 2;
	            var svg = '<svg xmlns="http://www.w3.org/2000/svg" width="'+s2+'" height="'+s2+'" version="1.1" viewBox="-'+s+' -'+s+' '+s2+' '+s2+'">' +
	            '<circle r="'+r+'" style="'+style+'" />' +
	            '</svg>';
	            return {
	                className: 'leaflet-control-locate-location',
	                svg: svg,
	                w: s2,
	                h: s2
	            };
	        },

	        setStyle: function(style) {
	            L.Util.setOptions(this, style);
	            this.createIcon();
	        }
	    });

	    var CompassMarker = LocationMarker.extend({
	        initialize: function (latlng, heading, options) {
	            L.Util.setOptions(this, options);
	            this._latlng = latlng;
	            this._heading = heading;
	            this.createIcon();
	        },

	        setHeading: function(heading) {
	            this._heading = heading;
	        },

	        /**
	         * Create a styled arrow compass marker
	         */
	        _getIconSVG: function(options, style) {
	            var r = options.radius;
	            var w = (options.width + options.weight);
	            var h = (r+options.depth + options.weight)*2;
	            var path = 'M0,0 l'+(options.width/2)+','+options.depth+' l-'+(w)+',0 z';
	            var svgstyle = 'transform: rotate('+this._heading+'deg)';
	            var svg = '<svg xmlns="http://www.w3.org/2000/svg" width="'+(w)+'" height="'+h+'" version="1.1" viewBox="-'+(w/2)+' 0 '+w+' '+h+'" style="'+svgstyle+'">'+
	            '<path d="'+path+'" style="'+style+'" />'+
	            '</svg>';
	            return {
	                className: 'leaflet-control-locate-heading',
	                svg: svg,
	                w: w,
	                h: h
	            };
	        },
	    });


	    var LocateControl = L.Control.extend({
	        options: {
	            /** Position of the control */
	            position: 'topleft',
	            /** The layer that the user's location should be drawn on. By default creates a new layer. */
	            layer: undefined,
	            /**
	             * Automatically sets the map view (zoom and pan) to the user's location as it updates.
	             * While the map is following the user's location, the control is in the `following` state,
	             * which changes the style of the control and the circle marker.
	             *
	             * Possible values:
	             *  - false: never updates the map view when location changes.
	             *  - 'once': set the view when the location is first determined
	             *  - 'always': always updates the map view when location changes.
	             *              The map view follows the user's location.
	             *  - 'untilPan': like 'always', except stops updating the
	             *                view if the user has manually panned the map.
	             *                The map view follows the user's location until she pans.
	             *  - 'untilPanOrZoom': (default) like 'always', except stops updating the
	             *                view if the user has manually panned the map.
	             *                The map view follows the user's location until she pans.
	             */
	            setView: 'untilPanOrZoom',
	            /** Keep the current map zoom level when setting the view and only pan. */
	            keepCurrentZoomLevel: false,
	            /**
	             * This callback can be used to override the viewport tracking
	             * This function should return a LatLngBounds object.
	             *
	             * For example to extend the viewport to ensure that a particular LatLng is visible:
	             *
	             * getLocationBounds: function(locationEvent) {
	             *    return locationEvent.bounds.extend([-33.873085, 151.219273]);
	             * },
	             */
	            getLocationBounds: function (locationEvent) {
	                return locationEvent.bounds;
	            },
	            /** Smooth pan and zoom to the location of the marker. Only works in Leaflet 1.0+. */
	            flyTo: false,
	            /**
	             * The user location can be inside and outside the current view when the user clicks on the
	             * control that is already active. Both cases can be configures separately.
	             * Possible values are:
	             *  - 'setView': zoom and pan to the current location
	             *  - 'stop': stop locating and remove the location marker
	             */
	            clickBehavior: {
	                /** What should happen if the user clicks on the control while the location is within the current view. */
	                inView: 'stop',
	                /** What should happen if the user clicks on the control while the location is outside the current view. */
	                outOfView: 'setView',
	                /**
	                 * What should happen if the user clicks on the control while the location is within the current view
	                 * and we could be following but are not. Defaults to a special value which inherits from 'inView';
	                 */
	                inViewNotFollowing: 'inView',
	            },
	            /**
	             * If set, save the map bounds just before centering to the user's
	             * location. When control is disabled, set the view back to the
	             * bounds that were saved.
	             */
	            returnToPrevBounds: false,
	            /**
	             * Keep a cache of the location after the user deactivates the control. If set to false, the user has to wait
	             * until the locate API returns a new location before they see where they are again.
	             */
	            cacheLocation: true,
	            /** If set, a circle that shows the location accuracy is drawn. */
	            drawCircle: true,
	            /** If set, the marker at the users' location is drawn. */
	            drawMarker: true,
	            /** If set and supported then show the compass heading */
	            showCompass: true,
	            /** The class to be used to create the marker. For example L.CircleMarker or L.Marker */
	            markerClass: LocationMarker,
	            /** The class us be used to create the compass bearing arrow */
	            compassClass: CompassMarker,
	            /** Accuracy circle style properties. NOTE these styles should match the css animations styles */
	            circleStyle: {
	                className:   'leaflet-control-locate-circle',
	                color:       '#136AEC',
	                fillColor:   '#136AEC',
	                fillOpacity: 0.15,
	                weight:      0
	            },
	            /** Inner marker style properties. Only works if your marker class supports `setStyle`. */
	            markerStyle: {
	                className:   'leaflet-control-locate-marker',
	                color:       '#fff',
	                fillColor:   '#2A93EE',
	                fillOpacity: 1,
	                weight:      3,
	                opacity:     1,
	                radius:      9
	            },
	            /** Compass */
	            compassStyle: {
	                fillColor:   '#2A93EE',
	                fillOpacity: 1,
	                weight:      0,
	                color:       '#fff',
	                opacity:     1,
	                radius:      9, // How far is the arrow is from the center of of the marker
	                width:       9, // Width of the arrow
	                depth:       6  // Length of the arrow
	            },
	            /**
	             * Changes to accuracy circle and inner marker while following.
	             * It is only necessary to provide the properties that should change.
	             */
	            followCircleStyle: {},
	            followMarkerStyle: {
	                // color: '#FFA500',
	                // fillColor: '#FFB000'
	            },
	            followCompassStyle: {},
	            /** The CSS class for the icon. For example fa-location-arrow or fa-map-marker */
	            icon: 'fa fa-map-marker',
	            iconLoading: 'fa fa-spinner fa-spin',
	            /** The element to be created for icons. For example span or i */
	            iconElementTag: 'span',
	            /** Padding around the accuracy circle. */
	            circlePadding: [0, 0],
	            /** Use metric units. */
	            metric: true,
	            /**
	             * This callback can be used in case you would like to override button creation behavior.
	             * This is useful for DOM manipulation frameworks such as angular etc.
	             * This function should return an object with HtmlElement for the button (link property) and the icon (icon property).
	             */
	            createButtonCallback: function (container, options) {
	                var link = L.DomUtil.create('a', 'leaflet-bar-part leaflet-bar-part-single', container);
	                link.title = options.strings.title;
	                var icon = L.DomUtil.create(options.iconElementTag, options.icon, link);
	                return { link: link, icon: icon };
	            },
	            /** This event is called in case of any location error that is not a time out error. */
	            onLocationError: function(err, control) {
	                alert(err.message);
	            },
	            /**
	             * This event is called when the user's location is outside the bounds set on the map.
	             * The event is called repeatedly when the location changes.
	             */
	            onLocationOutsideMapBounds: function(control) {
	                control.stop();
	                alert(control.options.strings.outsideMapBoundsMsg);
	            },
	            /** Display a pop-up when the user click on the inner marker. */
	            showPopup: true,
	            strings: {
	                title: "Show me where I am",
	                metersUnit: "meters",
	                feetUnit: "feet",
	                popup: "You are within {distance} {unit} from this point",
	                outsideMapBoundsMsg: "You seem located outside the boundaries of the map"
	            },
	            /** The default options passed to leaflets locate method. */
	            locateOptions: {
	                maxZoom: Infinity,
	                watch: true,  // if you overwrite this, visualization cannot be updated
	                setView: false // have to set this to false because we have to
	                               // do setView manually
	            }
	        },

	        initialize: function (options) {
	            // set default options if nothing is set (merge one step deep)
	            for (var i in options) {
	                if (typeof this.options[i] === 'object') {
	                    L.extend(this.options[i], options[i]);
	                } else {
	                    this.options[i] = options[i];
	                }
	            }

	            // extend the follow marker style and circle from the normal style
	            this.options.followMarkerStyle = L.extend({}, this.options.markerStyle, this.options.followMarkerStyle);
	            this.options.followCircleStyle = L.extend({}, this.options.circleStyle, this.options.followCircleStyle);
	            this.options.followCompassStyle = L.extend({}, this.options.compassStyle, this.options.followCompassStyle);
	        },

	        /**
	         * Add control to map. Returns the container for the control.
	         */
	        onAdd: function (map) {
	            var container = L.DomUtil.create('div',
	                'leaflet-control-locate leaflet-bar leaflet-control');

	            this._layer = this.options.layer || new L.LayerGroup();
	            this._layer.addTo(map);
	            this._event = undefined;
	            this._compassHeading = null;
	            this._prevBounds = null;

	            var linkAndIcon = this.options.createButtonCallback(container, this.options);
	            this._link = linkAndIcon.link;
	            this._icon = linkAndIcon.icon;

	            L.DomEvent
	                .on(this._link, 'click', L.DomEvent.stopPropagation)
	                .on(this._link, 'click', L.DomEvent.preventDefault)
	                .on(this._link, 'click', this._onClick, this)
	                .on(this._link, 'dblclick', L.DomEvent.stopPropagation);

	            this._resetVariables();

	            this._map.on('unload', this._unload, this);

	            return container;
	        },

	        /**
	         * This method is called when the user clicks on the control.
	         */
	        _onClick: function() {
	            this._justClicked = true;
	            var wasFollowing =  this._isFollowing();
	            this._userPanned = false;
	            this._userZoomed = false;

	            if (this._active && !this._event) {
	                // click while requesting
	                this.stop();
	            } else if (this._active && this._event !== undefined) {
	                var behaviors = this.options.clickBehavior;
	                var behavior = behaviors.outOfView;
	                if (this._map.getBounds().contains(this._event.latlng)) {
	                    behavior = wasFollowing ? behaviors.inView : behaviors.inViewNotFollowing;
	                }

	                // Allow inheriting from another behavior
	                if (behaviors[behavior]) {
	                    behavior = behaviors[behavior];
	                }

	                switch (behavior) {
	                    case 'setView':
	                        this.setView();
	                        break;
	                    case 'stop':
	                        this.stop();
	                        if (this.options.returnToPrevBounds) {
	                            var f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;
	                            f.bind(this._map)(this._prevBounds);
	                        }
	                        break;
	                }
	            } else {
	                if (this.options.returnToPrevBounds) {
	                  this._prevBounds = this._map.getBounds();
	                }
	                this.start();
	            }

	            this._updateContainerStyle();
	        },

	        /**
	         * Starts the plugin:
	         * - activates the engine
	         * - draws the marker (if coordinates available)
	         */
	        start: function() {
	            this._activate();

	            if (this._event) {
	                this._drawMarker(this._map);

	                // if we already have a location but the user clicked on the control
	                if (this.options.setView) {
	                    this.setView();
	                }
	            }
	            this._updateContainerStyle();
	        },

	        /**
	         * Stops the plugin:
	         * - deactivates the engine
	         * - reinitializes the button
	         * - removes the marker
	         */
	        stop: function() {
	            this._deactivate();

	            this._cleanClasses();
	            this._resetVariables();

	            this._removeMarker();
	        },

	        /**
	         * Keep the control active but stop following the location
	         */
	        stopFollowing: function() {
	            this._userPanned = true;
	            this._updateContainerStyle();
	            this._drawMarker();
	        },

	        /**
	         * This method launches the location engine.
	         * It is called before the marker is updated,
	         * event if it does not mean that the event will be ready.
	         *
	         * Override it if you want to add more functionalities.
	         * It should set the this._active to true and do nothing if
	         * this._active is true.
	         */
	        _activate: function() {
	            if (!this._active) {
	                this._map.locate(this.options.locateOptions);
	                this._active = true;

	                // bind event listeners
	                this._map.on('locationfound', this._onLocationFound, this);
	                this._map.on('locationerror', this._onLocationError, this);
	                this._map.on('dragstart', this._onDrag, this);
	                this._map.on('zoomstart', this._onZoom, this);
	                this._map.on('zoomend', this._onZoomEnd, this);
	                if (this.options.showCompass) {
	                    var oriAbs = 'ondeviceorientationabsolute' in window;
	                    if (oriAbs || ('ondeviceorientation' in window)) {
	                        var _this = this;
	                        var deviceorientation = function () {
	                            L.DomEvent.on(window, oriAbs ? 'deviceorientationabsolute' : 'deviceorientation', _this._onDeviceOrientation, _this);
	                        };
	                        if (DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
	                            DeviceOrientationEvent.requestPermission().then(function (permissionState) {
	                                if (permissionState === 'granted') {
	                                    deviceorientation();
	                                }
	                            });
	                        } else {
	                            deviceorientation();
	                        }
	                    }
	                }
	            }
	        },

	        /**
	         * Called to stop the location engine.
	         *
	         * Override it to shutdown any functionalities you added on start.
	         */
	        _deactivate: function() {
	            this._map.stopLocate();
	            this._active = false;

	            if (!this.options.cacheLocation) {
	                this._event = undefined;
	            }

	            // unbind event listeners
	            this._map.off('locationfound', this._onLocationFound, this);
	            this._map.off('locationerror', this._onLocationError, this);
	            this._map.off('dragstart', this._onDrag, this);
	            this._map.off('zoomstart', this._onZoom, this);
	            this._map.off('zoomend', this._onZoomEnd, this);
	            if (this.options.showCompass) {
	                this._compassHeading = null;
	                if ('ondeviceorientationabsolute' in window) {
	                    L.DomEvent.off(window, 'deviceorientationabsolute', this._onDeviceOrientation, this);
	                } else if ('ondeviceorientation' in window) {
	                    L.DomEvent.off(window, 'deviceorientation', this._onDeviceOrientation, this);
	                }
	            }
	        },

	        /**
	         * Zoom (unless we should keep the zoom level) and an to the current view.
	         */
	        setView: function() {
	            this._drawMarker();
	            if (this._isOutsideMapBounds()) {
	                this._event = undefined;  // clear the current location so we can get back into the bounds
	                this.options.onLocationOutsideMapBounds(this);
	            } else {
	                if (this.options.keepCurrentZoomLevel) {
	                    var f = this.options.flyTo ? this._map.flyTo : this._map.panTo;
	                    f.bind(this._map)([this._event.latitude, this._event.longitude]);
	                } else {
	                    var f = this.options.flyTo ? this._map.flyToBounds : this._map.fitBounds;
	                    // Ignore zoom events while setting the viewport as these would stop following
	                    this._ignoreEvent = true;
	                    f.bind(this._map)(this.options.getLocationBounds(this._event), {
	                        padding: this.options.circlePadding,
	                        maxZoom: this.options.locateOptions.maxZoom
	                    });
	                    L.Util.requestAnimFrame(function(){
	                        // Wait until after the next animFrame because the flyTo can be async
	                        this._ignoreEvent = false;
	                    }, this);

	                }
	            }
	        },

	        /**
	         *
	         */
	        _drawCompass: function() {
	            if (!this._event) {
	                return;
	            }

	            var latlng = this._event.latlng;

	            if (this.options.showCompass && latlng && this._compassHeading !== null) {
	                var cStyle = this._isFollowing() ? this.options.followCompassStyle : this.options.compassStyle;
	                if (!this._compass) {
	                    this._compass = new this.options.compassClass(latlng, this._compassHeading, cStyle).addTo(this._layer);
	                } else {
	                    this._compass.setLatLng(latlng);
	                    this._compass.setHeading(this._compassHeading);
	                    // If the compassClass can be updated with setStyle, update it.
	                    if (this._compass.setStyle) {
	                        this._compass.setStyle(cStyle);
	                    }
	                }
	                // 
	            }
	            if (this._compass && (!this.options.showCompass || this._compassHeading === null)) {
	                this._compass.removeFrom(this._layer);
	                this._compass = null;
	            }
	        },

	        /**
	         * Draw the marker and accuracy circle on the map.
	         *
	         * Uses the event retrieved from onLocationFound from the map.
	         */
	        _drawMarker: function() {
	            if (this._event.accuracy === undefined) {
	                this._event.accuracy = 0;
	            }

	            var radius = this._event.accuracy;
	            var latlng = this._event.latlng;

	            // circle with the radius of the location's accuracy
	            if (this.options.drawCircle) {
	                var style = this._isFollowing() ? this.options.followCircleStyle : this.options.circleStyle;

	                if (!this._circle) {
	                    this._circle = L.circle(latlng, radius, style).addTo(this._layer);
	                } else {
	                    this._circle.setLatLng(latlng).setRadius(radius).setStyle(style);
	                }
	            }

	            var distance, unit;
	            if (this.options.metric) {
	                distance = radius.toFixed(0);
	                unit =  this.options.strings.metersUnit;
	            } else {
	                distance = (radius * 3.2808399).toFixed(0);
	                unit = this.options.strings.feetUnit;
	            }

	            // small inner marker
	            if (this.options.drawMarker) {
	                var mStyle = this._isFollowing() ? this.options.followMarkerStyle : this.options.markerStyle;
	                if (!this._marker) {
	                    this._marker = new this.options.markerClass(latlng, mStyle).addTo(this._layer);
	                } else {
	                    this._marker.setLatLng(latlng);
	                    // If the markerClass can be updated with setStyle, update it.
	                    if (this._marker.setStyle) {
	                        this._marker.setStyle(mStyle);
	                    }
	                }
	            }

	            this._drawCompass();

	            var t = this.options.strings.popup;
	            if (this.options.showPopup && t && this._marker) {
	                this._marker
	                    .bindPopup(L.Util.template(t, {distance: distance, unit: unit}))
	                    ._popup.setLatLng(latlng);
	            }
	            if (this.options.showPopup && t && this._compass) {
	                this._compass
	                    .bindPopup(L.Util.template(t, {distance: distance, unit: unit}))
	                    ._popup.setLatLng(latlng);
	            }
	        },

	        /**
	         * Remove the marker from map.
	         */
	        _removeMarker: function() {
	            this._layer.clearLayers();
	            this._marker = undefined;
	            this._circle = undefined;
	        },

	        /**
	         * Unload the plugin and all event listeners.
	         * Kind of the opposite of onAdd.
	         */
	        _unload: function() {
	            this.stop();
	            this._map.off('unload', this._unload, this);
	        },

	        /**
	         * Sets the compass heading
	         */
	        _setCompassHeading: function(angle) {
	            if (!isNaN(parseFloat(angle)) && isFinite(angle)) {
	                angle = Math.round(angle);

	                this._compassHeading = angle;
	                L.Util.requestAnimFrame(this._drawCompass, this);
	            } else {
	                this._compassHeading = null;
	            }
	        },

	        /**
	         * If the compass fails calibration just fail safely and remove the compass
	         */
	        _onCompassNeedsCalibration: function() {
	            this._setCompassHeading();
	        },

	        /**
	         * Process and normalise compass events
	         */
	        _onDeviceOrientation: function(e) {
	            if (!this._active) {
	                return;
	            }

	            if (e.webkitCompassHeading) {
	                // iOS
	                this._setCompassHeading(e.webkitCompassHeading);
	            } else if (e.absolute && e.alpha) {
	                // Android
	                this._setCompassHeading(360 - e.alpha);
	            }
	        },

	        /**
	         * Calls deactivate and dispatches an error.
	         */
	        _onLocationError: function(err) {
	            // ignore time out error if the location is watched
	            if (err.code == 3 && this.options.locateOptions.watch) {
	                return;
	            }

	            this.stop();
	            this.options.onLocationError(err, this);
	        },

	        /**
	         * Stores the received event and updates the marker.
	         */
	        _onLocationFound: function(e) {
	            // no need to do anything if the location has not changed
	            if (this._event &&
	                (this._event.latlng.lat === e.latlng.lat &&
	                 this._event.latlng.lng === e.latlng.lng &&
	                     this._event.accuracy === e.accuracy)) {
	                return;
	            }

	            if (!this._active) {
	                // we may have a stray event
	                return;
	            }

	            this._event = e;

	            this._drawMarker();
	            this._updateContainerStyle();

	            switch (this.options.setView) {
	                case 'once':
	                    if (this._justClicked) {
	                        this.setView();
	                    }
	                    break;
	                case 'untilPan':
	                    if (!this._userPanned) {
	                        this.setView();
	                    }
	                    break;
	                case 'untilPanOrZoom':
	                    if (!this._userPanned && !this._userZoomed) {
	                        this.setView();
	                    }
	                    break;
	                case 'always':
	                    this.setView();
	                    break;
	            }

	            this._justClicked = false;
	        },

	        /**
	         * When the user drags. Need a separate event so we can bind and unbind event listeners.
	         */
	        _onDrag: function() {
	            // only react to drags once we have a location
	            if (this._event && !this._ignoreEvent) {
	                this._userPanned = true;
	                this._updateContainerStyle();
	                this._drawMarker();
	            }
	        },

	        /**
	         * When the user zooms. Need a separate event so we can bind and unbind event listeners.
	         */
	        _onZoom: function() {
	            // only react to drags once we have a location
	            if (this._event && !this._ignoreEvent) {
	                this._userZoomed = true;
	                this._updateContainerStyle();
	                this._drawMarker();
	            }
	        },

	        /**
	         * After a zoom ends update the compass and handle sideways zooms
	         */
	        _onZoomEnd: function() {
	            if (this._event) {
	                this._drawCompass();
	            }

	            if (this._event && !this._ignoreEvent) {
	                // If we have zoomed in and out and ended up sideways treat it as a pan
	                if (this._marker && !this._map.getBounds().pad(-.3).contains(this._marker.getLatLng())) {
	                    this._userPanned = true;
	                    this._updateContainerStyle();
	                    this._drawMarker();
	                }
	            }
	        },

	        /**
	         * Compute whether the map is following the user location with pan and zoom.
	         */
	        _isFollowing: function() {
	            if (!this._active) {
	                return false;
	            }

	            if (this.options.setView === 'always') {
	                return true;
	            } else if (this.options.setView === 'untilPan') {
	                return !this._userPanned;
	            } else if (this.options.setView === 'untilPanOrZoom') {
	                return !this._userPanned && !this._userZoomed;
	            }
	        },

	        /**
	         * Check if location is in map bounds
	         */
	        _isOutsideMapBounds: function() {
	            if (this._event === undefined) {
	                return false;
	            }
	            return this._map.options.maxBounds &&
	                !this._map.options.maxBounds.contains(this._event.latlng);
	        },

	        /**
	         * Toggles button class between following and active.
	         */
	        _updateContainerStyle: function() {
	            if (!this._container) {
	                return;
	            }

	            if (this._active && !this._event) {
	                // active but don't have a location yet
	                this._setClasses('requesting');
	            } else if (this._isFollowing()) {
	                this._setClasses('following');
	            } else if (this._active) {
	                this._setClasses('active');
	            } else {
	                this._cleanClasses();
	            }
	        },

	        /**
	         * Sets the CSS classes for the state.
	         */
	        _setClasses: function(state) {
	            if (state == 'requesting') {
	                removeClasses(this._container, "active following");
	                addClasses(this._container, "requesting");

	                removeClasses(this._icon, this.options.icon);
	                addClasses(this._icon, this.options.iconLoading);
	            } else if (state == 'active') {
	                removeClasses(this._container, "requesting following");
	                addClasses(this._container, "active");

	                removeClasses(this._icon, this.options.iconLoading);
	                addClasses(this._icon, this.options.icon);
	            } else if (state == 'following') {
	                removeClasses(this._container, "requesting");
	                addClasses(this._container, "active following");

	                removeClasses(this._icon, this.options.iconLoading);
	                addClasses(this._icon, this.options.icon);
	            }
	        },

	        /**
	         * Removes all classes from button.
	         */
	        _cleanClasses: function() {
	            L.DomUtil.removeClass(this._container, "requesting");
	            L.DomUtil.removeClass(this._container, "active");
	            L.DomUtil.removeClass(this._container, "following");

	            removeClasses(this._icon, this.options.iconLoading);
	            addClasses(this._icon, this.options.icon);
	        },

	        /**
	         * Reinitializes state variables.
	         */
	        _resetVariables: function() {
	            // whether locate is active or not
	            this._active = false;

	            // true if the control was clicked for the first time
	            // we need this so we can pan and zoom once we have the location
	            this._justClicked = false;

	            // true if the user has panned the map after clicking the control
	            this._userPanned = false;

	            // true if the user has zoomed the map after clicking the control
	            this._userZoomed = false;
	        }
	    });

	    L.control.locate = function (options) {
	        return new L.Control.Locate(options);
	    };

	    return LocateControl;
	}, window));
	});

	var props$10 = {
	  position: {
	    type: String,
	    "default": function _default() {
	      return 'bottomright';
	    }
	  },
	  options: {
	    type: Object,
	    "default": function _default() {
	      return {};
	    }
	  },
	  visible: {
	    type: Boolean,
	    custom: true,
	    "default": true
	  }
	};
	var script$i = {
	  name: 'l-control-locate',
	  props: props$10,
	  data: function data() {
	    return {
	      ready: false
	    };
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.parentContainer.removeLayer(this);
	  },
	  mounted: function mounted() {
	    this.mapObject = L$1__default.control.locate(this.getOptions());
	    L$1.DomEvent.on(this.mapObject, this.$listeners);
	    propsBinder(this, this.mapObject, props$10);
	    this.ready = true;
	    this.parentContainer = findRealParent(this.$parent);
	    this.mapObject.addTo(this.parentContainer.mapObject, !this.visible);
	  },
	  methods: {
	    getOptions: function getOptions() {
	      return _objectSpread2$1({
	        position: this.position
	      }, this.options);
	    }
	  }
	};

	/* script */
	var __vue_script__$i = script$i;
	/* template */
	var __vue_render__$f = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    { staticStyle: { display: "none" } },
	    [_vm.ready ? _vm._t("default") : _vm._e()],
	    2
	  )
	};
	var __vue_staticRenderFns__$f = [];
	__vue_render__$f._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$i = undefined;
	  /* scoped */
	  var __vue_scope_id__$i = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$i = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$i = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$i = normalizeComponent$1(
	    { render: __vue_render__$f, staticRenderFns: __vue_staticRenderFns__$f },
	    __vue_inject_styles__$i,
	    __vue_script__$i,
	    __vue_scope_id__$i,
	    __vue_is_functional_template__$i,
	    __vue_module_identifier__$i,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	/*
	 Leaflet.draw 1.0.4, a plugin that adds drawing and editing tools to Leaflet powered maps.
	 (c) 2012-2017, Jacob Toye, Jon West, Smartrak, Leaflet

	 https://github.com/Leaflet/Leaflet.draw
	 http://leafletjs.com
	 */
	!function(t,e,i){function o(t,e){for(;(t=t.parentElement)&&!t.classList.contains(e);){ }return t}L.drawVersion="1.0.4",L.Draw={},L.drawLocal={draw:{toolbar:{actions:{title:"Cancel drawing",text:"Cancel"},finish:{title:"Finish drawing",text:"Finish"},undo:{title:"Delete last point drawn",text:"Delete last point"},buttons:{polyline:"Draw a polyline",polygon:"Draw a polygon",rectangle:"Draw a rectangle",circle:"Draw a circle",marker:"Draw a marker",circlemarker:"Draw a circlemarker"}},handlers:{circle:{tooltip:{start:"Click and drag to draw circle."},radius:"Radius"},circlemarker:{tooltip:{start:"Click map to place circle marker."}},marker:{tooltip:{start:"Click map to place marker."}},polygon:{tooltip:{start:"Click to start drawing shape.",cont:"Click to continue drawing shape.",end:"Click first point to close this shape."}},polyline:{error:"<strong>Error:</strong> shape edges cannot cross!",tooltip:{start:"Click to start drawing line.",cont:"Click to continue drawing line.",end:"Click last point to finish line."}},rectangle:{tooltip:{start:"Click and drag to draw rectangle."}},simpleshape:{tooltip:{end:"Release mouse to finish drawing."}}}},edit:{toolbar:{actions:{save:{title:"Save changes",text:"Save"},cancel:{title:"Cancel editing, discards all changes",text:"Cancel"},clearAll:{title:"Clear all layers",text:"Clear All"}},buttons:{edit:"Edit layers",editDisabled:"No layers to edit",remove:"Delete layers",removeDisabled:"No layers to delete"}},handlers:{edit:{tooltip:{text:"Drag handles or markers to edit features.",subtext:"Click cancel to undo changes."}},remove:{tooltip:{text:"Click on a feature to remove."}}}}},L.Draw.Event={},L.Draw.Event.CREATED="draw:created",L.Draw.Event.EDITED="draw:edited",L.Draw.Event.DELETED="draw:deleted",L.Draw.Event.DRAWSTART="draw:drawstart",L.Draw.Event.DRAWSTOP="draw:drawstop",L.Draw.Event.DRAWVERTEX="draw:drawvertex",L.Draw.Event.EDITSTART="draw:editstart",L.Draw.Event.EDITMOVE="draw:editmove",L.Draw.Event.EDITRESIZE="draw:editresize",L.Draw.Event.EDITVERTEX="draw:editvertex",L.Draw.Event.EDITSTOP="draw:editstop",L.Draw.Event.DELETESTART="draw:deletestart",L.Draw.Event.DELETESTOP="draw:deletestop",L.Draw.Event.TOOLBAROPENED="draw:toolbaropened",L.Draw.Event.TOOLBARCLOSED="draw:toolbarclosed",L.Draw.Event.MARKERCONTEXT="draw:markercontext",L.Draw=L.Draw||{},L.Draw.Feature=L.Handler.extend({initialize:function(t,e){this._map=t,this._container=t._container,this._overlayPane=t._panes.overlayPane,this._popupPane=t._panes.popupPane,e&&e.shapeOptions&&(e.shapeOptions=L.Util.extend({},this.options.shapeOptions,e.shapeOptions)),L.setOptions(this,e);var i=L.version.split(".");1===parseInt(i[0],10)&&parseInt(i[1],10)>=2?L.Draw.Feature.include(L.Evented.prototype):L.Draw.Feature.include(L.Mixin.Events);},enable:function(){this._enabled||(L.Handler.prototype.enable.call(this),this.fire("enabled",{handler:this.type}),this._map.fire(L.Draw.Event.DRAWSTART,{layerType:this.type}));},disable:function(){this._enabled&&(L.Handler.prototype.disable.call(this),this._map.fire(L.Draw.Event.DRAWSTOP,{layerType:this.type}),this.fire("disabled",{handler:this.type}));},addHooks:function(){var t=this._map;t&&(L.DomUtil.disableTextSelection(),t.getContainer().focus(),this._tooltip=new L.Draw.Tooltip(this._map),L.DomEvent.on(this._container,"keyup",this._cancelDrawing,this));},removeHooks:function(){this._map&&(L.DomUtil.enableTextSelection(),this._tooltip.dispose(),this._tooltip=null,L.DomEvent.off(this._container,"keyup",this._cancelDrawing,this));},setOptions:function(t){L.setOptions(this,t);},_fireCreatedEvent:function(t){this._map.fire(L.Draw.Event.CREATED,{layer:t,layerType:this.type});},_cancelDrawing:function(t){27===t.keyCode&&(this._map.fire("draw:canceled",{layerType:this.type}),this.disable());}}),L.Draw.Polyline=L.Draw.Feature.extend({statics:{TYPE:"polyline"},Poly:L.Polyline,options:{allowIntersection:!0,repeatMode:!1,drawError:{color:"#b00b00",timeout:2500},icon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon"}),touchIcon:new L.DivIcon({iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon"}),guidelineDistance:20,maxGuideLineLength:4e3,shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!1,clickable:!0},metric:!0,feet:!0,nautic:!1,showLength:!0,zIndexOffset:2e3,factor:1,maxPoints:0},initialize:function(t,e){L.Browser.touch&&(this.options.icon=this.options.touchIcon),this.options.drawError.message=L.drawLocal.draw.handlers.polyline.error,e&&e.drawError&&(e.drawError=L.Util.extend({},this.options.drawError,e.drawError)),this.type=L.Draw.Polyline.TYPE,L.Draw.Feature.prototype.initialize.call(this,t,e);},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._markers=[],this._markerGroup=new L.LayerGroup,this._map.addLayer(this._markerGroup),this._poly=new L.Polyline([],this.options.shapeOptions),this._tooltip.updateContent(this._getTooltipText()),this._mouseMarker||(this._mouseMarker=L.marker(this._map.getCenter(),{icon:L.divIcon({className:"leaflet-mouse-marker",iconAnchor:[20,20],iconSize:[40,40]}),opacity:0,zIndexOffset:this.options.zIndexOffset})),this._mouseMarker.on("mouseout",this._onMouseOut,this).on("mousemove",this._onMouseMove,this).on("mousedown",this._onMouseDown,this).on("mouseup",this._onMouseUp,this).addTo(this._map),this._map.on("mouseup",this._onMouseUp,this).on("mousemove",this._onMouseMove,this).on("zoomlevelschange",this._onZoomEnd,this).on("touchstart",this._onTouch,this).on("zoomend",this._onZoomEnd,this));},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._clearHideErrorTimeout(),this._cleanUpShape(),this._map.removeLayer(this._markerGroup),delete this._markerGroup,delete this._markers,this._map.removeLayer(this._poly),delete this._poly,this._mouseMarker.off("mousedown",this._onMouseDown,this).off("mouseout",this._onMouseOut,this).off("mouseup",this._onMouseUp,this).off("mousemove",this._onMouseMove,this),this._map.removeLayer(this._mouseMarker),delete this._mouseMarker,this._clearGuides(),this._map.off("mouseup",this._onMouseUp,this).off("mousemove",this._onMouseMove,this).off("zoomlevelschange",this._onZoomEnd,this).off("zoomend",this._onZoomEnd,this).off("touchstart",this._onTouch,this).off("click",this._onTouch,this);},deleteLastVertex:function(){if(!(this._markers.length<=1)){var t=this._markers.pop(),e=this._poly,i=e.getLatLngs(),o=i.splice(-1,1)[0];this._poly.setLatLngs(i),this._markerGroup.removeLayer(t),e.getLatLngs().length<2&&this._map.removeLayer(e),this._vertexChanged(o,!1);}},addVertex:function(t){if(this._markers.length>=2&&!this.options.allowIntersection&&this._poly.newLatLngIntersects(t)){ return void this._showErrorTooltip(); }this._errorShown&&this._hideErrorTooltip(),this._markers.push(this._createMarker(t)),this._poly.addLatLng(t),2===this._poly.getLatLngs().length&&this._map.addLayer(this._poly),this._vertexChanged(t,!0);},completeShape:function(){this._markers.length<=1||!this._shapeIsValid()||(this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable());},_finishShape:function(){var t=this._poly._defaultShape?this._poly._defaultShape():this._poly.getLatLngs(),e=this._poly.newLatLngIntersects(t[t.length-1]);if(!this.options.allowIntersection&&e||!this._shapeIsValid()){ return void this._showErrorTooltip(); }this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable();},_shapeIsValid:function(){return !0},_onZoomEnd:function(){null!==this._markers&&this._updateGuide();},_onMouseMove:function(t){var e=this._map.mouseEventToLayerPoint(t.originalEvent),i=this._map.layerPointToLatLng(e);this._currentLatLng=i,this._updateTooltip(i),this._updateGuide(e),this._mouseMarker.setLatLng(i),L.DomEvent.preventDefault(t.originalEvent);},_vertexChanged:function(t,e){this._map.fire(L.Draw.Event.DRAWVERTEX,{layers:this._markerGroup}),this._updateFinishHandler(),this._updateRunningMeasure(t,e),this._clearGuides(),this._updateTooltip();},_onMouseDown:function(t){if(!this._clickHandled&&!this._touchHandled&&!this._disableMarkers){this._onMouseMove(t),this._clickHandled=!0,this._disableNewMarkers();var e=t.originalEvent,i=e.clientX,o=e.clientY;this._startPoint.call(this,i,o);}},_startPoint:function(t,e){this._mouseDownOrigin=L.point(t,e);},_onMouseUp:function(t){var e=t.originalEvent,i=e.clientX,o=e.clientY;this._endPoint.call(this,i,o,t),this._clickHandled=null;},_endPoint:function(e,i,o){if(this._mouseDownOrigin){var a=L.point(e,i).distanceTo(this._mouseDownOrigin),n=this._calculateFinishDistance(o.latlng);this.options.maxPoints>1&&this.options.maxPoints==this._markers.length+1?(this.addVertex(o.latlng),this._finishShape()):n<10&&L.Browser.touch?this._finishShape():Math.abs(a)<9*(t.devicePixelRatio||1)&&this.addVertex(o.latlng),this._enableNewMarkers();}this._mouseDownOrigin=null;},_onTouch:function(t){var e,i,o=t.originalEvent;!o.touches||!o.touches[0]||this._clickHandled||this._touchHandled||this._disableMarkers||(e=o.touches[0].clientX,i=o.touches[0].clientY,this._disableNewMarkers(),this._touchHandled=!0,this._startPoint.call(this,e,i),this._endPoint.call(this,e,i,t),this._touchHandled=null),this._clickHandled=null;},_onMouseOut:function(){this._tooltip&&this._tooltip._onMouseOut.call(this._tooltip);},_calculateFinishDistance:function(t){var e;if(this._markers.length>0){var i;if(this.type===L.Draw.Polyline.TYPE){ i=this._markers[this._markers.length-1]; }else{if(this.type!==L.Draw.Polygon.TYPE){ return 1/0; }i=this._markers[0];}var o=this._map.latLngToContainerPoint(i.getLatLng()),a=new L.Marker(t,{icon:this.options.icon,zIndexOffset:2*this.options.zIndexOffset}),n=this._map.latLngToContainerPoint(a.getLatLng());e=o.distanceTo(n);}else { e=1/0; }return e},_updateFinishHandler:function(){var t=this._markers.length;t>1&&this._markers[t-1].on("click",this._finishShape,this),t>2&&this._markers[t-2].off("click",this._finishShape,this);},_createMarker:function(t){var e=new L.Marker(t,{icon:this.options.icon,zIndexOffset:2*this.options.zIndexOffset});return this._markerGroup.addLayer(e),e},_updateGuide:function(t){var e=this._markers?this._markers.length:0;e>0&&(t=t||this._map.latLngToLayerPoint(this._currentLatLng),this._clearGuides(),this._drawGuide(this._map.latLngToLayerPoint(this._markers[e-1].getLatLng()),t));},_updateTooltip:function(t){var e=this._getTooltipText();t&&this._tooltip.updatePosition(t),this._errorShown||this._tooltip.updateContent(e);},_drawGuide:function(t,e){var i,o,a,n=Math.floor(Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))),s=this.options.guidelineDistance,r=this.options.maxGuideLineLength,l=n>r?n-r:s;for(this._guidesContainer||(this._guidesContainer=L.DomUtil.create("div","leaflet-draw-guides",this._overlayPane));l<n;l+=this.options.guidelineDistance){ i=l/n,o={x:Math.floor(t.x*(1-i)+i*e.x),y:Math.floor(t.y*(1-i)+i*e.y)},a=L.DomUtil.create("div","leaflet-draw-guide-dash",this._guidesContainer),a.style.backgroundColor=this._errorShown?this.options.drawError.color:this.options.shapeOptions.color,L.DomUtil.setPosition(a,o); }},_updateGuideColor:function(t){if(this._guidesContainer){ for(var e=0,i=this._guidesContainer.childNodes.length;e<i;e++){ this._guidesContainer.childNodes[e].style.backgroundColor=t; } }},_clearGuides:function(){if(this._guidesContainer){ for(;this._guidesContainer.firstChild;){ this._guidesContainer.removeChild(this._guidesContainer.firstChild); } }},_getTooltipText:function(){var t,e,i=this.options.showLength;return 0===this._markers.length?t={text:L.drawLocal.draw.handlers.polyline.tooltip.start}:(e=i?this._getMeasurementString():"",t=1===this._markers.length?{text:L.drawLocal.draw.handlers.polyline.tooltip.cont,subtext:e}:{text:L.drawLocal.draw.handlers.polyline.tooltip.end,subtext:e}),t},_updateRunningMeasure:function(t,e){var i,o,a=this._markers.length;1===this._markers.length?this._measurementRunningTotal=0:(i=a-(e?2:1),o=L.GeometryUtil.isVersion07x()?t.distanceTo(this._markers[i].getLatLng())*(this.options.factor||1):this._map.distance(t,this._markers[i].getLatLng())*(this.options.factor||1),this._measurementRunningTotal+=o*(e?1:-1));},_getMeasurementString:function(){var t,e=this._currentLatLng,i=this._markers[this._markers.length-1].getLatLng();return t=L.GeometryUtil.isVersion07x()?i&&e&&e.distanceTo?this._measurementRunningTotal+e.distanceTo(i)*(this.options.factor||1):this._measurementRunningTotal||0:i&&e?this._measurementRunningTotal+this._map.distance(e,i)*(this.options.factor||1):this._measurementRunningTotal||0,L.GeometryUtil.readableDistance(t,this.options.metric,this.options.feet,this.options.nautic,this.options.precision)},_showErrorTooltip:function(){this._errorShown=!0,this._tooltip.showAsError().updateContent({text:this.options.drawError.message}),this._updateGuideColor(this.options.drawError.color),this._poly.setStyle({color:this.options.drawError.color}),this._clearHideErrorTimeout(),this._hideErrorTimeout=setTimeout(L.Util.bind(this._hideErrorTooltip,this),this.options.drawError.timeout);},_hideErrorTooltip:function(){this._errorShown=!1,this._clearHideErrorTimeout(),this._tooltip.removeError().updateContent(this._getTooltipText()),this._updateGuideColor(this.options.shapeOptions.color),this._poly.setStyle({color:this.options.shapeOptions.color});},_clearHideErrorTimeout:function(){this._hideErrorTimeout&&(clearTimeout(this._hideErrorTimeout),this._hideErrorTimeout=null);},_disableNewMarkers:function(){this._disableMarkers=!0;},_enableNewMarkers:function(){setTimeout(function(){this._disableMarkers=!1;}.bind(this),50);},_cleanUpShape:function(){this._markers.length>1&&this._markers[this._markers.length-1].off("click",this._finishShape,this);},_fireCreatedEvent:function(){var t=new this.Poly(this._poly.getLatLngs(),this.options.shapeOptions);L.Draw.Feature.prototype._fireCreatedEvent.call(this,t);}}),L.Draw.Polygon=L.Draw.Polyline.extend({statics:{TYPE:"polygon"},Poly:L.Polygon,options:{showArea:!1,showLength:!1,shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0},metric:!0,feet:!0,nautic:!1,precision:{}},initialize:function(t,e){L.Draw.Polyline.prototype.initialize.call(this,t,e),this.type=L.Draw.Polygon.TYPE;},_updateFinishHandler:function(){var t=this._markers.length;1===t&&this._markers[0].on("click",this._finishShape,this),t>2&&(this._markers[t-1].on("dblclick",this._finishShape,this),t>3&&this._markers[t-2].off("dblclick",this._finishShape,this));},_getTooltipText:function(){var t,e;return 0===this._markers.length?t=L.drawLocal.draw.handlers.polygon.tooltip.start:this._markers.length<3?(t=L.drawLocal.draw.handlers.polygon.tooltip.cont,e=this._getMeasurementString()):(t=L.drawLocal.draw.handlers.polygon.tooltip.end,e=this._getMeasurementString()),{text:t,subtext:e}},_getMeasurementString:function(){var t=this._area,e="";return t||this.options.showLength?(this.options.showLength&&(e=L.Draw.Polyline.prototype._getMeasurementString.call(this)),t&&(e+="<br>"+L.GeometryUtil.readableArea(t,this.options.metric,this.options.precision)),e):null},_shapeIsValid:function(){return this._markers.length>=3},_vertexChanged:function(t,e){var i;!this.options.allowIntersection&&this.options.showArea&&(i=this._poly.getLatLngs(),this._area=L.GeometryUtil.geodesicArea(i)),L.Draw.Polyline.prototype._vertexChanged.call(this,t,e);},_cleanUpShape:function(){var t=this._markers.length;t>0&&(this._markers[0].off("click",this._finishShape,this),t>2&&this._markers[t-1].off("dblclick",this._finishShape,this));}}),L.SimpleShape={},L.Draw.SimpleShape=L.Draw.Feature.extend({options:{repeatMode:!1},initialize:function(t,e){this._endLabelText=L.drawLocal.draw.handlers.simpleshape.tooltip.end,L.Draw.Feature.prototype.initialize.call(this,t,e);},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._mapDraggable=this._map.dragging.enabled(),this._mapDraggable&&this._map.dragging.disable(),this._container.style.cursor="crosshair",this._tooltip.updateContent({text:this._initialLabelText}),this._map.on("mousedown",this._onMouseDown,this).on("mousemove",this._onMouseMove,this).on("touchstart",this._onMouseDown,this).on("touchmove",this._onMouseMove,this),e.addEventListener("touchstart",L.DomEvent.preventDefault,{passive:!1}));},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._map&&(this._mapDraggable&&this._map.dragging.enable(),this._container.style.cursor="",this._map.off("mousedown",this._onMouseDown,this).off("mousemove",this._onMouseMove,this).off("touchstart",this._onMouseDown,this).off("touchmove",this._onMouseMove,this),L.DomEvent.off(e,"mouseup",this._onMouseUp,this),L.DomEvent.off(e,"touchend",this._onMouseUp,this),e.removeEventListener("touchstart",L.DomEvent.preventDefault),this._shape&&(this._map.removeLayer(this._shape),delete this._shape)),this._isDrawing=!1;},_getTooltipText:function(){return {text:this._endLabelText}},_onMouseDown:function(t){this._isDrawing=!0,this._startLatLng=t.latlng,L.DomEvent.on(e,"mouseup",this._onMouseUp,this).on(e,"touchend",this._onMouseUp,this).preventDefault(t.originalEvent);},_onMouseMove:function(t){var e=t.latlng;this._tooltip.updatePosition(e),this._isDrawing&&(this._tooltip.updateContent(this._getTooltipText()),this._drawShape(e));},_onMouseUp:function(){this._shape&&this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable();}}),L.Draw.Rectangle=L.Draw.SimpleShape.extend({statics:{TYPE:"rectangle"},options:{shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0},showArea:!0,metric:!0},initialize:function(t,e){this.type=L.Draw.Rectangle.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.rectangle.tooltip.start,L.Draw.SimpleShape.prototype.initialize.call(this,t,e);},disable:function(){this._enabled&&(this._isCurrentlyTwoClickDrawing=!1,L.Draw.SimpleShape.prototype.disable.call(this));},_onMouseUp:function(t){if(!this._shape&&!this._isCurrentlyTwoClickDrawing){ return void(this._isCurrentlyTwoClickDrawing=!0); }this._isCurrentlyTwoClickDrawing&&!o(t.target,"leaflet-pane")||L.Draw.SimpleShape.prototype._onMouseUp.call(this);},_drawShape:function(t){this._shape?this._shape.setBounds(new L.LatLngBounds(this._startLatLng,t)):(this._shape=new L.Rectangle(new L.LatLngBounds(this._startLatLng,t),this.options.shapeOptions),this._map.addLayer(this._shape));},_fireCreatedEvent:function(){var t=new L.Rectangle(this._shape.getBounds(),this.options.shapeOptions);L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this,t);},_getTooltipText:function(){var t,e,i,o=L.Draw.SimpleShape.prototype._getTooltipText.call(this),a=this._shape,n=this.options.showArea;return a&&(t=this._shape._defaultShape?this._shape._defaultShape():this._shape.getLatLngs(),e=L.GeometryUtil.geodesicArea(t),i=n?L.GeometryUtil.readableArea(e,this.options.metric):""),{text:o.text,subtext:i}}}),L.Draw.Marker=L.Draw.Feature.extend({statics:{TYPE:"marker"},options:{icon:new L.Icon.Default,repeatMode:!1,zIndexOffset:2e3},initialize:function(t,e){this.type=L.Draw.Marker.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.marker.tooltip.start,L.Draw.Feature.prototype.initialize.call(this,t,e);},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._tooltip.updateContent({text:this._initialLabelText}),this._mouseMarker||(this._mouseMarker=L.marker(this._map.getCenter(),{icon:L.divIcon({className:"leaflet-mouse-marker",iconAnchor:[20,20],iconSize:[40,40]}),opacity:0,zIndexOffset:this.options.zIndexOffset})),this._mouseMarker.on("click",this._onClick,this).addTo(this._map),this._map.on("mousemove",this._onMouseMove,this),this._map.on("click",this._onTouch,this));},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._map&&(this._map.off("click",this._onClick,this).off("click",this._onTouch,this),this._marker&&(this._marker.off("click",this._onClick,this),this._map.removeLayer(this._marker),delete this._marker),this._mouseMarker.off("click",this._onClick,this),this._map.removeLayer(this._mouseMarker),delete this._mouseMarker,this._map.off("mousemove",this._onMouseMove,this));},_onMouseMove:function(t){var e=t.latlng;this._tooltip.updatePosition(e),this._mouseMarker.setLatLng(e),this._marker?(e=this._mouseMarker.getLatLng(),this._marker.setLatLng(e)):(this._marker=this._createMarker(e),this._marker.on("click",this._onClick,this),this._map.on("click",this._onClick,this).addLayer(this._marker));},_createMarker:function(t){return new L.Marker(t,{icon:this.options.icon,zIndexOffset:this.options.zIndexOffset})},_onClick:function(){this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable();},_onTouch:function(t){this._onMouseMove(t),this._onClick();},_fireCreatedEvent:function(){var t=new L.Marker.Touch(this._marker.getLatLng(),{icon:this.options.icon});L.Draw.Feature.prototype._fireCreatedEvent.call(this,t);}}),L.Draw.CircleMarker=L.Draw.Marker.extend({statics:{TYPE:"circlemarker"},options:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0,zIndexOffset:2e3},initialize:function(t,e){this.type=L.Draw.CircleMarker.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.circlemarker.tooltip.start,L.Draw.Feature.prototype.initialize.call(this,t,e);},_fireCreatedEvent:function(){var t=new L.CircleMarker(this._marker.getLatLng(),this.options);L.Draw.Feature.prototype._fireCreatedEvent.call(this,t);},_createMarker:function(t){return new L.CircleMarker(t,this.options)}}),L.Draw.Circle=L.Draw.SimpleShape.extend({statics:{TYPE:"circle"},options:{shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0},showRadius:!0,metric:!0,feet:!0,nautic:!1},initialize:function(t,e){this.type=L.Draw.Circle.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.circle.tooltip.start,L.Draw.SimpleShape.prototype.initialize.call(this,t,e);},_drawShape:function(t){if(L.GeometryUtil.isVersion07x()){ var e=this._startLatLng.distanceTo(t); }else { var e=this._map.distance(this._startLatLng,t); }this._shape?this._shape.setRadius(e):(this._shape=new L.Circle(this._startLatLng,e,this.options.shapeOptions),this._map.addLayer(this._shape));},_fireCreatedEvent:function(){var t=new L.Circle(this._startLatLng,this._shape.getRadius(),this.options.shapeOptions);L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this,t);},_onMouseMove:function(t){var e,i=t.latlng,o=this.options.showRadius,a=this.options.metric;if(this._tooltip.updatePosition(i),this._isDrawing){this._drawShape(i),e=this._shape.getRadius().toFixed(1);var n="";o&&(n=L.drawLocal.draw.handlers.circle.radius+": "+L.GeometryUtil.readableDistance(e,a,this.options.feet,this.options.nautic)),this._tooltip.updateContent({text:this._endLabelText,subtext:n});}}}),L.Edit=L.Edit||{},L.Edit.Marker=L.Handler.extend({initialize:function(t,e){this._marker=t,L.setOptions(this,e);},addHooks:function(){var t=this._marker;t.dragging.enable(),t.on("dragend",this._onDragEnd,t),this._toggleMarkerHighlight();},removeHooks:function(){var t=this._marker;t.dragging.disable(),t.off("dragend",this._onDragEnd,t),this._toggleMarkerHighlight();},_onDragEnd:function(t){var e=t.target;e.edited=!0,this._map.fire(L.Draw.Event.EDITMOVE,{layer:e});},_toggleMarkerHighlight:function(){var t=this._marker._icon;t&&(t.style.display="none",L.DomUtil.hasClass(t,"leaflet-edit-marker-selected")?(L.DomUtil.removeClass(t,"leaflet-edit-marker-selected"),this._offsetMarker(t,-4)):(L.DomUtil.addClass(t,"leaflet-edit-marker-selected"),this._offsetMarker(t,4)),t.style.display="");},_offsetMarker:function(t,e){var i=parseInt(t.style.marginTop,10)-e,o=parseInt(t.style.marginLeft,10)-e;t.style.marginTop=i+"px",t.style.marginLeft=o+"px";}}),L.Marker.addInitHook(function(){L.Edit.Marker&&(this.editing=new L.Edit.Marker(this),this.options.editable&&this.editing.enable());}),L.Edit=L.Edit||{},L.Edit.Poly=L.Handler.extend({initialize:function(t){this.latlngs=[t._latlngs],t._holes&&(this.latlngs=this.latlngs.concat(t._holes)),this._poly=t,this._poly.on("revert-edited",this._updateLatLngs,this);},_defaultShape:function(){return L.Polyline._flat?L.Polyline._flat(this._poly._latlngs)?this._poly._latlngs:this._poly._latlngs[0]:this._poly._latlngs},_eachVertexHandler:function(t){for(var e=0;e<this._verticesHandlers.length;e++){ t(this._verticesHandlers[e]); }},addHooks:function(){this._initHandlers(),this._eachVertexHandler(function(t){t.addHooks();});},removeHooks:function(){this._eachVertexHandler(function(t){t.removeHooks();});},updateMarkers:function(){this._eachVertexHandler(function(t){t.updateMarkers();});},_initHandlers:function(){this._verticesHandlers=[];for(var t=0;t<this.latlngs.length;t++){ this._verticesHandlers.push(new L.Edit.PolyVerticesEdit(this._poly,this.latlngs[t],this._poly.options.poly)); }},_updateLatLngs:function(t){this.latlngs=[t.layer._latlngs],t.layer._holes&&(this.latlngs=this.latlngs.concat(t.layer._holes));}}),L.Edit.PolyVerticesEdit=L.Handler.extend({options:{icon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon"}),touchIcon:new L.DivIcon({iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon"}),drawError:{color:"#b00b00",timeout:1e3}},initialize:function(t,e,i){L.Browser.touch&&(this.options.icon=this.options.touchIcon),this._poly=t,i&&i.drawError&&(i.drawError=L.Util.extend({},this.options.drawError,i.drawError)),this._latlngs=e,L.setOptions(this,i);},_defaultShape:function(){return L.Polyline._flat?L.Polyline._flat(this._latlngs)?this._latlngs:this._latlngs[0]:this._latlngs},addHooks:function(){var t=this._poly,e=t._path;t instanceof L.Polygon||(t.options.fill=!1,t.options.editing&&(t.options.editing.fill=!1)),e&&t.options.editing&&t.options.editing.className&&(t.options.original.className&&t.options.original.className.split(" ").forEach(function(t){L.DomUtil.removeClass(e,t);}),t.options.editing.className.split(" ").forEach(function(t){L.DomUtil.addClass(e,t);})),t.setStyle(t.options.editing),this._poly._map&&(this._map=this._poly._map,this._markerGroup||this._initMarkers(),this._poly._map.addLayer(this._markerGroup));},removeHooks:function(){var t=this._poly,e=t._path;e&&t.options.editing&&t.options.editing.className&&(t.options.editing.className.split(" ").forEach(function(t){L.DomUtil.removeClass(e,t);}),t.options.original.className&&t.options.original.className.split(" ").forEach(function(t){L.DomUtil.addClass(e,t);})),t.setStyle(t.options.original),t._map&&(t._map.removeLayer(this._markerGroup),delete this._markerGroup,delete this._markers);},updateMarkers:function(){this._markerGroup.clearLayers(),this._initMarkers();},_initMarkers:function(){this._markerGroup||(this._markerGroup=new L.LayerGroup),this._markers=[];var t,e,i,o,a=this._defaultShape();for(t=0,i=a.length;t<i;t++){ o=this._createMarker(a[t],t),o.on("click",this._onMarkerClick,this),o.on("contextmenu",this._onContextMenu,this),this._markers.push(o); }var n,s;for(t=0,e=i-1;t<i;e=t++){ (0!==t||L.Polygon&&this._poly instanceof L.Polygon)&&(n=this._markers[e],s=this._markers[t],this._createMiddleMarker(n,s),this._updatePrevNext(n,s)); }},_createMarker:function(t,e){var i=new L.Marker.Touch(t,{draggable:!0,icon:this.options.icon});return i._origLatLng=t,i._index=e,i.on("dragstart",this._onMarkerDragStart,this).on("drag",this._onMarkerDrag,this).on("dragend",this._fireEdit,this).on("touchmove",this._onTouchMove,this).on("touchend",this._fireEdit,this).on("MSPointerMove",this._onTouchMove,this).on("MSPointerUp",this._fireEdit,this),this._markerGroup.addLayer(i),i},_onMarkerDragStart:function(){this._poly.fire("editstart");},_spliceLatLngs:function(){var t=this._defaultShape(),e=[].splice.apply(t,arguments);return this._poly._convertLatLngs(t,!0),this._poly.redraw(),e},_removeMarker:function(t){var e=t._index;this._markerGroup.removeLayer(t),this._markers.splice(e,1),this._spliceLatLngs(e,1),this._updateIndexes(e,-1),t.off("dragstart",this._onMarkerDragStart,this).off("drag",this._onMarkerDrag,this).off("dragend",this._fireEdit,this).off("touchmove",this._onMarkerDrag,this).off("touchend",this._fireEdit,this).off("click",this._onMarkerClick,this).off("MSPointerMove",this._onTouchMove,this).off("MSPointerUp",this._fireEdit,this);},_fireEdit:function(){this._poly.edited=!0,this._poly.fire("edit"),this._poly._map.fire(L.Draw.Event.EDITVERTEX,{layers:this._markerGroup,poly:this._poly});},_onMarkerDrag:function(t){var e=t.target,i=this._poly,o=L.LatLngUtil.cloneLatLng(e._origLatLng);if(L.extend(e._origLatLng,e._latlng),i.options.poly){var a=i._map._editTooltip;if(!i.options.poly.allowIntersection&&i.intersects()){L.extend(e._origLatLng,o),e.setLatLng(o);var n=i.options.color;i.setStyle({color:this.options.drawError.color}),a&&a.updateContent({text:L.drawLocal.draw.handlers.polyline.error}),setTimeout(function(){i.setStyle({color:n}),a&&a.updateContent({text:L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.edit.handlers.edit.tooltip.subtext});},1e3);}}e._middleLeft&&e._middleLeft.setLatLng(this._getMiddleLatLng(e._prev,e)),e._middleRight&&e._middleRight.setLatLng(this._getMiddleLatLng(e,e._next)),this._poly._bounds._southWest=L.latLng(1/0,1/0),this._poly._bounds._northEast=L.latLng(-1/0,-1/0);var s=this._poly.getLatLngs();this._poly._convertLatLngs(s,!0),this._poly.redraw(),this._poly.fire("editdrag");},_onMarkerClick:function(t){var e=L.Polygon&&this._poly instanceof L.Polygon?4:3,i=t.target;this._defaultShape().length<e||(this._removeMarker(i),this._updatePrevNext(i._prev,i._next),i._middleLeft&&this._markerGroup.removeLayer(i._middleLeft),i._middleRight&&this._markerGroup.removeLayer(i._middleRight),i._prev&&i._next?this._createMiddleMarker(i._prev,i._next):i._prev?i._next||(i._prev._middleRight=null):i._next._middleLeft=null,this._fireEdit());},_onContextMenu:function(t){var e=t.target;this._poly;this._poly._map.fire(L.Draw.Event.MARKERCONTEXT,{marker:e,layers:this._markerGroup,poly:this._poly}),L.DomEvent.stopPropagation;},_onTouchMove:function(t){var e=this._map.mouseEventToLayerPoint(t.originalEvent.touches[0]),i=this._map.layerPointToLatLng(e),o=t.target;L.extend(o._origLatLng,i),o._middleLeft&&o._middleLeft.setLatLng(this._getMiddleLatLng(o._prev,o)),o._middleRight&&o._middleRight.setLatLng(this._getMiddleLatLng(o,o._next)),this._poly.redraw(),this.updateMarkers();},_updateIndexes:function(t,e){this._markerGroup.eachLayer(function(i){i._index>t&&(i._index+=e);});},_createMiddleMarker:function(t,e){var i,o,a,n=this._getMiddleLatLng(t,e),s=this._createMarker(n);s.setOpacity(.6),t._middleRight=e._middleLeft=s,o=function(){s.off("touchmove",o,this);var a=e._index;s._index=a,s.off("click",i,this).on("click",this._onMarkerClick,this),n.lat=s.getLatLng().lat,n.lng=s.getLatLng().lng,this._spliceLatLngs(a,0,n),this._markers.splice(a,0,s),s.setOpacity(1),this._updateIndexes(a,1),e._index++,this._updatePrevNext(t,s),this._updatePrevNext(s,e),this._poly.fire("editstart");},a=function(){s.off("dragstart",o,this),s.off("dragend",a,this),s.off("touchmove",o,this),this._createMiddleMarker(t,s),this._createMiddleMarker(s,e);},i=function(){o.call(this),a.call(this),this._fireEdit();},s.on("click",i,this).on("dragstart",o,this).on("dragend",a,this).on("touchmove",o,this),this._markerGroup.addLayer(s);},_updatePrevNext:function(t,e){t&&(t._next=e),e&&(e._prev=t);},_getMiddleLatLng:function(t,e){var i=this._poly._map,o=i.project(t.getLatLng()),a=i.project(e.getLatLng());return i.unproject(o._add(a)._divideBy(2))}}),L.Polyline.addInitHook(function(){this.editing||(L.Edit.Poly&&(this.editing=new L.Edit.Poly(this),this.options.editable&&this.editing.enable()),this.on("add",function(){this.editing&&this.editing.enabled()&&this.editing.addHooks();}),this.on("remove",function(){this.editing&&this.editing.enabled()&&this.editing.removeHooks();}));}),L.Edit=L.Edit||{},L.Edit.SimpleShape=L.Handler.extend({options:{moveIcon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-move"}),resizeIcon:new L.DivIcon({iconSize:new L.Point(8,8),
	className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize"}),touchMoveIcon:new L.DivIcon({iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-move leaflet-touch-icon"}),touchResizeIcon:new L.DivIcon({iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize leaflet-touch-icon"})},initialize:function(t,e){L.Browser.touch&&(this.options.moveIcon=this.options.touchMoveIcon,this.options.resizeIcon=this.options.touchResizeIcon),this._shape=t,L.Util.setOptions(this,e);},addHooks:function(){var t=this._shape;this._shape._map&&(this._map=this._shape._map,t.setStyle(t.options.editing),t._map&&(this._map=t._map,this._markerGroup||this._initMarkers(),this._map.addLayer(this._markerGroup)));},removeHooks:function(){var t=this._shape;if(t.setStyle(t.options.original),t._map){this._unbindMarker(this._moveMarker);for(var e=0,i=this._resizeMarkers.length;e<i;e++){ this._unbindMarker(this._resizeMarkers[e]); }this._resizeMarkers=null,this._map.removeLayer(this._markerGroup),delete this._markerGroup;}this._map=null;},updateMarkers:function(){this._markerGroup.clearLayers(),this._initMarkers();},_initMarkers:function(){this._markerGroup||(this._markerGroup=new L.LayerGroup),this._createMoveMarker(),this._createResizeMarker();},_createMoveMarker:function(){},_createResizeMarker:function(){},_createMarker:function(t,e){var i=new L.Marker.Touch(t,{draggable:!0,icon:e,zIndexOffset:10});return this._bindMarker(i),this._markerGroup.addLayer(i),i},_bindMarker:function(t){t.on("dragstart",this._onMarkerDragStart,this).on("drag",this._onMarkerDrag,this).on("dragend",this._onMarkerDragEnd,this).on("touchstart",this._onTouchStart,this).on("touchmove",this._onTouchMove,this).on("MSPointerMove",this._onTouchMove,this).on("touchend",this._onTouchEnd,this).on("MSPointerUp",this._onTouchEnd,this);},_unbindMarker:function(t){t.off("dragstart",this._onMarkerDragStart,this).off("drag",this._onMarkerDrag,this).off("dragend",this._onMarkerDragEnd,this).off("touchstart",this._onTouchStart,this).off("touchmove",this._onTouchMove,this).off("MSPointerMove",this._onTouchMove,this).off("touchend",this._onTouchEnd,this).off("MSPointerUp",this._onTouchEnd,this);},_onMarkerDragStart:function(t){t.target.setOpacity(0),this._shape.fire("editstart");},_fireEdit:function(){this._shape.edited=!0,this._shape.fire("edit");},_onMarkerDrag:function(t){var e=t.target,i=e.getLatLng();e===this._moveMarker?this._move(i):this._resize(i),this._shape.redraw(),this._shape.fire("editdrag");},_onMarkerDragEnd:function(t){t.target.setOpacity(1),this._fireEdit();},_onTouchStart:function(t){if(L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this,t),"function"==typeof this._getCorners){var e=this._getCorners(),i=t.target,o=i._cornerIndex;i.setOpacity(0),this._oppositeCorner=e[(o+2)%4],this._toggleCornerMarkers(0,o);}this._shape.fire("editstart");},_onTouchMove:function(t){var e=this._map.mouseEventToLayerPoint(t.originalEvent.touches[0]),i=this._map.layerPointToLatLng(e);return t.target===this._moveMarker?this._move(i):this._resize(i),this._shape.redraw(),!1},_onTouchEnd:function(t){t.target.setOpacity(1),this.updateMarkers(),this._fireEdit();},_move:function(){},_resize:function(){}}),L.Edit=L.Edit||{},L.Edit.Rectangle=L.Edit.SimpleShape.extend({_createMoveMarker:function(){var t=this._shape.getBounds(),e=t.getCenter();this._moveMarker=this._createMarker(e,this.options.moveIcon);},_createResizeMarker:function(){var t=this._getCorners();this._resizeMarkers=[];for(var e=0,i=t.length;e<i;e++){ this._resizeMarkers.push(this._createMarker(t[e],this.options.resizeIcon)),this._resizeMarkers[e]._cornerIndex=e; }},_onMarkerDragStart:function(t){L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this,t);var e=this._getCorners(),i=t.target,o=i._cornerIndex;this._oppositeCorner=e[(o+2)%4],this._toggleCornerMarkers(0,o);},_onMarkerDragEnd:function(t){var e,i,o=t.target;o===this._moveMarker&&(e=this._shape.getBounds(),i=e.getCenter(),o.setLatLng(i)),this._toggleCornerMarkers(1),this._repositionCornerMarkers(),L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this,t);},_move:function(t){for(var e,i=this._shape._defaultShape?this._shape._defaultShape():this._shape.getLatLngs(),o=this._shape.getBounds(),a=o.getCenter(),n=[],s=0,r=i.length;s<r;s++){ e=[i[s].lat-a.lat,i[s].lng-a.lng],n.push([t.lat+e[0],t.lng+e[1]]); }this._shape.setLatLngs(n),this._repositionCornerMarkers(),this._map.fire(L.Draw.Event.EDITMOVE,{layer:this._shape});},_resize:function(t){var e;this._shape.setBounds(L.latLngBounds(t,this._oppositeCorner)),e=this._shape.getBounds(),this._moveMarker.setLatLng(e.getCenter()),this._map.fire(L.Draw.Event.EDITRESIZE,{layer:this._shape});},_getCorners:function(){var t=this._shape.getBounds();return [t.getNorthWest(),t.getNorthEast(),t.getSouthEast(),t.getSouthWest()]},_toggleCornerMarkers:function(t){for(var e=0,i=this._resizeMarkers.length;e<i;e++){ this._resizeMarkers[e].setOpacity(t); }},_repositionCornerMarkers:function(){for(var t=this._getCorners(),e=0,i=this._resizeMarkers.length;e<i;e++){ this._resizeMarkers[e].setLatLng(t[e]); }}}),L.Rectangle.addInitHook(function(){L.Edit.Rectangle&&(this.editing=new L.Edit.Rectangle(this),this.options.editable&&this.editing.enable());}),L.Edit=L.Edit||{},L.Edit.CircleMarker=L.Edit.SimpleShape.extend({_createMoveMarker:function(){var t=this._shape.getLatLng();this._moveMarker=this._createMarker(t,this.options.moveIcon);},_createResizeMarker:function(){this._resizeMarkers=[];},_move:function(t){if(this._resizeMarkers.length){var e=this._getResizeMarkerPoint(t);this._resizeMarkers[0].setLatLng(e);}this._shape.setLatLng(t),this._map.fire(L.Draw.Event.EDITMOVE,{layer:this._shape});}}),L.CircleMarker.addInitHook(function(){L.Edit.CircleMarker&&(this.editing=new L.Edit.CircleMarker(this),this.options.editable&&this.editing.enable()),this.on("add",function(){this.editing&&this.editing.enabled()&&this.editing.addHooks();}),this.on("remove",function(){this.editing&&this.editing.enabled()&&this.editing.removeHooks();});}),L.Edit=L.Edit||{},L.Edit.Circle=L.Edit.CircleMarker.extend({_createResizeMarker:function(){var t=this._shape.getLatLng(),e=this._getResizeMarkerPoint(t);this._resizeMarkers=[],this._resizeMarkers.push(this._createMarker(e,this.options.resizeIcon));},_getResizeMarkerPoint:function(t){var e=this._shape._radius*Math.cos(Math.PI/4),i=this._map.project(t);return this._map.unproject([i.x+e,i.y-e])},_resize:function(t){var e=this._moveMarker.getLatLng();L.GeometryUtil.isVersion07x()?radius=e.distanceTo(t):radius=this._map.distance(e,t),this._shape.setRadius(radius),this._map.editTooltip&&this._map._editTooltip.updateContent({text:L.drawLocal.edit.handlers.edit.tooltip.subtext+"<br />"+L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.draw.handlers.circle.radius+": "+L.GeometryUtil.readableDistance(radius,!0,this.options.feet,this.options.nautic)}),this._shape.setRadius(radius),this._map.fire(L.Draw.Event.EDITRESIZE,{layer:this._shape});}}),L.Circle.addInitHook(function(){L.Edit.Circle&&(this.editing=new L.Edit.Circle(this),this.options.editable&&this.editing.enable());}),L.Map.mergeOptions({touchExtend:!0}),L.Map.TouchExtend=L.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane;},addHooks:function(){L.DomEvent.on(this._container,"touchstart",this._onTouchStart,this),L.DomEvent.on(this._container,"touchend",this._onTouchEnd,this),L.DomEvent.on(this._container,"touchmove",this._onTouchMove,this),this._detectIE()?(L.DomEvent.on(this._container,"MSPointerDown",this._onTouchStart,this),L.DomEvent.on(this._container,"MSPointerUp",this._onTouchEnd,this),L.DomEvent.on(this._container,"MSPointerMove",this._onTouchMove,this),L.DomEvent.on(this._container,"MSPointerCancel",this._onTouchCancel,this)):(L.DomEvent.on(this._container,"touchcancel",this._onTouchCancel,this),L.DomEvent.on(this._container,"touchleave",this._onTouchLeave,this));},removeHooks:function(){L.DomEvent.off(this._container,"touchstart",this._onTouchStart,this),L.DomEvent.off(this._container,"touchend",this._onTouchEnd,this),L.DomEvent.off(this._container,"touchmove",this._onTouchMove,this),this._detectIE()?(L.DomEvent.off(this._container,"MSPointerDown",this._onTouchStart,this),L.DomEvent.off(this._container,"MSPointerUp",this._onTouchEnd,this),L.DomEvent.off(this._container,"MSPointerMove",this._onTouchMove,this),L.DomEvent.off(this._container,"MSPointerCancel",this._onTouchCancel,this)):(L.DomEvent.off(this._container,"touchcancel",this._onTouchCancel,this),L.DomEvent.off(this._container,"touchleave",this._onTouchLeave,this));},_touchEvent:function(t,e){var i={};if(void 0!==t.touches){if(!t.touches.length){ return; }i=t.touches[0];}else{if("touch"!==t.pointerType){ return; }if(i=t,!this._filterClick(t)){ return }}var o=this._map.mouseEventToContainerPoint(i),a=this._map.mouseEventToLayerPoint(i),n=this._map.layerPointToLatLng(a);this._map.fire(e,{latlng:n,layerPoint:a,containerPoint:o,pageX:i.pageX,pageY:i.pageY,originalEvent:t});},_filterClick:function(t){var e=t.timeStamp||t.originalEvent.timeStamp,i=L.DomEvent._lastClick&&e-L.DomEvent._lastClick;return i&&i>100&&i<500||t.target._simulatedClick&&!t._simulated?(L.DomEvent.stop(t),!1):(L.DomEvent._lastClick=e,!0)},_onTouchStart:function(t){if(this._map._loaded){this._touchEvent(t,"touchstart");}},_onTouchEnd:function(t){if(this._map._loaded){this._touchEvent(t,"touchend");}},_onTouchCancel:function(t){if(this._map._loaded){var e="touchcancel";this._detectIE()&&(e="pointercancel"),this._touchEvent(t,e);}},_onTouchLeave:function(t){if(this._map._loaded){this._touchEvent(t,"touchleave");}},_onTouchMove:function(t){if(this._map._loaded){this._touchEvent(t,"touchmove");}},_detectIE:function(){var e=t.navigator.userAgent,i=e.indexOf("MSIE ");if(i>0){ return parseInt(e.substring(i+5,e.indexOf(".",i)),10); }if(e.indexOf("Trident/")>0){var o=e.indexOf("rv:");return parseInt(e.substring(o+3,e.indexOf(".",o)),10)}var a=e.indexOf("Edge/");return a>0&&parseInt(e.substring(a+5,e.indexOf(".",a)),10)}}),L.Map.addInitHook("addHandler","touchExtend",L.Map.TouchExtend),L.Marker.Touch=L.Marker.extend({_initInteraction:function(){return this.addInteractiveTarget?L.Marker.prototype._initInteraction.apply(this):this._initInteractionLegacy()},_initInteractionLegacy:function(){if(this.options.clickable){var t=this._icon,e=["dblclick","mousedown","mouseover","mouseout","contextmenu","touchstart","touchend","touchmove"];this._detectIE?e.concat(["MSPointerDown","MSPointerUp","MSPointerMove","MSPointerCancel"]):e.concat(["touchcancel"]),L.DomUtil.addClass(t,"leaflet-clickable"),L.DomEvent.on(t,"click",this._onMouseClick,this),L.DomEvent.on(t,"keypress",this._onKeyPress,this);for(var i=0;i<e.length;i++){ L.DomEvent.on(t,e[i],this._fireMouseEvent,this); }L.Handler.MarkerDrag&&(this.dragging=new L.Handler.MarkerDrag(this),this.options.draggable&&this.dragging.enable());}},_detectIE:function(){var e=t.navigator.userAgent,i=e.indexOf("MSIE ");if(i>0){ return parseInt(e.substring(i+5,e.indexOf(".",i)),10); }if(e.indexOf("Trident/")>0){var o=e.indexOf("rv:");return parseInt(e.substring(o+3,e.indexOf(".",o)),10)}var a=e.indexOf("Edge/");return a>0&&parseInt(e.substring(a+5,e.indexOf(".",a)),10)}}),L.LatLngUtil={cloneLatLngs:function(t){for(var e=[],i=0,o=t.length;i<o;i++){ Array.isArray(t[i])?e.push(L.LatLngUtil.cloneLatLngs(t[i])):e.push(this.cloneLatLng(t[i])); }return e},cloneLatLng:function(t){return L.latLng(t.lat,t.lng)}},function(){var t={km:2,ha:2,m:0,mi:2,ac:2,yd:0,ft:0,nm:2};L.GeometryUtil=L.extend(L.GeometryUtil||{},{geodesicArea:function(t){var e,i,o=t.length,a=0,n=Math.PI/180;if(o>2){for(var s=0;s<o;s++){ e=t[s],i=t[(s+1)%o],a+=(i.lng-e.lng)*n*(2+Math.sin(e.lat*n)+Math.sin(i.lat*n)); }a=6378137*a*6378137/2;}return Math.abs(a)},formattedNumber:function(t,e){var i=parseFloat(t).toFixed(e),o=L.drawLocal.format&&L.drawLocal.format.numeric,a=o&&o.delimiters,n=a&&a.thousands,s=a&&a.decimal;if(n||s){var r=i.split(".");i=n?r[0].replace(/(\d)(?=(\d{3})+(?!\d))/g,"$1"+n):r[0],s=s||".",r.length>1&&(i=i+s+r[1]);}return i},readableArea:function(e,i,o){var a,n,o=L.Util.extend({},t,o);return i?(n=["ha","m"],type=typeof i,"string"===type?n=[i]:"boolean"!==type&&(n=i),a=e>=1e6&&-1!==n.indexOf("km")?L.GeometryUtil.formattedNumber(1e-6*e,o.km)+" km²":e>=1e4&&-1!==n.indexOf("ha")?L.GeometryUtil.formattedNumber(1e-4*e,o.ha)+" ha":L.GeometryUtil.formattedNumber(e,o.m)+" m²"):(e/=.836127,a=e>=3097600?L.GeometryUtil.formattedNumber(e/3097600,o.mi)+" mi²":e>=4840?L.GeometryUtil.formattedNumber(e/4840,o.ac)+" acres":L.GeometryUtil.formattedNumber(e,o.yd)+" yd²"),a},readableDistance:function(e,i,o,a,n){var s,n=L.Util.extend({},t,n);switch(i?"string"==typeof i?i:"metric":o?"feet":a?"nauticalMile":"yards"){case"metric":s=e>1e3?L.GeometryUtil.formattedNumber(e/1e3,n.km)+" km":L.GeometryUtil.formattedNumber(e,n.m)+" m";break;case"feet":e*=3.28083,s=L.GeometryUtil.formattedNumber(e,n.ft)+" ft";break;case"nauticalMile":e*=.53996,s=L.GeometryUtil.formattedNumber(e/1e3,n.nm)+" nm";break;case"yards":default:e*=1.09361,s=e>1760?L.GeometryUtil.formattedNumber(e/1760,n.mi)+" miles":L.GeometryUtil.formattedNumber(e,n.yd)+" yd";}return s},isVersion07x:function(){var t=L.version.split(".");return 0===parseInt(t[0],10)&&7===parseInt(t[1],10)}});}(),L.Util.extend(L.LineUtil,{segmentsIntersect:function(t,e,i,o){return this._checkCounterclockwise(t,i,o)!==this._checkCounterclockwise(e,i,o)&&this._checkCounterclockwise(t,e,i)!==this._checkCounterclockwise(t,e,o)},_checkCounterclockwise:function(t,e,i){return (i.y-t.y)*(e.x-t.x)>(e.y-t.y)*(i.x-t.x)}}),L.Polyline.include({intersects:function(){var t,e,i,o=this._getProjectedPoints(),a=o?o.length:0;if(this._tooFewPointsForIntersection()){ return !1; }for(t=a-1;t>=3;t--){ if(e=o[t-1],i=o[t],this._lineSegmentsIntersectsRange(e,i,t-2)){ return !0; } }return !1},newLatLngIntersects:function(t,e){return !!this._map&&this.newPointIntersects(this._map.latLngToLayerPoint(t),e)},newPointIntersects:function(t,e){var i=this._getProjectedPoints(),o=i?i.length:0,a=i?i[o-1]:null,n=o-2;return !this._tooFewPointsForIntersection(1)&&this._lineSegmentsIntersectsRange(a,t,n,e?1:0)},_tooFewPointsForIntersection:function(t){var e=this._getProjectedPoints(),i=e?e.length:0;return i+=t||0,!e||i<=3},_lineSegmentsIntersectsRange:function(t,e,i,o){var a,n,s=this._getProjectedPoints();o=o||0;for(var r=i;r>o;r--){ if(a=s[r-1],n=s[r],L.LineUtil.segmentsIntersect(t,e,a,n)){ return !0; } }return !1},_getProjectedPoints:function(){if(!this._defaultShape){ return this._originalPoints; }for(var t=[],e=this._defaultShape(),i=0;i<e.length;i++){ t.push(this._map.latLngToLayerPoint(e[i])); }return t}}),L.Polygon.include({intersects:function(){var t,e,i,o,a=this._getProjectedPoints();return !this._tooFewPointsForIntersection()&&(!!L.Polyline.prototype.intersects.call(this)||(t=a.length,e=a[0],i=a[t-1],o=t-2,this._lineSegmentsIntersectsRange(i,e,o,1)))}}),L.Control.Draw=L.Control.extend({options:{position:"topleft",draw:{},edit:!1},initialize:function(t){if(L.version<"0.7"){ throw new Error("Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/"); }L.Control.prototype.initialize.call(this,t);var e;this._toolbars={},L.DrawToolbar&&this.options.draw&&(e=new L.DrawToolbar(this.options.draw),this._toolbars[L.DrawToolbar.TYPE]=e,this._toolbars[L.DrawToolbar.TYPE].on("enable",this._toolbarEnabled,this)),L.EditToolbar&&this.options.edit&&(e=new L.EditToolbar(this.options.edit),this._toolbars[L.EditToolbar.TYPE]=e,this._toolbars[L.EditToolbar.TYPE].on("enable",this._toolbarEnabled,this)),L.toolbar=this;},onAdd:function(t){var e,i=L.DomUtil.create("div","leaflet-draw"),o=!1;for(var a in this._toolbars){ this._toolbars.hasOwnProperty(a)&&(e=this._toolbars[a].addToolbar(t))&&(o||(L.DomUtil.hasClass(e,"leaflet-draw-toolbar-top")||L.DomUtil.addClass(e.childNodes[0],"leaflet-draw-toolbar-top"),o=!0),i.appendChild(e)); }return i},onRemove:function(){for(var t in this._toolbars){ this._toolbars.hasOwnProperty(t)&&this._toolbars[t].removeToolbar(); }},setDrawingOptions:function(t){for(var e in this._toolbars){ this._toolbars[e]instanceof L.DrawToolbar&&this._toolbars[e].setOptions(t); }},_toolbarEnabled:function(t){var e=t.target;for(var i in this._toolbars){ this._toolbars[i]!==e&&this._toolbars[i].disable(); }}}),L.Map.mergeOptions({drawControlTooltips:!0,drawControl:!1}),L.Map.addInitHook(function(){this.options.drawControl&&(this.drawControl=new L.Control.Draw,this.addControl(this.drawControl));}),L.Toolbar=L.Class.extend({initialize:function(t){L.setOptions(this,t),this._modes={},this._actionButtons=[],this._activeMode=null;var e=L.version.split(".");1===parseInt(e[0],10)&&parseInt(e[1],10)>=2?L.Toolbar.include(L.Evented.prototype):L.Toolbar.include(L.Mixin.Events);},enabled:function(){return null!==this._activeMode},disable:function(){this.enabled()&&this._activeMode.handler.disable();},addToolbar:function(t){var e,i=L.DomUtil.create("div","leaflet-draw-section"),o=0,a=this._toolbarClass||"",n=this.getModeHandlers(t);for(this._toolbarContainer=L.DomUtil.create("div","leaflet-draw-toolbar leaflet-bar"),this._map=t,e=0;e<n.length;e++){ n[e].enabled&&this._initModeHandler(n[e].handler,this._toolbarContainer,o++,a,n[e].title); }if(o){ return this._lastButtonIndex=--o,this._actionsContainer=L.DomUtil.create("ul","leaflet-draw-actions"),i.appendChild(this._toolbarContainer),i.appendChild(this._actionsContainer),i }},removeToolbar:function(){for(var t in this._modes){ this._modes.hasOwnProperty(t)&&(this._disposeButton(this._modes[t].button,this._modes[t].handler.enable,this._modes[t].handler),this._modes[t].handler.disable(),this._modes[t].handler.off("enabled",this._handlerActivated,this).off("disabled",this._handlerDeactivated,this)); }this._modes={};for(var e=0,i=this._actionButtons.length;e<i;e++){ this._disposeButton(this._actionButtons[e].button,this._actionButtons[e].callback,this); }this._actionButtons=[],this._actionsContainer=null;},_initModeHandler:function(t,e,i,o,a){var n=t.type;this._modes[n]={},this._modes[n].handler=t,this._modes[n].button=this._createButton({type:n,title:a,className:o+"-"+n,container:e,callback:this._modes[n].handler.enable,context:this._modes[n].handler}),this._modes[n].buttonIndex=i,this._modes[n].handler.on("enabled",this._handlerActivated,this).on("disabled",this._handlerDeactivated,this);},_detectIOS:function(){return /iPad|iPhone|iPod/.test(navigator.userAgent)&&!t.MSStream},_createButton:function(t){var e=L.DomUtil.create("a",t.className||"",t.container),i=L.DomUtil.create("span","sr-only",t.container);e.href="#",e.appendChild(i),t.title&&(e.title=t.title,i.innerHTML=t.title),t.text&&(e.innerHTML=t.text,i.innerHTML=t.text);var o=this._detectIOS()?"touchstart":"click";return L.DomEvent.on(e,"click",L.DomEvent.stopPropagation).on(e,"mousedown",L.DomEvent.stopPropagation).on(e,"dblclick",L.DomEvent.stopPropagation).on(e,"touchstart",L.DomEvent.stopPropagation).on(e,"click",L.DomEvent.preventDefault).on(e,o,t.callback,t.context),e},_disposeButton:function(t,e){var i=this._detectIOS()?"touchstart":"click";L.DomEvent.off(t,"click",L.DomEvent.stopPropagation).off(t,"mousedown",L.DomEvent.stopPropagation).off(t,"dblclick",L.DomEvent.stopPropagation).off(t,"touchstart",L.DomEvent.stopPropagation).off(t,"click",L.DomEvent.preventDefault).off(t,i,e);},_handlerActivated:function(t){this.disable(),this._activeMode=this._modes[t.handler],L.DomUtil.addClass(this._activeMode.button,"leaflet-draw-toolbar-button-enabled"),this._showActionsToolbar(),this.fire("enable");},_handlerDeactivated:function(){this._hideActionsToolbar(),L.DomUtil.removeClass(this._activeMode.button,"leaflet-draw-toolbar-button-enabled"),this._activeMode=null,this.fire("disable");},_createActions:function(t){var e,i,o,a,n=this._actionsContainer,s=this.getActions(t),r=s.length;for(i=0,o=this._actionButtons.length;i<o;i++){ this._disposeButton(this._actionButtons[i].button,this._actionButtons[i].callback); }for(this._actionButtons=[];n.firstChild;){ n.removeChild(n.firstChild); }for(var l=0;l<r;l++){ "enabled"in s[l]&&!s[l].enabled||(e=L.DomUtil.create("li","",n),a=this._createButton({title:s[l].title,text:s[l].text,container:e,callback:s[l].callback,context:s[l].context}),this._actionButtons.push({button:a,callback:s[l].callback})); }},_showActionsToolbar:function(){var t=this._activeMode.buttonIndex,e=this._lastButtonIndex,i=this._activeMode.button.offsetTop-1;this._createActions(this._activeMode.handler),this._actionsContainer.style.top=i+"px",0===t&&(L.DomUtil.addClass(this._toolbarContainer,"leaflet-draw-toolbar-notop"),L.DomUtil.addClass(this._actionsContainer,"leaflet-draw-actions-top")),t===e&&(L.DomUtil.addClass(this._toolbarContainer,"leaflet-draw-toolbar-nobottom"),L.DomUtil.addClass(this._actionsContainer,"leaflet-draw-actions-bottom")),this._actionsContainer.style.display="block",this._map.fire(L.Draw.Event.TOOLBAROPENED);},_hideActionsToolbar:function(){this._actionsContainer.style.display="none",L.DomUtil.removeClass(this._toolbarContainer,"leaflet-draw-toolbar-notop"),L.DomUtil.removeClass(this._toolbarContainer,"leaflet-draw-toolbar-nobottom"),L.DomUtil.removeClass(this._actionsContainer,"leaflet-draw-actions-top"),L.DomUtil.removeClass(this._actionsContainer,"leaflet-draw-actions-bottom"),this._map.fire(L.Draw.Event.TOOLBARCLOSED);}}),L.Draw=L.Draw||{},L.Draw.Tooltip=L.Class.extend({initialize:function(t){this._map=t,this._popupPane=t._panes.popupPane,this._visible=!1,this._container=t.options.drawControlTooltips?L.DomUtil.create("div","leaflet-draw-tooltip",this._popupPane):null,this._singleLineLabel=!1,this._map.on("mouseout",this._onMouseOut,this);},dispose:function(){this._map.off("mouseout",this._onMouseOut,this),this._container&&(this._popupPane.removeChild(this._container),this._container=null);},updateContent:function(t){return this._container?(t.subtext=t.subtext||"",0!==t.subtext.length||this._singleLineLabel?t.subtext.length>0&&this._singleLineLabel&&(L.DomUtil.removeClass(this._container,"leaflet-draw-tooltip-single"),this._singleLineLabel=!1):(L.DomUtil.addClass(this._container,"leaflet-draw-tooltip-single"),this._singleLineLabel=!0),this._container.innerHTML=(t.subtext.length>0?'<span class="leaflet-draw-tooltip-subtext">'+t.subtext+"</span><br />":"")+"<span>"+t.text+"</span>",t.text||t.subtext?(this._visible=!0,this._container.style.visibility="inherit"):(this._visible=!1,this._container.style.visibility="hidden"),this):this},updatePosition:function(t){var e=this._map.latLngToLayerPoint(t),i=this._container;return this._container&&(this._visible&&(i.style.visibility="inherit"),L.DomUtil.setPosition(i,e)),this},showAsError:function(){return this._container&&L.DomUtil.addClass(this._container,"leaflet-error-draw-tooltip"),this},removeError:function(){return this._container&&L.DomUtil.removeClass(this._container,"leaflet-error-draw-tooltip"),this},_onMouseOut:function(){this._container&&(this._container.style.visibility="hidden");}}),L.DrawToolbar=L.Toolbar.extend({statics:{TYPE:"draw"},options:{polyline:{},polygon:{},rectangle:{},circle:{},marker:{},circlemarker:{}},initialize:function(t){for(var e in this.options){ this.options.hasOwnProperty(e)&&t[e]&&(t[e]=L.extend({},this.options[e],t[e])); }this._toolbarClass="leaflet-draw-draw",L.Toolbar.prototype.initialize.call(this,t);},getModeHandlers:function(t){return [{enabled:this.options.polyline,handler:new L.Draw.Polyline(t,this.options.polyline),title:L.drawLocal.draw.toolbar.buttons.polyline},{enabled:this.options.polygon,handler:new L.Draw.Polygon(t,this.options.polygon),title:L.drawLocal.draw.toolbar.buttons.polygon},{enabled:this.options.rectangle,handler:new L.Draw.Rectangle(t,this.options.rectangle),title:L.drawLocal.draw.toolbar.buttons.rectangle},{enabled:this.options.circle,handler:new L.Draw.Circle(t,this.options.circle),title:L.drawLocal.draw.toolbar.buttons.circle},{enabled:this.options.marker,handler:new L.Draw.Marker(t,this.options.marker),title:L.drawLocal.draw.toolbar.buttons.marker},{enabled:this.options.circlemarker,handler:new L.Draw.CircleMarker(t,this.options.circlemarker),title:L.drawLocal.draw.toolbar.buttons.circlemarker}]},getActions:function(t){return [{enabled:t.completeShape,title:L.drawLocal.draw.toolbar.finish.title,text:L.drawLocal.draw.toolbar.finish.text,callback:t.completeShape,context:t},{enabled:t.deleteLastVertex,title:L.drawLocal.draw.toolbar.undo.title,text:L.drawLocal.draw.toolbar.undo.text,callback:t.deleteLastVertex,context:t},{title:L.drawLocal.draw.toolbar.actions.title,text:L.drawLocal.draw.toolbar.actions.text,callback:this.disable,context:this}]},setOptions:function(t){L.setOptions(this,t);for(var e in this._modes){ this._modes.hasOwnProperty(e)&&t.hasOwnProperty(e)&&this._modes[e].handler.setOptions(t[e]); }}}),L.EditToolbar=L.Toolbar.extend({statics:{TYPE:"edit"},options:{edit:{selectedPathOptions:{dashArray:"10, 10",fill:!0,fillColor:"#fe57a1",fillOpacity:.1,maintainColor:!1}},remove:{},poly:null,featureGroup:null},initialize:function(t){t.edit&&(void 0===t.edit.selectedPathOptions&&(t.edit.selectedPathOptions=this.options.edit.selectedPathOptions),t.edit.selectedPathOptions=L.extend({},this.options.edit.selectedPathOptions,t.edit.selectedPathOptions)),t.remove&&(t.remove=L.extend({},this.options.remove,t.remove)),t.poly&&(t.poly=L.extend({},this.options.poly,t.poly)),this._toolbarClass="leaflet-draw-edit",L.Toolbar.prototype.initialize.call(this,t),this._selectedFeatureCount=0;},getModeHandlers:function(t){var e=this.options.featureGroup;return [{enabled:this.options.edit,handler:new L.EditToolbar.Edit(t,{featureGroup:e,selectedPathOptions:this.options.edit.selectedPathOptions,poly:this.options.poly}),title:L.drawLocal.edit.toolbar.buttons.edit},{enabled:this.options.remove,handler:new L.EditToolbar.Delete(t,{featureGroup:e}),title:L.drawLocal.edit.toolbar.buttons.remove}]},getActions:function(t){var e=[{title:L.drawLocal.edit.toolbar.actions.save.title,text:L.drawLocal.edit.toolbar.actions.save.text,callback:this._save,context:this},{title:L.drawLocal.edit.toolbar.actions.cancel.title,text:L.drawLocal.edit.toolbar.actions.cancel.text,callback:this.disable,context:this}];return t.removeAllLayers&&e.push({title:L.drawLocal.edit.toolbar.actions.clearAll.title,text:L.drawLocal.edit.toolbar.actions.clearAll.text,callback:this._clearAllLayers,context:this}),e},addToolbar:function(t){var e=L.Toolbar.prototype.addToolbar.call(this,t);return this._checkDisabled(),this.options.featureGroup.on("layeradd layerremove",this._checkDisabled,this),e},removeToolbar:function(){this.options.featureGroup.off("layeradd layerremove",this._checkDisabled,this),L.Toolbar.prototype.removeToolbar.call(this);},disable:function(){this.enabled()&&(this._activeMode.handler.revertLayers(),L.Toolbar.prototype.disable.call(this));},_save:function(){this._activeMode.handler.save(),this._activeMode&&this._activeMode.handler.disable();},_clearAllLayers:function(){this._activeMode.handler.removeAllLayers(),this._activeMode&&this._activeMode.handler.disable();},_checkDisabled:function(){var t,e=this.options.featureGroup,i=0!==e.getLayers().length;this.options.edit&&(t=this._modes[L.EditToolbar.Edit.TYPE].button,i?L.DomUtil.removeClass(t,"leaflet-disabled"):L.DomUtil.addClass(t,"leaflet-disabled"),t.setAttribute("title",i?L.drawLocal.edit.toolbar.buttons.edit:L.drawLocal.edit.toolbar.buttons.editDisabled)),this.options.remove&&(t=this._modes[L.EditToolbar.Delete.TYPE].button,i?L.DomUtil.removeClass(t,"leaflet-disabled"):L.DomUtil.addClass(t,"leaflet-disabled"),t.setAttribute("title",i?L.drawLocal.edit.toolbar.buttons.remove:L.drawLocal.edit.toolbar.buttons.removeDisabled));}}),L.EditToolbar.Edit=L.Handler.extend({statics:{TYPE:"edit"},initialize:function(t,e){if(L.Handler.prototype.initialize.call(this,t),L.setOptions(this,e),this._featureGroup=e.featureGroup,!(this._featureGroup instanceof L.FeatureGroup)){ throw new Error("options.featureGroup must be a L.FeatureGroup"); }this._uneditedLayerProps={},this.type=L.EditToolbar.Edit.TYPE;var i=L.version.split(".");1===parseInt(i[0],10)&&parseInt(i[1],10)>=2?L.EditToolbar.Edit.include(L.Evented.prototype):L.EditToolbar.Edit.include(L.Mixin.Events);},enable:function(){!this._enabled&&this._hasAvailableLayers()&&(this.fire("enabled",{handler:this.type}),this._map.fire(L.Draw.Event.EDITSTART,{handler:this.type}),L.Handler.prototype.enable.call(this),this._featureGroup.on("layeradd",this._enableLayerEdit,this).on("layerremove",this._disableLayerEdit,this));},disable:function(){this._enabled&&(this._featureGroup.off("layeradd",this._enableLayerEdit,this).off("layerremove",this._disableLayerEdit,this),L.Handler.prototype.disable.call(this),this._map.fire(L.Draw.Event.EDITSTOP,{handler:this.type}),this.fire("disabled",{handler:this.type}));},addHooks:function(){var t=this._map;t&&(t.getContainer().focus(),this._featureGroup.eachLayer(this._enableLayerEdit,this),this._tooltip=new L.Draw.Tooltip(this._map),this._tooltip.updateContent({text:L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.edit.handlers.edit.tooltip.subtext}),t._editTooltip=this._tooltip,this._updateTooltip(),this._map.on("mousemove",this._onMouseMove,this).on("touchmove",this._onMouseMove,this).on("MSPointerMove",this._onMouseMove,this).on(L.Draw.Event.EDITVERTEX,this._updateTooltip,this));},removeHooks:function(){this._map&&(this._featureGroup.eachLayer(this._disableLayerEdit,this),this._uneditedLayerProps={},this._tooltip.dispose(),this._tooltip=null,this._map.off("mousemove",this._onMouseMove,this).off("touchmove",this._onMouseMove,this).off("MSPointerMove",this._onMouseMove,this).off(L.Draw.Event.EDITVERTEX,this._updateTooltip,this));},revertLayers:function(){this._featureGroup.eachLayer(function(t){this._revertLayer(t);},this);},save:function(){var t=new L.LayerGroup;this._featureGroup.eachLayer(function(e){e.edited&&(t.addLayer(e),e.edited=!1);}),this._map.fire(L.Draw.Event.EDITED,{layers:t});},_backupLayer:function(t){var e=L.Util.stamp(t);this._uneditedLayerProps[e]||(t instanceof L.Polyline||t instanceof L.Polygon||t instanceof L.Rectangle?this._uneditedLayerProps[e]={latlngs:L.LatLngUtil.cloneLatLngs(t.getLatLngs())}:t instanceof L.Circle?this._uneditedLayerProps[e]={latlng:L.LatLngUtil.cloneLatLng(t.getLatLng()),radius:t.getRadius()}:(t instanceof L.Marker||t instanceof L.CircleMarker)&&(this._uneditedLayerProps[e]={latlng:L.LatLngUtil.cloneLatLng(t.getLatLng())}));},_getTooltipText:function(){return {text:L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.edit.handlers.edit.tooltip.subtext}},_updateTooltip:function(){this._tooltip.updateContent(this._getTooltipText());},_revertLayer:function(t){var e=L.Util.stamp(t);t.edited=!1,this._uneditedLayerProps.hasOwnProperty(e)&&(t instanceof L.Polyline||t instanceof L.Polygon||t instanceof L.Rectangle?t.setLatLngs(this._uneditedLayerProps[e].latlngs):t instanceof L.Circle?(t.setLatLng(this._uneditedLayerProps[e].latlng),t.setRadius(this._uneditedLayerProps[e].radius)):(t instanceof L.Marker||t instanceof L.CircleMarker)&&t.setLatLng(this._uneditedLayerProps[e].latlng),t.fire("revert-edited",{layer:t}));},_enableLayerEdit:function(t){var e,i,o=t.layer||t.target||t;this._backupLayer(o),this.options.poly&&(i=L.Util.extend({},this.options.poly),o.options.poly=i),this.options.selectedPathOptions&&(e=L.Util.extend({},this.options.selectedPathOptions),e.maintainColor&&(e.color=o.options.color,e.fillColor=o.options.fillColor),o.options.original=L.extend({},o.options),o.options.editing=e),o instanceof L.Marker?(o.editing&&o.editing.enable(),o.dragging.enable(),o.on("dragend",this._onMarkerDragEnd).on("touchmove",this._onTouchMove,this).on("MSPointerMove",this._onTouchMove,this).on("touchend",this._onMarkerDragEnd,this).on("MSPointerUp",this._onMarkerDragEnd,this)):o.editing.enable();},_disableLayerEdit:function(t){var e=t.layer||t.target||t;e.edited=!1,e.editing&&e.editing.disable(),delete e.options.editing,delete e.options.original,
	this._selectedPathOptions&&(e instanceof L.Marker?this._toggleMarkerHighlight(e):(e.setStyle(e.options.previousOptions),delete e.options.previousOptions)),e instanceof L.Marker?(e.dragging.disable(),e.off("dragend",this._onMarkerDragEnd,this).off("touchmove",this._onTouchMove,this).off("MSPointerMove",this._onTouchMove,this).off("touchend",this._onMarkerDragEnd,this).off("MSPointerUp",this._onMarkerDragEnd,this)):e.editing.disable();},_onMouseMove:function(t){this._tooltip.updatePosition(t.latlng);},_onMarkerDragEnd:function(t){var e=t.target;e.edited=!0,this._map.fire(L.Draw.Event.EDITMOVE,{layer:e});},_onTouchMove:function(t){var e=t.originalEvent.changedTouches[0],i=this._map.mouseEventToLayerPoint(e),o=this._map.layerPointToLatLng(i);t.target.setLatLng(o);},_hasAvailableLayers:function(){return 0!==this._featureGroup.getLayers().length}}),L.EditToolbar.Delete=L.Handler.extend({statics:{TYPE:"remove"},initialize:function(t,e){if(L.Handler.prototype.initialize.call(this,t),L.Util.setOptions(this,e),this._deletableLayers=this.options.featureGroup,!(this._deletableLayers instanceof L.FeatureGroup)){ throw new Error("options.featureGroup must be a L.FeatureGroup"); }this.type=L.EditToolbar.Delete.TYPE;var i=L.version.split(".");1===parseInt(i[0],10)&&parseInt(i[1],10)>=2?L.EditToolbar.Delete.include(L.Evented.prototype):L.EditToolbar.Delete.include(L.Mixin.Events);},enable:function(){!this._enabled&&this._hasAvailableLayers()&&(this.fire("enabled",{handler:this.type}),this._map.fire(L.Draw.Event.DELETESTART,{handler:this.type}),L.Handler.prototype.enable.call(this),this._deletableLayers.on("layeradd",this._enableLayerDelete,this).on("layerremove",this._disableLayerDelete,this));},disable:function(){this._enabled&&(this._deletableLayers.off("layeradd",this._enableLayerDelete,this).off("layerremove",this._disableLayerDelete,this),L.Handler.prototype.disable.call(this),this._map.fire(L.Draw.Event.DELETESTOP,{handler:this.type}),this.fire("disabled",{handler:this.type}));},addHooks:function(){var t=this._map;t&&(t.getContainer().focus(),this._deletableLayers.eachLayer(this._enableLayerDelete,this),this._deletedLayers=new L.LayerGroup,this._tooltip=new L.Draw.Tooltip(this._map),this._tooltip.updateContent({text:L.drawLocal.edit.handlers.remove.tooltip.text}),this._map.on("mousemove",this._onMouseMove,this));},removeHooks:function(){this._map&&(this._deletableLayers.eachLayer(this._disableLayerDelete,this),this._deletedLayers=null,this._tooltip.dispose(),this._tooltip=null,this._map.off("mousemove",this._onMouseMove,this));},revertLayers:function(){this._deletedLayers.eachLayer(function(t){this._deletableLayers.addLayer(t),t.fire("revert-deleted",{layer:t});},this);},save:function(){this._map.fire(L.Draw.Event.DELETED,{layers:this._deletedLayers});},removeAllLayers:function(){this._deletableLayers.eachLayer(function(t){this._removeLayer({layer:t});},this),this.save();},_enableLayerDelete:function(t){(t.layer||t.target||t).on("click",this._removeLayer,this);},_disableLayerDelete:function(t){var e=t.layer||t.target||t;e.off("click",this._removeLayer,this),this._deletedLayers.removeLayer(e);},_removeLayer:function(t){var e=t.layer||t.target||t;this._deletableLayers.removeLayer(e),this._deletedLayers.addLayer(e),e.fire("deleted");},_onMouseMove:function(t){this._tooltip.updatePosition(t.latlng);},_hasAvailableLayers:function(){return 0!==this._deletableLayers.getLayers().length}});}(window,document);

	var leafletMixin = {
	  props: {}
	};

	var props$11 = {
	  featureGroup: {
	    type: Object,
	    "default": function _default() {
	      return L$1__default.featureGroup();
	    }
	  },
	  position: {
	    type: String,
	    "default": function _default() {
	      return 'topright';
	    }
	  },
	  options: {
	    type: Object,
	    "default": function _default() {
	      return {
	        draw: {
	          circlemarker: false,
	          circle: false,
	          polyline: false,
	          rectangle: false,
	          polygon: false
	        }
	      };
	    }
	  },
	  visible: {
	    type: Boolean,
	    custom: true,
	    "default": true
	  }
	};
	var script$j = {
	  name: 'l-control-draw',
	  mixins: [leafletMixin],
	  props: props$11,
	  data: function data() {
	    return {
	      ready: false
	    };
	  },
	  mounted: function mounted() {
	    this.mapObject = new L$1__default.Control.Draw(this.getOptions());
	    L$1.DomEvent.on(this.mapObject, this.$listeners);
	    propsBinder(this, this.mapObject, props$11);
	    this.ready = true;
	    this.parentContainer = findRealParent(this.$parent);
	    this.mapObject.addTo(this.parentContainer.mapObject, !this.visible);
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.parentContainer.removeLayer(this);
	  },
	  methods: {
	    getOptions: function getOptions() {
	      return _objectSpread2$1({
	        position: this.position
	      }, this.options);
	    }
	  }
	};

	/* script */
	var __vue_script__$j = script$j;
	/* template */
	var __vue_render__$g = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    { staticStyle: { display: "none" } },
	    [_vm.ready ? _vm._t("default") : _vm._e()],
	    2
	  )
	};
	var __vue_staticRenderFns__$g = [];
	__vue_render__$g._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$j = undefined;
	  /* scoped */
	  var __vue_scope_id__$j = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$j = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$j = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$j = normalizeComponent$1(
	    { render: __vue_render__$g, staticRenderFns: __vue_staticRenderFns__$g },
	    __vue_inject_styles__$j,
	    __vue_script__$j,
	    __vue_scope_id__$j,
	    __vue_is_functional_template__$j,
	    __vue_module_identifier__$j,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var _components;
	var script$k = {
	  name: 'leaflet-part',
	  components: (_components = {
	    'l-map': __vue_component__$d,
	    'l-tile-layer': __vue_component__$f,
	    'l-wms-tile-layer': __vue_component__$g
	  }, _defineProperty$1f(_components, __vue_component__$h.name, __vue_component__$h), _defineProperty$1f(_components, 'l-marker', __vue_component__$e), _defineProperty$1f(_components, 'l-control-layers', __vue_component__$b), _defineProperty$1f(_components, 'l-feature-group', __vue_component__$c), _defineProperty$1f(_components, __vue_component__$i.name, __vue_component__$i), _defineProperty$1f(_components, __vue_component__$j.name, __vue_component__$j), _components),
	  computed: {
	    layerItems: function layerItems() {
	      var vueLeaflet = {
	        TileLayer: 'l-tile-layer',
	        WMSTileLayer: 'l-wms-tile-layer',
	        GoogleLayer: 'l-google-layer'
	      };
	      return this.tileProviders.map(function (_ref) {
	        var type = _ref.type,
	            title = _ref.title,
	            _ref$checked = _ref.checked,
	            checked = _ref$checked === void 0 ? false : _ref$checked,
	            component = _ref.component;

	        var url = component.url,
	            name = component.name,
	            cql_filter = component.cql_filter,
	            options = _objectWithoutProperties(component, ["url", "name", "cql_filter"]);

	        var layerComponent = vueLeaflet[name] ? vueLeaflet[name] : 'l-wms-tile-layer';

	        var store = _objectSpread2$1({}, options, {
	          'layer-type': type ? type : 'overlay',
	          name: title,
	          visible: checked,
	          url: url,
	          'base-url': url,
	          layerComponent: layerComponent
	        });

	        if (cql_filter) { lodash.set(store, 'options.cql_filter', cql_filter); }
	        return store;
	      });
	    }
	  },
	  data: function data() {
	    return {
	      latlng: [],
	      tileProviders: [],
	      mapOptions: {
	        zoom: 14,
	        center: [10.801585, 106.650736]
	      }
	    };
	  },
	  mounted: function mounted() {
	    var _this = this;

	    this.tileProviders = window.appData.map.layers;
	    this.mapOptions = _objectSpread2$1({}, this.mapOptions, {}, window.appData.map.mapOptions);
	    this.$nextTick(function () {
	      var markerLatlng = window.appData.map.marker.latlng,
	          map = _this.$refs.map.mapObject,
	          featureGroup = _this.$refs.features.mapObject,
	          options = _objectSpread2$1({}, _this.$refs.drawControl.mapObject.options, {
	        edit: {
	          featureGroup: featureGroup
	        }
	      });

	      map.removeControl(_this.$refs.drawControl.mapObject);
	      _this.$refs.drawControl.mapObject = new L$1__default.Control.Draw(options);
	      map.addControl(_this.$refs.drawControl.mapObject);

	      if (!lodash.isEmpty(markerLatlng)) {
	        featureGroup.addLayer(L$1__default.marker(markerLatlng));
	        map.panTo(markerLatlng);
	      }

	      map.on(L$1__default.Draw.Event.CREATED, function (event) {
	        var layer = event.layer;
	        featureGroup.clearLayers();
	        featureGroup.addLayer(layer);
	        var latlng = layer.getLatLng();

	        _this.$store.commit('UPDATE_LATLNG', layer.getLatLng());
	      }).on(L$1__default.Draw.Event.EDITED, function (_ref2) {
	        var layers = _ref2.layers;
	        layers.eachLayer(function (l) {
	          _this.$store.commit('UPDATE_LATLNG', l.getLatLng());
	        });
	      });
	    });
	  }
	};

	/* script */
	var __vue_script__$k = script$k;
	/* template */
	var __vue_render__$h = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    [
	      _c(
	        "l-map",
	        _vm._b(
	          {
	            ref: "map",
	            staticStyle: { height: "80%", width: "100%" },
	            attrs: { id: "map" }
	          },
	          "l-map",
	          _vm.mapOptions,
	          false
	        ),
	        [
	          _c("l-control-layers", { attrs: { position: "topright" } }),
	          _vm._v(" "),
	          _vm._l(_vm.layerItems, function(l, k) {
	            return _c(
	              l.layerComponent,
	              _vm._b({ key: k, tag: "component" }, "component", l, false)
	            )
	          }),
	          _vm._v(" "),
	          _c("l-feature-group", {
	            ref: "features",
	            attrs: { "layer-type": "overlay", name: "Ca bệnh điều tra" }
	          }),
	          _vm._v(" "),
	          _c("l-control-locate"),
	          _vm._v(" "),
	          _c("l-control-draw", { ref: "drawControl" })
	        ],
	        2
	      )
	    ],
	    1
	  )
	};
	var __vue_staticRenderFns__$h = [];
	__vue_render__$h._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$k = undefined;
	  /* scoped */
	  var __vue_scope_id__$k = "data-v-1aafce11";
	  /* module identifier */
	  var __vue_module_identifier__$k = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$k = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$k = normalizeComponent$1(
	    { render: __vue_render__$h, staticRenderFns: __vue_staticRenderFns__$h },
	    __vue_inject_styles__$k,
	    __vue_script__$k,
	    __vue_scope_id__$k,
	    __vue_is_functional_template__$k,
	    __vue_module_identifier__$k,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );



	var partials = /*#__PURE__*/Object.freeze({
		__proto__: null,
		LeafletPart: __vue_component__$k,
		HeaderPart: __vue_component__$5,
		MapPart: __vue_component__$6,
		DieutraPart: __vue_component__$8,
		XacminhPart: __vue_component__$7,
		XulyPart: __vue_component__$9,
		ChuyencaPart: __vue_component__$a
	});

	var components$1 = _objectSpread2$1({}, lodash.mapKeys(partials, 'name'));

	var script$l = {
	  name: 'SxhForm',
	  components: _objectSpread2$1({}, components$1),
	  computed: _objectSpread2$1({}, Vuex.mapGetters(['loai_xm_cb']), {}, Vuex.mapState(['form', 'xacminh', 'shownDieutra', 'schema', 'dm', 'loading']), {
	    shownChuyenca: function shownChuyenca() {
	      var xacminh = this.xacminh.items,
	          lastXm = lodash.last(xacminh),
	          preLastXm = lodash.head(lodash.takeRight(xacminh, 2));
	      return xacminh.length > 1 && lastXm.tinh == 'HCM' && (lastXm.tinh && preLastXm.tinh != lastXm.tinh || lastXm.qh && preLastXm.qh != lastXm.qh || lastXm.px && preLastXm.px != lastXm.px);
	    }
	  }),
	  watch: {
	    'form.cachidiem': function formCachidiem(val) {
	      if (val == 0) {
	        this.setNullFormAttrs(['dietlangquang', 'giamsattheodoi', 'xulyonho', 'xulyorong']);
	        this.form.cathuphat = 1;
	      } else {
	        this.form.cathuphat = 0;
	      }
	    },
	    'form.cathuphat': function formCathuphat(val) {
	      if (val == 0) {
	        console.log(1111);
	        this.setNullFormAttrs(['odichmoi', 'odichcu', 'xuly', 'xuly_ngay']);
	      }
	    }
	  },
	  data: function data() {
	    return {
	      respHtml: '',
	      errors: {},
	      warnings: {}
	    };
	  },
	  created: function created() {
	    var _this = this;

	    // this.$store.commit('PREPEND_XACMINHS', [
	    //     {is_diachi: '1', is_benhnhan: '0', dienthoai: '', sonha: '', tenduong: '', to_kp: '', khupho: '', tinh: '', qh: '760', px: '', disabled: false},
	    //     {is_diachi: '1', is_benhnhan: null, dienthoai: '', sonha: '', tenduong: '', to_kp: '', khupho: '', tinh: '', qh: '760', px: '', disabled: false},
	    // ])
	    this.$store.commit('UPDATE_STORE');
	    this.$store.commit('CHECK_DISABLED');
	    this.$store.watch(function (state, getters) {
	      return JSON.stringify(state.xacminh);
	    }, function (val, oldVal) {
	      var after = val ? JSON.parse(val) : [],
	          before = oldVal ? JSON.parse(oldVal) : [];

	      if (after.length === before.length) {
	        _this.$store.dispatch('onChangeXacminh', {
	          after: after,
	          before: before
	        });
	      }
	    });
	  },
	  mounted: function mounted() {},
	  methods: {
	    setNullFormAttrs: function setNullFormAttrs(attrs) {
	      var _this2 = this;

	      attrs.map(function (name) {
	        _this2.form[name] = null;
	      });
	    },
	    makeToast: function makeToast() {
	      var variant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      this.$bvToast.toast('Toast body content', {
	        title: "Variant ".concat(variant || 'default'),
	        variant: variant,
	        solid: true
	      });
	    },
	    submitForm: function submitForm(e) {
	      e.preventDefault();
	      this.$refs.form.submit();
	      return false;
	    },
	    onSubmit: function onSubmit(e) {
	      e.preventDefault();
	      this.getPost();
	    },
	    resetForm: function resetForm() {},
	    resetMessages: function resetMessages() {
	      this.errors = [];
	      this.warnings = [];
	    },
	    setMessages: function setMessages(_ref) {
	      var errors = _ref.errors,
	          warnings = _ref.warnings;
	      this.errors = errors;
	      this.warnings = warnings;
	      this.$refs.observer.reset();
	      this.$refs.observer.setErrors(_objectSpread2$1({}, errors, {}, warnings));

	      if (!lodash.isEmpty(errors)) {
	        this.$noty.error("C\u1EADp nh\u1EADt <b class=\"text-uppercase\">kh\xF4ng th\xE0nh c\xF4ng</b> <br/> Vui l\xF2ng nh\u1EADp c\xE1c th\xF4ng tin b\u1EAFt bu\u1ED9c");
	      }

	      if (lodash.isEmpty(errors) && !lodash.isEmpty(warnings)) {
	        this.$noty.warning('Vui lòng nhập <b class="text-uppercase">đầy đủ thông tin</b> để hoàn tất quá trình điều tra');
	      }

	      if (lodash.isEmpty(errors) && lodash.isEmpty(warnings)) {
	        this.$noty.info('Đã cập nhật <b class="text-uppercase">thành công</b> phiếu điều tra');
	      }
	    },
	    getPost: function getPost() {
	      var SxhForm, url, search_params, id, data, _ref2, resp;

	      return regeneratorRuntime.async(function getPost$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              SxhForm = $('#sxh-form').serializeObject();
	              url = new URL(window.location.href), search_params = new URLSearchParams(url.search), id = search_params.get('id');
	              data = _defineProperty$1f({
	                SxhForm: _objectSpread2$1({}, SxhForm, {
	                  loai_xm_cb: this.loai_xm_cb
	                }),
	                status: {
	                  is_dieutra: this.shownDieutra,
	                  is_chuyenca: this.shownChuyenca
	                }
	              }, window.appData.csrf.param, window.appData.csrf.token);
	              this.$store.commit('LOADING');
	              this.resetMessages();
	              _context.prev = 5;
	              _context.next = 8;
	              return regeneratorRuntime.awrap(this.$http.post("/sxh/default/save?id=" + (id ? id : ''), data));

	            case 8:
	              _ref2 = _context.sent;
	              resp = _ref2.body;

	              if (lodash.isPlainObject(resp)) {
	                this.setMessages(resp);
	                this.$store.commit('UPDATE_FORM', resp.model);
	              }

	              if (lodash.isString(resp)) {
	                this.respHtml = resp;
	              } else {
	                this.respHtml = '';
	              }

	              this.$store.commit('LOADED');
	              _context.next = 19;
	              break;

	            case 15:
	              _context.prev = 15;
	              _context.t0 = _context["catch"](5);
	              this.$store.commit('LOADED');
	              console.log(_context.t0);

	            case 19:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, null, this, [[5, 15]]);
	    }
	  }
	};

	/* script */
	var __vue_script__$l = script$l;
	/* template */
	var __vue_render__$i = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    "div",
	    { attrs: { id: "cabenhForm" } },
	    [
	      _c("v-alert", { attrs: { messages: _vm.errors, variant: "danger" } }),
	      _vm._v(" "),
	      _c("v-alert", {
	        staticClass: "text-violet-800 alpha-violet",
	        attrs: {
	          messages: _vm.warnings,
	          label:
	            "Vui lòng nhập đầy đủ thông tin để hoàn tất phiếu - ĐÃ ĐIỀU TRA"
	        }
	      }),
	      _vm._v(" "),
	      _c("div", { domProps: { innerHTML: _vm._s(_vm.respHtml) } }),
	      _vm._v(" "),
	      _c("validation-observer", {
	        ref: "observer",
	        scopedSlots: _vm._u([
	          {
	            key: "default",
	            fn: function(ref) {
	              var passes = ref.passes;
	              var handleSubmit = ref.handleSubmit;
	              return [
	                _c(
	                  "b-form",
	                  {
	                    ref: "form",
	                    attrs: { id: "sxh-form" },
	                    on: {
	                      submit: function($event) {
	                        $event.preventDefault();
	                        return _vm.onSubmit($event)
	                      }
	                    }
	                  },
	                  [
	                    _c(
	                      "b-card",
	                      { attrs: { "no-body": "" } },
	                      [
	                        _c("leaflet-part"),
	                        _vm._v(" "),
	                        _c("header-part", {
	                          attrs: { shownChuyenca: _vm.shownChuyenca }
	                        }),
	                        _vm._v(" "),
	                        _c(
	                          "b-card-body",
	                          [
	                            _c("map-part"),
	                            _vm._v(" "),
	                            _c(
	                              "div",
	                              { staticClass: "phieu-body pr-0 pl-0 " },
	                              [
	                                _c("xacminh-part"),
	                                _vm._v(" "),
	                                _vm.shownDieutra
	                                  ? _c(
	                                      "div",
	                                      [
	                                        _c("dieutra-part"),
	                                        _vm._v(" "),
	                                        _c("xuly-part")
	                                      ],
	                                      1
	                                    )
	                                  : _vm._e()
	                              ],
	                              1
	                            ),
	                            _vm._v(" "),
	                            _c(
	                              "b-row",
	                              [
	                                _c(
	                                  "b-col",
	                                  [
	                                    _c("field-sxh", {
	                                      attrs: { name: "nguoidieutra" }
	                                    })
	                                  ],
	                                  1
	                                ),
	                                _vm._v(" "),
	                                _c(
	                                  "b-col",
	                                  [
	                                    _c("field-sxh", {
	                                      attrs: { name: "nguoidieutra_sdt" }
	                                    })
	                                  ],
	                                  1
	                                )
	                              ],
	                              1
	                            )
	                          ],
	                          1
	                        ),
	                        _vm._v(" "),
	                        _c(
	                          "b-card-footer",
	                          [
	                            !_vm._.isEmpty(_vm.form.list_chuyenca)
	                              ? _c("chuyenca-part")
	                              : _vm._e()
	                          ],
	                          1
	                        )
	                      ],
	                      1
	                    )
	                  ],
	                  1
	                )
	              ]
	            }
	          }
	        ])
	      })
	    ],
	    1
	  )
	};
	var __vue_staticRenderFns__$i = [];
	__vue_render__$i._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$l = undefined;
	  /* scoped */
	  var __vue_scope_id__$l = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$l = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$l = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$l = normalizeComponent$1(
	    { render: __vue_render__$i, staticRenderFns: __vue_staticRenderFns__$i },
	    __vue_inject_styles__$l,
	    __vue_script__$l,
	    __vue_scope_id__$l,
	    __vue_is_functional_template__$l,
	    __vue_module_identifier__$l,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	var script$m = {
	  props: {
	    id: String,
	    label: String,
	    disabled: [Boolean, String, Object],
	    name: {
	      type: String,
	      required: true
	    },
	    nameKey: String,
	    path: String
	  },
	  name: 'field-sxh',
	  computed: _objectSpread2$1({}, Vuex.mapState(['dm', 'form', 'schema', 'xacminh']), {
	    // ...mapState({
	    //     storeDisabled: state => state.disabled
	    // }),
	    innerId: function innerId() {
	      if (this.id) { return this.id; }
	      return "field-".concat(this.attrs.name);
	    },
	    cname: function cname() {
	      return this.nameKey ? this.nameKey : this.name;
	    },
	    innerLabel: function innerLabel() {
	      if (this.label) { return this.label; }

	      if (!lodash.isUndefined(this.$attrs.index) && this.attrs.label) {
	        return "".concat(this.attrs.label, " (").concat(this.$attrs.index + 1, ")");
	      }

	      return this.attrs.label;
	    },
	    innerPath: function innerPath() {
	      // Dùng để lấy dữ liệu từ store
	      return this.path ? this.path : "form.".concat(this.cname);
	    },
	    innerDisabled: function innerDisabled() {
	      // Lock từ props
	      if (this.disabled == true) {
	        return this.disabled;
	      } // Lock từ schema (server)


	      if (this.attrs.disabled) {
	        return this.attrs.disabled;
	      } // Lock từ store: locked px 1 (server)


	      var pathArr = this.innerPath.split('.');

	      if (pathArr.length > 2) {
	        var path = pathArr.slice(0, -1).join('.'),
	            data = lodash.get(this, path, {});

	        if (!lodash.isUndefined(data.disabled)) {
	          return data.disabled;
	        }
	      }

	      return false;
	    },
	    modelValue: {
	      get: function get() {
	        return lodash.get(this, this.innerPath);
	      },
	      set: function set(newValue) {
	        if (!lodash.isArray(newValue)) {
	          var pathArr = this.innerPath.split('.'),
	              key = pathArr.slice(0, 1),
	              path = pathArr.slice(1).join('.');

	          lodash.set(this[key], path, newValue);
	        }
	      }
	    },
	    attrs: function attrs() {
	      var $attrs = lodash.get(this.schema, "".concat(this.cname), {});

	      if ($attrs.options && lodash.isString($attrs.options)) {
	        $attrs.options = this.dm[$attrs.options];
	      }

	      if (this.$attrs.depends) {
	        $attrs.depends = this.$attrs.depends;
	      }

	      return $attrs;
	    },
	    component: function component() {
	      return lodash.get(this.schema, "".concat(this.cname, ".component"), 'field-input');
	    }
	  }),
	  methods: {}
	};

	/* script */
	var __vue_script__$m = script$m;

	/* template */
	var __vue_render__$j = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c(
	    _vm.component,
	    _vm._b(
	      {
	        tag: "component",
	        attrs: {
	          label: _vm.innerLabel,
	          id: _vm.innerId,
	          name: _vm.name,
	          disabled: _vm.innerDisabled
	        },
	        model: {
	          value: _vm.modelValue,
	          callback: function($$v) {
	            _vm.modelValue = $$v;
	          },
	          expression: "modelValue"
	        }
	      },
	      "component",
	      _vm.attrs,
	      false
	    )
	  )
	};
	var __vue_staticRenderFns__$j = [];
	__vue_render__$j._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$m = undefined;
	  /* scoped */
	  var __vue_scope_id__$m = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$m = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$m = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$m = normalizeComponent$1(
	    { render: __vue_render__$j, staticRenderFns: __vue_staticRenderFns__$j },
	    __vue_inject_styles__$m,
	    __vue_script__$m,
	    __vue_scope_id__$m,
	    __vue_is_functional_template__$m,
	    __vue_module_identifier__$m,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	//
	var script$n = {
	  name: 'v-alert',
	  props: {
	    messages: [Array, Object],
	    variant: String,
	    label: {
	      type: String,
	      "default": function _default() {
	        return 'Vui lòng điền các thông tin sau:';
	      }
	    }
	  },
	  computed: {
	    messagesArr: function messagesArr() {
	      return lodash.map(this.messages, function (v) {
	        return v.join(', ');
	      });
	    }
	  }
	};

	/* script */
	var __vue_script__$n = script$n;

	/* template */
	var __vue_render__$k = function() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return !_vm._.isEmpty(_vm.messagesArr)
	    ? _c(
	        "b-alert",
	        {
	          staticClass: "border-0",
	          attrs: { show: "", variant: _vm.variant, dismissible: "" }
	        },
	        [
	          _c("span", { staticClass: "font-weight-semibold" }, [
	            _vm._v(_vm._s(_vm.label))
	          ]),
	          _vm._v(" "),
	          _c(
	            "ul",
	            _vm._l(_vm.messagesArr, function(v, k) {
	              return _c("li", { key: k }, [_vm._v(_vm._s(v))])
	            }),
	            0
	          )
	        ]
	      )
	    : _vm._e()
	};
	var __vue_staticRenderFns__$k = [];
	__vue_render__$k._withStripped = true;

	  /* style */
	  var __vue_inject_styles__$n = undefined;
	  /* scoped */
	  var __vue_scope_id__$n = undefined;
	  /* module identifier */
	  var __vue_module_identifier__$n = undefined;
	  /* functional template */
	  var __vue_is_functional_template__$n = false;
	  /* style inject */
	  
	  /* style inject SSR */
	  
	  /* style inject shadow dom */
	  

	  
	  var __vue_component__$n = normalizeComponent$1(
	    { render: __vue_render__$k, staticRenderFns: __vue_staticRenderFns__$k },
	    __vue_inject_styles__$n,
	    __vue_script__$n,
	    __vue_scope_id__$n,
	    __vue_is_functional_template__$n,
	    __vue_module_identifier__$n,
	    false,
	    undefined,
	    undefined,
	    undefined
	  );

	Vue.component(__vue_component__$l.name, __vue_component__$l);
	Vue.component(__vue_component__$m.name, __vue_component__$m);
	Vue.component(__vue_component__$n.name, __vue_component__$n);

	Vue.filter('or', function (val1, val2) {
	  if (val1) { return val1; }
	  if (val2) { return val2; }
	  return '';
	});

	Vue.config.devtools = true;
	Vue.use(BootstrapVue);
	Vue.use(FormPlugin$1);
	Vue.use(window.Vuex);
	$(function () {
	  var app = new Vue({
	    el: '#vueApp',
	    store: store
	  });
	});

}(Vue, _, moment, $, Vuex, L));
